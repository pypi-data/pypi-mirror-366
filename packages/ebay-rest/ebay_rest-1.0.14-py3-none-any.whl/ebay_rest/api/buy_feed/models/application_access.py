# coding: utf-8

"""
    Buy Feed API

    The Feed API provides the ability to download TSV_GZIP feed files containing eBay items and an hourly snapshot file for a specific category, date, and marketplace.<br /><br />In addition to the API, there is an open-source Feed SDK written in Java that downloads, combines files into a single file when needed, and unzips the entire feed file. It also lets you specify field filters to curate the items in the file.  # noqa: E501

    OpenAPI spec version: v1.2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class ApplicationAccess(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'accesses': 'list[Access]'
    }

    attribute_map = {
        'accesses': 'accesses'
    }

    def __init__(self, accesses=None):  # noqa: E501
        """ApplicationAccess - a model defined in Swagger"""  # noqa: E501
        self._accesses = None
        self.discriminator = None
        if accesses is not None:
            self.accesses = accesses

    @property
    def accesses(self):
        """Gets the accesses of this ApplicationAccess.  # noqa: E501

        The response payload will contain a list of every feed type the application can access. The marketplaces and L1 categories to which the application is constrained within each feed are also returned. If no marketplaces are listed for a particular feed type, the application has access to all marketplaces. L1 categories are constrained according to marketplace. If a marketplace is listed with no L1 categories, the application has access to all categories in that marketplace. See <b>Sample 1: getAccess Request</b> below.  # noqa: E501

        :return: The accesses of this ApplicationAccess.  # noqa: E501
        :rtype: list[Access]
        """
        return self._accesses

    @accesses.setter
    def accesses(self, accesses):
        """Sets the accesses of this ApplicationAccess.

        The response payload will contain a list of every feed type the application can access. The marketplaces and L1 categories to which the application is constrained within each feed are also returned. If no marketplaces are listed for a particular feed type, the application has access to all marketplaces. L1 categories are constrained according to marketplace. If a marketplace is listed with no L1 categories, the application has access to all categories in that marketplace. See <b>Sample 1: getAccess Request</b> below.  # noqa: E501

        :param accesses: The accesses of this ApplicationAccess.  # noqa: E501
        :type: list[Access]
        """

        self._accesses = accesses

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(ApplicationAccess, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ApplicationAccess):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
