Metadata-Version: 2.4
Name: cptd
Version: 2.1.1
Summary: CPTD CLI
Home-page: https://www.cptdcli.com
Author: Asbjorn Rasen
Author-email: asbjornrasen@gmail.com
License: CC BY-ND 4.0
Project-URL: License, https://creativecommons.org/licenses/by-nd/4.0/
Project-URL: Homepage, https://www.cptdcli.com
Project-URL: Source, https://github.com/asbjornrasen/cptd-cli
Classifier: Programming Language :: Python :: 3
Classifier: License :: Other/Proprietary License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.7
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: argcomplete>=1.12.0
Requires-Dist: PyYAML>=6.0
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: license
Dynamic: license-file
Dynamic: project-url
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

### **CPTD CLI**

**CPTD CLI** is not just a command-line tool. It is an extensible management platform designed for:  
â€¢ Creating custom commands and extensions;  
â€¢ Sharing commands between users;  
â€¢ Integrating with external tools and APIs;  
â€¢ Automating workflows, reporting, and strategic analysis;  
â€¢ Acting as the engine for any custom or graphical interface (UI).

---

### **Architecture Principles**

**1. CLI as an Extensible Platform**  
Each command is a standard Python file with a defined interface. You can create your own command in under 5 minutes.  
Commands are simple Python modules with minimal structure. Each command includes a manifest file containing information (name, description, author, version, dependencies). Developers can use the `cptd newcommand` template to get started quickly.

Commands can be tested and debugged interactively without restarting the system:

```bash
cptd command --add yourcommand.zip     # add command (ZIP only)  
cptd command --del yourcommand         # remove command  
```

Run the command:

```bash
cptd yourcommand
```

Run the project:

```bash
cptd yourcommand
```

---

**2. Security and Validation**  
â€¢ All commands in the public repository undergo strict security review.  
â€¢ Upon installation, automatic checks are performed for prohibited code (e.g., `pip install` inside the command).  
â€¢ When publishing to the public repository, each command is checked for security, structure, and manifest integrity.  
â€¢ Community-contributed commands are moderated before publication.

---

**3. CLI as the Engine for UI**  
The CLI acts as a bridge for graphical interfaces that use it as the backend. **CPTD CLI** serves as the backend for all current and future interfaces. All logic is processed through the CLI.

---

**4. Centralized and Decentralized Distribution**  
â€¢ Commands can be downloaded and used from the public repository.  
â€¢ A standard format for importing, exporting, and sharing commands is supported.

---

**5. Autonomy and Reliability**  
â€¢ Fully offline operation â€” no cloud required.  
â€¢ No telemetry, hidden data collection, or external connections.  
â€¢ Supported on Windows, Linux, and macOS.

---

### **Why This Matters**

â€¢ **Flexibility**: Adapt the CLI to any scenario â€” from license checking to automation.  
â€¢ **Scalability**: From individual developers to entire teams.  
â€¢ **Extensibility**: Creation, sharing, moderation, and integration of commands.  
â€¢ **Security**: Strict checks at all stages â€” install, execute, publish.  
â€¢ **Transparency**: All code is open, modular, and auditable.

---

### **Open Source and Repository**

CPTD CLI is a free open-source project [https://cptdcli.com](https://cptdcli.com)**   . 
The complete source code is available in the public repository:  
ğŸ‘‰ **[https://github.com/asbjornrasen/cptd-cli](https://github.com/asbjornrasen/cptd-cli)**  
This ensures full transparency, builds trust and security, and allows anyone to verify, modify, or copy the system. Thanks to its openness, CPTD guarantees independence and verifiability in the long term.

## ğŸ”¹ List of Basic Commands for cptd

The following commands are available in the CPTD CLI:

| Command       | Purpose                                                                                    | Available |
|---------------|--------------------------------------------------------------------------------------------|-----------|
| `about`       | Shows information about CPTD CLI                                                           | yes       |
| `list`        | Displays all available commands                                                            | yes       |
| `dsl`         | Management of personal affairs through the declared DSL language, maintaining ToDo lists   | yes       |
| `newcommand`  | Generates a template for a new CLI command (for developers)                                | yes       |
| `command`     | Add, delete, or list custom CLI commands                                                   | yes       |
| `cpdsl`       | Interprets and executes `.dsl` registered CPTD CLI commands                                | yes       |
| `history`     | View, search, clear, or export the CPTD CLI command history                                | yes       |
| `install`     | Installing commands from the CPTD repository                                               | yes       |

> âš ï¸ Note: The CLI is under active development and not yet ready for production use.

---

## ğŸ“¥ How to Add a New Command to CPTD CLI

**Submission Format (ZIP only)**  
All CPTD CLI commands must be submitted as a `.zip` archive.

**Example of a Simple Command:**

```
taskcleaner.zip
â”œâ”€â”€ main.py
â”œâ”€â”€ icon.png
â”œâ”€â”€ manifest.yaml
â””â”€â”€ manifest.json
```

**Example of a Project Command with Subfolders:**

```
taskmanager.zip
â”œâ”€â”€ main.py
â”œâ”€â”€ icon.png
â”œâ”€â”€ manifest.yaml
â”œâ”€â”€ manifest.json
â”œâ”€â”€ util/
â”‚   â””â”€â”€ parser.py
â””â”€â”€ service/
    â””â”€â”€ api.py
```

**Rules:**  
â€¢ `main.py`, `icon.png`, `manifest.yaml`, and `manifest.json` must be at the archive root  
â€¢ The archive must not contain a nested folder named after the command  
â€¢ Archive name defines the command name: `taskcleaner.zip` â†’ `cptd taskcleaner`  
â€¢ In both manifests, the `entrypoint` field must be `main.py`  
â€¢ If `main.py` is not at the root â€” the command will be rejected  
â€¢ Both manifest files (YAML and JSON) are required  
â€¢ Subfolders like `util/`, `service/` are allowed  
â€¢ Auto-installing dependencies within the code is prohibited

---

### **Required Elements of a Command**

1. **Command Description in SYNTAX:**
    

```python
SYNTAX = {
  "name": "yourcommand",
  "description": "What the command does",
  "usage": "cptd yourcommand --input <path> [--flag]",
  "arguments": [
    {"name": "--input", "required": True, "help": "Path to input file"},
    {"name": "--flag", "required": False, "help": "Optional flag"}
  ],
  "examples": [
    "cptd yourcommand --input file.cptd",
    "cptd yourcommand --input folder --flag"
  ]
}
```

2. **`run(argv)` Function**
    

```python
def run(argv):
    ...
```

3. **Handle `--help`:**
    

```python
if "--help" in argv or "-h" in argv:
    print_help(SYNTAX)
    return
```

4. **Print help on error:**
    

```python
except Exception as e:
    print(f"[!] Argument error: {e}")
    print_help(SYNTAX)
    return
```

5. **Recommended Template:**
    

```python
from pathlib import Path
import argparse
from cptd_tools.syntax_utils import print_help

SYNTAX = {...}

def run(argv):
  if "--help" in argv or "-h" in argv:
    print_help(SYNTAX)
    return

  parser = argparse.ArgumentParser(...)
  parser.add_argument('--input', type=Path, required=True, ...)
  parser.add_argument('--flag', action='store_true', ...)

  try:
    args = parser.parse_args(argv)
  except Exception as e:
    print(f"[!] Argument error: {e}")
    print_help(SYNTAX)
    return

  if not args.input.exists():
    print(f"[!] Path does not exist:\n    {args.input}")
    return

  print(f"[âœ”] Processing: {args.input}")
  if args.flag:
    print("[âœ”] Flag is set")
```

---

### **Add or Test Command**

â€¢ Add: `cptd command --add yourcommand.zip`  
â€¢ View all: `cptd list`  
â€¢ Get help: `cptd yourcommand --help`  
â€¢ Run command: `cptd yourcommand`  
â€¢ Remove: `cptd command --del yourcommand`

---

### **Standards**

â€¢ `SYNTAX` is required  
â€¢ `run(argv)` is required  
â€¢ Use `print_help(SYNTAX)` only â€” do not rely on `argparse` for help  
â€¢ Code must be clean, readable, minimal dependencies

---

### **Manifests**

Manifests must be in the same folder as `main.py`:  
â€¢ `manifest.yaml` â€” human-readable  
â€¢ `manifest.json` â€” machine-readable

Required fields in the manifests:  
â€¢ `name`: unique name of the command (must match the archive name)  
â€¢ `description`: a description of the command  
â€¢ `version`: for example, 1.0.0  
â€¢ `entrypoint`: always `main.py`  
â€¢ `target`: supported operating systems (`all`, `linux`, `windows`, `macos`)  
â€¢ `dependencies`: list of required pip dependencies  
â€¢ `author`: name of the author  
â€¢ `email`: contact email  
â€¢ `github`: link to the GitHub repository  
â€¢ `website`: website (optional)  
â€¢ `license`: license (e.g., `MIT`, `license.md`, etc.)

---

## ğŸ§© `cpdsl` â€” Declarative Script Interpreter for CPTD

**Name:** `cpdsl`  
**Role:** Interpreter for `.dsl` scripts that sequentially execute installed `cptd` commands  
**Support:** Cross-platform (Linux / Windows / Mac)  
**Format:** YAML step definitions

---

### ğŸš€ What is `cpdsl` and Why Use It?

`cpdsl` is the official script interpreter of **CPTD CLI**. It executes YAML-defined commands line-by-line â€” turning manual sequences into structured, repeatable, and safe automation.

---

### ğŸ§  Why Use `cpdsl`?

â€¢ Automate routine processes with `cptd` commands  
â€¢ Replace fragile shell scripts with validated YAML instructions  
â€¢ Portability â€” one `.dsl` file can run anywhere  
â€¢ Transparent, repeatable, logged steps  
â€¢ Centralizes complex workflows: backup, encryption, upload, logging, etc.

---

### ğŸ“Œ Why It's Convenient

â€¢ A single `.dsl` file defines a full workflow  
â€¢ Scenarios can be shared as modules  
â€¢ UI integration: e.g., "Run Backup" button  
â€¢ Debug and reuse scenarios easily

---

### ğŸ“Š Advantages of DSL Approach

|Feature|Advantage|
|---|---|
|ğŸ“¦ Unification|Uniform interface for all commands|
|â™»ï¸ Repeatability|One DSL can run on 1000 machines or schedule|
|ğŸ“‹ Self-documenting|DSL file reads like a technical spec|
|ğŸ§± Extensibility|Easy to expand: if, loop, include, etc.|
|ğŸ” Security|No shell injection, no `eval`, no `rm -rf`|
|ğŸ§  Cross-platform|One DSL works on Windows, Linux, servers|
|ğŸ§° Integration|Use from UI, web panels, triggers, apps|

---

### ğŸ“‚ Example Run

```bash
cptd cpdsl run backup.dsl --log out.txt --strict --wait-all --summary
```

---

### ğŸ“˜ Official YAML Script Format

```yaml
name: "Script Name"
description: "Short purpose description"

steps:
  - name: "Step Name"
    command: "command_name"
    args:
      --flag1: value
      --flag2: true
    async: true
    depends_on: "step_name"
```

---

### ğŸ§© Field Descriptions

**Top-Level:**

|Field|Type|Purpose|
|---|---|---|
|`name`|string|Human-readable scenario name|
|`description`|string|Brief description|
|`steps`|list|List of step definitions|

**Inside `steps[]`:**

|Field|Type|Required|Description|
|---|---|---|---|
|`name`|string|No|Step name (for display or `depends_on`)|
|`command`|string|âœ… Yes|Name of registered CPTD command|
|`args`|dict|No|Arguments â€” if value is `true`, flag is passed|
|`async`|bool|No|Run step in background if true|
|`depends_on`|string/list|No|Dependencies; run only after these steps|

**Environment Variables:**

```yaml
args:
  --password-env: SFTP_PASS
```

â†’ Becomes: `--password-env <value from SFTP_PASS>`

---

### âœ… Example Scenario (.dsl)

```yaml
name: "Backup"
description: "Mount, archive and upload data"

steps:
  - name: "Mount"
    command: "cpdisk"
    args:
      --mount: true
      --file: "vault.hc"

  - name: "Archive"
    command: "compress"
    args:
      --input: "/vault/data"
      --output: "/tmp/data.zip"
    depends_on: "Mount"

  - name: "Upload"
    command: "uploader"
    args:
      --file: "/tmp/data.zip"
      --target: "sftp://host/upload"
      --password-env: SFTP_PASS
    async: true
    depends_on: "Archive"
```

---

### ğŸ§ª Run the Scenario

```bash
cptd cpdsl run backup.dsl --log log.txt --strict --wait-all --summary
```

**Arguments:**

|Argument|Meaning|
|---|---|
|`--log`|Save log to file|
|`--strict`|Stop on first error|
|`--wait-all`|Wait for all async steps to complete|
|`--summary`|Print table with statuses at the end|

**Sample Summary Table:**

```
Summary:
âœ” Step 1 - Mount                [OK]
âœ” Step 2 - Archive              [OK]
âœ” Step 3 - Upload               [ASYNC]
```

---

### âš ï¸ Error Handling

|Situation|Default|With `--strict`|
|---|---|---|
|`depends_on` points to missing step|Error|Error|
|Step exits with non-zero code|Continues|Stops|
|Async step fails|Warns|Stops|

---

### ğŸš€ Writing Tips

â€¢ Always provide unique `name:` for each step  
â€¢ Use `depends_on` to define logical sequence  
â€¢ Use `async: true` for background tasks  
â€¢ Store `.dsl` files in `scripts/` or `scenarios/` folders

---

### ğŸ Conclusion

**`cpdsl` is not just syntax. It's structure. It's automation strategy.**  
Forget the chaos of `bash` chains and `&&`.  
Create readable, repeatable, testable scenarios that evolve with your project.

---

### Ready? Submit Your Command to CPTD CLI

1. Fork: [https://github.com/asbjornrasen/cptdcli-plugin](https://github.com/asbjornrasen/cptdcli-plugin)
    
2. Create branch: `feature/mycommand`
    
3. Add ZIP: `community_plugin/your_system/your_command.zip`

  your_system:

    linux/ â€” plugins designed for Linux OS.

    macos/ â€” plugins compatible with macOS.

    windows/ â€” plugins implemented for Windows.
    
4. Make sure:
    
    - Structure is valid
        
    - `main.py`, manifests at root
        
    - `--help` works
        
    - No auto-installation logic
        
5. Add manifest to `community-plugins.json`:
    

```json
{
  "name": "example",
  "description": "example",
  "long_description": "example",
  "version": "1.0.0",
  "target": "Windows",
  "entrypoint": "example.py",
  "dependencies": ["example"],
  "author": "example",
  "email": "example@example.com",
  "github": "https://github.com/example/example",
  "website": "https://example.com",
  "license": "example.md",
  "documentation":""
}
```

6. Submit Pull Request with description
    

---

**Tip:** Follow CPTD philosophy â€” clarity, modularity, practicality.

Need a template?

```bash
cptd newcommand
```

You'll get a project structure with `main.py`, `manifest.yaml`, `util/`, `service/`.

---

**Ready to create commands? CPTD CLI awaits your ideas.**  
The best ones will be included in the official release.

---

**Summary:**  
**CPTD CLI** is more than a tool. Itâ€™s a foundation for creating, testing, and sharing smart utilities.  
Its flexible architecture, strict security, and open model make it an ideal management core for both personal and enterprise systems.
