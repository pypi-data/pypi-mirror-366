#!/usr/bin/env python3
"""
Monitoring Dashboard for OxenORM

This module provides real-time performance metrics, system health monitoring,
and query performance visualization.
"""

import asyncio
import time
import json
import threading
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import statistics


class MetricType(Enum):
    """Types of metrics that can be monitored."""
    QUERY_PERFORMANCE = "query_performance"
    SYSTEM_HEALTH = "system_health"
    CONNECTION_POOL = "connection_pool"
    CACHE_PERFORMANCE = "cache_performance"
    ERROR_RATE = "error_rate"
    THROUGHPUT = "throughput"


class AlertLevel(Enum):
    """Alert levels for monitoring."""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


@dataclass
class MetricPoint:
    """A single metric data point."""
    timestamp: datetime
    value: float
    tags: Dict[str, str] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Alert:
    """An alert generated by the monitoring system."""
    id: str
    level: AlertLevel
    message: str
    metric_name: str
    current_value: float
    threshold: float
    timestamp: datetime
    resolved: bool = False
    resolved_at: Optional[datetime] = None


class MetricCollector:
    """Collects and stores metrics over time."""
    
    def __init__(self, max_points: int = 1000, retention_hours: int = 24):
        self.max_points = max_points
        self.retention_hours = retention_hours
        self.metrics: Dict[str, List[MetricPoint]] = {}
        self.lock = threading.Lock()
    
    def record_metric(self, name: str, value: float, tags: Optional[Dict[str, str]] = None, 
                     metadata: Optional[Dict[str, Any]] = None):
        """Record a new metric point."""
        with self.lock:
            if name not in self.metrics:
                self.metrics[name] = []
            
            point = MetricPoint(
                timestamp=datetime.now(),
                value=value,
                tags=tags or {},
                metadata=metadata or {}
            )
            
            self.metrics[name].append(point)
            
            # Clean up old data
            self._cleanup_old_data(name)
    
    def _cleanup_old_data(self, metric_name: str):
        """Remove old metric points based on retention policy."""
        cutoff_time = datetime.now() - timedelta(hours=self.retention_hours)
        self.metrics[metric_name] = [
            point for point in self.metrics[metric_name]
            if point.timestamp > cutoff_time
        ]
        
        # Limit number of points
        if len(self.metrics[metric_name]) > self.max_points:
            self.metrics[metric_name] = self.metrics[metric_name][-self.max_points:]
    
    def get_metric(self, name: str, window_minutes: Optional[int] = None) -> List[MetricPoint]:
        """Get metric points for a specific metric."""
        with self.lock:
            if name not in self.metrics:
                return []
            
            points = self.metrics[name]
            
            if window_minutes:
                cutoff_time = datetime.now() - timedelta(minutes=window_minutes)
                points = [p for p in points if p.timestamp > cutoff_time]
            
            return points
    
    def get_statistics(self, name: str, window_minutes: Optional[int] = None) -> Dict[str, float]:
        """Get statistics for a metric."""
        points = self.get_metric(name, window_minutes)
        
        if not points:
            return {}
        
        values = [p.value for p in points]
        
        return {
            'count': len(values),
            'min': min(values),
            'max': max(values),
            'avg': statistics.mean(values),
            'median': statistics.median(values),
            'std_dev': statistics.stdev(values) if len(values) > 1 else 0.0,
            'latest': values[-1] if values else 0.0
        }


class AlertManager:
    """Manages alerts and thresholds."""
    
    def __init__(self):
        self.alerts: List[Alert] = []
        self.thresholds: Dict[str, Dict[str, float]] = {}
        self.lock = threading.Lock()
    
    def set_threshold(self, metric_name: str, warning: float, critical: float):
        """Set thresholds for a metric."""
        with self.lock:
            self.thresholds[metric_name] = {
                'warning': warning,
                'critical': critical
            }
    
    def check_thresholds(self, metric_name: str, current_value: float) -> Optional[Alert]:
        """Check if a metric exceeds thresholds and create an alert."""
        with self.lock:
            if metric_name not in self.thresholds:
                return None
            
            thresholds = self.thresholds[metric_name]
            
            if current_value >= thresholds['critical']:
                level = AlertLevel.CRITICAL
                message = f"Critical: {metric_name} = {current_value} (threshold: {thresholds['critical']})"
            elif current_value >= thresholds['warning']:
                level = AlertLevel.WARNING
                message = f"Warning: {metric_name} = {current_value} (threshold: {thresholds['warning']})"
            else:
                return None
            
            alert = Alert(
                id=f"{metric_name}_{int(time.time())}",
                level=level,
                message=message,
                metric_name=metric_name,
                current_value=current_value,
                threshold=thresholds['critical'] if level == AlertLevel.CRITICAL else thresholds['warning'],
                timestamp=datetime.now()
            )
            
            self.alerts.append(alert)
            return alert
    
    def get_active_alerts(self) -> List[Alert]:
        """Get all active (unresolved) alerts."""
        with self.lock:
            return [alert for alert in self.alerts if not alert.resolved]
    
    def resolve_alert(self, alert_id: str):
        """Mark an alert as resolved."""
        with self.lock:
            for alert in self.alerts:
                if alert.id == alert_id:
                    alert.resolved = True
                    alert.resolved_at = datetime.now()
                    break


class PerformanceMonitor:
    """Enhanced performance monitor with real-time metrics."""
    
    def __init__(self):
        self.collector = MetricCollector()
        self.alert_manager = AlertManager()
        self.monitoring_active = False
        self.monitoring_thread = None
        
        # Set default thresholds
        self._setup_default_thresholds()
    
    def _setup_default_thresholds(self):
        """Setup default monitoring thresholds."""
        self.alert_manager.set_threshold('query_execution_time', 1.0, 5.0)  # seconds
        self.alert_manager.set_threshold('error_rate', 0.05, 0.1)  # 5%, 10%
        self.alert_manager.set_threshold('cache_hit_rate', 0.7, 0.5)  # 70%, 50%
        self.alert_manager.set_threshold('connection_pool_usage', 0.8, 0.95)  # 80%, 95%
    
    def start_monitoring(self):
        """Start the monitoring system."""
        if self.monitoring_active:
            return
        
        self.monitoring_active = True
        self.monitoring_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        self.monitoring_thread.start()
    
    def stop_monitoring(self):
        """Stop the monitoring system."""
        self.monitoring_active = False
        if self.monitoring_thread:
            self.monitoring_thread.join()
    
    def _monitoring_loop(self):
        """Main monitoring loop."""
        while self.monitoring_active:
            try:
                # Collect system metrics
                self._collect_system_metrics()
                
                # Check for alerts
                self._check_alerts()
                
                # Sleep for monitoring interval
                time.sleep(5)  # 5 second intervals
                
            except Exception as e:
                print(f"Monitoring error: {e}")
    
    def _collect_system_metrics(self):
        """Collect system-level metrics."""
        # This would integrate with actual system metrics
        # For now, we'll use placeholder metrics
        pass
    
    def _check_alerts(self):
        """Check current metrics against thresholds."""
        # Get latest metrics and check thresholds
        for metric_name in self.alert_manager.thresholds:
            stats = self.collector.get_statistics(metric_name, window_minutes=5)
            if stats and 'latest' in stats:
                alert = self.alert_manager.check_thresholds(metric_name, stats['latest'])
                if alert:
                    print(f"ðŸš¨ ALERT: {alert.message}")
    
    def record_query_metric(self, execution_time: float, success: bool, rows_affected: int):
        """Record query performance metrics."""
        # Record execution time
        self.collector.record_metric('query_execution_time', execution_time)
        
        # Record success/failure
        self.collector.record_metric('query_success_rate', 1.0 if success else 0.0)
        
        # Record throughput
        self.collector.record_metric('queries_per_second', 1.0 / max(execution_time, 0.001))
        
        # Record rows affected
        self.collector.record_metric('rows_affected', rows_affected)
    
    def record_cache_metric(self, hit: bool):
        """Record cache performance metrics."""
        self.collector.record_metric('cache_hit_rate', 1.0 if hit else 0.0)
    
    def record_connection_metric(self, pool_size: int, active_connections: int):
        """Record connection pool metrics."""
        usage_rate = active_connections / max(pool_size, 1)
        self.collector.record_metric('connection_pool_usage', usage_rate)
        self.collector.record_metric('active_connections', active_connections)
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """Get comprehensive dashboard data."""
        # Get recent metrics (last 10 minutes)
        window_minutes = 10
        
        dashboard_data = {
            'timestamp': datetime.now().isoformat(),
            'metrics': {},
            'alerts': [],
            'summary': {}
        }
        
        # Collect all metric statistics
        for metric_name in self.collector.metrics:
            stats = self.collector.get_statistics(metric_name, window_minutes)
            if stats:
                dashboard_data['metrics'][metric_name] = stats
        
        # Get active alerts
        dashboard_data['alerts'] = [
            {
                'id': alert.id,
                'level': alert.level.value,
                'message': alert.message,
                'timestamp': alert.timestamp.isoformat(),
                'metric_name': alert.metric_name,
                'current_value': alert.current_value,
                'threshold': alert.threshold
            }
            for alert in self.alert_manager.get_active_alerts()
        ]
        
        # Generate summary
        dashboard_data['summary'] = self._generate_summary()
        
        return dashboard_data
    
    def _generate_summary(self) -> Dict[str, Any]:
        """Generate a summary of system health."""
        summary = {
            'status': 'healthy',
            'active_alerts': len(self.alert_manager.get_active_alerts()),
            'total_metrics': len(self.collector.metrics),
            'last_updated': datetime.now().isoformat()
        }
        
        # Check for critical alerts
        critical_alerts = [
            alert for alert in self.alert_manager.get_active_alerts()
            if alert.level == AlertLevel.CRITICAL
        ]
        
        if critical_alerts:
            summary['status'] = 'critical'
        elif summary['active_alerts'] > 0:
            summary['status'] = 'warning'
        
        return summary


class MonitoringDashboard:
    """Main monitoring dashboard interface."""
    
    def __init__(self):
        self.monitor = PerformanceMonitor()
        self.callbacks: List[Callable[[Dict[str, Any]], None]] = []
    
    def start(self):
        """Start the monitoring dashboard."""
        self.monitor.start_monitoring()
        print("ðŸš€ Monitoring dashboard started")
    
    def stop(self):
        """Stop the monitoring dashboard."""
        self.monitor.stop_monitoring()
        print("ðŸ›‘ Monitoring dashboard stopped")
    
    def add_callback(self, callback: Callable[[Dict[str, Any]], None]):
        """Add a callback for dashboard updates."""
        self.callbacks.append(callback)
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """Get current dashboard data."""
        return self.monitor.get_dashboard_data()
    
    def export_dashboard_report(self, filename: str):
        """Export dashboard data to JSON file."""
        data = self.get_dashboard_data()
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2, default=str)
    
    def set_alert_threshold(self, metric_name: str, warning: float, critical: float):
        """Set alert thresholds for a metric."""
        self.monitor.alert_manager.set_threshold(metric_name, warning, critical)
    
    def get_metric_history(self, metric_name: str, hours: int = 24) -> List[Dict[str, Any]]:
        """Get historical data for a metric."""
        points = self.monitor.collector.get_metric(metric_name, hours * 60)
        return [
            {
                'timestamp': point.timestamp.isoformat(),
                'value': point.value,
                'tags': point.tags,
                'metadata': point.metadata
            }
            for point in points
        ]


# Global monitoring instance
_global_dashboard = MonitoringDashboard()


def get_dashboard() -> MonitoringDashboard:
    """Get the global monitoring dashboard instance."""
    return _global_dashboard


def start_monitoring():
    """Start the global monitoring system."""
    _global_dashboard.start()


def stop_monitoring():
    """Stop the global monitoring system."""
    _global_dashboard.stop()


def record_query_metric(execution_time: float, success: bool, rows_affected: int):
    """Record a query metric in the global monitoring system."""
    _global_dashboard.monitor.record_query_metric(execution_time, success, rows_affected)


def record_cache_metric(hit: bool):
    """Record a cache metric in the global monitoring system."""
    _global_dashboard.monitor.record_cache_metric(hit)


def record_connection_metric(pool_size: int, active_connections: int):
    """Record a connection metric in the global monitoring system."""
    _global_dashboard.monitor.record_connection_metric(pool_size, active_connections) 