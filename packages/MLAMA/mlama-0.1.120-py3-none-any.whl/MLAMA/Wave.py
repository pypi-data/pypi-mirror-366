# -*- coding: utf-8 -*-
"""Wave.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HjQ_HMGOhGvAU_5tWiW6z0QR_BS9BK29
"""

import datetime
import pandas as pd

#from MLAMA Package 2025 Data.ipynb
#Wave class to represent each waves
#Wave.py
class Wave:
  """
  A class to represent a wave.
  Attributes:
    waveID (int): Unique ID for each wave
    startDate (Date object): Start date of the wave
    endDate (Date object): End date of the wave
    trainStartDate (Date object): Start date of the training data
    trainEndDate (Date object): End date of the training data
    testStartDate (Date object): Start date of the testing data
    testEndDate (Date object): End date of the testing data
    df (DataFrame): Dataframe of the wave
  Methods:
    print_wave: Prints the wave information
    get_wave_dates_with_shift: Gets the wave data, train data, and test data with shift
    get_wave_test_start_date_with_shift: Gets the test start date with shift
    get_wave_df: Gets the wave data as a dataframe
  """
  def __init__(self, waveID, startDate, endDate,
               trainStartDate, trainEndDate, testStartDate, testEndDate, trend_adjustment_steps, df):
    """
    Constructs all the necessary attributes for the wave object.
    Args:
      waveID (int): Unique ID for each wave
      startDate (Date object): Start date of the wave
      endDate (Date object): End date of the wave
      trainStartDate (Date object): Start date of the training data
      trainEndDate (Date object): End date of the training data
      testStartDate (Date object): Start date of the testing data
      testEndDate (Date object): End date of the testing data
      df (DataFrame): Dataframe of the wave
    """
    self.waveID = waveID
    self.startDate = startDate
    self.endDate = endDate

    self.trainStartDate = trainStartDate
    self.trainEndDate = trainEndDate
    self.testStartDate = testStartDate
    self.testEndDate = testEndDate

    if trend_adjustment_steps is not None:
        self.max_shift = max(trend_adjustment_steps)
        sliding_room = datetime.timedelta(weeks=self.max_shift)
    else:
        self.max_shift = 0
        sliding_room = datetime.timedelta(0)

    # Only use strptime if self.endDate is a string
    if isinstance(self.endDate, str):
        e = datetime.datetime.strptime(self.endDate, "%Y-%m-%d")
    else:
        e = self.endDate  # Already a datetime object

    end = e + sliding_room#end extra to allow for sliding room, for different Prediction lengths and shifts
    end_str = end.strftime("%Y-%m-%d")


    self.all_df = df
    self.df = df.loc[self.startDate:end_str]#+wiggle room which is = max_shift. so this df is not actual wave start end, it conatins wiggle room

  def get_wave_df(self):
    """
    Gets the wave data (from start date to end date) as a dataframe.
    Returns:
      self.df (DataFrame): Wave data as a dataframe
    """
    return self.df.loc[self.startDate:self.endDate]

  def clone(self):
    """
    Creates a deep copy of the Wave object for safe re-use without mutation.
    """
    return Wave(
        waveID=self.waveID,
        startDate=self.startDate,
        endDate=self.endDate,
        trainStartDate=self.trainStartDate,
        trainEndDate=self.trainEndDate,
        testStartDate=self.testStartDate,
        testEndDate=self.testEndDate,
        trend_adjustment_steps=[self.max_shift],  # reconstruct sliding room
        df=self.all_df.copy(deep=True)
    )

  def print_wave(self):
    print('Wave', self.waveID, ':')
    print('All:', self.startDate, ':', self.endDate)
    print('Maximum shift: ', self.max_shift)
    print('Train:', self.trainStartDate, ':', self.trainEndDate)
    print('Test:', self.testStartDate, ':', self.testEndDate)


  def add_one_week(self, week_data):#for adding future  data to the current data
    """
    Gets the test start date, enddate after calculating shift. Test start and end shifted.
    for plot display
    Args:
      week_data: one week data, dont need it, i might need ow many weeks i want to add
    Returns:
      self/nothing
    """

    # Only use strptime if self.endDate is a string
    if isinstance(self.endDate, str):
        e = datetime.datetime.strptime(self.endDate, "%Y-%m-%d")
    else:
        e = self.endDate  # Already a datetime object

    w = datetime.timedelta(weeks=1)#new wave end date, one new week added
    end = e + w #new wave end date
    self.endDate = end.strftime("%Y-%m-%d")

    # Only use strptime if self.trainEndDate is a string
    if isinstance(self.trainEndDate, str):
        e = datetime.datetime.strptime(self.trainEndDate, "%Y-%m-%d")
    else:
        e = self.trainEndDate  # Already a datetime object

    w = datetime.timedelta(weeks=1)#new train end date
    end = e + w #
    self.trainEndDate = end.strftime("%Y-%m-%d")


    w = datetime.timedelta(weeks=2)#next of train end date, so 2 weeks after old tarin enddate
    start = e + w #test start date shifted, a day after train end
    self.testStartDate = start.strftime("%Y-%m-%d")


    # e = datetime.datetime.strptime(self.testEndDate,"%Y-%m-%d")
    # Only use strptime if self.testEndDate is a string
    if isinstance(self.testEndDate, str):
        e = datetime.datetime.strptime(self.testEndDate, "%Y-%m-%d")
    else:
        e = self.testEndDate  # Already a datetime object


    w = datetime.timedelta(weeks=1)
    end = e + w#test end shifted by one week

    self.testEndDate = end.strftime("%Y-%m-%d")

    sliding_room = datetime.timedelta(weeks=self.max_shift)

    # Only use strptime if self.endDate is a string
    if isinstance(self.endDate, str):
        e = datetime.datetime.strptime(self.endDate, "%Y-%m-%d")
    else:
        e = self.endDate  # Already a datetime object

    end = e + sliding_room#end extra to allow for sliding room, for different Prediction lengths and shifts
    #new sliding rom

    end = pd.to_datetime(end)  # Ensure end is datetime
    end_str = end.strftime("%Y-%m-%d")


    self.df = self.all_df.loc[self.startDate:end_str]#+wiggle room which is = max_shift. so this df is not actual wave start end, it conatins wiggle room

  def slide_one_week(self):#slide training data to maintain the latest training window, slide test start accordingly, whole wave and test end remains the same
    """
    Gets the test start date, enddate after calculating shift. Test start and end shifted.
    for plot display
    Args:
      week_data: one week data, dont need it, i might need ow many weeks i want to add
    Returns:
      self/nothing
    """

    #slide trainStartDate and trainEndDate
    #test start date shifted
    # Only use strptime if self.trainStartDate is a string
    if isinstance(self.trainStartDate, str):
        s = datetime.datetime.strptime(self.trainStartDate, "%Y-%m-%d")
    else:
        s = self.trainStartDate  # Already a datetime object

    w = datetime.timedelta(weeks=1)
    start = s + w #test start date shifted
    self.trainStartDate = start.strftime("%Y-%m-%d")

    # Only use strptime if self.trainEndDate is a string
    if isinstance(self.trainEndDate, str):
        e = datetime.datetime.strptime(self.trainEndDate, "%Y-%m-%d")
    else:
        e = self.trainEndDate  # Already a datetime object

    w = datetime.timedelta(weeks=1)#new train end date
    end = e + w #
    self.trainEndDate = end.strftime("%Y-%m-%d")


    #slide test start date, end remains the same
    w = datetime.timedelta(weeks=2)#next of train end date, so 2 weeks after old tarin enddate
    start = e + w #test start date shifted, a day after train end

    self.testStartDate = start.strftime("%Y-%m-%d")


  def get_wave_dates_with_shift_delay(self, shift, wave_start_shift_matrix):#JMM definition. get_wave_dates_with_shift_delay
    """
    Gets the wave data, train data, and test data after calculating shift.
    Wave start remains the same, wave end shifted.
    Train start remains the same, train end not shifted (Mahmood definition). (Only change than Yushu definition)
    Test start and end shifted.
    Args:
      wave:Wave object
      shift (int): shift in weeks
    Returns:
      wave_data (DataFrame): Wave data with shift
      train_data (DataFrame): Train data with shift
      test_data (DataFrame): Test data with shift
    """

    shifted_start = wave_start_shift_matrix[str(self.waveID)][shift]
    #for the waves start is also shifted
    #start fixed, irrespective of shift
    if isinstance(self.startDate, str):
        s = datetime.datetime.strptime(self.startDate, "%Y-%m-%d")
    else:
        s = self.startDate  # Already a datetime object

    w = datetime.timedelta(weeks=shifted_start)
    start = s + w#end shifted
    start_str = start.strftime("%Y-%m-%d")

    # Only use strptime if self.endDate is a string
    if isinstance(self.endDate, str):
        e = datetime.datetime.strptime(self.endDate, "%Y-%m-%d")
    else:
        e = self.endDate  # Already a datetime object

    w = datetime.timedelta(weeks=shift)
    end = e + w#end shifted
    end_str = end.strftime("%Y-%m-%d")

    wave_data = self.df.loc[start_str:end_str]

    ############Train data
    #start don't need to calculate again. same as wave start
    # Only use strptime if self.trainEndDate is a string
    if isinstance(self.trainEndDate, str):
        e = datetime.datetime.strptime(self.trainEndDate, "%Y-%m-%d")
    else:
        e = self.trainEndDate  # Already a datetime object

    w = datetime.timedelta(weeks=shift)
    end = e #end not shifted
    end_str = end.strftime("%Y-%m-%d")

    train_data = self.df.loc[start_str:end_str]

    ############Test data
    #trainEndDate here, that's how Yushu plotted the lines#but this will make incorrect predictions, for plot maybe do one week subtract if needed. so, testStartDate
    #next week of train end
    #test start date shifted
    if self.trainEndDate < self.endDate:
        w = datetime.timedelta(weeks=shift + 1)  # next of train end date
        start = e + w  # test start date shifted, a day after train end; e is the unshifted trainEndDate
        start_str = start.strftime("%Y-%m-%d")

    elif self.trainEndDate == self.endDate:
        s = datetime.datetime.strptime(self.testStartDate, "%Y-%m-%d")  # start fixed, irrespective of shift
        w = datetime.timedelta(weeks=shift)
        start = s + w  # start shifted
        start_str = start.strftime("%Y-%m-%d")

    #end same as wave end date actually
    # Only use strptime if self.testEndDate is a string
    if isinstance(self.testEndDate, str):
        e = datetime.datetime.strptime(self.testEndDate, "%Y-%m-%d")
    else:
        e = self.testEndDate  # Already a datetime object

    w = datetime.timedelta(weeks=shift)
    end = e + w#end shifted
    end_str = end.strftime("%Y-%m-%d")
    test_data = self.df.loc[start_str:end_str]

    return wave_data, train_data, test_data


  def get_wave_dates_with_shift_responsiveness(self, shift, wave_start_shift_matrix):#yushu definition.#get_wave_dates_with_shift_responsiveness
    """
    Gets the wave data, train data, and test data after calculating shift.
    Wave start remains the same, wave end shifted. Train start remains the same, train end shifted. Test start and end shifted.
    Args:
      wave:Wave object
      shift (int): shift in weeks
    Returns:
      wave_data (DataFrame): Wave data with shift
      train_data (DataFrame): Train data with shift
      test_data (DataFrame): Test data with shift
    """

    shifted_start = wave_start_shift_matrix[str(self.waveID)][shift]
    #for the waves start is also shifted
    # Only use strptime if self.startDate is a string
    if isinstance(self.startDate, str):
        s = datetime.datetime.strptime(self.startDate, "%Y-%m-%d")
    else:
        s = self.startDate  # Already a datetime object

    w = datetime.timedelta(weeks=shifted_start)
    start = s + w#start shifted
    start_str = start.strftime("%Y-%m-%d")

    # Only use strptime if self.testEndDate is a string
    if isinstance(self.endDate, str):
        e = datetime.datetime.strptime(self.endDate, "%Y-%m-%d")
    else:
        e = self.endDate  # Already a datetime object

    w = datetime.timedelta(weeks=shift)
    end = e + w#end shifted
    end_str = end.strftime("%Y-%m-%d")

    wave_data = self.df.loc[start_str:end_str]

    ############Train data
    #start don't need to calculate again. train start same as wave start
    # Only use strptime if self.testEndDate is a string
    if isinstance(self.trainEndDate, str):
        e = datetime.datetime.strptime(self.trainEndDate, "%Y-%m-%d")
    else:
        e = self.trainEndDate  # Already a datetime object

    w = datetime.timedelta(weeks=shift)
    end = e + w#end shifted
    end_str = end.strftime("%Y-%m-%d")

    train_data = self.df.loc[start_str:end_str]

    ############Test data
    #trainEndDate here, that's how Yushu plotted the lines
    #but this will make incorrect predictions, for plot maybe do one week subtract if needed.
    #so, testStartDat is next week of train end

    if self.trainEndDate < self.endDate:
        w = datetime.timedelta(weeks=shift + 1)  # next of train end date
        start = e + w  # test start date shifted, a day after train end; e is the unshifted trainEndDate
        start_str = start.strftime("%Y-%m-%d")

    elif self.trainEndDate == self.endDate:
        # start fixed, irrespective of shift value
        # Only use strptime if self.testEndDate is a string
        if isinstance(self.testStartDate, str):
            s = datetime.datetime.strptime(self.testStartDate, "%Y-%m-%d")
        else:
            s = self.trainEndDate  # Already a datetime object
        w = datetime.timedelta(weeks=shift)
        start = s + w  # start shifted
        start_str = start.strftime("%Y-%m-%d")

    #end same as wave end date actually
    # Only use strptime if self.testEndDate is a string
    if isinstance(self.testEndDate, str):
        e = datetime.datetime.strptime(self.testEndDate, "%Y-%m-%d")
    else:
        e = self.testEndDate  # Already a datetime object

    w = datetime.timedelta(weeks=shift)
    end = e + w#end shifted
    end_str = end.strftime("%Y-%m-%d")

    test_data = self.df.loc[start_str:end_str]

    return wave_data, train_data, test_data

  def get_wave_test_start_date_with_shift(self, shift):#need to change this, yushu definition.
    """
    Gets the test start date, enddate after calculating shift. Test start and end shifted.
    for plot display
    Args:
      wave:Wave object
      shift (int): shift in weeks
    Returns:
      start_str (string): Test start date with shift
      end_str (string): Test end date with shift
    """

    # Only use strptime if self.testEndDate is a string
    if isinstance(self.trainEndDate, str):
        e = datetime.datetime.strptime(self.trainEndDate, "%Y-%m-%d")
    else:
        e = self.trainEndDate  # Already a datetime object

    w = datetime.timedelta(weeks=shift+1)#next of train end date
    start = e + w #test start date shifted, a day after train end
    start_str = start.strftime("%Y-%m-%d")

    # Only use strptime if self.testEndDate is a string
    if isinstance(self.testEndDate, str):
        e = datetime.datetime.strptime(self.testEndDate, "%Y-%m-%d")
    else:
        e = self.testEndDate  # Already a datetime object

    w = datetime.timedelta(weeks=shift)
    end = e + w#end shifted
    end_str = end.strftime("%Y-%m-%d")

    return start_str, end_str


  def get_wave_dates_with_shift(self, shift, wave_start_shift_matrix, shift_type='Responsiveness'):
    """
    Gets the wave data, train data, and test data after calculating shift.

    Args:
      shift (int): shift in weeks.
      wave_start_shift_matrix: Matrix for shifting later waves' start dates.
      shift_type (str): Should be either 'shift' or 'Responsiveness'.

    Returns:
      DataFrame: Wave data with shift.
    """
    if shift_type not in ['Delay', 'Responsiveness']:
        raise ValueError("Invalid shift_type. Expected 'shift' or 'Responsiveness'.")

    if shift_type == 'Delay':
        return self.get_wave_dates_with_shift_delay(shift, wave_start_shift_matrix)

    return self.get_wave_dates_with_shift_responsiveness(shift, wave_start_shift_matrix)

#Wave.py


def generate_test_start_date(test_end_date, predictions):
  """
  Generates the test start date.
  Args:
    test_end_date (string): Test end date
    test_length (int): Test length
  Returns:
    test_start_date (string): Test start date
  """
  test_length = max(predictions) if predictions else 0
  e = datetime.datetime.strptime(test_end_date,"%Y-%m-%d")#test start date shifted
  w = datetime.timedelta(weeks=test_length-1)
  test_start_date = (e - w).strftime("%Y-%m-%d")
  return test_start_date

def generate_train_end_date(wave_end_date, predictions):
  """
  Generates the train end date.
  Args:
    wave_end_date (string): Wave end date
    test_length (int): Test length
  Returnsshift train_end_date (string): Train endshift
  """
  test_length = max(predictions) if predictions else 0
  e = datetime.datetime.strptime(wave_end_date,"%Y-%m-%d")#test start date shifted
  w = datetime.timedelta(weeks=test_length)
  train_end_date = (e - w).strftime("%Y-%m-%d")
  return train_end_date