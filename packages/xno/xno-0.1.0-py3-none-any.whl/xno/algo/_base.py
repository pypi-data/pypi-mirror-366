# xno/algo/_base.py
import logging
from abc import abstractmethod
from typing import Union, TypedDict, List, Dict
import pandas as pd
import numpy as np
from xno import OHLCHandler
from xno.algo.features import TimeseriesFeatures
from xno.analytics.vs import StrategyVisualizer
from xno.timeseries import CROSS, CROSS_ABOVE, CROSS_BELOW, LAG


class HistoryRecord(TypedDict):
    time: pd.Timestamp
    current_tick: int
    signal: float
    action: str
    amount: float
    value: float
    price: float
    fee: float
    equity: float # Current portfolio equity
    bm_equity: float # Benchmark portfolio equity
    step_ret: float
    cum_ret: float
    bm_step_ret: float
    bm_cum_ret: float

class Algorithm:
    """
    Base class for all trading algorithms.
    """
    _price_scale = 1  # Default price scale, can be overridden in subclasses
    def __init__(self):
        self._name = None
        self._init_cash = 1_000_000_000 # Default initial cash, can be overridden in subclasses
        self._slippage = 0.05  # Assumed slippage price impact, can be overridden in subclasses
        self._resolution = None
        self._ticker = None
        self._from_time = None
        self._to_time = None
        self._df_ticker = pd.DataFrame()
        self._features: Union[None, TimeseriesFeatures] = None
        self._init_price: float | None = None
        # The benchmark is used to compare the performance of the algorithm
        self._bm_open_size: int | None = None  # Number of shares for the benchmark, can be set in subclasses
        self._bm_equity: float | None = None  # Benchmark equity, can be set in subclasses
        # Store the current state of the algorithm
        self._current_time_idx: int | None = None
        self._current_time: pd.Timestamp | None = None
        self._current_position: float | None = None
        self._current_open_size: int | None = None
        self._current_equity: float | None = None
        # The algorithm will generate signals, which are stored in the following lists
        self._ht_times: List[pd.Timestamp] = []  # Timestamps for each signal
        self._ht_prices: List[float] = []  # Prices at which the signals were generated
        self._bt_results: List[HistoryRecord] = []  # Store trading history records
        self._bt_df: Union[pd.DataFrame, None] = None  # DataFrame to store the trading history records
        self._bt_columns = list(HistoryRecord.__annotations__.keys())  # Columns for the backtest DataFrame
        self.performance: Dict[str, float] = {}  # Store performance metrics
        self._signals: pd.Series | None = None  # Store the signals generated by the algorithm

    def __reset__(self):
        """
        Reset the algorithm state.
        This method should be called before running the algorithm.
        """
        self._init_price = float(self.df_ticker['Close'].values[0] * self._price_scale)  # Reset initial price
        # Current State
        self._current_time_idx = 0  # Reset current time index
        self._current_position = 0.0  # Reset current position
        self._current_open_size = 0  # Reset current open size
        self._ht_times.clear()
        self._ht_prices.clear()
        self._bt_results.clear()  # Clear the history records
        self._signals = pd.Series(dtype=float)  # Reset signals
        self._ht_times = self.df_ticker.index.tolist()  # Reset history times from the DataFrame index
        self._ht_prices = (self.df_ticker['Close'].values * self._price_scale).tolist()  # Reset history prices from the DataFrame

        # Allocate empty lists for history records
        self._current_time = self.df_ticker.index[0] if not self.df_ticker.empty else None
        # Initialize benchmark equity and current equity
        self._bm_equity = self._init_cash
        self._current_equity = self._init_cash
        # Add result backtest
        self._bt_df = pd.DataFrame(columns=self._bt_columns)
        # Init signals with all zeroes
        self._signals = pd.Series(0.0, index=self.df_ticker.index, dtype=float)

    @abstractmethod
    def __step__(self, time_idx: int):
        self._current_time_idx = time_idx

    @abstractmethod
    def __setup__(self):
        raise NotImplementedError("The setup method must be implemented by subclasses.")

    @abstractmethod
    def __algorithm__(self):
        raise NotImplementedError("The algorithm method must be implemented by subclasses.")

    def hold(self, conditions):
        self._signals[conditions] = 0.0  # Set hold signal

    def buy(self, conditions, weight=1):
        self._signals[conditions] = weight  # Set buy signal

    def sell(self, conditions, weight=1):
        self._signals[conditions] = -weight  # Set sell signal at the current time

    @property
    def Open(self):
        return self.df_ticker['Open'].values

    @property
    def High(self):
        return self.df_ticker['High'].values

    @property
    def Low(self):
        return self.df_ticker['Low'].values

    @property
    def Close(self):
        return self.df_ticker['Close'].values

    @property
    def Volume(self):
        return self.df_ticker['Volume'].values

    def __load_data__(self):
        assert self._ticker is not None, "Ticker must be set before loading data."
        logging.info(f"Loading data for tickers: {self._ticker} from {self._from_time} to {self._to_time}")
        if self._resolution != 'D':
            load_resolution = "m" if self._resolution.endswith('min') else self._resolution[-1]
        else:
            load_resolution = "D"

        data_handler = OHLCHandler([self._ticker], resolution=load_resolution)
        data_handler.load_data(from_time=self._from_time, to_time=self._to_time)
        self.df_ticker = data_handler.get_data(self._ticker)
        self.df_ticker = self.df_ticker.xs(self._ticker, level="Symbol", drop_level=True)
        # Resample
        if self._resolution != "D":
            self.df_ticker = self.df_ticker.resample(self._resolution).agg({
                'Open': 'first',
                'High': 'max',
                'Low': 'min',
                'Close': 'last',
                'Volume': 'sum'
            }).dropna()

        if self.df_ticker.empty:
            raise ValueError(f"No data found for ticker {self._ticker} in the specified date range.")
        logging.info(f"Data loaded for ticker {self._ticker} with {len(self.df_ticker)} records.")

    def run(self):
        """
        Vectorized run method for the algorithm.
        """
        self.__setup__()
        self.__load_data__()
        self.__reset__()
        self._features = TimeseriesFeatures(self.df_ticker)  # Initialize features with the full DataFrame
        # Run the core trading algorithm (fills self._signals)
        self.__algorithm__()
        if not hasattr(self, "_signals") or self._signals is None:
            raise ValueError("Trading signals (_signals) are not generated.")

        # Step through each signal (buy/sell/hold) and simulate trading
        for time_idx in range(len(self._signals)):
            self.__step__(time_idx)

        # Finalize (e.g., calculate metrics, save results)
        self.__done__()

    @classmethod
    def crossed(cls, series1: Union[pd.Series, np.ndarray], series2: Union[pd.Series, np.ndarray]) -> bool:
        """
        Check if series1 crosses over series2.

        :param series1: The first series to check.
        :param series2: The second series to check.
        :return: True if series1 crosses over series2, False otherwise.
        """
        return CROSS(series1, series2)

    @classmethod
    def crossed_above(cls, series1: Union[pd.Series, np.ndarray, float], series2: Union[pd.Series, np.ndarray, float]) -> bool:
        """
        Check if series1 is above series2.

        :param series1: The first series to check.
        :param series2: The second series to check.
        :return: True if series1 is above series2, False otherwise.
        """
        return CROSS_ABOVE(series1, series2)

    @classmethod
    def crossed_below(cls, series1: Union[pd.Series, np.ndarray, float], series2: Union[pd.Series, np.ndarray, float]) -> bool:
        """
        Check if series1 is below series2.

        :param series1: The first series to check.
        :param series2: The second series to check.
        :return: True if series1 is below series2, False otherwise.
        """
        return CROSS_BELOW(series1, series2)

    @classmethod
    def current(cls, series):
        if isinstance(series, pd.Series):
            return series.values
        elif isinstance(series, np.ndarray):
            return series
        else:
            raise TypeError(f"Unsupported type {type(series)} for `current()`")

    @classmethod
    def previous(cls, series, periods: int = 1):
        if isinstance(series, pd.Series):
            return LAG(series.values, periods)
        elif isinstance(series, np.ndarray):
            return LAG(series, periods)
        else:
            raise TypeError(f"Unsupported type {type(series)} for `current()`")

    @classmethod
    def And(cls, *conditions):
        if not conditions:
            raise ValueError("And() requires at least one condition")
        result = conditions[0]
        for cond in conditions[1:]:
            result = result & cond  # element-wise AND
        return result

    @classmethod
    def Or(cls, *conditions):
        if not conditions:
            raise ValueError("Or() requires at least one condition")
        result = conditions[0]
        for cond in conditions[1:]:
            result = result | cond  # element-wise OR
        return result

    def __done__(self):
        """
        Finalize the algorithm run.
        1. Convert the results to pd.DataFrame.
        2. Add columns: `step_ret`, `cum_ret`, `bm_step_ret`, `bm_cum_ret`.
        """
        logging.info(f"Algorithm `{self._name}` run completed. Total records: {len(self._bt_results)}")
        self._bt_df = pd.DataFrame(self._bt_results, columns=self._bt_columns)
        # Vectorized calculations for returns
        equity = self._bt_df['equity'].values
        bm_equity = self._bt_df['bm_equity'].values
        # Strategy returns
        step_ret = np.zeros_like(equity, dtype=np.float64)
        step_ret[1:] = (equity[1:] - equity[:-1]) / equity[:-1]
        cum_ret = np.cumprod(1 + step_ret) - 1

        # Benchmark returns
        bm_step_ret = np.zeros_like(bm_equity, dtype=np.float64)
        bm_step_ret[1:] = (bm_equity[1:] - bm_equity[:-1]) / bm_equity[:-1]
        bm_cum_ret = np.cumprod(1 + bm_step_ret) - 1

        # Assign back to DataFrame
        self._bt_df['step_ret'] = step_ret
        self._bt_df['cum_ret'] = cum_ret
        self._bt_df['bm_step_ret'] = bm_step_ret
        self._bt_df['bm_cum_ret'] = bm_cum_ret
        self._bt_df.set_index('time', inplace=True)
        return self

    def visualize(self):
        visualizer = StrategyVisualizer(self._bt_df)
        visualizer.name = self._name
        visualizer.visualize()
