var Q={};Q.layout=(d,b,E,_)=>{let S=0,z=e=>{let l=++S;return e+l},H=e=>{if(Array.isArray(e)&&e.every(t=>!Array.isArray(t)))return e;let l=[];for(let t of e){if(!Array.isArray(t)){l.push(t);continue}for(let a of t)l.push(a)}return l},j=(e,l,t,a)=>{let c="";do c=z(a);while(e.hasNode(c));return t.dummy=l,e.setNode(c,t),c},U=e=>{let l=new Q.Graph(!0,!1);for(let t of e.nodes.values()){let a=t.v;e.hasChildren(a)||l.setNode(a,t.label)}for(let t of e.edges.values())l.setEdge(t.v,t.w,t.label);return l},re=e=>{let l=Number.NEGATIVE_INFINITY;for(let t of e.nodes.values()){let a=t.label.rank;a!==void 0&&a>l&&(l=a)}return l===Number.NEGATIVE_INFINITY?void 0:l},se=e=>{let l=re(e),t=l===void 0?0:l+1,a=Array.from(new Array(t),()=>[]);for(let c of e.nodes.values()){let o=c.label,f=o.rank;f!==void 0&&(a[f][o.order]=c.v)}return a},ce=(e,l,t)=>{t.ranksep/=2;let a=t.rankdir;for(let c of e.edges.values()){let o=c.label;o.minlen*=2,o.labelpos.toLowerCase()!=="c"&&(a==="TB"||a==="BT"?o.width+=o.labeloffset:o.height+=o.labeloffset)}},Te=e=>{for(let l of e.edges.values())if(l.v===l.w){let t=l.vNode.label;t.selfEdges||(t.selfEdges=[]),t.selfEdges.push({e:l,label:l.label}),e.removeEdge(l)}},_e=e=>{let l=[],t=new Set,a=new Set,c=Array.from(e.nodes.keys()).reverse();for(;c.length>0;){let o=c.pop();if(Array.isArray(o))a.delete(o[0]);else if(!t.has(o)){t.add(o),a.add(o),c.push([o]);let f=e.node(o).out;for(let p=f.length-1;p>=0;p--){let x=f[p];a.has(x.w)&&l.push(x),c.push(x.w)}}}for(let o of l){let f=o.label;e.removeEdge(o),f.forwardName=o.name,f.reversed=!0,e.setEdge(o.w,o.v,f,z("rev"))}},Re=e=>{for(let l of e.edges.values()){let t=l.label;if(t.reversed){t.points.reverse(),e.removeEdge(l);let a=t.forwardName;delete t.reversed,delete t.forwardName,e.setEdge(l.w,l.v,t,a)}}},ie=(e,l)=>l.wNode.label.rank-l.vNode.label.rank-l.label.minlen,Oe=e=>{e=U(e);let l=c=>{let o=new Q.Graph(!1,!1),f=c.nodes.keys().next().value,p=c.nodes.size;o.setNode(f,{});let x=(w,G)=>{let O=Array.from(w.nodes.keys()).reverse();for(;O.length>0;){let C=O.pop(),B=G.node(C);for(let T of B.in.concat(B.out)){let P=T.v,q=C===P?T.w:P;!w.hasNode(q)&&!ie(G,T)&&(w.setNode(q,{}),w.setEdge(C,q,{}),O.push(q))}}return w.nodes.size};for(;x(o,c)<p;){let w=Number.MAX_SAFE_INTEGER,G=null;for(let C of c.edges.values())if(o.hasNode(C.v)!==o.hasNode(C.w)){let B=ie(c,C);B<w&&(w=B,G=C)}let O=o.hasNode(G.v)?ie(c,G):-ie(c,G);for(let C of o.nodes.keys())c.node(C).label.rank+=O}return o},t=c=>{let o=new Set,f=[Array.from(c.nodes.values()).filter(p=>p.in.length===0).reverse()];for(;f.length>0;){let p=f[f.length-1];if(Array.isArray(p)){let x=p.pop();if(p.length===0&&f.pop(),!o.has(x)){o.add(x);let w=x.out.map(G=>G.wNode);w.length>0?(f.push(x),f.push(w.reverse())):x.label.rank=0}}else{f.pop();let x=Number.MAX_SAFE_INTEGER;for(let w of p.out)x=Math.min(x,w.wNode.label.rank-w.label.minlen);p.label.rank=x}}},a=c=>{let o=T=>{let P=new Q.Graph(!0,!1);for(let q of T.nodes.values())P.setNode(q.v,q.label);for(let q of T.edges.values()){let u=P.edge(q.v,q.w),R=u?u.label:{weight:0,minlen:1},N=q.label;P.setEdge(q.v,q.w,{weight:R.weight+N.weight,minlen:Math.max(R.minlen,N.minlen)})}return P},f=(T,P)=>{let q=(R,N,k)=>{let i=1,s=new Map,r=[[k,null,0]];for(;r.length>0;){let[n,h,m]=r.pop();if(m===0){if(!N.has(n)){N.add(n);let g=R.node(n).label,A=i;s.set(n,{label:g,low:A,parent:h,lim:null}),r.push([n,h,1]);for(let v of R.neighbors(n))N.has(v)||r.push([v,n,0])}}else{let g=s.get(n),A=g.label;A.low=g.low,A.lim=i++,g.parent?A.parent=g.parent:delete A.parent}}};P=T.nodes.keys().next().value,q(T,new Set,P)},p=(T,P)=>{let q=[],u=new Set,R=[Array.from(T.nodes.keys()).reverse()];for(;R.length>0;){let N=R[R.length-1];if(Array.isArray(N)){let k=N.pop();if(N.length===0&&R.pop(),!u.has(k)){u.add(k);let i=T.neighbors(k);i.size>0?(R.push(k),R.push(Array.from(i).reverse())):q.push(k)}}else q.push(R.pop())}for(let N of q.slice(0,q.length-1)){let i=T.node(N).label.parent,s=P.edge(N,i),r=!!s,h=(s?s.label:P.edge(i,N).label).weight,m=P.node(N);for(let g of m.in.concat(m.out)){let A=g.v===N,v=A?g.w:g.v;if(v!==i){let y=A===r;h+=y?g.label.weight:-g.label.weight;let L=T.edge(N,v);if(L){let I=L.label.cutvalue;h+=y?-I:I}}}T.edge(N,i).label.cutvalue=h}},x=T=>Array.from(T.edges.values()).find(P=>P.label.cutvalue<0),w=(T,P,q)=>{let u=q.v,R=q.w;P.edge(u,R)||(u=q.w,R=q.v);let N=T.node(u).label,k=T.node(R).label,i=N,s=!1;N.lim>k.lim&&(i=k,s=!0);let r=(m,g)=>g.low<=m.lim&&m.lim<=g.lim,n=Number.POSITIVE_INFINITY,h=null;for(let m of P.edges.values())if(s===r(T.node(m.v).label,i)&&s!==r(T.node(m.w).label,i)){let g=ie(P,m);g<n&&(n=g,h=m)}return h},G=(T,P,q,u)=>{T.removeEdge(q),T.setEdge(u.v,u.w,{}),f(T),p(T,P);let N=[Array.from(T.nodes.keys()).find(s=>!P.node(s).label.parent)],k=new Set;for(;N.length>0;){let s=N.pop();if(!k.has(s)){k.add(s);let r=Array.from(T.neighbors(s));for(let n=r.length-1;n>=0;n--)N.push(r[n])}}let i=Array.from(k);for(let s of i.slice(1)){let r=T.node(s).label.parent,n=P.edge(s,r),h=!1;n||(n=P.edge(r,s),h=!0),P.node(s).label.rank=P.node(r).label.rank+(h?n.label.minlen:-n.label.minlen)}};c=o(c),t(c);let O=l(c);f(O),p(O,c);let C=null,B=null;for(;C=x(O);)B=w(O,c,C),G(O,c,C,B)};switch(E.ranker){case"tight-tree":t(e),l(e);break;case"longest-path":t(e);break;default:a(e);break}},Le=e=>{for(let l of e.edges.values()){let t=l.label;if(t.width&&t.height){let a=l.vNode.label,c=l.wNode.label;j(e,"edge-proxy",{rank:(c.rank-a.rank)/2+a.rank,e:l},"_ep")}}},De=(e,l)=>{if(e.nodes.size>0){let t=Number.MAX_SAFE_INTEGER,a=Number.MIN_SAFE_INTEGER,c=Array.from(e.nodes.values());for(let f of c){let p=f.label;p.rank!==void 0&&(t=Math.min(t,p.rank),a=Math.max(a,p.rank))}let o=a-t;if(o>0){let f=new Array(o);for(let w of c){let G=w.label;if(G.rank!==void 0){let O=G.rank-t;f[O]||(f[O]=[]),f[O].push(w.v)}}let p=0,x=l.nodeRankFactor;for(let w=0;w<f.length;w++){let G=f[w];if(G===void 0&&w%x!==0)p--;else if(p&&G)for(let O of G)e.node(O).label.rank+=p}}}},Ge=(e,l)=>{let t=j(e,"root",{},"_root"),a=w=>{let G={},O=(C,B)=>{for(let T of w.children(C))O(T,B+1);G[C]=B};for(let C of w.children())O(C,1);return G},c=(w,G,O,C,B,T,P)=>{let q=Array.from(w.children(P));if(!q.length){P!==G&&w.setEdge(G,P,{weight:0,minlen:O});return}let u=j(w,"border",{width:0,height:0},"_bt"),R=j(w,"border",{width:0,height:0},"_bb"),N=w.node(P).label;w.hasBorder=!0,w.setParent(u,P),N.borderTop=u,w.setParent(R,P),N.borderBottom=R;for(let k of q){c(w,G,O,C,B,T,k);let i=w.node(k).label,s=i.borderTop?i.borderTop:k,r=i.borderBottom?i.borderBottom:k,n=i.borderTop?C:2*C,h=s===r?B-T[P]+1:1;w.setEdge(u,s,{weight:n,minlen:h,nestingEdge:!0}),w.setEdge(r,R,{weight:n,minlen:h,nestingEdge:!0})}w.parent(P)||w.setEdge(G,u,{weight:0,minlen:B+T[P]})},o=a(e),f=Math.max(...Object.values(o))-1,p=2*f+1;l.nestingRoot=t;for(let w of e.edges.values())w.label.minlen*=p;let x=Array.from(e.edges.values()).reduce((w,G)=>w+G.label.weight,0)+1;for(let w of e.children())c(e,t,p,x,f,o,w);l.nodeRankFactor=p},Me=(e,l)=>{e.removeNode(l.nestingRoot),delete l.nestingRoot;for(let t of e.edges.values())t.label.nestingEdge&&e.removeEdge(t)},Ve=(e,l)=>{let t=Number.POSITIVE_INFINITY;for(let c of e.nodes.values()){let o=c.label.rank;o!==void 0&&o<t&&(t=o)}for(let c of e.nodes.values()){let o=c.label;o.rank!==void 0&&(o.rank-=t)}let a=0;if(e.hasBorder)for(let c of e.nodes.values()){let o=c.label;o.borderTop&&(o.minRank=e.node(o.borderTop).label.rank,o.maxRank=e.node(o.borderBottom).label.rank,a=Math.max(a,o.maxRank))}l.maxRank=a},Ce=(e,l)=>{l.dummyChains=[];for(let t of e.edges.values()){let a=t.v,c=t.w,o=t.name,f=t.label,p=f.labelRank,x=e.node(a).label.rank,w=e.node(c).label.rank;if(w!==x+1){e.removeEdge(t);let G=!0;for(x++;x<w;){f.points=[],delete t.key;let O={width:0,height:0,edgeLabel:f,edgeObj:t,rank:x},C=j(e,"edge",O,"_d");x===p&&(O.width=f.width,O.height=f.height,O.dummy="edge-label",O.labelpos=f.labelpos),e.setEdge(a,C,{weight:f.weight},o),G&&(l.dummyChains.push(C),G=!1),a=C,x++}e.setEdge(a,c,{weight:f.weight},o)}}},Se=(e,l)=>{for(let t of l.dummyChains){let a=e.node(t).label,c=a.edgeLabel,o=a.edgeObj;for(e.setEdge(o.v,o.w,c,o.name);a.dummy;){let f=e.successors(t).keys().next().value;e.removeNode(t),c.points.push({x:a.x,y:a.y}),a.dummy==="edge-label"&&(c.x=a.x,c.y=a.y,c.width=a.width,c.height=a.height),t=f,a=e.node(t).label}}},Pe=e=>{for(let l of e.nodes.values()){let t=l.label;t.dummy==="edge-proxy"&&(t.e.label.labelRank=t.rank,e.removeNode(l.v))}},qe=(e,l)=>{let t=(o,f,p,x)=>{let w=Math.min(f[p].low,f[x].low),G=Math.max(f[p].lim,f[x].lim),O=p,C=[];do O=o.parent(O),C.push(O);while(O&&(f[O].low>w||G>f[O].lim));let B=O;O=x;let T=[];for(;(O=o.parent(O))!==B;)T.push(O);return{path:C.concat(T.reverse()),lca:B}},c=(o=>{let f={},p=0,x=w=>{let G=p;for(let O of o.children(w))x(O);f[w]={low:G,lim:p++}};for(let w of o.children())x(w);return f})(e);for(let o of l.dummyChains||[]){let p=e.node(o).label.edgeObj,x=t(e,c,p.v,p.w),w=x.path,G=x.lca,O=0,C=w[O],B=!0;for(;o!==p.w;){let T=e.node(o).label;if(B){for(;(C=w[O])!==G&&e.node(C).label.maxRank<T.rank;)O++;C===G&&(B=!1)}if(!B){for(;O<w.length-1&&e.node(w[O+1]).label.minRank<=T.rank;)O++;C=w[O]}e.setParent(o,C),o=e.successors(o).keys().next().value}}},Ye=e=>{let l=(a,c,o,f,p,x)=>{let w={width:0,height:0,rank:x,borderType:c},G=p[c][x-1],O=j(a,"border",w,o);p[c][x]=O,a.setParent(O,f),G&&a.setEdge(G,O,{weight:1})},t=Array.from(e.children());for(let a=0;a<t.length;a++){let c=t[a],o=e.node(c).label;if("minRank"in o){o.borderLeft=[],o.borderRight=[];let p=o.maxRank+1;for(let x=o.minRank;x<p;x++)l(e,"borderLeft","_bl",c,o,x),l(e,"borderRight","_br",c,o,x)}let f=e.children(c);for(let p of f)t.push(p)}},ze=e=>{let l=(u,R,N,k)=>{let i=(I,D)=>{let V=new Map;for(let M=0;M<I.length;M++){let F=I[M],Z={indegree:0,in:[],out:[],vs:[F.v],i:M};F.barycenter!==void 0&&(Z.barycenter=F.barycenter,Z.weight=F.weight),V.set(F.v,Z)}for(let M of D.edges.values()){let F=V.get(M.v),Z=V.get(M.w);F&&Z&&(Z.indegree++,F.out.push(Z))}let Y=Array.from(V.values()).filter(M=>!M.indegree),X=[];function $(M){return function(F){if(!F.merged&&(F.barycenter===void 0||M.barycenter===void 0||F.barycenter>=M.barycenter)){let Z=0,te=0;M.weight&&(Z+=M.barycenter*M.weight,te+=M.weight),F.weight&&(Z+=F.barycenter*F.weight,te+=F.weight),M.vs=F.vs.concat(M.vs),M.barycenter=Z/te,M.weight=te,M.i=Math.min(F.i,M.i),F.merged=!0}}}function K(M){return function(F){F.in.push(M),--F.indegree===0&&Y.push(F)}}for(;Y.length;){let M=Y.pop();X.push(M),M.in.reverse().forEach($(M)),M.out.forEach(K(M))}return X.filter(M=>!M.merged).map(M=>{let F={vs:M.vs,i:M.i};return M.barycenter!==void 0&&(F.barycenter=M.barycenter),M.weight!==void 0&&(F.weight=M.weight),F})},s=(I,D)=>Array.from(D).map(V=>{let Y=I.node(V).in;if(!Y.length)return{v:V};let X=Y.reduce(($,K)=>{let M=K.label,F=K.vNode.label;return{sum:$.sum+M.weight*F.order,weight:$.weight+M.weight}},{sum:0,weight:0});return{v:V,barycenter:X.sum/X.weight,weight:X.weight}}),r=(I,D)=>{let V=(J,ee,ne)=>{let xe=null;for(;ee.length&&(xe=ee[ee.length-1]).i<=ne;)ee.pop(),J.push(xe.vs),ne++;return ne},Y=J=>function(ee,ne){return ee.barycenter<ne.barycenter?-1:ee.barycenter>ne.barycenter?1:J?ne.i-ee.i:ee.i-ne.i},X={lhs:[],rhs:[]};for(let J of I)"barycenter"in J?X.lhs.push(J):X.rhs.push(J);let $=X.lhs,K=X.rhs.sort((J,ee)=>-J.i+ee.i),M=[],F=0,Z=0,te=0;$.sort(Y(!!D)),te=V(M,K,te);for(let J of $)te+=J.vs.length,M.push(J.vs),F+=J.barycenter*J.weight,Z+=J.weight,te=V(M,K,te);let ue={vs:H(M)};return Z&&(ue.barycenter=F/Z,ue.weight=Z),ue},n=u.node(R),h=n&&n.label?n.label.borderLeft:void 0,m=n&&n.label?n.label.borderRight:void 0,g={},A=h?Array.from(u.children(R)).filter(I=>I!==h&&I!==m):u.children(R),v=s(u,A);for(let I of v)if(u.hasChildren(I.v)){let D=l(u,I.v,N,k);g[I.v]=D,"barycenter"in D&&(I.barycenter===void 0?(I.barycenter=D.barycenter,I.weight=D.weight):(I.barycenter=(I.barycenter*I.weight+D.barycenter*D.weight)/(I.weight+D.weight),I.weight+=D.weight))}let y=i(v,N);for(let I of y)I.vs=H(I.vs.map(D=>g[D]?g[D].vs:D));let L=r(y,k);if(h){L.vs=H([h,L.vs,m]);let I=u.predecessors(h);if(I.size>0){let D=u.node(I.keys().next().value).label,V=u.node(u.predecessors(m).keys().next().value).label;"barycenter"in L||(L.barycenter=0,L.weight=0),L.barycenter=(L.barycenter*L.weight+D.order+V.order)/(L.weight+2),L.weight+=2}}return L},t=(u,R)=>{let N=new Q.Graph(!0,!1);for(let k of u){let i=k.root,r=l(k,i,N,R).vs,n=r.length;for(let A=0;A<n;A++)k.node(r[A]).label.order=A;let h={},m="",g=!1;for(let A of r){let v=k.parent(A),y=null;for(;v;){let L=k.parent(v);if(L?(y=h[L],h[L]=v):(y=m,m=v),y&&y!==v){N.setEdge(y,v,null),g=!0;break}v=L}if(g)break}}},a=(u,R,N)=>{let k=0;for(let i=1;i<R.length;i++){let s=R[i-1],r=R[i],n=new Map;for(let v=0;v<r.length;v++)n.set(r[v],v);let h=[];for(let v of s){let y=[];for(let L of u.node(v).out)y.push({pos:n.get(L.w),weight:L.label.weight});y.sort((L,I)=>L.pos-I.pos);for(let L of y)h.push(L)}let m=1;for(;m<r.length;)m<<=1;let g=2*m-1;m-=1;let A=Array.from(new Array(g),()=>0);for(let v of h){let y=v.pos+m;A[y]+=v.weight;let L=0;for(;y>0;)y%2&&(L+=A[y+1]),y=y-1>>1,A[y]+=v.weight;k+=v.weight*L}if(k>N)break}return k},c=u=>{let R=new Set,N=Array.from(u.nodes.values()).filter(i=>!u.hasChildren(i.v)),k=-1;for(let i of N){let s=i.label.rank;(k===-1||s!==void 0&&s>k)&&(k=s)}if(k!==-1){let i=Array.from(new Array(k+1),()=>[]),s=N.sort((r,n)=>r.label.rank-n.label.rank).map(r=>r.v).reverse();for(let r=0;r<s.length;r++){let n=s[r];if(!R.has(n)){R.add(n);let h=u.node(n).label.rank;i[h].push(n),s.push(...u.successors(n).keys())}}return i}return[]},o=(u,R,N,k,i)=>{let s="";for(;u.hasNode(s=z("_root")););let r=new Q.Graph(!0,!0);r.root=s,r.setDefaultNodeLabel(h=>{let m=u.node(h);return m?m.label:void 0});let n=R.length;if(u.hasBorder){let h=0;for(;h<n;){let m=R[h++],g=m.label;if(g.rank===k||"minRank"in g&&"maxRank"in g&&g.minRank<=k&&k<=g.maxRank){let A=m.v;r.setNode(A);let v=u.parent(A);if(r.setParent(A,v||s),i)for(let y of m.in)r.setEdge(y.v,A,{weight:y.label.weight});else for(let y of m.out)r.setEdge(y.w,A,{weight:y.label.weight});"minRank"in g&&r.setNode(A,{borderLeft:g.borderLeft[k],borderRight:g.borderRight[k]})}}}else{let h=N.get(k);for(;h<n;){let m=R[h++];if(m.label.rank!==k)break;let A=m.v;r.setNode(A);let v=u.parent(A);if(r.setParent(A,v||s),i)for(let y of m.in)r.setEdge(y.v,A,{weight:y.label.weight});else for(let y of m.out)r.setEdge(y.w,A,{weight:y.label.weight})}}return r},f=c(e),p=(u,R)=>{for(let N of R)for(let k=0;k<N.length;k++)u.node(N[k]).label.order=k};p(e,f);let x=re(e)||0,w=new Array(x),G=new Array(x),O=Array.from(e.nodes.values()),C=null;if(!e.hasBorder){O.sort((u,R)=>u.label.rank-R.label.rank),C=new Map;for(let u=0;u<O.length;++u){let N=O[u].label.rank;C.has(N)||C.set(N,u)}}for(let u=0;u<x;u++)w[u]=o(e,O,C,u+1,!0),G[u]=o(e,O,C,x-u-1,!1);let B=Number.POSITIVE_INFINITY,T=[];for(let u=0,R=0;R<4;++u,++R){t(u%2?w:G,u%4>=2),f=se(e);let N=a(e,f,B);if(N<B){R=0;let k=f.length;T=new Array(k);for(let i=0;i<k;i++)T[i]=f[i].slice();B=N}}let P=(u,R)=>u<R?1:2;for(let u=4;u<T.length;u+=2){let R=T[u];for(let N=0;N<R.length;++N){let k=e.nodes.get(R[N]);if(k.in&&k.in.length===2){let i=k.in[0].vNode.in[0].vNode,s=k.in[1].vNode.in[0].vNode,r=[],n=0;for(let h=u-2;h>=0;h-=2){let m=T[h],g=m.indexOf(i.v),A=m.indexOf(s.v),v=P(g,A);if(n|=v,g===A||Math.abs(g-A)!==1||i.in.length!==1||s.in.length!==1||i.out.length!==1||s.out.length!==1){if(n===3){let y=v,L=h+2;for(;r.length!==0;){let I=r.pop(),D=r.pop(),V=T[L],Y=T[L-1],X=Y.indexOf(e.node(V[D]).in[0].v),$=Y.indexOf(e.node(V[I]).in[0].v);P(D,I)!==y&&([V[D],V[I]]=[V[I],V[D]]),P(X,$)!==y&&([Y[X],Y[$]]=[Y[$],Y[X]]),L+=2}}break}r.push(g,A),i=i.in[0].vNode.in[0].vNode,s=s.in[0].vNode.in[0].vNode}}}}let q=(u,R,N)=>{let k=u.indexOf(R.v),i=u.indexOf(N.v);u[i]=R.v,u[k]=N.v};for(let u=0;u<T.length-2;u+=2){let R=T[u],N=T[u+1],k=T[u+2];for(let i=0;i<R.length;++i){let s=e.nodes.get(R[i]);if(s.out&&s.out.length>=2)for(let r=0;r<s.out.length-1;++r){let n=s.out[r].wNode,h=s.out[r+1].wNode,m=n.out[0].wNode,g=h.out[0].wNode;N.indexOf(n.v)<N.indexOf(h.v)^k.indexOf(m.v)<k.indexOf(g.v)&&q(N,n,h)}}for(let i=0;i<k.length;++i){let s=e.nodes.get(k[i]);if(s.in&&s.in.length>=2)if(s.in.length===2){let r=s.in[0].vNode,n=s.in[1].vNode,h=r.in[0].vNode,m=n.in[0].vNode;N.indexOf(r.v)<N.indexOf(n.v)^R.indexOf(h.v)<R.indexOf(m.v)&&q(N,r,n)}else{let r=[];for(let n=0;n<s.in.length;++n){let h=s.in[n].vNode,m=h.in[0].vNode,g=R.indexOf(m.v),A=N.indexOf(h.v);s.in[n].idx0=g,r.push(A)}s.in.sort((n,h)=>n.idx0-h.idx0),r.sort((n,h)=>n-h);for(let n=0;n<r.length;++n)N[r[n]]=s.in[n].v}}}for(let u=0;u<T.length-4;u+=2){let R=T[u],N=T[u+2],k=T[u+4];if(N.length>=2&&k.length>=2){let i=T[u+1],s=T[u+3];for(let r=0;r<R.length;++r){let n=e.nodes.get(R[r]);if(n.in&&n.out&&n.out.length>=2)for(let h=0;h<n.out.length-1;++h){let m=n.out[h].wNode,g=n.out[h+1].wNode,A=m.out[0].wNode,v=g.out[0].wNode;if(A.out.length===1&&v.out.length===1){let y=N.indexOf(A.v),L=N.indexOf(v.v);if(y+1===L){let I=A.out[0].wNode,D=v.out[0].wNode;if(I.out.length===1&&D.out.length===1){let V=I.out[0].wNode,Y=D.out[0].wNode,X=k.indexOf(V.v),$=k.indexOf(Y.v);X>$&&(q(i,m,g),q(N,A,v),q(s,I,D),++h)}}}}}for(let r=0;r<N.length-1;++r){let n=e.nodes.get(N[r]);if(n.in&&n.out&&n.in.length===1&&n.out.length===1){let h=e.nodes.get(N[r+1]);if(h.in&&h.out&&h.in.length===1&&h.out.length===1){let m=n.in[0].vNode,g=h.in[0].vNode;if(m.in.length===1&&g.in.length===1){let A=m.in[0].vNode,v=g.in[0].vNode,y=R.indexOf(A.v),L=R.indexOf(v.v);if(L+1===y){let I=n.out[0].wNode,D=h.out[0].wNode;y=s.indexOf(I.v),L=s.indexOf(D.v),y+1===L&&I.out[0].wNode===D.out[0].wNode&&(q(i,m,g),q(N,n,h),q(s,I,D),r+=1)}}}}}}}p(e,T)},Fe=e=>{let l=se(e);for(let t of l){let a=0;t.forEach((c,o)=>{let f=e.node(c).label;if(f.order=o+a,f.selfEdges){for(let p of f.selfEdges)j(e,"selfedge",{width:p.label.width,height:p.label.height,rank:f.rank,order:o+ ++a,e:p.e,label:p.label},"_se");delete f.selfEdges}})}},we=e=>{for(let l of e.nodes.values()){let t=l.label,a=t.width;t.width=t.height,t.height=a}for(let l of e.edges.values()){let t=l.label,a=t.width;t.width=t.height,t.height=a}},He=(e,l,t)=>{let a=t.rankdir.toLowerCase();(a==="lr"||a==="rl")&&we(e)},Be=(e,l,t)=>{let a=t.rankdir.toLowerCase();if(a==="bt"||a==="rl"){for(let c of e.nodes.values())c.label.y=-c.label.y;for(let c of e.edges.values()){let o=c.label;for(let f of o.points)f.y=-f.y;"y"in o&&(o.y=-o.y)}}if(a==="lr"||a==="rl"){let c=o=>{[o.x,o.y]=[o.y,o.x]};for(let o of e.nodes.values())c(o.label);for(let o of e.edges.values()){let f=o.label;for(let p of f.points)c(p);f.x!==void 0&&c(f)}we(e)}},$e=(e,l,t)=>{let a=(i,s,r)=>{s>r&&([s,r]=[r,s]);let n=i.get(s);n||(n=new Set,i.set(s,n)),n.add(r)},c=(i,s,r)=>(s>r&&([s,r]=[r,s]),i.has(s)&&i.get(s).has(r)),o=(i,s,r,n,h)=>{let m=s.nodesep,g=s.edgesep,A=new Q.Graph(!0,!1);for(let v of r){let y=null;for(let L of v){let I=n.get(L);if(A.setNode(I,{}),y){let D=n.get(y),V=i.node(L).label,Y=i.node(y).label,X=0,$=0;if(X+=V.width/2,"labelpos"in V)switch(V.labelpos){case"l":$=-V.width/2;break;case"r":$=V.width/2;break;default:throw new Q.Error(`Unsupported label position '${V.labelpos}'.`)}if($&&(X+=h?$:-$),$=0,X+=(V.dummy?g:m)/2,X+=(Y.dummy?g:m)/2,X+=Y.width/2,"labelpos"in Y)switch(Y.labelpos){case"l":$=Y.width/2;break;case"r":$=-Y.width/2;break;default:throw new Q.Error(`Unsupported label position '${Y.labelpos}'.`)}$&&(X+=h?$:-$);let K=A.edge(D,I),M=Math.max(X,K?K.label:0);K?K.label=M:A.setEdge(D,I,M)}y=L}}return A},f=(i,s,r)=>{let n=new Map,h=new Map,m=new Map;for(let g of i){let A=0;for(let v of g)n.set(v,v),h.set(v,v),m.set(v,A),A++}for(let g of i){let A=-1;for(let v of g){let y=r(v);if(y.size>0){y=Array.from(y.keys()),y=y.sort((D,V)=>m.get(D)-m.get(V));let L=(y.length-1)/2.0000001,I=Math.ceil(L);for(let D=Math.floor(L);D<=I;D++){let V=y[D];if(h.get(v)===v&&A<m.get(V)&&!c(s,v,V)){let Y=n.get(V);h.set(V,v),h.set(v,Y),n.set(v,Y),A=m.get(V)}}}}}return{root:n,align:h}},p=(i,s,r,n,h,m)=>{let g=o(i,s,r,n,m),A=m?"borderLeft":"borderRight",v=new Map;if(g.nodes.size>0){let y=Array.from(g.nodes.keys()),L=new Set;for(;y.length>0;){let I=y.pop();if(L.has(I)){let D=0;for(let V of g.node(I).in)D=Math.max(D,v.get(V.v)+V.label);v.set(I,D)}else L.add(I),y.push(I),y.push(...g.predecessors(I).keys())}}if(g.nodes.size>0){let y=Array.from(g.nodes.keys()),L=new Set;for(;y.length>0;){let I=y.pop();if(L.has(I)){let D=Number.POSITIVE_INFINITY;for(let Y of g.node(I).out)D=Math.min(D,v.get(Y.w)-Y.label);let V=i.node(I).label;if(V.dummy)continue;D!==Number.POSITIVE_INFINITY&&V.borderType!==A&&v.set(I,Math.max(v.get(I),D))}else L.add(I),y.push(I),y.push(...g.successors(I).keys())}}for(let y of h.values())v.set(y,v.get(n.get(y)));return v},x=(i,s)=>{let r=new Map;if(s.length>0){let[n]=s;for(let h=1;h<s.length;h++){let m=s[h],g=0,A=0,v=n.length,y=m[m.length-1];for(let L=0;L<m.length;L++){let I=m[L],D=i.node(I).label.dummy?Array.from(i.predecessors(I).keys()).find(V=>i.node(V).label.dummy):null;if(D||I===y){let V=D?i.node(D).label.order:v;for(let Y of m.slice(A,L+1))if(i.predecessors(Y).size>0)for(let $ of i.predecessors(Y).keys()){let K=i.node($).label,M=K.order;(M<g||V<M)&&!(K.dummy&&i.node(Y).label.dummy)&&a(r,$,Y)}A=L+1,g=V}}n=m}}return r},w=(i,s)=>{let r=new Map,n=(h,m,g,A,v)=>{for(let y=m;y<g;y++){let L=h[y];if(i.node(L).labeldummy)for(let I of i.predecessors(L).keys()){let D=i.node(I).label;D.dummy&&(D.order<A||D.order>v)&&a(r,I,L)}}};if(s.length>0){let[h]=s;for(let m=1;m<s.length;m++){let g=s[m],A=-1,v=0,y=0;g.forEach((L,I)=>{if(i.node(L).label.dummy==="border"){let D=i.predecessors(L);D.size>0&&(v=i.node(D.keys().next().value).label.order,n(g,y,I,A,v),y=I,A=v)}n(g,y,g.length,v,h.length)}),h=g}}return r};e=U(e);let G=se(e),O=t.ranksep,C=0;for(let i of G){let s=i.reduce((r,n)=>Math.max(r,e.node(n).label.height),0);for(let r of i)e.node(r).label.y=C+s/2;C+=s+O}let B=new Map([...x(e,G).entries(),...w(e,G).entries()]),T={};for(let i of["u","d"]){let s=i==="u"?G:Object.values(G).reverse();for(let r of["l","r"]){r==="r"&&(s=s.map(g=>Object.values(g).reverse()));let n=(i==="u"?e.predecessors:e.successors).bind(e),h=f(s,B,n),m=p(e,t,s,h.root,h.align,r==="r");if(r==="r")for(let[g,A]of m.entries(m))m.set(g,-A);T[i+r]=m}}let P=Number.POSITIVE_INFINITY,q=null;for(let i of Object.values(T)){let s=Number.NEGATIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(let[h,m]of i.entries()){let g=e.node(h).label.width/2;s=Math.max(m+g,s),r=Math.min(m-g,r)}let n=s-r;n<P&&(P=n,q=i)}let u=q,R=i=>{let s=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;for(let n of i)n<s&&(s=n),n>r&&(r=n);return[s,r]},N=R(u.values(u));for(let i of["u","d"])for(let s of["l","r"]){let r=i+s,n=T[r];if(n!==u){let h=R(n.values()),m=s==="l"?N[0]-h[0]:N[1]-h[1];if(m){let g=new Map;for(let[A,v]of n.entries())g.set(A,v+m);T[r]=g}}}let k=t.align;if(k){let i=T[k.toLowerCase()];for(let s of T.ul.keys())e.node(s).label.x=i.get(s)}else for(let i of T.ul.keys()){let s=[T.ul.get(i),T.ur.get(i),T.dl.get(i),T.dr.get(i)].sort((r,n)=>r-n);e.node(i).label.x=(s[1]+s[2])/2}},Xe=e=>{for(let l of e.nodes.values()){let t=l.label;if(t.dummy==="selfedge"){let a=l.v,c=e.node(t.e.v).label,o=c.x+c.width/2,f=c.y,p=t.x-o,x=c.height/2;e.setEdge(t.e.v,t.e.w,t.label),e.removeNode(a),t.label.points=[{x:o+2*p/3,y:f-x},{x:o+5*p/6,y:f-x},{x:o+p,y:f},{x:o+5*p/6,y:f+x},{x:o+2*p/3,y:f+x}],t.label.x=t.x,t.label.y=t.y}}},je=e=>{for(let l of e.nodes.values()){let t=l.v;if(e.hasChildren(t)){let a=l.label,c=e.node(a.borderTop).label,o=e.node(a.borderBottom).label,f=e.node(a.borderLeft[a.borderLeft.length-1]).label,p=e.node(a.borderRight[a.borderRight.length-1]).label;a.width=Math.abs(p.x-f.x),a.height=Math.abs(o.y-c.y),a.x=f.x+a.width/2,a.y=c.y+a.height/2}}for(let l of e.nodes.values())l.label.dummy==="border"&&e.removeNode(l.v)},We=e=>{for(let l of e.edges.values()){let t=l.label;if("x"in t)switch((t.labelpos==="l"||t.labelpos==="r")&&(t.width-=t.labeloffset),t.labelpos){case"l":t.x-=t.width/2+t.labeloffset;break;case"r":t.x+=t.width/2+t.labeloffset;break;default:throw new Q.Error(`Unsupported label position '${t.labelpos}'.`)}}},Ue=(e,l)=>{let t=Number.POSITIVE_INFINITY,a=0,c=Number.POSITIVE_INFINITY,o=0,f=p=>{let x=p.x,w=p.y,G=p.width,O=p.height;t=Math.min(t,x-G/2),a=Math.max(a,x+G/2),c=Math.min(c,w-O/2),o=Math.max(o,w+O/2)};for(let p of e.nodes.values())f(p.label);for(let p of e.edges.values()){let x=p.label;"x"in x&&f(x)}for(let p of e.nodes.values())p.label.x-=t,p.label.y-=c;for(let p of e.edges.values()){let x=p.label;for(let w of x.points)w.x-=t,w.y-=c;"x"in x&&(x.x-=t),"y"in x&&(x.y-=c)}l.width=a-t,l.height=o-c},Ze=e=>{let l=(t,a)=>{let c=t.x,o=t.y,f=a.x-c,p=a.y-o;if(f===0&&p===0)throw new Error("Not possible to find intersection inside of the rectangle");let x=t.width/2,w=t.height/2;return Math.abs(p)*x>Math.abs(f)*w?(w=p<0?-w:w,{x:c+w*f/p,y:o+w}):(x=f<0?-x:x,{x:c+x,y:o+x*p/f})};for(let t of e.edges.values()){let a=t.label,c=t.vNode.label,o=t.wNode.label,f=null,p=null;a.points?([f]=a.points,p=a.points[a.points.length-1]):(a.points=[],f=o,p=c),a.points.unshift(l(c,f)),a.points.push(l(o,p))}},oe=new Q.Graph(!0,!0);for(let e of d)oe.setNode(e.v,{width:e.width,height:e.height}),e.parent&&oe.setParent(e.v,e.parent);for(let e of b)oe.setEdge(e.v,e.w,{minlen:e.minlen||1,weight:e.weight||1,width:e.width||0,height:e.height||0,labeloffset:e.labeloffset||10,labelpos:e.labelpos||"r"});E={ranksep:50,edgesep:20,nodesep:50,rankdir:"tb",...E};let ye=[ce,Te,_e,Ge,Oe,Le,De,Me,Ve,Pe,Ce,qe,Ye,ze,Fe,He,$e,Xe,je,Se,We,Be,Ue,Ze,Re];for(;ye.length>0;)ye.shift()(oe,_,E);for(let e of d){let l=oe.node(e.v).label;e.x=l.x,e.y=l.y,oe.hasChildren(e.v)&&(e.width=l.width,e.height=l.height)}for(let e of b){let l=oe.edge(e.v,e.w).label;e.points=l.points,"x"in l&&(e.x=l.x,e.y=l.y)}_.log&&(_.log=oe.toString())};Q.Graph=class{constructor(d,b){this.directed=d,this.compound=b,this._defaultNodeLabelFn=()=>{},this.nodes=new Map,this.edges=new Map,this.compound&&(this._parent=new Map,this._children=new Map,this._children.set("\0",new Map))}setDefaultNodeLabel(d){this._defaultNodeLabelFn=d}setNode(d,b){let E=this.nodes.get(d);if(E)b&&(E.label=b);else{let _={label:b||this._defaultNodeLabelFn(d),in:[],out:[],predecessors:new Map,successors:new Map,v:d};this.nodes.set(d,_),this.compound&&(this._parent.set(d,"\0"),this._children.set(d,new Map),this._children.get("\0").set(d,!0))}}node(d){return this.nodes.get(d)}hasNode(d){return this.nodes.has(d)}removeNode(d){let b=this.nodes.get(d);if(b){if(this.compound){this._children.get(this._parent.get(d)).delete(d),this._parent.delete(d);for(let E of this.children(d))this.setParent(E);this._children.delete(d)}for(let E of b.in.concat())this.removeEdge(E);for(let E of b.out.concat())this.removeEdge(E);this.nodes.delete(d)}}setParent(d,b){if(!this.compound)throw new Error("Cannot set parent in a non-compound graph");if(b){for(let E=b;E!==void 0;E=this.parent(E))if(E===d)throw new Error(`Setting ${b} as parent of ${d} would create a cycle.`);this.setNode(b)}else b="\0";this._children.get(this._parent.get(d)).delete(d),this._parent.set(d,b),this._children.get(b).set(d,!0)}parent(d){if(this.compound){let b=this._parent.get(d);if(b!=="\0")return b}return null}children(d){return this.compound?this._children.get(d===void 0?"\0":d).keys():d===void 0?this.nodes.keys():this.hasNode(d)?[]:null}hasChildren(d){return this.compound?this._children.get(d===void 0?"\0":d).size>0:d===void 0?this.nodes.size>0:!1}predecessors(d){return this.nodes.get(d).predecessors}successors(d){return this.nodes.get(d).successors}neighbors(d){let b=this.nodes.get(d),E=b.predecessors.keys(),_=b.successors.keys(),S=new Set;for(let z of E)S.add(z);for(let z of _)S.add(z);return S}edge(d,b){return this.edges.get(this._edgeKey(this.directed,d,b))}setEdge(d,b,E,_){let S=this._edgeKey(this.directed,d,b,_),z=this.edges.get(S);if(z)z.label=E;else{!this.directed&&d>b&&([d,b]=[b,d]);let H={label:E,v:d,w:b,name:_,key:S,vNode:null,wNode:null};this.edges.set(S,H),this.setNode(d),this.setNode(b);let j=this.nodes.get(b),U=this.nodes.get(d);H.wNode=j,H.vNode=U;let re=(se,ce)=>{se.set(ce,(se.get(ce)??0)+1)};re(j.predecessors,d),re(U.successors,b),j.in.push(H),U.out.push(H)}}removeEdge(d){let b=d.key,E=d.v,_=d.w,S=d.wNode,z=d.vNode;if(S.predecessors.has(E)){let U=S.predecessors.get(E);U===1?S.predecessors.delete(E):S.predecessors.set(E,U-1)}if(z.successors.has(_)){let U=z.successors.get(_);U===1?z.successors.delete(_):z.successors.set(_,U-1)}let H=S.in.findIndex(U=>U.key===b);H!==-1&&S.in.splice(H,1);let j=z.out.findIndex(U=>U.key===b);j!==-1&&z.out.splice(j,1),this.edges.delete(b)}_edgeKey(d,b,E,_){return!d&&b>E?_?`${E}:${b}:${_}`:`${E}:${b}:`:_?`${b}:${E}:${_}`:`${b}:${E}:`}toString(){return["[nodes]",Array.from(this.nodes.values()).map(d=>JSON.stringify(d.label)).join(`
`),"[edges]",Array.from(this.edges.values()).map(d=>JSON.stringify(d.label)).join(`
`),"[parents]",JSON.stringify(this._parent,null,2),"[children]",JSON.stringify(this._children,null,2)].join(`
`)}};var{layout:Ne,Graph:ot}=Q;var ve=6,ae=30,Ie=12,fe=Ie+ve*2;var Ee="--qds-node-category-uncategorized",W={DATA:"Data",NN_LAYER:"NN Layer",ACTIVATION:"Activation",POOLING:"Pooling",NORMALIZATION:"Normalization",MATH:"Math",SHAPE:"Shape",TRANSFORM:"Transform",QUANTIZATION:"Quantization",SYNTHETIC_LAYER:"Synthetic Layer",NAMESPACE_LAYER:"Namespace Layer",DEFAULT:"Default"},Ke={[W.DATA]:"--qds-node-category-data",[W.NN_LAYER]:"--qds-node-category-layer",[W.ACTIVATION]:"--qds-node-category-activation",[W.POOLING]:"--qds-node-category-pool",[W.NORMALIZATION]:"--qds-node-category-normalization",[W.MATH]:"--qds-node-category-math",[W.SHAPE]:"--qds-node-category-shape",[W.TRANSFORM]:"--qds-node-category-transform",[W.QUANTIZATION]:"--qds-node-category-quantization",[W.SYNTHETIC_LAYER]:"--qds-artificial-layer-header-1",[W.NAMESPACE_LAYER]:"--qds-layer-header-1",[W.DEFAULT]:Ee},rt={[W.NN_LAYER]:["conv","deconv","fc","dense","linear","lstm","gru","rnn","attention","transformer","embedding"],[W.ACTIVATION]:["relu","sigmoid","tanh","softmax","gelu","swish","elu","selu","activation"],[W.POOLING]:["pool","maxpool","avgpool"],[W.NORMALIZATION]:["norm","batchnorm","layernorm","groupnorm","instancenorm","rmsnorm","lrn"],[W.MATH]:["add","sub","mul","div","mod","pow","neg","abs","sin","cos","tan","asin","acos","atan","sinh","cosh","tanh","exp","log","sqrt","reciprocal","erf","sum","mean","max","min","reducesum","reducemean","reducemax","reducemin","reduceprod","reducel1","reducel2","reducelogsum","reducelogsumexp","reducesumsquare","equal","greater","less","greaterorequal","lessorequal","and","or","xor","not","floor","ceil","round","clip","sign","matmul","bitwiseand","bitwiseor","bitwisexor","bitwisenot","cumsum"],[W.SHAPE]:["reshape","shape","size","flatten"],[W.TRANSFORM]:["transpose","gather","slice","concat","split","cast","pad","tile","repeat","flip","squeeze","unsqueeze","expand"],[W.QUANTIZATION]:["quant","dequant","quantize","dequantize"]};function pe(d){return d.children?.length>0}function he(d){let b=1/0,E=1/0,_=-1/0,S=-1/0;for(let j of d)b=Math.min(b,j.x),_=Math.max(_,j.x+(j.width??0)),E=Math.min(E,j.y),S=Math.max(S,j.y+(j.height??0));let z=_-b,H=S-E;return{x:b,y:E,width:z,height:H}}var Je={nodesep:20,ranksep:20};function be(d,b,E){let _=d.children.map(H=>{let{width:j,height:U}=b[H.id];return{v:H.id,x:void 0,y:void 0,globalX:void 0,globalY:void 0,width:j,height:U,data:H,parentGraph:E}}),S=d.edges.map(H=>({v:H.sourceNode.id,w:H.targetNode.id,data:H,points:[],globalPoints:[],globalEdgeBounds:void 0})),z={nodes:_,edges:S};return ke(z),z}function le(d,b){if(d.nodes.find(E=>E.data.id===b))return d;for(let E of d.nodes)if(E.childGraph){let _=le(E.childGraph,b);if(_)return _}console.error(`No graph was found that contains node "${b}"`)}function ke(d){Ne(d.nodes,d.edges,Je,{}),d.nodes.forEach(b=>{b.x-=b.width/2,b.y-=b.height/2,b.globalX=b.x,b.globalY=b.y}),d.edges.forEach(b=>{b.globalPoints=b.points,b.globalEdgeBounds=he(b.globalPoints)})}function Qe(d){let b=d.nodes,E=d.edges.flatMap(S=>S.points),_=[...b,...E];return he(_)}function me(d,b,E){let _=d.nodes.find(S=>S.data.id===b);if(_.expanded){let{width:S,height:z}=Qe(_.childGraph);_.width=S+ae*2,_.height=z+ae*2+fe}else _.width=E[_.data.id].width,_.height=E[_.data.id].height;if(ke(d),_.data.parent){let S=_.data.parent.id;_.parentGraph&&me(_.parentGraph,S,E)}}function ge(d,b,E){let _=b.nodes.find(S=>S.data.id===d);!pe(_.data)||_.expanded||(_.expanded=!0,_.childGraph=be(_.data,E,b),me(b,d,E))}function Ae(d,b,E){let _=b.nodes.find(S=>S.data.id===d);!pe(_.data)||!_.expanded||(_.expanded=!1,delete _.childGraph,me(b,d,E))}function de(d,b){for(let E of d.edges)E.globalPoints=E.points.map(_=>({x:_.x+b.x,y:_.y+b.y})),E.globalEdgeBounds=he(E.globalPoints);for(let E of d.nodes)E.globalX=E.x+b.x,E.globalY=E.y+b.y,E.childGraph&&de(E.childGraph,{x:E.globalX+ae,y:E.globalY+ae+fe})}function et(d){let{type:b,data:E}=d.data;switch(b){case 0:{let{layerNode:_,nodeDimensions:S}=E,z=be(_,S);postMessage({rootViewGraph:z});break}case 1:{let{rootViewGraph:_,clickedNodeId:S,nodeDimensions:z}=E,H=le(_,S);ge(S,H,z),de(_,{x:0,y:0}),postMessage({rootViewGraph:_});break}case 2:{let{rootViewGraph:_,clickedNodeId:S,nodeDimensions:z}=E,H=le(_,S);Ae(S,H,z),de(_,{x:0,y:0}),postMessage({rootViewGraph:_});break}case 3:{let{rootViewGraph:_,ancestors:S,nodeDimensions:z}=E;for(let H of S){let j=le(_,H.id);ge(H.id,j,z),de(_,{x:0,y:0})}postMessage({rootViewGraph:_});break}}}addEventListener("message",et);export{et as messageHandler};
