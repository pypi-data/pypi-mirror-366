#!/bin/env python
# -*- coding: utf-8 -*-
"""
parse_idna_tables.py - Parse IDNA2008 tables to list codepoint property.

Parse the IDNA 2008 tables from IANA website and create a dictionary with all
codepoints and their IDNA property.

Copied from https://github.com/kjd/idna/blob/master/tools/build-idnadata.py
"""
import argparse
import logging
import os.path
import sys
from collections import defaultdict
from urllib.request import urlopen

from lxml import etree

IANA_IDNATABLES_URL = "https://www.iana.org/assignments/idna-tables-{version}/idna-tables-{version}.xml"
IANA_IDNATABLES_NS = "http://www.iana.org/assignments"

UNICODE_IDNATABLES_URL = "https://www.unicode.org/Public/idna/idna2008derived/Idna2008-{version}.txt"

CODEPOINT_TAG = "{%s}codepoint" % IANA_IDNATABLES_NS
PROPERTY_TAG = "{%s}property" % IANA_IDNATABLES_NS

logger = logging.getLogger(__name__)


class IdnaTablesParser:
    """
    Base class used to make the list of codepoints from IDNA tables.

    Parse IDNA table data, and create a mapping of all codepoints to their
    structure.

    Input:
        * version: The unicode version to use.
        * table: The path to the table if locally available (optional)
    """
    cp_separator = None

    def __init__(self, version, table=None):
        self.version = version
        self.gen_from = None

    def iter_input(self):
        raise NotImplementedError

    def parse_iter(self, it):
        raise NotImplementedError

    def parse(self):
        print('# -*- coding: utf-8 -*-')
        print('# File generated by parse_idna_tables tool')
        print('# Unicode version: %s' % self.version)
        print('# Generated from %s' % self.gen_from)
        print('')
        print('idna_tables_%s = {' % self.version.replace('.', ''))

        properties = defaultdict(set)
        for it in self.iter_input():
            codepoint, prop = self.parse_iter(it)

            if prop == 'UNASSIGNED':
                continue

            if self.cp_separator in codepoint:
                # Codepoint is a range
                (first_cp, last_cp) = [int(c, 16) for c in codepoint.split(self.cp_separator)]
                for cp in range(first_cp, last_cp + 1):
                    properties[prop].add(cp)
            else:
                # Single codepoint
                properties[prop].add(int(codepoint, 16))

        for prop in properties:
            print("    '{0}':".format(prop))
            self.print_optimised_list(properties[prop])

        print('}')

    def print_optimised_list(self, prop):
        codepoint_list = sorted(prop)
        single_codepoints = []
        set_elements = []
        last_write = -1
        for i in range(0, len(codepoint_list)):
            if i + 1 < len(codepoint_list):
                if codepoint_list[i] == codepoint_list[i + 1] - 1:
                    continue
            codepoint_range = codepoint_list[last_write + 1:i + 1]
            if len(codepoint_range) == 1:
                single_codepoints.append("{0}".format(hex(codepoint_range[0])))
            else:
                set_elements.append("list(range({0},{1}))".format(codepoint_range[0],
                                                                  codepoint_range[-1] + 1))
            last_write = i

        print("        frozenset(")
        if len(single_codepoints) > 0:
            print("        [\n         " + ",\n         ".join(single_codepoints))
            print("        ] +")
        print("        " + " +\n        ".join(set_elements))
        print("    ),")


class IanaIdnaTablesParser(IdnaTablesParser):
    cp_separator = '-'

    def __init__(self, version, table=None):
        super().__init__(version, table)
        if not table:
            idna_url = IANA_IDNATABLES_URL.format(version=version)
            logger.debug("Fetching and parsing '%s'", idna_url)
            self.registry = etree.parse(idna_url)
            self.gen_from = idna_url
        else:
            self.registry = etree.parse(table)
            self.gen_from = os.path.basename(table)

        # To keep '{}' when string-formatting
        namespace = "{{{0}}}".format(IANA_IDNATABLES_NS)
        registry_id = "idna-tables-properties"
        if list(map(int, version.split('.'))) <= [6, 0, 0]:
            registry_id = "idna-tables-{}-properties".format(version)
        self.record_xpath = '{0}registry[@id="{1}"]/{0}record'.format(namespace,
                                                                      registry_id)

    def iter_input(self):
        for record in self.registry.findall(self.record_xpath):
            yield record

    def parse_iter(self, record):
        return record.find(CODEPOINT_TAG).text, record.find(PROPERTY_TAG).text


class UnicodeIdnaTablesParser(IdnaTablesParser):
    cp_separator = '..'

    def __init__(self, version, table=None):
        super().__init__(version, table)
        if not table:
            idna_url = UNICODE_IDNATABLES_URL.format(version=version)
            logger.debug("Fetching and parsing '%s'", idna_url)
            self.gen_from = idna_url
            self.open_func = lambda: urlopen(idna_url)
        else:
            self.gen_from = os.path.basename(table)
            self.open_func = lambda: open(table)

    def iter_input(self):
        with self.open_func() as data:
            for line in data:
                if isinstance(line, bytes):
                    line = line.decode('utf-8')
                # remove comments
                d = line.split('#', 1)[0].strip()
                if ';' in d:
                    yield d

    def parse_iter(self, line):
        return [c.strip() for c in line.split(';', 1)]


def main():
    parser = argparse.ArgumentParser(description='Parse and make IDNA properties '
                                                 'from IDNA2008 registry or Unicode IDNA2008 table')
    parser.add_argument('-v', '--verbose', action='store_true', help='be verbose')
    parser.add_argument('-t', '--table', type=str, default=None, help='Provide local registry XML or Unicode IDN table')
    parser.add_argument('-s', '--source', type=str, default='IANA', help='Parse table from IANA or UNICODE')
    parser.add_argument('unicode', metavar='Unicode Version')

    args = parser.parse_args()

    logging.basicConfig(stream=sys.stderr, level=logging.DEBUG if args.verbose else logging.INFO)

    if args.source == 'UNICODE':
        parser = UnicodeIdnaTablesParser(args.unicode, args.table)
    else:
        parser = IanaIdnaTablesParser(args.unicode, args.table)
    parser.parse()


if __name__ == '__main__':
    main()
