# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import typing
from enum import Enum, auto

class EvaluationResult:
    objective: builtins.float
    constraints: builtins.dict[builtins.str, Violation]
    penalties: builtins.dict[builtins.str, Violation]
    def __new__(cls,objective:builtins.float=0.0, constraints:typing.Mapping[builtins.str, Violation]={}, penalties:typing.Mapping[builtins.str, Violation]={}): ...
    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...


class MeasuringTime:
    def __new__(cls,solving_time:typing.Optional[SolvingTime]=None, system_time:typing.Optional[SystemTime]=None): ...
    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...

    def total(self) -> builtins.float:
        r"""
        Returns the total time measurred, across both `SolvingTime` and `SystemTime`.
        """
        ...

    def view_solving_time(self) -> SolvingTime:
        r"""
        Returns a readonly view of the internal `SolvingTime` field.
        """
        ...

    def view_system_time(self) -> SystemTime:
        r"""
        Returns a readonly view of the internal `SystemTime` field.
        """
        ...


class Sample:
    r"""
    A Sample representing an individual solution found by running the mathematical optimization model.
    
    Variables in `var_values` are stored in instances of `SparseVarValues`. This uses a dictionary
    style, retaining only non-zero elements. For example, if the values for a two-dimensional
    decision variable are `x = [[0, 1, 2], [1, 0, 0]]`, they will be stored as
    `{(0,1): 1, (0,2): 2, (1,0): 1}`. To retrieve this, use `sample.var_values["x"].values`.
    If you want a dense array of decision variables, you can use the `to_dense()` method.
    
    `run_id` is a unique identifier of the run in which this sample was found.
    Note that this is not the same as a unique identifier of the Sample.
    """
    run_id: builtins.str
    num_occurrences: builtins.int
    run_info: builtins.dict[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]
    var_values: builtins.dict[builtins.str, SparseVarValues]
    eval: EvaluationResult
    def __new__(cls,num_occurrences:builtins.int=1, run_id:typing.Optional[builtins.str]=None, run_info:typing.Optional[typing.Mapping[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]]=None, var_values:typing.Optional[typing.Mapping[builtins.str, SparseVarValues]]=None, eval:typing.Optional[EvaluationResult]=None): ...
    @staticmethod
    def from_dense_arrays(dict:typing.Mapping[builtins.str, numpy.typing.NDArray[numpy.float64] | list], num_occurrences:builtins.int=1, var_types:typing.Optional[typing.Mapping[builtins.str, VarType]]=None, run_id:typing.Optional[builtins.str]=None, meta_info:typing.Optional[typing.Mapping[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]]=None) -> Sample:
        ...

    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...

    def __eq__(self, other:typing.Any) -> builtins.bool:
        ...

    def is_feasible(self, epsilon:builtins.float=1e-08) -> builtins.bool:
        ...

    def to_dense(self) -> builtins.dict[builtins.str, numpy.typing.NDArray[numpy.float64]]:
        ...

    @staticmethod
    def from_dict(dict:dict) -> Sample:
        r"""
        Converts a python dictionary into a SampleSet.
        
        This is intended to be used primarily with dictionaries generated by
        the `to_dict()` method. As such sparse value maps must be represented as
        association lists.
        """
        ...

    def to_dict(self) -> typing.Any:
        r"""
        Converts this SampleSet into a regular python dictionary.
        
        Note that this dictionary has a slightly different structure to better support JSON
        serialization of the output dictionary: sparse values are stored differently. Any mapping
        with tuples as keys is transformed into an association list of key-value pairs,
        that is, `[(k1, v1), (k2, v2), ...]`.
        """
        ...


class SampleIter:
    def __iter__(self) -> SampleIter:
        ...

    def __next__(self) -> Sample:
        ...


class SampleSet:
    data: builtins.list[Sample]
    set_id: builtins.str
    set_info: builtins.dict[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]
    run_info: builtins.dict[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]
    measuring_time: MeasuringTime
    run_times: builtins.dict[builtins.str, MeasuringTime]
    def __new__(cls,data:typing.Sequence[Sample]=[], *, set_id:typing.Optional[builtins.str]=None, set_info:typing.Optional[typing.Mapping[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]]=None, run_info:typing.Optional[typing.Mapping[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]]=None, measuring_time:MeasuringTime=..., run_times:typing.Mapping[builtins.str, MeasuringTime]={}): ...
    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...

    def __eq__(self, other:typing.Any) -> builtins.bool:
        ...

    def __len__(self) -> builtins.int:
        ...

    def __getitem__(self, idx:builtins.int) -> Sample:
        ...

    def __iter__(self) -> SampleIter:
        ...

    @staticmethod
    def from_array(samples:typing.Sequence[typing.Mapping[builtins.str, numpy.typing.NDArray[numpy.float64] | list]]) -> SampleSet:
        r"""
        Builds a SampleSet from a list of dictionaries, where each entry is interpreted as a sample.
        
        Args
        -----
        - `samples`(`list[dict[str, list | numpy.ndarray]]`)
        """
        ...

    @staticmethod
    def concat(family:typing.Sequence[SampleSet]) -> SampleSet:
        r"""
        Creates a single SampleSet by concatenating a list of multiple SampleSets.
        
        Args
        -----
        - `family` (`list[SampleSet]`)
        """
        ...

    @staticmethod
    def from_dict(dict:dict) -> SampleSet:
        r"""
        Converts a python dictionary into a SampleSet.
        
        This is intended to be used primarily with dictionaries generated by
        the `to_dict()` method. As such sparse value maps must be represented as
        association lists.
        """
        ...

    def to_dict(self) -> typing.Any:
        r"""
        Converts this SampleSet into a regular python dictionary.
        
        Note that this dictionary has a slightly different structure to better support JSON
        serialization of the output dictionary: sparse values are stored differently. Any mapping
        with tuples as keys is transformed into an association list of key-value pairs,
        that is, `[(k1, v1), (k2, v2), ...]`.
        """
        ...

    def feasibles(self, epsilon:builtins.float=1e-08) -> SampleSet:
        r"""
        Returns a SampleSet containing only the feasible samples.
        
        Args
        -----
        - `epsilon` (`float`, optional): Tolerance threshold for constraint violations. Defaults to $1e-8$.
        
        Returns
        --------
        - `SampleSet`: a feasible subset of the current set.
        """
        ...

    def separate(self) -> builtins.dict[builtins.str, SampleSet]:
        r"""
        Splits this `SampleSet` based on the `run_id` of the samples.
        
        In other words, for each distinct `run_id` among the `Sample`s contained in this instance, a
        new `SampleSet` is created to store all `Sample`s with that ID.
        
        Returns
        -----
        - `sets` (dict[str, SampleSet]): The separated SampleSets. Keys are the run IDs.
        """
        ...

    def lowest(self, epsilon:builtins.float=1e-08) -> builtins.list[Sample]:
        r"""
        Returns a list of the feasible samples which have the lowest objective value.
        If there are no feasible solutions, this returns an empty list.
        
        Args
        -----
        - `epsilon` (`float`, optional): Tolerance threshold. Objective values within this tolerance are included, even if not exactly the minimum value. Defaults to $1e-8$.
        
        Returns
        -----
        `lowest_samples`: A list of Sample objects with the lowest ojective value in this SampleSet.
        """
        ...


class SolvingTime:
    compiling_time: builtins.float
    transpiling_time: builtins.float
    preprocess_time: builtins.float
    solving_time: builtins.float
    decoding_time: builtins.float
    postprocess_time: builtins.float
    def __new__(cls,compiling_time:builtins.float=0.0, transpiling_time:builtins.float=0.0, preprocess_time:builtins.float=0.0, solving_time:builtins.float=0.0, decoding_time:builtins.float=0.0, postprocess_time:builtins.float=0.0): ...
    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...

    def total(self) -> builtins.float:
        ...


class SparseVarValues:
    name: builtins.str
    values: builtins.dict[typing.Tuple[int, ...], builtins.float]
    var_type: VarType
    shape: tuple
    def __new__(cls,name:builtins.str, values:typing.Mapping[typing.Tuple[int, ...], builtins.float], shape:typing.Sequence[builtins.int], var_type:VarType=...): ...
    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...

    @staticmethod
    def from_array(name:builtins.str, array:numpy.typing.NDArray[numpy.float64], var_type:VarType=...) -> SparseVarValues:
        ...

    def to_dense(self) -> numpy.typing.NDArray[numpy.float64]:
        ...


class SystemTime:
    posting_time: typing.Optional[builtins.float]
    request_queuing_time: typing.Optional[builtins.float]
    fetching_problem_time: typing.Optional[builtins.float]
    fetching_result_time: typing.Optional[builtins.float]
    deserialize_time: typing.Optional[builtins.float]
    def __new__(cls,posting_time:typing.Optional[builtins.float]=None, request_queuing_time:typing.Optional[builtins.float]=None, fetching_problem_time:typing.Optional[builtins.float]=None, fetching_result_time:typing.Optional[builtins.float]=None, deserialize_time:typing.Optional[builtins.float]=None): ...
    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...


class Violation:
    name: builtins.str
    total_violation: builtins.float
    expr_values: builtins.dict[typing.Tuple[int, ...], builtins.float]
    def __new__(cls,name:builtins.str, total_violation:builtins.float, expr_values:typing.Mapping[typing.Tuple[int, ...], builtins.float]): ...
    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...


class VarType(Enum):
    CONTINUOUS = auto()
    INTEGER = auto()
    BINARY = auto()

def from_old_sampleset(sampleset:typing.Any) -> SampleSet:
    ...

