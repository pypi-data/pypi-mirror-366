<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>snowdrop.src.info.graph &#8212; Python Platform 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=61cd365c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for snowdrop.src.info.graph</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Python class that demonstrates the essential facts and functionalities of graphs.</span>
<span class="sd">This class represents a directed graph using adjacency list representation </span>
<span class="sd">It finds biconnected components in a given undirected graph with complexity : O(V + E) </span>

<span class="sd">Original version of the code can be found at:</span>
<span class="sd">    https://www.python-course.eu/graphs_python.php</span>
<span class="sd">    https://tutorialspoint.dev/data-structure/graph-data-structure/biconnected-components</span>

<span class="sd">Modified by A.Goumilevski</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span> 

<span class="n">instances</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="Graph">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph">[docs]</a>
<span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Graph class.&quot;&quot;&quot;</span>
    
    <span class="n">__graph_dict</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">__weights</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">__vertices</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">__inv_vertices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">__graph</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate graph object.</span>
<span class="sd">        </span>
<span class="sd">        If no dictionary or None is given, an empty dictionary will be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">instances</span>
        <span class="n">instances</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span> <span class="o">=</span> <span class="n">graph_dict</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">graph_dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">graph_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__addEdge</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__addEdge</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Self loop</span>
                
        <span class="c1"># Nodes dictionary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        
        <span class="c1"># No. of vertices </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span> <span class="k">else</span> <span class="mi">0</span>
          
        <span class="c1"># default dictionary to store graph </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> 
          
        <span class="c1"># default dictionary to store components </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  
          
        <span class="c1"># time is used to find discovery times </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Time</span> <span class="o">=</span> <span class="mi">0</span> 
          
        <span class="c1"># Count is number of biconnected components </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>          

<div class="viewcode-block" id="Graph.vertices">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.vertices">[docs]</a>
    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the vertices of a graph.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="Graph.edges">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.edges">[docs]</a>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the edges of a graph.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_edges</span><span class="p">()</span></div>


<div class="viewcode-block" id="Graph.add_vertex">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.add_vertex">[docs]</a>
    <span class="k">def</span> <span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add graph vertex.</span>
<span class="sd">        </span>
<span class="sd">        If the vertex is not in self.__graph_dict, a key &quot;vertex&quot; with an empty</span>
<span class="sd">        list as a value is added to the dictionary. Otherwise nothing has to be done. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__inv_vertices</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertex</span></div>


<div class="viewcode-block" id="Graph.add_edge">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.add_edge">[docs]</a>
    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an edge.</span>
<span class="sd">        </span>
<span class="sd">        It is assumed that edge is of type set, tuple or list; between two vertices can be multiple edges! </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">vertex1</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">edge</span><span class="p">:</span>
            <span class="c1"># not a loop</span>
            <span class="n">vertex2</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># a loop</span>
            <span class="n">vertex2</span> <span class="o">=</span> <span class="n">vertex1</span>
        <span class="k">if</span> <span class="n">vertex1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">[</span><span class="n">vertex1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">[</span><span class="n">vertex1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertex2</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vertex1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">[</span><span class="n">vertex1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__inv_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertex1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">[</span><span class="n">vertex1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vertex2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">[</span><span class="n">vertex2</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__inv_vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertex2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">[</span><span class="n">vertex2</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">str</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)])</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">w</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">__addEdge</span><span class="p">(</span><span class="n">vertex1</span><span class="p">,</span><span class="n">vertex2</span><span class="p">,</span><span class="n">weight</span><span class="p">)</span>     </div>


    <span class="k">def</span> <span class="nf">__addEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an edge that connects two vertices to a graph.</span>

<span class="sd">        Args:</span>
<span class="sd">        u : str.</span>
<span class="sd">            Vertex name.</span>
<span class="sd">        v : str.</span>
<span class="sd">            Vertex name.</span>
<span class="sd">        w : int, optional</span>
<span class="sd">            Edge weight. The default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__inv_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__inv_vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            
        <span class="n">k</span> <span class="o">=</span> <span class="nb">str</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)])</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">w</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">weight</span><span class="p">])</span> 
        
<div class="viewcode-block" id="Graph.addEdge">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.addEdge">[docs]</a>
    <span class="k">def</span> <span class="nf">addEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to add an edge to graph.&quot;&quot;&quot;</span> 
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> </div>

     
    <span class="k">def</span> <span class="nf">__generate_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the edges of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Edges are represented as sets with one (a loop back to the vertex) </span>
<span class="sd">        or two vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">[</span><span class="n">vertex</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">{</span><span class="n">neighbour</span><span class="p">,</span> <span class="n">vertex</span><span class="p">}</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">vertex</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">edges</span>
 
<div class="viewcode-block" id="Graph.find_isolated_vertices">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.find_isolated_vertices">[docs]</a>
    <span class="k">def</span> <span class="nf">find_isolated_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of isolated vertices.&quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span>
        <span class="n">isolated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">isolated</span><span class="p">,</span> <span class="n">vertex</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="p">[</span><span class="n">vertex</span><span class="p">]:</span>
                <span class="n">isolated</span> <span class="o">+=</span> <span class="p">[</span><span class="n">vertex</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">isolated</span></div>


<div class="viewcode-block" id="Graph.BCCUtil">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.BCCUtil">[docs]</a>
    <span class="k">def</span> <span class="nf">BCCUtil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A recursive function that finds and prints strongly connected components using DFS traversal </span>
<span class="sd">        </span>
<span class="sd">        u --&gt; The vertex to be visited next </span>
<span class="sd">        disc[] --&gt; Stores discovery times of visited vertices </span>
<span class="sd">        low[] -- &gt;&gt; earliest visited vertex (the vertex with minimum </span>
<span class="sd">                   discovery time) that can be reached from subtree </span>
<span class="sd">                   rooted with current vertex </span>
<span class="sd">        st -- &gt;&gt; To store visited edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
  
        <span class="c1"># Count of children in current node  </span>
        <span class="n">children</span> <span class="o">=</span> <span class="mi">0</span>
  
        <span class="c1"># Initialize discovery time and low value </span>
        <span class="n">disc</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Time</span> 
        <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Time</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">Time</span> <span class="o">+=</span> <span class="mi">1</span>
  
        <span class="c1"># Recur for all the vertices adjacent to this vertex </span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span> 
            <span class="c1"># If v is not visited yet, then make it a child of u </span>
            <span class="c1"># in DFS tree and recur for it </span>
            <span class="k">if</span> <span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> 
                <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span> 
                <span class="n">children</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="c1"># store the edge in stack </span>
                <span class="bp">self</span><span class="o">.</span><span class="n">BCCUtil</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span> 
  
                <span class="c1"># Check if the subtree rooted with v has a connection to one of the ancestors of u </span>
                <span class="c1"># Case 1 -- per Strongly Connected Components Article </span>
                <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> 
  
                <span class="c1"># If u is an articulation point, pop all edges from stack till (u, v) </span>
                <span class="k">if</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">children</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">disc</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">while</span> <span class="n">w</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span> 
                        <span class="n">w</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> 
                        <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                    <span class="c1">#     print(w)</span>
                    <span class="c1"># print()  </span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># increment count </span>
              
            <span class="k">elif</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="ow">and</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span> 
<span class="w">                </span><span class="sd">&#39;&#39;&#39;Update low value of &#39;u&#39; only of &#39;v&#39; is still in stack </span>
<span class="sd">                (i.e. it&#39;s a back edge, not cross edge). </span>
<span class="sd">                Case 2  </span>
<span class="sd">                -- per Strongly Connected Components Article&#39;&#39;&#39;</span>
  
                <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low</span> <span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> 
      
                <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> 
        <span class="k">return</span> </div>

  
<div class="viewcode-block" id="Graph.BCC">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.BCC">[docs]</a>
    <span class="k">def</span> <span class="nf">BCC</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to do DFS traversal. It uses recursive BCCUtil().&quot;&quot;&quot;</span>
           
        <span class="c1"># Initialize disc and low, and parent arrays </span>
        <span class="n">disc</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span> 
        <span class="n">low</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span> 
        <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span> 
        <span class="n">st</span> <span class="o">=</span> <span class="p">[]</span> 
         
        <span class="c1"># Call the recursive helper function to find articulation points </span>
        <span class="c1"># in DFS tree rooted with vertex &#39;i&#39; </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">):</span> 
            <span class="k">if</span> <span class="n">disc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">BCCUtil</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span> 
         
            <span class="c1"># If stack is not empty, pop all edges from stack </span>
            <span class="k">if</span> <span class="n">st</span><span class="p">:</span> 
                <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="n">st</span><span class="p">:</span> 
                    <span class="n">w</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> 
                    <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="c1">#     print (w) </span>
                <span class="c1"># print()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span></div>

  
<div class="viewcode-block" id="Graph.find_path">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.find_path">[docs]</a>
    <span class="k">def</span> <span class="nf">find_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">,</span> <span class="n">end_vertex</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find a path from start_vertex to end_vertex in graph.&quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">start_vertex</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start_vertex</span> <span class="o">==</span> <span class="n">end_vertex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">path</span>
        <span class="k">if</span> <span class="n">start_vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start_vertex</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">extended_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_path</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span><span class="n">end_vertex</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">extended_path</span><span class="p">:</span> 
                    <span class="k">return</span> <span class="n">extended_path</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    

<div class="viewcode-block" id="Graph.find_all_paths">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.find_all_paths">[docs]</a>
    <span class="k">def</span> <span class="nf">find_all_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">,</span> <span class="n">end_vertex</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find all paths from start_vertex to end_vertex in graph.&quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span> 
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">start_vertex</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start_vertex</span> <span class="o">==</span> <span class="n">end_vertex</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start_vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start_vertex</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">extended_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_all_paths</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">end_vertex</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">extended_paths</span><span class="p">:</span> 
                    <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span></div>

    
    
<div class="viewcode-block" id="Graph.find_shortest_path">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.find_shortest_path">[docs]</a>
    <span class="k">def</span> <span class="nf">find_shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">,</span> <span class="n">end_vertex</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find shortest path from start_vertex to end_vertex.&quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">start_vertex</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start_vertex</span> <span class="o">==</span> <span class="n">end_vertex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">path</span>
        <span class="k">if</span> <span class="n">start_vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">shortest</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start_vertex</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">newpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_shortest_path</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">end_vertex</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newpath</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">shortest</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">newpath</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">shortest</span><span class="p">):</span>
                        <span class="n">shortest</span> <span class="o">=</span> <span class="n">newpath</span>
        <span class="k">return</span> <span class="n">shortest</span></div>

    
<div class="viewcode-block" id="Graph.find_distance">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.find_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">find_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">,</span> <span class="n">end_vertex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find number of edges from start_vertex to end_vertex.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start_vertex</span> <span class="o">==</span> <span class="n">end_vertex</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shortest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_shortest_path</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">,</span> <span class="n">end_vertex</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shortest</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dist</span><span class="o">-</span><span class="mi">1</span></div>

    
<div class="viewcode-block" id="Graph.get_vertices">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.get_vertices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get graph vertices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            vertices : list</span>
<span class="sd">                List of vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">vertices</span></div>

    
<div class="viewcode-block" id="Graph.get_connected_vertices">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.get_connected_vertices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_connected_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">,</span> <span class="n">vertices_encountered</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gdict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine if graph is connected.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">gdict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span>   
        <span class="k">if</span> <span class="n">vertices_encountered</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vertices_encountered</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="n">vertices_encountered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">)</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gdict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#vertices = self.get_vertices()</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">start_vertex</span> <span class="ow">in</span> <span class="n">gdict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">gdict</span><span class="p">[</span><span class="n">start_vertex</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vertices_encountered</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_connected_vertices</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">vertices_encountered</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vertices_encountered</span></div>

    
<div class="viewcode-block" id="Graph.get_components">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.get_components">[docs]</a>
    <span class="k">def</span> <span class="nf">get_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find isolated components of a graph.&quot;&quot;&quot;</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getComponents</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
        <span class="n">components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">b</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c1</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">c2</span><span class="p">):</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">components</span></div>

               
    <span class="k">def</span> <span class="nf">__getComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find isolated vertices.&quot;&quot;&quot;</span>
        <span class="c1"># gdict = self.__graph_dict        </span>
        <span class="c1"># vertices = set(gdict.keys())</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">())</span>
        <span class="n">components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">while</span> <span class="nb">bool</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
            <span class="n">start_vertex</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connected_vertices</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">)</span>
            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="n">vertices</span> <span class="o">-=</span> <span class="nb">set</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">components</span>
            
<div class="viewcode-block" id="Graph.is_connected">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.is_connected">[docs]</a>
    <span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices_encountered</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">start_vertex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine if graph is connected.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertices_encountered</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vertices_encountered</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">gdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span>        
        <span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gdict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#vertices = self.get_vertices()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">start_vertex</span><span class="p">:</span>
            <span class="c1"># chosse a vertex from graph as a starting point</span>
            <span class="n">start_vertex</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vertices_encountered</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices_encountered</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">gdict</span><span class="p">[</span><span class="n">start_vertex</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vertices_encountered</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">vertices_encountered</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    
<div class="viewcode-block" id="Graph.vertex_degree">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.vertex_degree">[docs]</a>
    <span class="k">def</span> <span class="nf">vertex_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find vertex degree.</span>
<span class="sd">        </span>
<span class="sd">        The degree of a vertex is the number of edges connecting</span>
<span class="sd">        it, i.e. the number of adjacent vertices. Loops are counted </span>
<span class="sd">        double, i.e. every occurence of vertex in the list </span>
<span class="sd">        of adjacent vertices. </span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="n">adj_vertices</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_vertices</span><span class="p">)</span> <span class="o">+</span> <span class="n">adj_vertices</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">degree</span></div>


<div class="viewcode-block" id="Graph.degree_sequence">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.degree_sequence">[docs]</a>
    <span class="k">def</span> <span class="nf">degree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the degree sequence.&quot;&quot;&quot;</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_degree</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.is_degree_sequence">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.is_degree_sequence">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_degree_sequence</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find degree sequence.</span>
<span class="sd">        </span>
<span class="sd">        Method returns True, if the &quot;sequence&quot; is a </span>
<span class="sd">        degree sequence, i.e. a non-increasing sequence. </span>
<span class="sd">        Otherwise returns False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if the sequence sequence is non-increasing:</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span> <span class="n">x</span><span class="o">&gt;=</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">sequence</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span></div>


<div class="viewcode-block" id="Graph.delta">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.delta">[docs]</a>
    <span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the minimum degree of the vertices.&quot;&quot;&quot;</span>
        <span class="n">minv</span> <span class="o">=</span> <span class="mf">1e10</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">:</span>
            <span class="n">vertex_degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_degree</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vertex_degree</span> <span class="o">&lt;</span> <span class="n">minv</span><span class="p">:</span>
                <span class="n">minv</span> <span class="o">=</span> <span class="n">vertex_degree</span>
        <span class="k">return</span> <span class="n">minv</span></div>

        
<div class="viewcode-block" id="Graph.Delta">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.Delta">[docs]</a>
    <span class="k">def</span> <span class="nf">Delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the maximum degree of the vertices.&quot;&quot;&quot;</span>
        <span class="n">maxv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span><span class="p">:</span>
            <span class="n">vertex_degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_degree</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vertex_degree</span> <span class="o">&gt;</span> <span class="n">maxv</span><span class="p">:</span>
                <span class="n">maxv</span> <span class="o">=</span> <span class="n">vertex_degree</span>
        <span class="k">return</span> <span class="n">maxv</span></div>


<div class="viewcode-block" id="Graph.density">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.density">[docs]</a>
    <span class="k">def</span> <span class="nf">density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the density of a graph.&quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_dict</span>
        <span class="n">V</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">E</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">E</span> <span class="o">/</span> <span class="p">(</span><span class="n">V</span> <span class="o">*</span><span class="p">(</span><span class="n">V</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="Graph.diameter">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.diameter">[docs]</a>
    <span class="k">def</span> <span class="nf">diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the diameter of the graph.&quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span> 
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">smallest_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_all_paths</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="o">&gt;</span>  <span class="mi">0</span><span class="p">:</span>
                <span class="n">smallest</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">smallest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">smallest</span><span class="p">)</span>

        <span class="n">smallest_paths</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>

        <span class="c1"># longest path is at the end of list, </span>
        <span class="c1"># i.e. diameter corresponds to the length of this pathz</span>
        <span class="n">diameter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">smallest_paths</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">diameter</span></div>


<div class="viewcode-block" id="Graph.erdoes_gallai">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.erdoes_gallai">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">erdoes_gallai</span><span class="p">(</span><span class="n">dsequence</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the condition of the Erdoes-Gallai inequality is fullfilled.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dsequence</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># sum of sequence is odd</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">Graph</span><span class="o">.</span><span class="n">is_degree_sequence</span><span class="p">(</span><span class="n">dsequence</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">dsequence</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">left</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dsequence</span><span class="p">[:</span><span class="n">k</span><span class="p">])</span>
                <span class="n">right</span> <span class="o">=</span>  <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dsequence</span><span class="p">[</span><span class="n">k</span><span class="p">:]])</span>
                <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># sequence is increasing</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Graph.find">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.find">[docs]</a>
    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find a set of an element i.</span>
<span class="sd">        </span>
<span class="sd">        This algorithm uses path compression technique.</span>

<span class="sd">        Args:</span>
<span class="sd">            parent : list</span>
<span class="sd">                Parent list.</span>
<span class="sd">            i : int</span>
<span class="sd">                Element.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Set of an element i.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span> 
            <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
            
        <span class="k">return</span> <span class="n">k</span></div>

 
<div class="viewcode-block" id="Graph.union">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.union">[docs]</a>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return  union of two sets of x and y.</span>
<span class="sd">        </span>
<span class="sd">        This algoritm sorts uses union by rank.</span>

<span class="sd">        Args:</span>
<span class="sd">            parent : list</span>
<span class="sd">                Parent list of vertices.</span>
<span class="sd">            rank : list</span>
<span class="sd">                Rank of tree.</span>
<span class="sd">            x : list</span>
<span class="sd">                Graph vertices.</span>
<span class="sd">            y : list</span>
<span class="sd">                Graph vertices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> 
        <span class="n">yroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> 
  
        <span class="c1"># Attach smaller rank tree under root of high rank tree (Union by Rank) </span>
        <span class="k">if</span> <span class="n">rank</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">yroot</span><span class="p">]:</span> 
            <span class="n">parent</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span> <span class="o">=</span> <span class="n">yroot</span> 
        <span class="k">elif</span> <span class="n">rank</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">yroot</span><span class="p">]:</span> 
            <span class="n">parent</span><span class="p">[</span><span class="n">yroot</span><span class="p">]</span> <span class="o">=</span> <span class="n">xroot</span> 
  
        <span class="c1"># If ranks are same, then make one as root and increment its rank by one </span>
        <span class="k">else</span> <span class="p">:</span> 
            <span class="n">parent</span><span class="p">[</span><span class="n">yroot</span><span class="p">]</span> <span class="o">=</span> <span class="n">xroot</span> 
            <span class="n">rank</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>          </div>

 
<div class="viewcode-block" id="Graph.isCyclic">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.isCyclic">[docs]</a>
    <span class="k">def</span> <span class="nf">isCyclic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether a given graph contains a cycle or not.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool</span>
<span class="sd">                True if graph is cyclic and False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Allocate memory for creating V subsets and </span>
        <span class="c1"># Initialize all subsets as single element sets </span>
        <span class="n">V</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">)</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">V</span>
  
        <span class="c1"># Iterate through all edges of graph, find subset of both </span>
        <span class="c1"># vertices of every edge, if both subsets are same, then </span>
        <span class="c1"># there is cycle in graph. </span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)):</span>
            <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>  
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span> 
                <span class="k">return</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>            </div>

                
<div class="viewcode-block" id="Graph.getMinimumSpanningTree">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.getMinimumSpanningTree">[docs]</a>
    <span class="k">def</span> <span class="nf">getMinimumSpanningTree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kruskal&#39;s algorithm to find Minimum Spanning Tree (MST)of a given connected, undirected and weighted graph.</span>

<span class="sd">        Time Complexity: O(ElogE) or O(ElogV). Here E is the number of edges and V is the number of vertices.</span>
<span class="sd">        Sorting of edges takes O(ELogE) time. After sorting, we iterate through all edges and apply find-union algorithm. </span>
<span class="sd">        The find and union operations can take atmost O(LogV) time. So overall complexity is O(ELogE + ELogV) time. </span>
<span class="sd">        The value of E can be atmost O(V2), so O(LogV) are O(LogE) same. Therefore, overall time complexity is O(ElogE) or O(ElogV).</span>
<span class="sd">        </span>
<span class="sd">        https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/</span>

<span class="sd">        Args:</span>
<span class="sd">            self: Graph object.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mst</span> <span class="o">=</span><span class="p">[]</span> <span class="c1">#This will store the resultant MST </span>
  
        <span class="c1"># Step 1:  Sort all the edges in non-decreasing # order of their # weight.  </span>
        <span class="c1"># If we are not allowed to change the given graph, we can create a copy of graph </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span> <span class="o">=</span>  <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> 
  
        <span class="n">parent</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">;</span> <span class="n">rank</span> <span class="o">=</span> <span class="p">[]</span> 
  
        <span class="c1"># Create V subsets with single elements </span>
        <span class="n">V</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vertices</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span> 
            <span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
            <span class="n">rank</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> 
      
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># An index variable, used for sorted edges </span>
        <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># An index variable, used for result[] </span>
        
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span>
        <span class="c1">#vertices = self.__vertices</span>
        <span class="n">inv_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__inv_vertices</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span>
        
        <span class="c1"># Number of edges to be taken is equal to V-1 </span>
        <span class="k">while</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">V</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">):</span> 
  
            <span class="c1"># Step 2: Pick the smallest edge and increment the index for next iteration </span>
            <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span>  <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
            <span class="c1">#print(i,e,V)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> 
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parent</span> <span class="p">,</span><span class="n">v</span><span class="p">)</span>
            <span class="c1">#print(u,v,x,y)</span>
  
            <span class="c1"># If including this edge does&#39;t cause cycle,  </span>
            <span class="c1"># Include it in result and increment the index of result for next edge </span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span> 
                <span class="n">e</span> <span class="o">+=</span> <span class="mi">1</span>     
                <span class="n">k</span> <span class="o">=</span> <span class="nb">str</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)])</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">inv_vertices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="n">u1</span> <span class="o">=</span> <span class="n">inv_vertices</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">mst</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">w</span><span class="p">])</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c1"># discard the edge </span>
  
        <span class="k">return</span> <span class="n">mst</span></div>

            
<div class="viewcode-block" id="Graph.connected">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.connected">[docs]</a>
    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return connected vertices of a minimum spanning tree.</span>

<span class="sd">        Args:</span>
<span class="sd">            t : list</span>
<span class="sd">                List of vertices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Connected vertices of a minimum spanning tree.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">utils.util</span> <span class="kn">import</span> <span class="n">findVariableLag</span><span class="p">,</span><span class="n">findVariableLead</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
        <span class="n">ll</span> <span class="o">=</span> <span class="n">LinkedList</span><span class="p">()</span>
        <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__connect</span><span class="p">(</span><span class="n">ll</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
            
        <span class="n">current</span> <span class="o">=</span> <span class="n">ll</span><span class="o">.</span><span class="n">head</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="n">current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">value</span>
            <span class="k">if</span> <span class="s2">&quot;_plus_&quot;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">lead</span> <span class="o">=</span> <span class="n">findVariableLead</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;_plus&quot;</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="n">ind</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lead</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
            <span class="k">elif</span> <span class="s2">&quot;_minus_&quot;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">lag</span> <span class="o">=</span> <span class="n">findVariableLag</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;_minus_&quot;</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="n">ind</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lag</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&gt;&quot;</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
        
        <span class="k">return</span> <span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span></div>

                          
    <span class="k">def</span> <span class="nf">__connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">lli</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a list of connected nodes.</span>

<span class="sd">        Args:</span>
<span class="sd">            lli : LinkedList</span>
<span class="sd">                List of nodes.</span>
<span class="sd">            d : dict</span>
<span class="sd">                Dictionary that has node labels as keys and their edge numbers as values.</span>
<span class="sd">            t : list</span>
<span class="sd">                Minimum spanning tree.</span>
<span class="sd">            u : str</span>
<span class="sd">                Node label.</span>
<span class="sd">            v : str</span>
<span class="sd">                Node label.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of connected nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">==</span><span class="n">v</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="n">head</span> <span class="o">=</span> <span class="n">lli</span><span class="o">.</span><span class="n">head</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="n">LinkedList</span><span class="o">.</span><span class="n">toList</span><span class="p">(</span><span class="n">lli</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">==</span> <span class="n">head</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">lli</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lli</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                   
        <span class="n">lst</span> <span class="o">=</span> <span class="n">LinkedList</span><span class="o">.</span><span class="n">toList</span><span class="p">(</span><span class="n">lli</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">u</span> <span class="o">==</span> <span class="n">head</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">lli</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lli</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            
        <span class="n">lst</span> <span class="o">=</span> <span class="n">LinkedList</span><span class="o">.</span><span class="n">toList</span><span class="p">(</span><span class="n">lli</span><span class="p">)</span>
        <span class="c1">#LinkedList.display(li)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">w1</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">u1</span> <span class="ow">in</span> <span class="n">lst</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__connect</span><span class="p">(</span><span class="n">lli</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">)</span>
                <span class="n">lst</span> <span class="o">=</span> <span class="n">LinkedList</span><span class="o">.</span><span class="n">toList</span><span class="p">(</span><span class="n">lli</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">u2</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">w2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">u2</span> <span class="ow">in</span> <span class="n">lst</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__connect</span><span class="p">(</span><span class="n">lli</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">u2</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span>
                <span class="n">lst</span> <span class="o">=</span> <span class="n">LinkedList</span><span class="o">.</span><span class="n">toList</span><span class="p">(</span><span class="n">lli</span><span class="p">)</span>
                  
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Represent Graph object as a string.&quot;&quot;&quot;</span>
        <span class="c1"># d = self.__graph_dict</span>
        <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Model Equations Graph Information:</span><span class="se">\n</span><span class="s2">----------------------------------&quot;</span>
        <span class="c1"># res += &quot;\nVertices: &quot;</span>
        <span class="c1"># for k in d:</span>
        <span class="c1">#     res += str(k) + &quot; &quot;</span>
        <span class="c1"># res += &quot;\nEdges: &quot;</span>
        <span class="c1"># edges = self.__generate_edges()</span>
        <span class="c1"># for edge in edges:</span>
        <span class="c1">#     res += str(edge) + &quot; &quot;</span>
        <span class="c1"># v = self.__vertices</span>
        <span class="c1"># res += &quot;\nNumber of vertices: &quot; + str(len(v))</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Diameter: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="p">())</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Is cyclic: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isCyclic</span><span class="p">())</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Minimum degree: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Maximum degree: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Delta</span><span class="p">())</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Density: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">density</span><span class="p">())</span>
        <span class="c1"># components = self.get_components()</span>
        <span class="c1"># res += &quot;\nNumber of components: {}&quot;.format(len(components))</span>
        <span class="c1"># res += &quot;\nComponents: {}&quot;.format(components)</span>
        <span class="c1"># mst = self.getMinimumSpanningTree()</span>
        <span class="c1"># print the contents of result[] to display the built MST </span>
        <span class="c1"># res += &quot;\nFollowing are the edges in the constructed MST:\n&quot;</span>
        <span class="c1"># for u,v,weight  in mst: </span>
        <span class="c1">#     res += &quot;Edge: {0}--{1},  weight: {2}\n&quot;.format(u,v,weight)</span>
            
        <span class="c1"># res += &quot;\nLinked list of connected vertices of minimum spanning tree:\n&quot;</span>
        <span class="c1"># res += self.connected(mst)</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">res</span>
      
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Graph object represntation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
               
<div class="viewcode-block" id="Graph.printBiconnectedComponents">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.printBiconnectedComponents">[docs]</a>
    <span class="k">def</span> <span class="nf">printBiconnectedComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">There are </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="si">}</span><span class="s2"> biconnected components in a graph:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">im</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">im</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>

                           
<div class="viewcode-block" id="Graph.summary">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.summary">[docs]</a>
    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="c1">#print (f&quot;\nNumber of graph vertices {self.V}&quot;)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="si">}</span><span class="s2"> biconnected components in a graph:&quot;</span><span class="p">)</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBiconnectedComponents</span><span class="p">()</span>
        <span class="n">all_sizes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="n">all_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_sizes</span><span class="p">))</span>
        <span class="n">all_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_sizes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">all_sizes</span><span class="o">==</span><span class="n">x</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> component(s) of size </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

            
<div class="viewcode-block" id="Graph.getBiconnectedComponents">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Graph.getBiconnectedComponents">[docs]</a>
    <span class="k">def</span> <span class="nf">getBiconnectedComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get biconnected components in a graph.&quot;&quot;&quot;</span>
        <span class="n">components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">im</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">im</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">]</span>
            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">components</span></div>
</div>

    

<div class="viewcode-block" id="Node">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.Node">[docs]</a>
<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Node class.&quot;&quot;&quot;</span>
    
    <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="nb">next</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>
                          
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Representats Graph object as a string.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">res</span>
                
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Graph object represntation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>



<div class="viewcode-block" id="LinkedList">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.LinkedList">[docs]</a>
<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Simple linked list class.&quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sequence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>           
            
<div class="viewcode-block" id="LinkedList.push">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.LinkedList.push">[docs]</a>
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a new node at the beginning.&quot;&quot;&quot;</span>
        <span class="c1"># 1 &amp; 2: Allocate the Node &amp; </span>
        <span class="c1">#        Put in the data </span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> 
        <span class="c1"># 3. Make next of new Node as head </span>
        <span class="n">new_node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> 
        <span class="c1"># 4. Move the head to point to new Node </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span>   </div>

    
<div class="viewcode-block" id="LinkedList.insertAfter">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.LinkedList.insertAfter">[docs]</a>
    <span class="k">def</span> <span class="nf">insertAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_node</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a new node after the given prev_node.&quot;&quot;&quot;</span>
        <span class="c1"># 1. check if the given prev_node exists </span>
        <span class="k">if</span> <span class="n">prev_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The given previous node must exist in the Linked List.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1">#  2. create new node &amp; </span>
        <span class="c1">#      Put in the data </span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> 
        <span class="c1"># 4. Make next of new Node as next of prev_node </span>
        <span class="n">new_node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span>
        <span class="c1"># 5. make next of prev_node as new_node </span>
        <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_node</span> </div>

     
<div class="viewcode-block" id="LinkedList.getParentNode">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.LinkedList.getParentNode">[docs]</a>
    <span class="k">def</span> <span class="nf">getParentNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get previous node in the linked list.&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> 
        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span> 
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">next</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">n</span>
        <span class="k">return</span> <span class="kc">None</span></div>

                    
<div class="viewcode-block" id="LinkedList.insertBefore">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.LinkedList.insertBefore">[docs]</a>
    <span class="k">def</span> <span class="nf">insertBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a new node before the given node.&quot;&quot;&quot;</span>
        <span class="c1"># 1. check if the given prev_node exists </span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The given node must exist in the Linked List.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">parentNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParentNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parentNode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#  2. create new node and put in the data </span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> 
            <span class="c1"># 4. Make next of new Node as next of prev_node </span>
            <span class="n">parentNode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="c1"># 5. make next of prev_node as new_node </span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span> </div>

            
<div class="viewcode-block" id="LinkedList.append">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.LinkedList.append">[docs]</a>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Append a new node at the end.&quot;&quot;&quot;</span>
        <span class="c1"># 1. Create a new node </span>
        <span class="c1"># 2. Put in the data </span>
        <span class="c1"># 3. Set next as None </span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> 
        <span class="c1"># 4. If the Linked List is empty, then make the new node as head </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 5. Else traverse till the last node </span>
            <span class="n">last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> 
            <span class="k">while</span> <span class="p">(</span><span class="n">last</span><span class="o">.</span><span class="n">next</span><span class="p">):</span> 
                <span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="n">next</span>
            <span class="c1"># 6. Change the next of last node </span>
            <span class="n">last</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span>  <span class="n">new_node</span> </div>

                           
<div class="viewcode-block" id="LinkedList.getNode">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.LinkedList.getNode">[docs]</a>
    <span class="k">def</span> <span class="nf">getNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return node of a linked list by value.&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> 
        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span> 
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">n</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">next</span>
            
        <span class="k">return</span> <span class="kc">None</span></div>

       
<div class="viewcode-block" id="LinkedList.toList">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.LinkedList.toList">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">toList</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a linked list to a list.&quot;&quot;&quot;</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> 
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">temp</span><span class="p">):</span> 
            <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> 
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">lst</span></div>

    
<div class="viewcode-block" id="LinkedList.display">
<a class="viewcode-back" href="../../../../source/snowdrop.src.info.html#snowdrop.src.info.graph.LinkedList.display">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display the linked list.&quot;&quot;&quot;</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> 
        <span class="k">while</span> <span class="p">(</span><span class="n">temp</span><span class="p">):</span> 
            <span class="nb">print</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">next</span></div>

                                      
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Representats LinkedList object as a string.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> 
        <span class="k">while</span> <span class="p">(</span><span class="n">temp</span><span class="p">):</span> 
            <span class="n">res</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">res</span>       
        
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Graph object represntation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>

            
          
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Test methods of Graph class. &quot;&quot;&quot;</span>
      
    <span class="c1"># Create a graph given in the above diagram </span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;D&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;E&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span><span class="s1">&#39;G&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="s1">&#39;J&#39;</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="s1">&#39;K&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="mi">11</span><span class="p">}</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span> 
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">,</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>
      
    <span class="n">g</span><span class="o">.</span><span class="n">BCC</span><span class="p">()</span> 
    <span class="n">g</span><span class="o">.</span><span class="n">printBiconnectedComponents</span><span class="p">()</span>
      
    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;a&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">],</span>
              <span class="s2">&quot;b&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="s2">&quot;e&quot;</span><span class="p">],</span>
              <span class="s2">&quot;c&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">],</span>
              <span class="s2">&quot;d&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">],</span>
              <span class="s2">&quot;e&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">],</span>
              <span class="s2">&quot;f&quot;</span> <span class="p">:</span> <span class="p">[]</span>
            <span class="p">}</span>
    
        <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">graph_dict</span><span class="o">=</span><span class="n">g</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Veryices degree:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">  -  </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">graph</span><span class="o">.</span><span class="n">vertex_degree</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;List of isolated vertices:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">find_isolated_vertices</span><span class="p">())</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;A path from &quot;a&quot; to &quot;e&quot;:&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">find_path</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">))</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;A shortest path from &quot;a&quot; to &quot;e&quot;:&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">find_shortest_path</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">))</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;All pathes from &quot;a&quot; to &quot;e&quot;:&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">find_all_paths</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;e&quot;</span><span class="p">))</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Check graph connectivity from &quot;a&quot;:&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">start_vertex</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">))</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;&quot;Find distance from &quot;a&quot; to &quot;e&quot;:&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">find_distance</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">))</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;&quot;Find connected vertices from &quot;a&quot;:&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">get_connected_vertices</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">))</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;&quot;Find connected vertices from &quot;f&quot;:&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">get_connected_vertices</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">))</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The maximum degree of the graph is:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">Delta</span><span class="p">())</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The minimum degree of the graph is:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edges:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Degree Sequence: &quot;</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">degree_sequence</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
    
        <span class="n">fullfilling</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                      <span class="p">]</span> 
        <span class="n">non_fullfilling</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> 
                          <span class="p">]</span>
    
        <span class="k">for</span> <span class="n">sequence</span> <span class="ow">in</span> <span class="n">fullfilling</span> <span class="o">+</span> <span class="n">non_fullfilling</span> <span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">Graph</span><span class="o">.</span><span class="n">erdoes_gallai</span><span class="p">(</span><span class="n">sequence</span><span class="p">))</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Add vertex &#39;z&#39;:&quot;</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Add edge (&#39;x&#39;,&#39;y&#39;): &quot;</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Add edge (&#39;a&#39;,&#39;d&#39;): &quot;</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Add edge (&#39;a&#39;,&#39;x&#39;): &quot;</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">Python Platform</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/modules.html">snowdrop</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../info.html">Python Platform</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Alexei Goumilevski.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>