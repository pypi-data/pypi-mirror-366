# unit tests for ntparse formatter functions

import pytest
import tempfile
import json
from io import StringIO

from ntparse.formatter import (
    to_json, 
    to_csv, 
    to_asm, 
    to_python_dict
)


class TestFormatterFunctions:
    """Test formatter functions"""
    
    def setup_method(self):
        """Set up test data"""
        self.syscalls = {
            "NtClose": 12,
            "NtOpenProcess": 38,
            "NtCreateFile": 85
        }
    
    def test_to_json(self):
        """Test JSON formatter"""
        result = to_json(self.syscalls)
        
        # Parse the JSON to verify structure
        data = json.loads(result)
        
        assert "syscalls" in data
        assert "count" in data
        assert "metadata" in data
        
        assert data["count"] == 3
        assert data["syscalls"]["NtClose"] == 12
        assert data["syscalls"]["NtOpenProcess"] == 38
        assert data["syscalls"]["NtCreateFile"] == 85
        
        # Check that syscalls are sorted by number
        syscall_items = list(data["syscalls"].items())
        assert syscall_items[0][1] <= syscall_items[1][1] <= syscall_items[2][1]
    
    def test_to_json_with_file(self):
        """Test JSON formatter with file output"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            to_json(self.syscalls, f)
            temp_path = f.name
        
        try:
            with open(temp_path, 'r') as f:
                content = f.read()
            
            data = json.loads(content)
            assert data["count"] == 3
            assert "NtClose" in data["syscalls"]
        finally:
            import os
            os.unlink(temp_path)
    
    def test_to_csv(self):
        """Test CSV formatter"""
        result = to_csv(self.syscalls)
        
        lines = result.strip().split('\n')
        assert len(lines) == 4  # Header + 3 syscalls
        
        # Check header
        assert lines[0] == "Function Name,Syscall Number,Hex Number"
        
        # Check that syscalls are sorted by number
        syscall_lines = lines[1:]
        numbers = [int(line.split(',')[1]) for line in syscall_lines]
        assert numbers == sorted(numbers)
        
        # Check hex format
        for line in syscall_lines:
            parts = line.split(',')
            assert len(parts) == 3
            assert parts[2].startswith('0x')
    
    def test_to_csv_with_file(self):
        """Test CSV formatter with file output"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            to_csv(self.syscalls, f)
            temp_path = f.name
        
        try:
            with open(temp_path, 'r') as f:
                content = f.read()
            
            lines = content.strip().split('\n')
            assert len(lines) == 4
            assert "Function Name,Syscall Number,Hex Number" in lines[0]
        finally:
            import os
            os.unlink(temp_path)
    
    def test_to_asm(self):
        """Test Assembly formatter"""
        result = to_asm(self.syscalls)
        
        lines = result.strip().split('\n')
        
        # Check header
        assert ".code" in lines[0]
        assert "Generated by ntparse" in lines[2]
        assert "Syscall stubs for x64" in lines[3]
        
        # Check that each syscall has proper assembly structure
        for func_name, syscall_num in self.syscalls.items():
            assert f"{func_name} PROC" in result
            assert f"mov rax, {syscall_num}" in result
            assert "syscall" in result
            assert "ret" in result
            assert f"{func_name} ENDP" in result
        
        # Check footer
        assert "end" in lines[-1]
    
    def test_to_asm_with_file(self):
        """Test Assembly formatter with file output"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.asm', delete=False) as f:
            to_asm(self.syscalls, f)
            temp_path = f.name
        
        try:
            with open(temp_path, 'r') as f:
                content = f.read()
            
            assert ".code" in content
            assert "NtClose PROC" in content
            assert "end" in content
        finally:
            import os
            os.unlink(temp_path)
    
    def test_to_python_dict(self):
        """Test Python dictionary formatter"""
        result = to_python_dict(self.syscalls)
        
        lines = result.strip().split('\n')
        
        # Check header comment
        assert "# Generated by ntparse" in lines[0]
        assert "# Syscall numbers for x64" in lines[1]
        
        # Check dictionary structure
        assert "SYSCALLS = {" in result
        
        # Check that each syscall is properly formatted
        for func_name, syscall_num in self.syscalls.items():
            expected_line = f"    '{func_name}': 0x{syscall_num:02X},"
            assert expected_line in result
        
        # Check closing brace
        assert "}" in lines[-1]
    
    def test_to_python_dict_with_file(self):
        """Test Python dictionary formatter with file output"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            to_python_dict(self.syscalls, f)
            temp_path = f.name
        
        try:
            with open(temp_path, 'r') as f:
                content = f.read()
            
            assert "# Generated by ntparse" in content
            assert "SYSCALLS = {" in content
            assert "'NtClose': 0x0C," in content
        finally:
            import os
            os.unlink(temp_path)
    
    def test_empty_syscalls(self):
        """Test formatters with empty syscalls dictionary"""
        empty_syscalls = {}
        
        # Test JSON
        json_result = to_json(empty_syscalls)
        data = json.loads(json_result)
        assert data["count"] == 0
        assert len(data["syscalls"]) == 0
        
        # Test CSV
        csv_result = to_csv(empty_syscalls)
        lines = csv_result.strip().split('\n')
        assert len(lines) == 1  # Only header
        assert lines[0] == "Function Name,Syscall Number,Hex Number"
        
        # Test Assembly
        asm_result = to_asm(empty_syscalls)
        assert ".code" in asm_result
        assert "end" in asm_result
        assert "PROC" not in asm_result  # No procedures
        
        # Test Python dict
        py_result = to_python_dict(empty_syscalls)
        assert "SYSCALLS = {" in py_result
        assert "}" in py_result
        assert "': 0x" not in py_result  # No syscall entries


class TestFormatterEdgeCases:
    """Test edge cases in formatters"""
    
    def test_syscalls_with_special_characters(self):
        """Test formatters with syscall names containing special characters"""
        syscalls = {
            "NtCreateFile": 85,
            "NtQueryInformationFile": 9,
            "NtSetInformationFile": 18
        }
        
        # All formatters should handle these names correctly
        json_result = to_json(syscalls)
        csv_result = to_csv(syscalls)
        asm_result = to_asm(syscalls)
        py_result = to_python_dict(syscalls)
        
        # Verify all names are present in output
        for name in syscalls.keys():
            assert name in json_result
            assert name in csv_result
            assert name in asm_result
            assert name in py_result
    
    def test_large_syscall_numbers(self):
        """Test formatters with large syscall numbers"""
        syscalls = {
            "NtTest1": 255,
            "NtTest2": 1000,
            "NtTest3": 65535
        }
        
        json_result = to_json(syscalls)
        csv_result = to_csv(syscalls)
        asm_result = to_asm(syscalls)
        py_result = to_python_dict(syscalls)
        
        # Verify hex formatting
        assert "0xFF" in csv_result  # 255
        assert "0x3E8" in csv_result  # 1000
        assert "0xFFFF" in csv_result  # 65535
        
        # Verify assembly uses decimal
        assert "mov rax, 255" in asm_result
        assert "mov rax, 1000" in asm_result
        assert "mov rax, 65535" in asm_result 