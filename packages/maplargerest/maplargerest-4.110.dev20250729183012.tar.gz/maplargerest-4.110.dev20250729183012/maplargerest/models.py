"""Classes representing the inputs and outputs for the MapLarge Rest API."""
from contextlib import AbstractContextManager
from datetime import datetime
from enum import Enum
from typing import Any, cast, ClassVar, Dict, Generic, IO, Iterable, List, Optional, overload, Tuple, TypeVar, Union
T = TypeVar("T")

class File:
	"""A wrapper for data to be uploaded to the server."""
	def __init__(self, file: IO[bytes], name: str, content_type: Optional[str] = None):
		"""
		:param file: The data to upload to the server.
		:param name: The filename.
		:param content_type: The MIME type.
		"""
		self._file = file
		self._name = name
		self._content_type = content_type

	@property
	def file(self) -> IO[bytes]:
		"""The data to upload to the server."""
		return self._file

	@file.setter
	def file(self, value: IO[bytes]) -> None:
		"""The data to upload to the server."""
		self._file = value

	@property
	def name(self) -> str:
		"""The filename."""
		return self._name

	@name.setter
	def name(self, value: str) -> None:
		"""The filename."""
		self._name = value

	@property
	def content_type(self) -> Optional[str]:
		"""The MIME type."""
		return self._content_type

	@content_type.setter
	def content_type(self, value: Optional[str]) -> None:
		"""The MIME type."""
		self._content_type = value

	def __enter__(self) -> "File":
		return self

	def __exit__(self, exc_type, exc_value, traceback) -> None: # type: ignore[no-untyped-def]
		if isinstance(self.file, IO):
			self.file.close()
class Account:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "int", None),
		"name": ("name", "str", None),
		"code": ("code", "str", None),
		"description": ("description", "str", None),
		"use_resource_permissions": ("useResourcePermissions", "bool", None),
		"total_estimated_size": ("totalEstimatedSize", "int", None),
		"estimated_size_limit": ("estimatedSizeLimit", "int", None),
		"max_row_limit": ("maxRowLimit", "int", None),
		"max_cell_limit": ("maxCellLimit", "int", None),
		"allow_anonymous_downloads": ("allowAnonymousDownloads", "bool", None),
		"owner": ("owner", "UserReference", None),
		"is_organization": ("isOrganization", "bool", None),
		"links": ("_links", "AccountLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "int",
		name: "str",
		code: "str",
		description: "str",
		use_resource_permissions: "bool",
		total_estimated_size: "int",
		links: "AccountLinks",
		estimated_size_limit: Optional["int"] = None,
		max_row_limit: Optional["int"] = None,
		max_cell_limit: Optional["int"] = None,
		allow_anonymous_downloads: Optional["bool"] = None,
		owner: Optional["UserReference"] = None,
		is_organization: Optional["bool"] = None,
	) -> None:
		"""
		:param id_: The unique numeric ID of the account.
		:type id_: int
		:param name: Account name. Usually matches `code`.
		:type name: str
		:param code: Text that uniquely identifies this account.
		:type code: str
		:param description: Account description.
		:type description: str
		:param use_resource_permissions: Set to true to enable fine-grained access control over tables and other resources.
		:type use_resource_permissions: bool
		:param total_estimated_size: The total estimated size of all tables in the account, expressed in number of table cells.
		:type total_estimated_size: int
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: AccountLinks
		:param estimated_size_limit: The number of table cells this account is allowed to store, across all tables.
		:type estimated_size_limit: int or None
		:param max_row_limit: Maximum number of rows this account may export at one time.
		:type max_row_limit: int or None
		:param max_cell_limit: Maximum number of cells this account may export from a raster at one time.
		:type max_cell_limit: int or None
		:param allow_anonymous_downloads: Allow downloads from this account without authentication.
		:type allow_anonymous_downloads: bool or None
		:param owner: The user this account belongs to, if this account is a personal account.
		:type owner: UserReference or None
		:param is_organization: Set to true if this account is an organization and adminstrators can issue public registration links from it.
		:type is_organization: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(int, kwargs.get("id_"))
		self._name = cast(str, kwargs.get("name"))
		self._code = cast(str, kwargs.get("code"))
		self._description = cast(str, kwargs.get("description"))
		self._use_resource_permissions = cast(bool, kwargs.get("use_resource_permissions"))
		self._total_estimated_size = cast(int, kwargs.get("total_estimated_size"))
		self._estimated_size_limit = cast(Optional[int], kwargs.get("estimated_size_limit"))
		self._max_row_limit = cast(Optional[int], kwargs.get("max_row_limit"))
		self._max_cell_limit = cast(Optional[int], kwargs.get("max_cell_limit"))
		self._allow_anonymous_downloads = cast(Optional[bool], kwargs.get("allow_anonymous_downloads"))
		self._owner = cast(Optional[UserReference], kwargs.get("owner"))
		self._is_organization = cast(Optional[bool], kwargs.get("is_organization"))
		self._links = cast(AccountLinks, kwargs.get("links"))
	@property
	def id_(self) -> "int":
		"""The unique numeric ID of the account."""
		return self._id_
	@id_.setter
	def id_(self, value: "int") -> None:
		"""The unique numeric ID of the account."""
		self._id_ = value
	@property
	def name(self) -> "str":
		"""Account name. Usually matches `code`."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""Account name. Usually matches `code`."""
		self._name = value
	@property
	def code(self) -> "str":
		"""Text that uniquely identifies this account."""
		return self._code
	@code.setter
	def code(self, value: "str") -> None:
		"""Text that uniquely identifies this account."""
		self._code = value
	@property
	def description(self) -> "str":
		"""Account description."""
		return self._description
	@description.setter
	def description(self, value: "str") -> None:
		"""Account description."""
		self._description = value
	@property
	def use_resource_permissions(self) -> "bool":
		"""Set to true to enable fine-grained access control over tables and other resources."""
		return self._use_resource_permissions
	@use_resource_permissions.setter
	def use_resource_permissions(self, value: "bool") -> None:
		"""Set to true to enable fine-grained access control over tables and other resources."""
		self._use_resource_permissions = value
	@property
	def total_estimated_size(self) -> "int":
		"""The total estimated size of all tables in the account, expressed in number of table cells."""
		return self._total_estimated_size
	@total_estimated_size.setter
	def total_estimated_size(self, value: "int") -> None:
		"""The total estimated size of all tables in the account, expressed in number of table cells."""
		self._total_estimated_size = value
	@property
	def estimated_size_limit(self) -> Optional["int"]:
		"""The number of table cells this account is allowed to store, across all tables."""
		return self._estimated_size_limit
	@estimated_size_limit.setter
	def estimated_size_limit(self, value: Optional["int"]) -> None:
		"""The number of table cells this account is allowed to store, across all tables."""
		self._estimated_size_limit = value
	@property
	def max_row_limit(self) -> Optional["int"]:
		"""Maximum number of rows this account may export at one time."""
		return self._max_row_limit
	@max_row_limit.setter
	def max_row_limit(self, value: Optional["int"]) -> None:
		"""Maximum number of rows this account may export at one time."""
		self._max_row_limit = value
	@property
	def max_cell_limit(self) -> Optional["int"]:
		"""Maximum number of cells this account may export from a raster at one time."""
		return self._max_cell_limit
	@max_cell_limit.setter
	def max_cell_limit(self, value: Optional["int"]) -> None:
		"""Maximum number of cells this account may export from a raster at one time."""
		self._max_cell_limit = value
	@property
	def allow_anonymous_downloads(self) -> Optional["bool"]:
		"""Allow downloads from this account without authentication."""
		return self._allow_anonymous_downloads
	@allow_anonymous_downloads.setter
	def allow_anonymous_downloads(self, value: Optional["bool"]) -> None:
		"""Allow downloads from this account without authentication."""
		self._allow_anonymous_downloads = value
	@property
	def owner(self) -> Optional["UserReference"]:
		"""The user this account belongs to, if this account is a personal account."""
		return self._owner
	@owner.setter
	def owner(self, value: Optional["UserReference"]) -> None:
		"""The user this account belongs to, if this account is a personal account."""
		self._owner = value
	@property
	def is_organization(self) -> Optional["bool"]:
		"""Set to true if this account is an organization and adminstrators can issue public registration links from it."""
		return self._is_organization
	@is_organization.setter
	def is_organization(self, value: Optional["bool"]) -> None:
		"""Set to true if this account is an organization and adminstrators can issue public registration links from it."""
		self._is_organization = value
	@property
	def links(self) -> "AccountLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "AccountLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class Links:
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class AccountLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"owner": ("owner", "Link", None),
		"groups": ("groups", "Link", None),
		"tables": ("tables", "Link", None),
		"root_resource_folder": ("rootResourceFolder", "Link", None),
		"tile_sets": ("tileSets", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		groups: "Link",
		tables: "Link",
		root_resource_folder: "Link",
		tile_sets: "Link",
		self_: "Link",
		owner: Optional["Link"] = None,
	) -> None:
		"""
		:param groups: A link to the groups owned by this account.
		:type groups: Link
		:param tables: A link to the tables owned by this account.
		:type tables: Link
		:param root_resource_folder: A link to the root resource folder for this account.
		:type root_resource_folder: Link
		:param tile_sets: A link to the tile sets owned by this account.
		:type tile_sets: Link
		:param self_: A link to the current resource.
		:type self_: Link
		:param owner: The user this account belongs to, if this account is a personal account.
		:type owner: Link or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._owner = cast(Optional[Link], kwargs.get("owner"))
		self._groups = cast(Link, kwargs.get("groups"))
		self._tables = cast(Link, kwargs.get("tables"))
		self._root_resource_folder = cast(Link, kwargs.get("root_resource_folder"))
		self._tile_sets = cast(Link, kwargs.get("tile_sets"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def owner(self) -> Optional["Link"]:
		"""The user this account belongs to, if this account is a personal account."""
		return self._owner
	@owner.setter
	def owner(self, value: Optional["Link"]) -> None:
		"""The user this account belongs to, if this account is a personal account."""
		self._owner = value
	@property
	def groups(self) -> "Link":
		"""A link to the groups owned by this account."""
		return self._groups
	@groups.setter
	def groups(self, value: "Link") -> None:
		"""A link to the groups owned by this account."""
		self._groups = value
	@property
	def tables(self) -> "Link":
		"""A link to the tables owned by this account."""
		return self._tables
	@tables.setter
	def tables(self, value: "Link") -> None:
		"""A link to the tables owned by this account."""
		self._tables = value
	@property
	def root_resource_folder(self) -> "Link":
		"""A link to the root resource folder for this account."""
		return self._root_resource_folder
	@root_resource_folder.setter
	def root_resource_folder(self, value: "Link") -> None:
		"""A link to the root resource folder for this account."""
		self._root_resource_folder = value
	@property
	def tile_sets(self) -> "Link":
		"""A link to the tile sets owned by this account."""
		return self._tile_sets
	@tile_sets.setter
	def tile_sets(self, value: "Link") -> None:
		"""A link to the tile sets owned by this account."""
		self._tile_sets = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class AccountReference:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "int", None),
		"code": ("code", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: Optional["int"] = None,
		code: Optional["str"] = None,
	) -> None:
		"""
		:param id_: The unique numeric ID of the account. At least one of `id` or `code` must be specified. If both are specified, `id` takes precedence.
		:type id_: int or None
		:param code: Text that uniquely identifies this account. At least one of `id` or `code` must be specified. If both are specified, `id` takes precedence.
		:type code: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(Optional[int], kwargs.get("id_"))
		self._code = cast(Optional[str], kwargs.get("code"))
	@property
	def id_(self) -> Optional["int"]:
		"""The unique numeric ID of the account. At least one of `id` or `code` must be specified. If both are specified, `id` takes precedence."""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["int"]) -> None:
		"""The unique numeric ID of the account. At least one of `id` or `code` must be specified. If both are specified, `id` takes precedence."""
		self._id_ = value
	@property
	def code(self) -> Optional["str"]:
		"""Text that uniquely identifies this account. At least one of `id` or `code` must be specified. If both are specified, `id` takes precedence."""
		return self._code
	@code.setter
	def code(self, value: Optional["str"]) -> None:
		"""Text that uniquely identifies this account. At least one of `id` or `code` must be specified. If both are specified, `id` takes precedence."""
		self._code = value





class AdapterTransportsEnum(str, Enum):
	# pylint: disable=missing-class-docstring
	UNSET = 'UNSET'
	ATOMIC = 'ATOMIC'
	BULK = 'BULK'
	FILE = 'FILE'
	MESSAGING = 'MESSAGING'
	SMS = 'SMS'
	SMTP = 'SMTP'
	PUSHNOTIFICATION = 'PUSHNOTIFICATION'
	REMOTEDATA = 'REMOTEDATA'
	FILESYSTEM = 'FILESYSTEM'
	DATABASE = 'DATABASE'
	AMAZON = 'AMAZON'
	S3 = 'S3'
	ELASTIC = 'ELASTIC'
	AWSELASTIC = 'AWSELASTIC'
	HYPERION = 'HYPERION'
	CUSTOM = 'CUSTOM'
	INBOX = 'INBOX'
	FCMS = 'FCMS'
	CGI = 'CGI'
	KAFKA = 'KAFKA'


AdapterTransports = Iterable[AdapterTransportsEnum]


class AggregateMode(str, Enum):
	"""Defines the behavior when multiple values are in a single cell"""
	AVG = 'Avg'
	MIN = 'Min'
	MAX = 'Max'
	TOP_ONLY = 'TopOnly'

AggregateMode.AVG.__doc__ = """Uses the mean average of the values"""
AggregateMode.MIN.__doc__ = """Uses the minimum of the values"""
AggregateMode.MAX.__doc__ = """Uses the maximum of the values"""
AggregateMode.TOP_ONLY.__doc__ = """The highest value based on a sort column"""
class AlertRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "int", None),
		"name": ("name", "str", None),
		"query": ("query", "str", None),
		"emails": ("emails", "str", None),
		"urls": ("urls", "str", None),
		"notes": ("notes", "str", None),
		"results_table_name": ("resultsTableName", "str", None),
		"is_muted": ("isMuted", "bool", None),
		"is_paused": ("isPaused", "bool", None),
		"times_triggered": ("timesTriggered", "int", None),
		"saved_map_id": ("savedMapId", "str", None),
		"saved_map_extents_layer": ("savedMapExtentsLayer", "int", None),
		"saved_report_id": ("savedReportId", "str", None),
		"account": ("account", "str", None),
		"color": ("color", "str", None),
		"severity": ("severity", "int", None),
		"identity_column": ("identityColumn", "str", None),
		"watch_column": ("watchColumn", "str", None),
		"trigger_mode": ("triggerMode", "str", None),
		"total_column": ("totalColumn", "str", None),
		"initial_threshold": ("initialThreshold", "float", None),
		"incremental_threshold": ("incrementalThreshold", "float", None),
		"is_incremental_percentage": ("isIncrementalPercentage", "bool", None),
		"generate_event_per_result": ("generateEventPerResult", "bool", None),
		"trigger_table_active_ids": ("triggerTableActiveIds", "str", None),
		"message_guid": ("messageGuid", "str", None),
		"geo_column": ("geoColumn", "str", None),
		"dashboard_context": ("dashboardContext", "str", None),
		"notification": ("notification", "str", None),
		"bypass_debounce": ("bypassDebounce", "bool", None),
		"reset_last_total_value_on_alert_update": ("resetLastTotalValueOnAlertUpdate", "bool", None),
		"only_fire_increments_on_change": ("onlyFireIncrementsOnChange", "bool", None),
		"clone_results_to_table": ("cloneResultsToTable", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "int",
		times_triggered: "int",
		saved_map_extents_layer: "int",
		severity: "int",
		initial_threshold: "float",
		incremental_threshold: "float",
		is_incremental_percentage: "bool",
		generate_event_per_result: "bool",
		bypass_debounce: "bool",
		reset_last_total_value_on_alert_update: "bool",
		only_fire_increments_on_change: "bool",
		clone_results_to_table: "bool",
		name: Optional["str"] = None,
		query: Optional["str"] = None,
		emails: Optional["str"] = None,
		urls: Optional["str"] = None,
		notes: Optional["str"] = None,
		results_table_name: Optional["str"] = None,
		is_muted: Optional["bool"] = None,
		is_paused: Optional["bool"] = None,
		saved_map_id: Optional["str"] = None,
		saved_report_id: Optional["str"] = None,
		account: Optional["str"] = None,
		color: Optional["str"] = None,
		identity_column: Optional["str"] = None,
		watch_column: Optional["str"] = None,
		trigger_mode: Optional["str"] = None,
		total_column: Optional["str"] = None,
		trigger_table_active_ids: Optional["str"] = None,
		message_guid: Optional["str"] = None,
		geo_column: Optional["str"] = None,
		dashboard_context: Optional["str"] = None,
		notification: Optional["str"] = None,
	) -> None:
		"""
		:param id_:
		:type id_: int
		:param times_triggered:
		:type times_triggered: int
		:param saved_map_extents_layer:
		:type saved_map_extents_layer: int
		:param severity:
		:type severity: int
		:param initial_threshold:
		:type initial_threshold: float
		:param incremental_threshold:
		:type incremental_threshold: float
		:param is_incremental_percentage:
		:type is_incremental_percentage: bool
		:param generate_event_per_result:
		:type generate_event_per_result: bool
		:param bypass_debounce:
		:type bypass_debounce: bool
		:param reset_last_total_value_on_alert_update:
		:type reset_last_total_value_on_alert_update: bool
		:param only_fire_increments_on_change:
		:type only_fire_increments_on_change: bool
		:param clone_results_to_table:
		:type clone_results_to_table: bool
		:param name:
		:type name: str or None
		:param query:
		:type query: str or None
		:param emails:
		:type emails: str or None
		:param urls:
		:type urls: str or None
		:param notes:
		:type notes: str or None
		:param results_table_name:
		:type results_table_name: str or None
		:param is_muted:
		:type is_muted: bool or None
		:param is_paused:
		:type is_paused: bool or None
		:param saved_map_id:
		:type saved_map_id: str or None
		:param saved_report_id:
		:type saved_report_id: str or None
		:param account:
		:type account: str or None
		:param color:
		:type color: str or None
		:param identity_column:
		:type identity_column: str or None
		:param watch_column:
		:type watch_column: str or None
		:param trigger_mode:
		:type trigger_mode: str or None
		:param total_column:
		:type total_column: str or None
		:param trigger_table_active_ids:
		:type trigger_table_active_ids: str or None
		:param message_guid:
		:type message_guid: str or None
		:param geo_column:
		:type geo_column: str or None
		:param dashboard_context:
		:type dashboard_context: str or None
		:param notification:
		:type notification: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(int, kwargs.get("id_"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._query = cast(Optional[str], kwargs.get("query"))
		self._emails = cast(Optional[str], kwargs.get("emails"))
		self._urls = cast(Optional[str], kwargs.get("urls"))
		self._notes = cast(Optional[str], kwargs.get("notes"))
		self._results_table_name = cast(Optional[str], kwargs.get("results_table_name"))
		self._is_muted = cast(Optional[bool], kwargs.get("is_muted"))
		self._is_paused = cast(Optional[bool], kwargs.get("is_paused"))
		self._times_triggered = cast(int, kwargs.get("times_triggered"))
		self._saved_map_id = cast(Optional[str], kwargs.get("saved_map_id"))
		self._saved_map_extents_layer = cast(int, kwargs.get("saved_map_extents_layer"))
		self._saved_report_id = cast(Optional[str], kwargs.get("saved_report_id"))
		self._account = cast(Optional[str], kwargs.get("account"))
		self._color = cast(Optional[str], kwargs.get("color"))
		self._severity = cast(int, kwargs.get("severity"))
		self._identity_column = cast(Optional[str], kwargs.get("identity_column"))
		self._watch_column = cast(Optional[str], kwargs.get("watch_column"))
		self._trigger_mode = cast(Optional[str], kwargs.get("trigger_mode"))
		self._total_column = cast(Optional[str], kwargs.get("total_column"))
		self._initial_threshold = cast(float, kwargs.get("initial_threshold"))
		self._incremental_threshold = cast(float, kwargs.get("incremental_threshold"))
		self._is_incremental_percentage = cast(bool, kwargs.get("is_incremental_percentage"))
		self._generate_event_per_result = cast(bool, kwargs.get("generate_event_per_result"))
		self._trigger_table_active_ids = cast(Optional[str], kwargs.get("trigger_table_active_ids"))
		self._message_guid = cast(Optional[str], kwargs.get("message_guid"))
		self._geo_column = cast(Optional[str], kwargs.get("geo_column"))
		self._dashboard_context = cast(Optional[str], kwargs.get("dashboard_context"))
		self._notification = cast(Optional[str], kwargs.get("notification"))
		self._bypass_debounce = cast(bool, kwargs.get("bypass_debounce"))
		self._reset_last_total_value_on_alert_update = cast(bool, kwargs.get("reset_last_total_value_on_alert_update"))
		self._only_fire_increments_on_change = cast(bool, kwargs.get("only_fire_increments_on_change"))
		self._clone_results_to_table = cast(bool, kwargs.get("clone_results_to_table"))
	@property
	def id_(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def query(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._query
	@query.setter
	def query(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._query = value
	@property
	def emails(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._emails
	@emails.setter
	def emails(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._emails = value
	@property
	def urls(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._urls
	@urls.setter
	def urls(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._urls = value
	@property
	def notes(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._notes
	@notes.setter
	def notes(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._notes = value
	@property
	def results_table_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._results_table_name
	@results_table_name.setter
	def results_table_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._results_table_name = value
	@property
	def is_muted(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._is_muted
	@is_muted.setter
	def is_muted(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._is_muted = value
	@property
	def is_paused(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._is_paused
	@is_paused.setter
	def is_paused(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._is_paused = value
	@property
	def times_triggered(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._times_triggered
	@times_triggered.setter
	def times_triggered(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._times_triggered = value
	@property
	def saved_map_id(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._saved_map_id
	@saved_map_id.setter
	def saved_map_id(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._saved_map_id = value
	@property
	def saved_map_extents_layer(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._saved_map_extents_layer
	@saved_map_extents_layer.setter
	def saved_map_extents_layer(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._saved_map_extents_layer = value
	@property
	def saved_report_id(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._saved_report_id
	@saved_report_id.setter
	def saved_report_id(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._saved_report_id = value
	@property
	def account(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._account
	@account.setter
	def account(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._account = value
	@property
	def color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._color = value
	@property
	def severity(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._severity
	@severity.setter
	def severity(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._severity = value
	@property
	def identity_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._identity_column
	@identity_column.setter
	def identity_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._identity_column = value
	@property
	def watch_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._watch_column
	@watch_column.setter
	def watch_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._watch_column = value
	@property
	def trigger_mode(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._trigger_mode
	@trigger_mode.setter
	def trigger_mode(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._trigger_mode = value
	@property
	def total_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._total_column
	@total_column.setter
	def total_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._total_column = value
	@property
	def initial_threshold(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._initial_threshold
	@initial_threshold.setter
	def initial_threshold(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._initial_threshold = value
	@property
	def incremental_threshold(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._incremental_threshold
	@incremental_threshold.setter
	def incremental_threshold(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._incremental_threshold = value
	@property
	def is_incremental_percentage(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_incremental_percentage
	@is_incremental_percentage.setter
	def is_incremental_percentage(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_incremental_percentage = value
	@property
	def generate_event_per_result(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._generate_event_per_result
	@generate_event_per_result.setter
	def generate_event_per_result(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._generate_event_per_result = value
	@property
	def trigger_table_active_ids(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._trigger_table_active_ids
	@trigger_table_active_ids.setter
	def trigger_table_active_ids(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._trigger_table_active_ids = value
	@property
	def message_guid(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._message_guid
	@message_guid.setter
	def message_guid(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._message_guid = value
	@property
	def geo_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._geo_column
	@geo_column.setter
	def geo_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._geo_column = value
	@property
	def dashboard_context(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._dashboard_context
	@dashboard_context.setter
	def dashboard_context(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._dashboard_context = value
	@property
	def notification(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._notification
	@notification.setter
	def notification(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._notification = value
	@property
	def bypass_debounce(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._bypass_debounce
	@bypass_debounce.setter
	def bypass_debounce(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._bypass_debounce = value
	@property
	def reset_last_total_value_on_alert_update(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._reset_last_total_value_on_alert_update
	@reset_last_total_value_on_alert_update.setter
	def reset_last_total_value_on_alert_update(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._reset_last_total_value_on_alert_update = value
	@property
	def only_fire_increments_on_change(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._only_fire_increments_on_change
	@only_fire_increments_on_change.setter
	def only_fire_increments_on_change(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._only_fire_increments_on_change = value
	@property
	def clone_results_to_table(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._clone_results_to_table
	@clone_results_to_table.setter
	def clone_results_to_table(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._clone_results_to_table = value
class AlertTrigger:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("ID", "str", None),
		"name": ("Name", "str", None),
		"query": ("Query", "str", None),
		"emails": ("Emails", "str", None),
		"urls": ("Urls", "str", None),
		"notes": ("Notes", "str", None),
		"results_table_name": ("ResultsTableName", "str", None),
		"is_muted": ("IsMuted", "bool", None),
		"is_paused": ("IsPaused", "bool", None),
		"times_triggered": ("TimesTriggered", "int", None),
		"saved_map_id": ("SavedMapId", "str", None),
		"saved_map_extents_layer": ("SavedMapExtentsLayer", "int", None),
		"saved_report_id": ("SavedReportId", "str", None),
		"account": ("Account", "str", None),
		"color": ("Color", "str", None),
		"identity_column": ("IdentityColumn", "str", None),
		"watch_column": ("WatchColumn", "str", None),
		"severity": ("Severity", "int", None),
		"trigger_mode": ("TriggerMode", "str", None),
		"total_column": ("TotalColumn", "str", None),
		"initial_threshold": ("InitialThreshold", "float", None),
		"incremental_threshold": ("IncrementalThreshold", "float", None),
		"is_incremental_percentage": ("IsIncrementalPercentage", "bool", None),
		"generate_event_per_result": ("GenerateEventPerResult", "bool", None),
		"trigger_table_active_ids": ("TriggerTableActiveIds", "str", None),
		"message_guid": ("MessageGuid", "str", None),
		"geo_column": ("GeoColumn", "str", None),
		"dashboard_context": ("DashboardContext", "str", None),
		"notification": ("Notification", "str", None),
		"bypass_debounce": ("BypassDebounce", "bool", None),
		"only_fire_increments_on_change": ("OnlyFireIncrementsOnChange", "bool", None),
		"clone_results_to_table": ("CloneResultsToTable", "bool", None),
		"links": ("_links", "AlertTriggerLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		is_muted: "bool",
		is_paused: "bool",
		times_triggered: "int",
		saved_map_extents_layer: "int",
		severity: "int",
		initial_threshold: "float",
		incremental_threshold: "float",
		is_incremental_percentage: "bool",
		generate_event_per_result: "bool",
		bypass_debounce: "bool",
		only_fire_increments_on_change: "bool",
		clone_results_to_table: "bool",
		links: "AlertTriggerLinks",
		id_: Optional["str"] = None,
		name: Optional["str"] = None,
		query: Optional["str"] = None,
		emails: Optional["str"] = None,
		urls: Optional["str"] = None,
		notes: Optional["str"] = None,
		results_table_name: Optional["str"] = None,
		saved_map_id: Optional["str"] = None,
		saved_report_id: Optional["str"] = None,
		account: Optional["str"] = None,
		color: Optional["str"] = None,
		identity_column: Optional["str"] = None,
		watch_column: Optional["str"] = None,
		trigger_mode: Optional["str"] = None,
		total_column: Optional["str"] = None,
		trigger_table_active_ids: Optional["str"] = None,
		message_guid: Optional["str"] = None,
		geo_column: Optional["str"] = None,
		dashboard_context: Optional["str"] = None,
		notification: Optional["str"] = None,
	) -> None:
		"""
		:param is_muted:
		:type is_muted: bool
		:param is_paused:
		:type is_paused: bool
		:param times_triggered:
		:type times_triggered: int
		:param saved_map_extents_layer:
		:type saved_map_extents_layer: int
		:param severity:
		:type severity: int
		:param initial_threshold:
		:type initial_threshold: float
		:param incremental_threshold:
		:type incremental_threshold: float
		:param is_incremental_percentage:
		:type is_incremental_percentage: bool
		:param generate_event_per_result:
		:type generate_event_per_result: bool
		:param bypass_debounce:
		:type bypass_debounce: bool
		:param only_fire_increments_on_change:
		:type only_fire_increments_on_change: bool
		:param clone_results_to_table:
		:type clone_results_to_table: bool
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: AlertTriggerLinks
		:param id_: The unique ID of the alert trigger.
		:type id_: str or None
		:param name: Alert trigger name.
		:type name: str or None
		:param query:
		:type query: str or None
		:param emails:
		:type emails: str or None
		:param urls:
		:type urls: str or None
		:param notes:
		:type notes: str or None
		:param results_table_name:
		:type results_table_name: str or None
		:param saved_map_id:
		:type saved_map_id: str or None
		:param saved_report_id:
		:type saved_report_id: str or None
		:param account:
		:type account: str or None
		:param color:
		:type color: str or None
		:param identity_column:
		:type identity_column: str or None
		:param watch_column:
		:type watch_column: str or None
		:param trigger_mode:
		:type trigger_mode: str or None
		:param total_column:
		:type total_column: str or None
		:param trigger_table_active_ids:
		:type trigger_table_active_ids: str or None
		:param message_guid:
		:type message_guid: str or None
		:param geo_column:
		:type geo_column: str or None
		:param dashboard_context:
		:type dashboard_context: str or None
		:param notification:
		:type notification: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._query = cast(Optional[str], kwargs.get("query"))
		self._emails = cast(Optional[str], kwargs.get("emails"))
		self._urls = cast(Optional[str], kwargs.get("urls"))
		self._notes = cast(Optional[str], kwargs.get("notes"))
		self._results_table_name = cast(Optional[str], kwargs.get("results_table_name"))
		self._is_muted = cast(bool, kwargs.get("is_muted"))
		self._is_paused = cast(bool, kwargs.get("is_paused"))
		self._times_triggered = cast(int, kwargs.get("times_triggered"))
		self._saved_map_id = cast(Optional[str], kwargs.get("saved_map_id"))
		self._saved_map_extents_layer = cast(int, kwargs.get("saved_map_extents_layer"))
		self._saved_report_id = cast(Optional[str], kwargs.get("saved_report_id"))
		self._account = cast(Optional[str], kwargs.get("account"))
		self._color = cast(Optional[str], kwargs.get("color"))
		self._identity_column = cast(Optional[str], kwargs.get("identity_column"))
		self._watch_column = cast(Optional[str], kwargs.get("watch_column"))
		self._severity = cast(int, kwargs.get("severity"))
		self._trigger_mode = cast(Optional[str], kwargs.get("trigger_mode"))
		self._total_column = cast(Optional[str], kwargs.get("total_column"))
		self._initial_threshold = cast(float, kwargs.get("initial_threshold"))
		self._incremental_threshold = cast(float, kwargs.get("incremental_threshold"))
		self._is_incremental_percentage = cast(bool, kwargs.get("is_incremental_percentage"))
		self._generate_event_per_result = cast(bool, kwargs.get("generate_event_per_result"))
		self._trigger_table_active_ids = cast(Optional[str], kwargs.get("trigger_table_active_ids"))
		self._message_guid = cast(Optional[str], kwargs.get("message_guid"))
		self._geo_column = cast(Optional[str], kwargs.get("geo_column"))
		self._dashboard_context = cast(Optional[str], kwargs.get("dashboard_context"))
		self._notification = cast(Optional[str], kwargs.get("notification"))
		self._bypass_debounce = cast(bool, kwargs.get("bypass_debounce"))
		self._only_fire_increments_on_change = cast(bool, kwargs.get("only_fire_increments_on_change"))
		self._clone_results_to_table = cast(bool, kwargs.get("clone_results_to_table"))
		self._links = cast(AlertTriggerLinks, kwargs.get("links"))
	@property
	def id_(self) -> Optional["str"]:
		"""The unique ID of the alert trigger."""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		"""The unique ID of the alert trigger."""
		self._id_ = value
	@property
	def name(self) -> Optional["str"]:
		"""Alert trigger name."""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""Alert trigger name."""
		self._name = value
	@property
	def query(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._query
	@query.setter
	def query(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._query = value
	@property
	def emails(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._emails
	@emails.setter
	def emails(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._emails = value
	@property
	def urls(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._urls
	@urls.setter
	def urls(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._urls = value
	@property
	def notes(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._notes
	@notes.setter
	def notes(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._notes = value
	@property
	def results_table_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._results_table_name
	@results_table_name.setter
	def results_table_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._results_table_name = value
	@property
	def is_muted(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_muted
	@is_muted.setter
	def is_muted(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_muted = value
	@property
	def is_paused(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_paused
	@is_paused.setter
	def is_paused(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_paused = value
	@property
	def times_triggered(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._times_triggered
	@times_triggered.setter
	def times_triggered(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._times_triggered = value
	@property
	def saved_map_id(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._saved_map_id
	@saved_map_id.setter
	def saved_map_id(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._saved_map_id = value
	@property
	def saved_map_extents_layer(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._saved_map_extents_layer
	@saved_map_extents_layer.setter
	def saved_map_extents_layer(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._saved_map_extents_layer = value
	@property
	def saved_report_id(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._saved_report_id
	@saved_report_id.setter
	def saved_report_id(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._saved_report_id = value
	@property
	def account(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._account
	@account.setter
	def account(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._account = value
	@property
	def color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._color = value
	@property
	def identity_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._identity_column
	@identity_column.setter
	def identity_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._identity_column = value
	@property
	def watch_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._watch_column
	@watch_column.setter
	def watch_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._watch_column = value
	@property
	def severity(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._severity
	@severity.setter
	def severity(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._severity = value
	@property
	def trigger_mode(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._trigger_mode
	@trigger_mode.setter
	def trigger_mode(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._trigger_mode = value
	@property
	def total_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._total_column
	@total_column.setter
	def total_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._total_column = value
	@property
	def initial_threshold(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._initial_threshold
	@initial_threshold.setter
	def initial_threshold(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._initial_threshold = value
	@property
	def incremental_threshold(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._incremental_threshold
	@incremental_threshold.setter
	def incremental_threshold(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._incremental_threshold = value
	@property
	def is_incremental_percentage(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_incremental_percentage
	@is_incremental_percentage.setter
	def is_incremental_percentage(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_incremental_percentage = value
	@property
	def generate_event_per_result(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._generate_event_per_result
	@generate_event_per_result.setter
	def generate_event_per_result(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._generate_event_per_result = value
	@property
	def trigger_table_active_ids(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._trigger_table_active_ids
	@trigger_table_active_ids.setter
	def trigger_table_active_ids(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._trigger_table_active_ids = value
	@property
	def message_guid(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._message_guid
	@message_guid.setter
	def message_guid(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._message_guid = value
	@property
	def geo_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._geo_column
	@geo_column.setter
	def geo_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._geo_column = value
	@property
	def dashboard_context(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._dashboard_context
	@dashboard_context.setter
	def dashboard_context(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._dashboard_context = value
	@property
	def notification(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._notification
	@notification.setter
	def notification(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._notification = value
	@property
	def bypass_debounce(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._bypass_debounce
	@bypass_debounce.setter
	def bypass_debounce(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._bypass_debounce = value
	@property
	def only_fire_increments_on_change(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._only_fire_increments_on_change
	@only_fire_increments_on_change.setter
	def only_fire_increments_on_change(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._only_fire_increments_on_change = value
	@property
	def clone_results_to_table(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._clone_results_to_table
	@clone_results_to_table.setter
	def clone_results_to_table(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._clone_results_to_table = value
	@property
	def links(self) -> "AlertTriggerLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "AlertTriggerLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class AlertTriggerLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value


class AltitudeBase(str, Enum):
	# pylint: disable=missing-class-docstring
	UNSET = 'UNSET'
	SPHEROID = 'spheroid'
	TERRAIN = 'terrain'
	ABSOLUTE = 'absolute'

class ArcGisAuth:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"token_request_url": ("tokenRequestURL", "str", None),
		"user_name": ("userName", "str", None),
		"password": ("password", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		token_request_url: Optional["str"] = None,
		user_name: Optional["str"] = None,
		password: Optional["str"] = None,
	) -> None:
		"""
		:param token_request_url:
		:type token_request_url: str or None
		:param user_name:
		:type user_name: str or None
		:param password:
		:type password: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._token_request_url = cast(Optional[str], kwargs.get("token_request_url"))
		self._user_name = cast(Optional[str], kwargs.get("user_name"))
		self._password = cast(Optional[str], kwargs.get("password"))
	@property
	def token_request_url(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._token_request_url
	@token_request_url.setter
	def token_request_url(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._token_request_url = value
	@property
	def user_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._user_name
	@user_name.setter
	def user_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._user_name = value
	@property
	def password(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._password
	@password.setter
	def password(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._password = value


class AuthProviderType(str, Enum):
	# pylint: disable=missing-class-docstring
	BASIC = 'Basic'
	OAUTH = 'OAuth'
	NONE = 'None'
	CLIENT_CERTIFICATE = 'ClientCertificate'

AuthProviderType.BASIC.__doc__ = """Standard MapLarge authentication."""
class Axis:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"type_": ("type", "AxisType", None),
		"direction": ("direction", "AxisDirection", None),
		"position": ("position", "AxisPosition", None),
		"major_tick": ("majorTick", "Tick", None),
		"minor_tick": ("minorTick", "Tick", None),
		"draw_line": ("drawLine", "bool", None),
		"title": ("title", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		type_: "AxisType",
		direction: "AxisDirection",
		position: "AxisPosition",
		major_tick: "Tick",
		minor_tick: "Tick",
		draw_line: "bool",
		title: Optional["str"] = None,
	) -> None:
		"""
		:param type_:
		:type type_: AxisType
		:param direction:
		:type direction: AxisDirection
		:param position:
		:type position: AxisPosition
		:param major_tick:
		:type major_tick: Tick
		:param minor_tick:
		:type minor_tick: Tick
		:param draw_line:
		:type draw_line: bool
		:param title:
		:type title: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._type_ = cast(AxisType, kwargs.get("type_"))
		self._direction = cast(AxisDirection, kwargs.get("direction"))
		self._position = cast(AxisPosition, kwargs.get("position"))
		self._major_tick = cast(Tick, kwargs.get("major_tick"))
		self._minor_tick = cast(Tick, kwargs.get("minor_tick"))
		self._draw_line = cast(bool, kwargs.get("draw_line"))
		self._title = cast(Optional[str], kwargs.get("title"))
	@property
	def type_(self) -> "AxisType":
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: "AxisType") -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def direction(self) -> "AxisDirection":
		# pylint: disable=missing-function-docstring
		return self._direction
	@direction.setter
	def direction(self, value: "AxisDirection") -> None:
		# pylint: disable=missing-function-docstring
		self._direction = value
	@property
	def position(self) -> "AxisPosition":
		# pylint: disable=missing-function-docstring
		return self._position
	@position.setter
	def position(self, value: "AxisPosition") -> None:
		# pylint: disable=missing-function-docstring
		self._position = value
	@property
	def major_tick(self) -> "Tick":
		# pylint: disable=missing-function-docstring
		return self._major_tick
	@major_tick.setter
	def major_tick(self, value: "Tick") -> None:
		# pylint: disable=missing-function-docstring
		self._major_tick = value
	@property
	def minor_tick(self) -> "Tick":
		# pylint: disable=missing-function-docstring
		return self._minor_tick
	@minor_tick.setter
	def minor_tick(self, value: "Tick") -> None:
		# pylint: disable=missing-function-docstring
		self._minor_tick = value
	@property
	def draw_line(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._draw_line
	@draw_line.setter
	def draw_line(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._draw_line = value
	@property
	def title(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._title
	@title.setter
	def title(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._title = value


class AxisDirection(str, Enum):
	# pylint: disable=missing-class-docstring
	VERTICAL = 'Vertical'
	HORIZONTAL = 'Horizontal'



class AxisPosition(str, Enum):
	# pylint: disable=missing-class-docstring
	BEFORE = 'Before'
	AFTER = 'After'



class AxisType(str, Enum):
	# pylint: disable=missing-class-docstring
	DISCRETE = 'Discrete'
	CONTINUOUS = 'Continuous'

class BackgroundBaseMapTheme:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"ocean_color": ("oceanColor", "str", None),
		"lake_river_color": ("lakeRiverColor", "str", None),
		"landmass_color": ("landmassColor", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		ocean_color: Optional["str"] = None,
		lake_river_color: Optional["str"] = None,
		landmass_color: Optional["str"] = None,
	) -> None:
		"""
		:param ocean_color:
		:type ocean_color: str or None
		:param lake_river_color:
		:type lake_river_color: str or None
		:param landmass_color:
		:type landmass_color: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._ocean_color = cast(Optional[str], kwargs.get("ocean_color"))
		self._lake_river_color = cast(Optional[str], kwargs.get("lake_river_color"))
		self._landmass_color = cast(Optional[str], kwargs.get("landmass_color"))
	@property
	def ocean_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._ocean_color
	@ocean_color.setter
	def ocean_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._ocean_color = value
	@property
	def lake_river_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._lake_river_color
	@lake_river_color.setter
	def lake_river_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._lake_river_color = value
	@property
	def landmass_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._landmass_color
	@landmass_color.setter
	def landmass_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._landmass_color = value
class BandwidthLimit:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"entity_id": ("entityId", "str", None),
		"limit_bytes": ("limitBytes", "int", None),
		"period": ("period", "str", None),
		"bandwidth_limit_type": ("bandwidthLimitType", "BandwidthLimitType", None),
		"links": ("_links", "BandwidthLimitLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
		limit_bytes: "int",
		period: "str",
		bandwidth_limit_type: "BandwidthLimitType",
		links: "BandwidthLimitLinks",
		entity_id: Optional["str"] = None,
	) -> None:
		"""
		:param id_: The unique id of the bandwidth limit. Used for updates and deletes.
		:type id_: str
		:param limit_bytes: The target number of bytes to send or receive in the defined Period.
		:type limit_bytes: int
		:param period: The amount of time that the bandwidth limit applies to.  Specified in HH:MM:SS or DD.HH:MM:SS formats
		:type period: str
		:param bandwidth_limit_type: Defines how the bandwidth limit is applied. Options are 'Additional' or 'Exception'
		:type bandwidth_limit_type: BandwidthLimitType
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: BandwidthLimitLinks
		:param entity_id: The unique id of the central server or synced table pair for entity limits. Empty string for global limits.
		:type entity_id: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
		self._entity_id = cast(Optional[str], kwargs.get("entity_id"))
		self._limit_bytes = cast(int, kwargs.get("limit_bytes"))
		self._period = cast(str, kwargs.get("period"))
		self._bandwidth_limit_type = cast(BandwidthLimitType, kwargs.get("bandwidth_limit_type"))
		self._links = cast(BandwidthLimitLinks, kwargs.get("links"))
	@property
	def id_(self) -> "str":
		"""The unique id of the bandwidth limit. Used for updates and deletes."""
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		"""The unique id of the bandwidth limit. Used for updates and deletes."""
		self._id_ = value
	@property
	def entity_id(self) -> Optional["str"]:
		"""The unique id of the central server or synced table pair for entity limits. Empty string for global limits."""
		return self._entity_id
	@entity_id.setter
	def entity_id(self, value: Optional["str"]) -> None:
		"""The unique id of the central server or synced table pair for entity limits. Empty string for global limits."""
		self._entity_id = value
	@property
	def limit_bytes(self) -> "int":
		"""The target number of bytes to send or receive in the defined Period."""
		return self._limit_bytes
	@limit_bytes.setter
	def limit_bytes(self, value: "int") -> None:
		"""The target number of bytes to send or receive in the defined Period."""
		self._limit_bytes = value
	@property
	def period(self) -> "str":
		"""The amount of time that the bandwidth limit applies to.  Specified in HH:MM:SS or DD.HH:MM:SS formats"""
		return self._period
	@period.setter
	def period(self, value: "str") -> None:
		"""The amount of time that the bandwidth limit applies to.  Specified in HH:MM:SS or DD.HH:MM:SS formats"""
		self._period = value
	@property
	def bandwidth_limit_type(self) -> "BandwidthLimitType":
		"""Defines how the bandwidth limit is applied. Options are 'Additional' or 'Exception'"""
		return self._bandwidth_limit_type
	@bandwidth_limit_type.setter
	def bandwidth_limit_type(self, value: "BandwidthLimitType") -> None:
		"""Defines how the bandwidth limit is applied. Options are 'Additional' or 'Exception'"""
		self._bandwidth_limit_type = value
	@property
	def links(self) -> "BandwidthLimitLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "BandwidthLimitLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class BandwidthLimitLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"bandwidth_limit": ("bandwidthLimit", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		bandwidth_limit: "Link",
		self_: "Link",
	) -> None:
		"""
		:param bandwidth_limit: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type bandwidth_limit: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._bandwidth_limit = cast(Link, kwargs.get("bandwidth_limit"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def bandwidth_limit(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._bandwidth_limit
	@bandwidth_limit.setter
	def bandwidth_limit(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._bandwidth_limit = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value


class BandwidthLimitType(str, Enum):
	# pylint: disable=missing-class-docstring
	ADDITIONAL = 'Additional'
	EXCEPTION = 'Exception'

class BasemapTheme:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"links": ("_links", "BasemapThemeLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		links: "BasemapThemeLinks",
	) -> None:
		"""
		:param name: The name of the theme
		:type name: str
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: BasemapThemeLinks
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._links = cast(BasemapThemeLinks, kwargs.get("links"))
	@property
	def name(self) -> "str":
		"""The name of the theme"""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The name of the theme"""
		self._name = value
	@property
	def links(self) -> "BasemapThemeLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "BasemapThemeLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class BasemapThemeAvailableVersions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"theme_list": ("themeList", "Link", None),
		"versions": ("versions", "list", "BasemapVersionLink"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		theme_list: "Link",
		versions: "List[BasemapVersionLink]",
	) -> None:
		"""
		:param name:
		:type name: str
		:param theme_list: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type theme_list: Link
		:param versions:
		:type versions: List[BasemapVersionLink]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._theme_list = cast(Link, kwargs.get("theme_list"))
		self._versions = cast(List[BasemapVersionLink], kwargs.get("versions"))
	@property
	def name(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def theme_list(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._theme_list
	@theme_list.setter
	def theme_list(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._theme_list = value
	@property
	def versions(self) -> "List[BasemapVersionLink]":
		# pylint: disable=missing-function-docstring
		return self._versions
	@versions.setter
	def versions(self, value: "List[BasemapVersionLink]") -> None:
		# pylint: disable=missing-function-docstring
		self._versions = value
class BasemapThemeDetail:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"theme": ("theme", "IMapLargeBaseMapTheme", None),
		"links": ("_links", "BasemapThemeDetailLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		theme: "IMapLargeBaseMapTheme",
		links: "BasemapThemeDetailLinks",
	) -> None:
		"""
		:param theme:
		:type theme: IMapLargeBaseMapTheme
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: BasemapThemeDetailLinks
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._theme = cast(IMapLargeBaseMapTheme, kwargs.get("theme"))
		self._links = cast(BasemapThemeDetailLinks, kwargs.get("links"))
	@property
	def theme(self) -> "IMapLargeBaseMapTheme":
		# pylint: disable=missing-function-docstring
		return self._theme
	@theme.setter
	def theme(self, value: "IMapLargeBaseMapTheme") -> None:
		# pylint: disable=missing-function-docstring
		self._theme = value
	@property
	def links(self) -> "BasemapThemeDetailLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "BasemapThemeDetailLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class BasemapThemeDetailLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"theme": ("theme", "Link", None),
		"samples": ("samples", "list", "Link"),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		theme: "Link",
		samples: "List[Link]",
		self_: "Link",
	) -> None:
		"""
		:param theme: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type theme: Link
		:param samples:
		:type samples: List[Link]
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._theme = cast(Link, kwargs.get("theme"))
		self._samples = cast(List[Link], kwargs.get("samples"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def theme(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._theme
	@theme.setter
	def theme(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._theme = value
	@property
	def samples(self) -> "List[Link]":
		# pylint: disable=missing-function-docstring
		return self._samples
	@samples.setter
	def samples(self, value: "List[Link]") -> None:
		# pylint: disable=missing-function-docstring
		self._samples = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class BasemapThemeLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class BasemapVersionLink:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"version": ("version", "str", None),
		"link": ("link", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		version: "str",
		link: "Link",
	) -> None:
		"""
		:param version:
		:type version: str
		:param link: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type link: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._version = cast(str, kwargs.get("version"))
		self._link = cast(Link, kwargs.get("link"))
	@property
	def version(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._version
	@version.setter
	def version(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._version = value
	@property
	def link(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._link
	@link.setter
	def link(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._link = value


class BlendMode(str, Enum):
	# pylint: disable=missing-class-docstring
	CLEAR = 'Clear'
	SRC = 'Src'
	DST = 'Dst'
	SRC_OVER = 'SrcOver'
	DST_OVER = 'DstOver'
	SRC_IN = 'SrcIn'
	DST_IN = 'DstIn'
	SRC_OUT = 'SrcOut'
	DST_OUT = 'DstOut'
	SRC_ATOP = 'SrcATop'
	DST_ATOP = 'DstATop'
	XOR = 'Xor'
	PLUS = 'Plus'
	MODULATE = 'Modulate'
	SCREEN = 'Screen'
	OVERLAY = 'Overlay'
	DARKEN = 'Darken'
	LIGHTEN = 'Lighten'
	COLOR_DODGE = 'ColorDodge'
	COLOR_BURN = 'ColorBurn'
	HARD_LIGHT = 'HardLight'
	SOFT_LIGHT = 'SoftLight'
	DIFFERENCE = 'Difference'
	EXCLUSION = 'Exclusion'
	MULTIPLY = 'Multiply'
	HUE = 'Hue'
	SATURATION = 'Saturation'
	COLOR = 'Color'
	LUMINOSITY = 'Luminosity'



class BlurStyle(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	INNER = 'Inner'
	OUTER = 'Outer'
	NORMAL = 'Normal'
	SOLID = 'Solid'

class BorderBaseMapTheme:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"color": ("color", "str", None),
		"size": ("size", "int", None),
		"showmaritime": ("showmaritime", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		size: "int",
		showmaritime: "bool",
		color: Optional["str"] = None,
	) -> None:
		"""
		:param size:
		:type size: int
		:param showmaritime:
		:type showmaritime: bool
		:param color:
		:type color: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._color = cast(Optional[str], kwargs.get("color"))
		self._size = cast(int, kwargs.get("size"))
		self._showmaritime = cast(bool, kwargs.get("showmaritime"))
	@property
	def color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._color = value
	@property
	def size(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._size
	@size.setter
	def size(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._size = value
	@property
	def showmaritime(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._showmaritime
	@showmaritime.setter
	def showmaritime(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._showmaritime = value


class BorderClipping(str, Enum):
	"""Polygon property"""
	NONE = 'None'
	INSIDE = 'Inside'
	OUTSIDE = 'Outside'

class BuildingBaseMapTheme:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"buildings": ("buildings", "BuildingStyleDescriptor", None),
		"footprints_labels": ("footprintsLabels", "BuildingStyleDescriptor", None),
		"footprints": ("footprints", "dict", "FootprintsCollection"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		buildings: "BuildingStyleDescriptor",
		footprints_labels: "BuildingStyleDescriptor",
		footprints: "Dict[str, FootprintsCollection]",
	) -> None:
		"""
		:param buildings:
		:type buildings: BuildingStyleDescriptor
		:param footprints_labels:
		:type footprints_labels: BuildingStyleDescriptor
		:param footprints:
		:type footprints: Dict[str, FootprintsCollection]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._buildings = cast(BuildingStyleDescriptor, kwargs.get("buildings"))
		self._footprints_labels = cast(BuildingStyleDescriptor, kwargs.get("footprints_labels"))
		self._footprints = cast(Dict[str, FootprintsCollection], kwargs.get("footprints"))
	@property
	def buildings(self) -> "BuildingStyleDescriptor":
		# pylint: disable=missing-function-docstring
		return self._buildings
	@buildings.setter
	def buildings(self, value: "BuildingStyleDescriptor") -> None:
		# pylint: disable=missing-function-docstring
		self._buildings = value
	@property
	def footprints_labels(self) -> "BuildingStyleDescriptor":
		# pylint: disable=missing-function-docstring
		return self._footprints_labels
	@footprints_labels.setter
	def footprints_labels(self, value: "BuildingStyleDescriptor") -> None:
		# pylint: disable=missing-function-docstring
		self._footprints_labels = value
	@property
	def footprints(self) -> "Dict[str, FootprintsCollection]":
		# pylint: disable=missing-function-docstring
		return self._footprints
	@footprints.setter
	def footprints(self, value: "Dict[str, FootprintsCollection]") -> None:
		# pylint: disable=missing-function-docstring
		self._footprints = value
class BuildingStyleDescriptor:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"color": ("color", "str", None),
		"border": ("border", "str", None),
		"label_show": ("labelShow", "bool", None),
		"show": ("show", "bool", None),
		"label_color": ("labelColor", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		label_show: "bool",
		show: "bool",
		color: Optional["str"] = None,
		border: Optional["str"] = None,
		label_color: Optional["str"] = None,
	) -> None:
		"""
		:param label_show:
		:type label_show: bool
		:param show:
		:type show: bool
		:param color:
		:type color: str or None
		:param border:
		:type border: str or None
		:param label_color:
		:type label_color: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._color = cast(Optional[str], kwargs.get("color"))
		self._border = cast(Optional[str], kwargs.get("border"))
		self._label_show = cast(bool, kwargs.get("label_show"))
		self._show = cast(bool, kwargs.get("show"))
		self._label_color = cast(Optional[str], kwargs.get("label_color"))
	@property
	def color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._color = value
	@property
	def border(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._border
	@border.setter
	def border(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._border = value
	@property
	def label_show(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._label_show
	@label_show.setter
	def label_show(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._label_show = value
	@property
	def show(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._show
	@show.setter
	def show(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._show = value
	@property
	def label_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._label_color
	@label_color.setter
	def label_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._label_color = value
class CatalogDetails:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"links": ("links", "CatalogLinks", None),
		"bounding_box": ("boundingBox", "OgcBoundingBox", None),
		"crs": ("crs", "str", None),
		"dimensions": ("dimensions", "list", "DimensionalData"),
		"feature_attributes": ("featureAttributes", "list", "OgcAttribute"),
		"column_mapping": ("columnMapping", "list", "OgcColumnPair"),
		"entry": ("entry", "EntryReference", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		links: "CatalogLinks",
		bounding_box: "OgcBoundingBox",
		dimensions: "List[DimensionalData]",
		feature_attributes: "List[OgcAttribute]",
		column_mapping: "List[OgcColumnPair]",
		entry: "EntryReference",
		crs: Optional["str"] = None,
	) -> None:
		"""
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: CatalogLinks
		:param bounding_box: Data bounds
		:type bounding_box: OgcBoundingBox
		:param dimensions: Dimension settings
		:type dimensions: List[DimensionalData]
		:param feature_attributes: MapLarge resource column descriptors
		:type feature_attributes: List[OgcAttribute]
		:param column_mapping: Column name mapping
		:type column_mapping: List[OgcColumnPair]
		:param entry: Catalog Entry
		:type entry: EntryReference
		:param crs: Reference system identifier
		:type crs: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._links = cast(CatalogLinks, kwargs.get("links"))
		self._bounding_box = cast(OgcBoundingBox, kwargs.get("bounding_box"))
		self._crs = cast(Optional[str], kwargs.get("crs"))
		self._dimensions = cast(List[DimensionalData], kwargs.get("dimensions"))
		self._feature_attributes = cast(List[OgcAttribute], kwargs.get("feature_attributes"))
		self._column_mapping = cast(List[OgcColumnPair], kwargs.get("column_mapping"))
		self._entry = cast(EntryReference, kwargs.get("entry"))
	@property
	def links(self) -> "CatalogLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "CatalogLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
	@property
	def bounding_box(self) -> "OgcBoundingBox":
		"""Data bounds"""
		return self._bounding_box
	@bounding_box.setter
	def bounding_box(self, value: "OgcBoundingBox") -> None:
		"""Data bounds"""
		self._bounding_box = value
	@property
	def crs(self) -> Optional["str"]:
		"""Reference system identifier"""
		return self._crs
	@crs.setter
	def crs(self, value: Optional["str"]) -> None:
		"""Reference system identifier"""
		self._crs = value
	@property
	def dimensions(self) -> "List[DimensionalData]":
		"""Dimension settings"""
		return self._dimensions
	@dimensions.setter
	def dimensions(self, value: "List[DimensionalData]") -> None:
		"""Dimension settings"""
		self._dimensions = value
	@property
	def feature_attributes(self) -> "List[OgcAttribute]":
		"""MapLarge resource column descriptors"""
		return self._feature_attributes
	@feature_attributes.setter
	def feature_attributes(self, value: "List[OgcAttribute]") -> None:
		"""MapLarge resource column descriptors"""
		self._feature_attributes = value
	@property
	def column_mapping(self) -> "List[OgcColumnPair]":
		"""Column name mapping"""
		return self._column_mapping
	@column_mapping.setter
	def column_mapping(self, value: "List[OgcColumnPair]") -> None:
		"""Column name mapping"""
		self._column_mapping = value
	@property
	def entry(self) -> "EntryReference":
		"""Catalog Entry"""
		return self._entry
	@entry.setter
	def entry(self, value: "EntryReference") -> None:
		"""Catalog Entry"""
		self._entry = value
class CatalogEntry:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"links": ("_links", "CatalogLinks", None),
		"source_type": ("sourceType", "str", None),
		"name": ("name", "str", None),
		"title": ("title", "str", None),
		"id_column": ("idColumn", "str", None),
		"description": ("description", "str", None),
		"group": ("group", "str", None),
		"data_source": ("dataSource", "str", None),
		"strip_filters": ("stripFilters", "bool", None),
		"default_filters": ("defaultFilters", "list", "FilterNode"),
		"effective_date": ("effectiveDate", "datetime", None),
		"active": ("active", "bool", None),
		"time_column": ("timeColumn", "DimensionalData", None),
		"elevation_column": ("elevationColumn", "DimensionalData", None),
		"dimension_settings": ("dimensionSettings", "dict", "DimensionalData"),
		"auto_update": ("autoUpdate", "bool", None),
		"max_stat_age": ("maxStatAge", "str", None),
		"use_column_labels": ("useColumnLabels", "bool", None),
		"published_id": ("publishedId", "str", None),
		"namespace_id": ("namespaceId", "str", None),
		"namespace_name": ("namespaceName", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		links: "CatalogLinks",
		source_type: "str",
		strip_filters: "bool",
		default_filters: "List[FilterNode]",
		active: "bool",
		time_column: "DimensionalData",
		elevation_column: "DimensionalData",
		dimension_settings: "Dict[str, DimensionalData]",
		name: Optional["str"] = None,
		title: Optional["str"] = None,
		id_column: Optional["str"] = None,
		description: Optional["str"] = None,
		group: Optional["str"] = None,
		data_source: Optional["str"] = None,
		effective_date: Optional["datetime"] = None,
		auto_update: Optional["bool"] = None,
		max_stat_age: Optional["str"] = None,
		use_column_labels: Optional["bool"] = None,
		published_id: Optional["str"] = None,
		namespace_id: Optional["str"] = None,
		namespace_name: Optional["str"] = None,
	) -> None:
		"""
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: CatalogLinks
		:param source_type: Type of underlying data
		:type source_type: str
		:param strip_filters: Strips filters from original resource
		:type strip_filters: bool
		:param default_filters: Default filters if none are supplied in the request.  Useful for extremely large datasets
		:type default_filters: List[FilterNode]
		:param active: Active (available in GetCapabilities docs) or inactive (not listed)
		:type active: bool
		:param time_column: Designated time column and setttings; if not set, the default is the first available DateTime column
		:type time_column: DimensionalData
		:param elevation_column: Designated elevation column and settings.
		:type elevation_column: DimensionalData
		:param dimension_settings: User overrides for dimensional columns
		:type dimension_settings: Dict[str, DimensionalData]
		:param name: Published name/identifier
		:type name: str or None
		:param title: Human readable title
		:type title: str or None
		:param id_column: Identifier for the a given column row; if null or blank, the ranking in the table is used
		:type id_column: str or None
		:param description: Abstract describing the data and representation
		:type description: str or None
		:param group: OGC account/namespace for the entry
		:type group: str or None
		:param data_source: MapLarge resource for the underlying data
		:type data_source: str or None
		:param effective_date: Published data
		:type effective_date: datetime or None
		:param auto_update: Indicates whether the OGC layer's definition (PublishedLayer.SavedJsonHash) will automatically update when the underlying data changes (autoUpdate:true), or if the layer is a frozen snapshot of the data(autoUpdate:false). Default is false.
		:type auto_update: bool or None
		:param max_stat_age: The maximum amount that layer statistics, such as bounding box and dimension minimums and maximums, are allowed to be stale.
		:type max_stat_age: str or None
		:param use_column_labels: When set to true, any configured, valid column labels (for that output format) will be substituted for the column name in the results.
		:type use_column_labels: bool or None
		:param published_id: Published name in XmlQualifiedName format ('account:ogcName')
		:type published_id: str or None
		:param namespace_id: Published name in XmlQualifiedName format ('account:ogcName'), with any illegal characters replaced with underscores
		:type namespace_id: str or None
		:param namespace_name: Name portion of the entry, with XML illegal characters replaced
		:type namespace_name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._links = cast(CatalogLinks, kwargs.get("links"))
		self._source_type = cast(str, kwargs.get("source_type"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._title = cast(Optional[str], kwargs.get("title"))
		self._id_column = cast(Optional[str], kwargs.get("id_column"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._group = cast(Optional[str], kwargs.get("group"))
		self._data_source = cast(Optional[str], kwargs.get("data_source"))
		self._strip_filters = cast(bool, kwargs.get("strip_filters"))
		self._default_filters = cast(List[FilterNode], kwargs.get("default_filters"))
		self._effective_date = cast(Optional[datetime], kwargs.get("effective_date"))
		self._active = cast(bool, kwargs.get("active"))
		self._time_column = cast(DimensionalData, kwargs.get("time_column"))
		self._elevation_column = cast(DimensionalData, kwargs.get("elevation_column"))
		self._dimension_settings = cast(Dict[str, DimensionalData], kwargs.get("dimension_settings"))
		self._auto_update = cast(Optional[bool], kwargs.get("auto_update"))
		self._max_stat_age = cast(Optional[str], kwargs.get("max_stat_age"))
		self._use_column_labels = cast(Optional[bool], kwargs.get("use_column_labels"))
		self._published_id = cast(Optional[str], kwargs.get("published_id"))
		self._namespace_id = cast(Optional[str], kwargs.get("namespace_id"))
		self._namespace_name = cast(Optional[str], kwargs.get("namespace_name"))
	@property
	def links(self) -> "CatalogLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "CatalogLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
	@property
	def source_type(self) -> "str":
		"""Type of underlying data"""
		return self._source_type
	@source_type.setter
	def source_type(self, value: "str") -> None:
		"""Type of underlying data"""
		self._source_type = value
	@property
	def name(self) -> Optional["str"]:
		"""Published name/identifier"""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""Published name/identifier"""
		self._name = value
	@property
	def title(self) -> Optional["str"]:
		"""Human readable title"""
		return self._title
	@title.setter
	def title(self, value: Optional["str"]) -> None:
		"""Human readable title"""
		self._title = value
	@property
	def id_column(self) -> Optional["str"]:
		"""Identifier for the a given column row; if null or blank, the ranking in the table is used"""
		return self._id_column
	@id_column.setter
	def id_column(self, value: Optional["str"]) -> None:
		"""Identifier for the a given column row; if null or blank, the ranking in the table is used"""
		self._id_column = value
	@property
	def description(self) -> Optional["str"]:
		"""Abstract describing the data and representation"""
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		"""Abstract describing the data and representation"""
		self._description = value
	@property
	def group(self) -> Optional["str"]:
		"""OGC account/namespace for the entry"""
		return self._group
	@group.setter
	def group(self, value: Optional["str"]) -> None:
		"""OGC account/namespace for the entry"""
		self._group = value
	@property
	def data_source(self) -> Optional["str"]:
		"""MapLarge resource for the underlying data"""
		return self._data_source
	@data_source.setter
	def data_source(self, value: Optional["str"]) -> None:
		"""MapLarge resource for the underlying data"""
		self._data_source = value
	@property
	def strip_filters(self) -> "bool":
		"""Strips filters from original resource"""
		return self._strip_filters
	@strip_filters.setter
	def strip_filters(self, value: "bool") -> None:
		"""Strips filters from original resource"""
		self._strip_filters = value
	@property
	def default_filters(self) -> "List[FilterNode]":
		"""Default filters if none are supplied in the request.  Useful for extremely large datasets"""
		return self._default_filters
	@default_filters.setter
	def default_filters(self, value: "List[FilterNode]") -> None:
		"""Default filters if none are supplied in the request.  Useful for extremely large datasets"""
		self._default_filters = value
	@property
	def effective_date(self) -> Optional["datetime"]:
		"""Published data"""
		return self._effective_date
	@effective_date.setter
	def effective_date(self, value: Optional["datetime"]) -> None:
		"""Published data"""
		self._effective_date = value
	@property
	def active(self) -> "bool":
		"""Active (available in GetCapabilities docs) or inactive (not listed)"""
		return self._active
	@active.setter
	def active(self, value: "bool") -> None:
		"""Active (available in GetCapabilities docs) or inactive (not listed)"""
		self._active = value
	@property
	def time_column(self) -> "DimensionalData":
		"""Designated time column and setttings; if not set, the default is the first available DateTime column"""
		return self._time_column
	@time_column.setter
	def time_column(self, value: "DimensionalData") -> None:
		"""Designated time column and setttings; if not set, the default is the first available DateTime column"""
		self._time_column = value
	@property
	def elevation_column(self) -> "DimensionalData":
		"""Designated elevation column and settings."""
		return self._elevation_column
	@elevation_column.setter
	def elevation_column(self, value: "DimensionalData") -> None:
		"""Designated elevation column and settings."""
		self._elevation_column = value
	@property
	def dimension_settings(self) -> "Dict[str, DimensionalData]":
		"""User overrides for dimensional columns"""
		return self._dimension_settings
	@dimension_settings.setter
	def dimension_settings(self, value: "Dict[str, DimensionalData]") -> None:
		"""User overrides for dimensional columns"""
		self._dimension_settings = value
	@property
	def auto_update(self) -> Optional["bool"]:
		"""Indicates whether the OGC layer's definition (PublishedLayer.SavedJsonHash) will automatically update when the underlying data changes (autoUpdate:true), or if the layer is a frozen snapshot of the data(autoUpdate:false). Default is false."""
		return self._auto_update
	@auto_update.setter
	def auto_update(self, value: Optional["bool"]) -> None:
		"""Indicates whether the OGC layer's definition (PublishedLayer.SavedJsonHash) will automatically update when the underlying data changes (autoUpdate:true), or if the layer is a frozen snapshot of the data(autoUpdate:false). Default is false."""
		self._auto_update = value
	@property
	def max_stat_age(self) -> Optional["str"]:
		"""The maximum amount that layer statistics, such as bounding box and dimension minimums and maximums, are allowed to be stale."""
		return self._max_stat_age
	@max_stat_age.setter
	def max_stat_age(self, value: Optional["str"]) -> None:
		"""The maximum amount that layer statistics, such as bounding box and dimension minimums and maximums, are allowed to be stale."""
		self._max_stat_age = value
	@property
	def use_column_labels(self) -> Optional["bool"]:
		"""When set to true, any configured, valid column labels (for that output format) will be substituted for the column name in the results."""
		return self._use_column_labels
	@use_column_labels.setter
	def use_column_labels(self, value: Optional["bool"]) -> None:
		"""When set to true, any configured, valid column labels (for that output format) will be substituted for the column name in the results."""
		self._use_column_labels = value
	@property
	def published_id(self) -> Optional["str"]:
		"""Published name in XmlQualifiedName format ('account:ogcName')"""
		return self._published_id
	@published_id.setter
	def published_id(self, value: Optional["str"]) -> None:
		"""Published name in XmlQualifiedName format ('account:ogcName')"""
		self._published_id = value
	@property
	def namespace_id(self) -> Optional["str"]:
		"""Published name in XmlQualifiedName format ('account:ogcName'), with any illegal characters replaced with underscores"""
		return self._namespace_id
	@namespace_id.setter
	def namespace_id(self, value: Optional["str"]) -> None:
		"""Published name in XmlQualifiedName format ('account:ogcName'), with any illegal characters replaced with underscores"""
		self._namespace_id = value
	@property
	def namespace_name(self) -> Optional["str"]:
		"""Name portion of the entry, with XML illegal characters replaced"""
		return self._namespace_name
	@namespace_name.setter
	def namespace_name(self, value: Optional["str"]) -> None:
		"""Name portion of the entry, with XML illegal characters replaced"""
		self._namespace_name = value
class CatalogLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"details": ("details", "Link", None),
		"entry": ("entry", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		details: "Link",
		entry: "Link",
		self_: "Link",
	) -> None:
		"""
		:param details: A link to fetch the details of the underlying resource
		:type details: Link
		:param entry: Link to fetch the catalog entry
		:type entry: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._details = cast(Link, kwargs.get("details"))
		self._entry = cast(Link, kwargs.get("entry"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def details(self) -> "Link":
		"""A link to fetch the details of the underlying resource"""
		return self._details
	@details.setter
	def details(self, value: "Link") -> None:
		"""A link to fetch the details of the underlying resource"""
		self._details = value
	@property
	def entry(self) -> "Link":
		"""Link to fetch the catalog entry"""
		return self._entry
	@entry.setter
	def entry(self, value: "Link") -> None:
		"""Link to fetch the catalog entry"""
		self._entry = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class CCFFWriteParameters:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"max_rows_per_chunk": ("maxRowsPerChunk", "int", None),
		"max_chunks_per_page": ("maxChunksPerPage", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		max_rows_per_chunk: "int",
		max_chunks_per_page: "int",
	) -> None:
		"""
		:param max_rows_per_chunk:
		:type max_rows_per_chunk: int
		:param max_chunks_per_page:
		:type max_chunks_per_page: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._max_rows_per_chunk = cast(int, kwargs.get("max_rows_per_chunk"))
		self._max_chunks_per_page = cast(int, kwargs.get("max_chunks_per_page"))
	@property
	def max_rows_per_chunk(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._max_rows_per_chunk
	@max_rows_per_chunk.setter
	def max_rows_per_chunk(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._max_rows_per_chunk = value
	@property
	def max_chunks_per_page(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._max_chunks_per_page
	@max_chunks_per_page.setter
	def max_chunks_per_page(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._max_chunks_per_page = value
class CentralServer:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"name": ("name", "str", None),
		"target_url": ("targetURL", "str", None),
		"auth_provider_type": ("authProviderType", "AuthProviderType", None),
		"auth_url": ("authURL", "str", None),
		"auth_username": ("authUsername", "str", None),
		"owner": ("owner", "UserReference", None),
		"tag_behavior": ("tagBehavior", None, None),
		"links": ("_links", "CentralServerLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
		target_url: "str",
		auth_provider_type: "AuthProviderType",
		auth_username: "str",
		links: "CentralServerLinks",
		name: Optional["str"] = None,
		auth_url: Optional["str"] = None,
		owner: Optional["UserReference"] = None,
		tag_behavior: Optional["Any"] = None,
	) -> None:
		"""
		:param id_:
		:type id_: str
		:param target_url:
		:type target_url: str
		:param auth_provider_type: 
* `Basic` - Standard MapLarge authentication.
		:type auth_provider_type: AuthProviderType
		:param auth_username:
		:type auth_username: str
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: CentralServerLinks
		:param name:
		:type name: str or None
		:param auth_url:
		:type auth_url: str or None
		:param owner:
		:type owner: UserReference or None
		:param tag_behavior:
		:type tag_behavior: Any or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._target_url = cast(str, kwargs.get("target_url"))
		self._auth_provider_type = cast(AuthProviderType, kwargs.get("auth_provider_type"))
		self._auth_url = cast(Optional[str], kwargs.get("auth_url"))
		self._auth_username = cast(str, kwargs.get("auth_username"))
		self._owner = cast(Optional[UserReference], kwargs.get("owner"))
		self._tag_behavior = kwargs.get("tag_behavior")
		self._links = cast(CentralServerLinks, kwargs.get("links"))
	@property
	def id_(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def target_url(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._target_url
	@target_url.setter
	def target_url(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._target_url = value
	@property
	def auth_provider_type(self) -> "AuthProviderType":
		"""
* `Basic` - Standard MapLarge authentication."""
		return self._auth_provider_type
	@auth_provider_type.setter
	def auth_provider_type(self, value: "AuthProviderType") -> None:
		"""
* `Basic` - Standard MapLarge authentication."""
		self._auth_provider_type = value
	@property
	def auth_url(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._auth_url
	@auth_url.setter
	def auth_url(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._auth_url = value
	@property
	def auth_username(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._auth_username
	@auth_username.setter
	def auth_username(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._auth_username = value
	@property
	def owner(self) -> Optional["UserReference"]:
		# pylint: disable=missing-function-docstring
		return self._owner
	@owner.setter
	def owner(self, value: Optional["UserReference"]) -> None:
		# pylint: disable=missing-function-docstring
		self._owner = value
	@property
	def tag_behavior(self) -> Optional["Any"]:
		# pylint: disable=missing-function-docstring
		return self._tag_behavior
	@tag_behavior.setter
	def tag_behavior(self, value: Optional["Any"]) -> None:
		# pylint: disable=missing-function-docstring
		self._tag_behavior = value
	@property
	def links(self) -> "CentralServerLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "CentralServerLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class CentralServerLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"table_pairs": ("tablePairs", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		table_pairs: "Link",
		self_: "Link",
	) -> None:
		"""
		:param table_pairs: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type table_pairs: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._table_pairs = cast(Link, kwargs.get("table_pairs"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def table_pairs(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._table_pairs
	@table_pairs.setter
	def table_pairs(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._table_pairs = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class CentralServerReference:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
	) -> None:
		"""
		:param id_:
		:type id_: str
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
	@property
	def id_(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value


class CentroidMode(str, Enum):
	# pylint: disable=missing-class-docstring
	POI = 'POI'
	BOUNDING_BOX = 'BoundingBox'
	CLASSIC = 'Classic'
	INSCRIBED_CIRCLE = 'InscribedCircle'

CentroidMode.POI.__doc__ = """Pole Of Inaccessiblity"""
CentroidMode.BOUNDING_BOX.__doc__ = """Bounding Box"""
CentroidMode.CLASSIC.__doc__ = """Classic"""
CentroidMode.INSCRIBED_CIRCLE.__doc__ = """Inscribed Circle"""


class ChartType(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	PIE = 'Pie'
	VERTICAL_STACKED = 'VerticalStacked'
	HORIZONTAL_STACKED = 'HorizontalStacked'
	VERTICAL_BAR = 'VerticalBar'
	HORIZONTAL_BAR = 'HorizontalBar'
	LINE = 'Line'
	PYRAMID = 'Pyramid'

class ChatInfo:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"model": ("model", "str", None),
		"stream": ("stream", "bool", None),
		"messages": ("messages", "list", "ChatMessage"),
		"tools": ("tools", "list", "ChatTool"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		model: "str",
		messages: "List[ChatMessage]",
		tools: "List[ChatTool]",
		stream: Optional["bool"] = None,
	) -> None:
		"""
		:param model: Name of the LLM to query.
		:type model: str
		:param messages: Optionally send the chat history to the LLM for context.
		:type messages: List[ChatMessage]
		:param tools: Tools that can be used by the LLM.
		:type tools: List[ChatTool]
		:param stream: True to stream the response. Defaults to true. When streaming the response the server will return JSON lines formatted output (see: https://jsonlines.org/). If not streaming a standard JSON object will be returned.
		:type stream: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._model = cast(str, kwargs.get("model"))
		self._stream = cast(Optional[bool], kwargs.get("stream"))
		self._messages = cast(List[ChatMessage], kwargs.get("messages"))
		self._tools = cast(List[ChatTool], kwargs.get("tools"))
	@property
	def model(self) -> "str":
		"""Name of the LLM to query."""
		return self._model
	@model.setter
	def model(self, value: "str") -> None:
		"""Name of the LLM to query."""
		self._model = value
	@property
	def stream(self) -> Optional["bool"]:
		"""True to stream the response. Defaults to true. When streaming the response the server will return JSON lines formatted output (see: https://jsonlines.org/). If not streaming a standard JSON object will be returned."""
		return self._stream
	@stream.setter
	def stream(self, value: Optional["bool"]) -> None:
		"""True to stream the response. Defaults to true. When streaming the response the server will return JSON lines formatted output (see: https://jsonlines.org/). If not streaming a standard JSON object will be returned."""
		self._stream = value
	@property
	def messages(self) -> "List[ChatMessage]":
		"""Optionally send the chat history to the LLM for context."""
		return self._messages
	@messages.setter
	def messages(self, value: "List[ChatMessage]") -> None:
		"""Optionally send the chat history to the LLM for context."""
		self._messages = value
	@property
	def tools(self) -> "List[ChatTool]":
		"""Tools that can be used by the LLM."""
		return self._tools
	@tools.setter
	def tools(self, value: "List[ChatTool]") -> None:
		"""Tools that can be used by the LLM."""
		self._tools = value
class ChatMessage:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"role": ("role", "str", None),
		"content": ("content", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		role: "str",
		content: "str",
	) -> None:
		"""
		:param role: Who sent the message. Typically it's 'user' or 'assistant'.
		:type role: str
		:param content: The text of the message.
		:type content: str
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._role = cast(str, kwargs.get("role"))
		self._content = cast(str, kwargs.get("content"))
	@property
	def role(self) -> "str":
		"""Who sent the message. Typically it's 'user' or 'assistant'."""
		return self._role
	@role.setter
	def role(self, value: "str") -> None:
		"""Who sent the message. Typically it's 'user' or 'assistant'."""
		self._role = value
	@property
	def content(self) -> "str":
		"""The text of the message."""
		return self._content
	@content.setter
	def content(self, value: "str") -> None:
		"""The text of the message."""
		self._content = value
class ChatRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"chat_info": ("chatInfo", "ChatInfo", None),
		"workload_id": ("workloadId", "str", None),
		"workload_name": ("workloadName", "str", None),
		"port": ("port", "int", None),
		"use_https": ("useHttps", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		chat_info: "ChatInfo",
		workload_id: Optional["str"] = None,
		workload_name: Optional["str"] = None,
		port: Optional["int"] = None,
		use_https: Optional["bool"] = None,
	) -> None:
		"""
		:param chat_info: The chat information to send to the workload's chat service.
		:type chat_info: ChatInfo
		:param workload_id: Id of the workload with the LLM to query. Either this or workloadName are required.
		:type workload_id: str or None
		:param workload_name: Name of the workload with the LLM to query. Either this or workloadId are required.
		:type workload_name: str or None
		:param port: Port on the workload exposing the chat service. A default port will be searched for if not provided.
		:type port: int or None
		:param use_https: True to use HTTPS when connecting to the chat service. Defaults to false/HTTP.
		:type use_https: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._chat_info = cast(ChatInfo, kwargs.get("chat_info"))
		self._workload_id = cast(Optional[str], kwargs.get("workload_id"))
		self._workload_name = cast(Optional[str], kwargs.get("workload_name"))
		self._port = cast(Optional[int], kwargs.get("port"))
		self._use_https = cast(Optional[bool], kwargs.get("use_https"))
	@property
	def chat_info(self) -> "ChatInfo":
		"""The chat information to send to the workload's chat service."""
		return self._chat_info
	@chat_info.setter
	def chat_info(self, value: "ChatInfo") -> None:
		"""The chat information to send to the workload's chat service."""
		self._chat_info = value
	@property
	def workload_id(self) -> Optional["str"]:
		"""Id of the workload with the LLM to query. Either this or workloadName are required."""
		return self._workload_id
	@workload_id.setter
	def workload_id(self, value: Optional["str"]) -> None:
		"""Id of the workload with the LLM to query. Either this or workloadName are required."""
		self._workload_id = value
	@property
	def workload_name(self) -> Optional["str"]:
		"""Name of the workload with the LLM to query. Either this or workloadId are required."""
		return self._workload_name
	@workload_name.setter
	def workload_name(self, value: Optional["str"]) -> None:
		"""Name of the workload with the LLM to query. Either this or workloadId are required."""
		self._workload_name = value
	@property
	def port(self) -> Optional["int"]:
		"""Port on the workload exposing the chat service. A default port will be searched for if not provided."""
		return self._port
	@port.setter
	def port(self, value: Optional["int"]) -> None:
		"""Port on the workload exposing the chat service. A default port will be searched for if not provided."""
		self._port = value
	@property
	def use_https(self) -> Optional["bool"]:
		"""True to use HTTPS when connecting to the chat service. Defaults to false/HTTP."""
		return self._use_https
	@use_https.setter
	def use_https(self, value: Optional["bool"]) -> None:
		"""True to use HTTPS when connecting to the chat service. Defaults to false/HTTP."""
		self._use_https = value
class ChatTool:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"type_": ("type", "str", None),
		"function": ("function", "ChatToolFunction", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		function: "ChatToolFunction",
		type_: Optional["str"] = None,
	) -> None:
		"""
		:param function:
		:type function: ChatToolFunction
		:param type_:
		:type type_: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._function = cast(ChatToolFunction, kwargs.get("function"))
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def function(self) -> "ChatToolFunction":
		# pylint: disable=missing-function-docstring
		return self._function
	@function.setter
	def function(self, value: "ChatToolFunction") -> None:
		# pylint: disable=missing-function-docstring
		self._function = value
class ChatToolFunction:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"description": ("description", "str", None),
		"parameters": ("parameters", "ChatToolParameters", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		parameters: "ChatToolParameters",
		description: Optional["str"] = None,
	) -> None:
		"""
		:param name: Name of the tool.
		:type name: str
		:param parameters: Parameters needed for the tool to be used.
		:type parameters: ChatToolParameters
		:param description: What, how, and why the tool is supposed to be used.
		:type description: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._parameters = cast(ChatToolParameters, kwargs.get("parameters"))
	@property
	def name(self) -> "str":
		"""Name of the tool."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""Name of the tool."""
		self._name = value
	@property
	def description(self) -> Optional["str"]:
		"""What, how, and why the tool is supposed to be used."""
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		"""What, how, and why the tool is supposed to be used."""
		self._description = value
	@property
	def parameters(self) -> "ChatToolParameters":
		"""Parameters needed for the tool to be used."""
		return self._parameters
	@parameters.setter
	def parameters(self, value: "ChatToolParameters") -> None:
		"""Parameters needed for the tool to be used."""
		self._parameters = value
class ChatToolParameters:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"type_": ("type", "str", None),
		"description": ("description", "str", None),
		"properties": ("properties", "dict", "ChatToolParameters"),
		"required": ("required", "list", "str"),
		"additional_properties": ("additionalProperties", "bool", None),
		"enum": ("enum", "list", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		properties: "Dict[str, ChatToolParameters]",
		required: "List[str]",
		enum: "List[Any]",
		type_: Optional["str"] = None,
		description: Optional["str"] = None,
		additional_properties: Optional["bool"] = None,
	) -> None:
		"""
		:param properties:
		:type properties: Dict[str, ChatToolParameters]
		:param required:
		:type required: List[str]
		:param enum:
		:type enum: List[Any]
		:param type_:
		:type type_: str or None
		:param description:
		:type description: str or None
		:param additional_properties:
		:type additional_properties: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._properties = cast(Dict[str, ChatToolParameters], kwargs.get("properties"))
		self._required = cast(List[str], kwargs.get("required"))
		self._additional_properties = cast(Optional[bool], kwargs.get("additional_properties"))
		self._enum = cast(List[Any], kwargs.get("enum"))
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def description(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._description = value
	@property
	def properties(self) -> "Dict[str, ChatToolParameters]":
		# pylint: disable=missing-function-docstring
		return self._properties
	@properties.setter
	def properties(self, value: "Dict[str, ChatToolParameters]") -> None:
		# pylint: disable=missing-function-docstring
		self._properties = value
	@property
	def required(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._required
	@required.setter
	def required(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._required = value
	@property
	def additional_properties(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._additional_properties
	@additional_properties.setter
	def additional_properties(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._additional_properties = value
	@property
	def enum(self) -> "List[Any]":
		# pylint: disable=missing-function-docstring
		return self._enum
	@enum.setter
	def enum(self, value: "List[Any]") -> None:
		# pylint: disable=missing-function-docstring
		self._enum = value


class CheckFilesExistMode(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	ALL = 'All'
	ANY = 'Any'



class ClusterCentroid(str, Enum):
	# pylint: disable=missing-class-docstring
	CENTROID = 'centroid'
	CENTER = 'center'
	LOCATION = 'location'
	WEIGHTED = 'weighted'

class ClusterOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"timeout": ("timeout", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		timeout: "int",
	) -> None:
		"""
		:param timeout: Number of seconds after which the operation will timeout and be cancelled.
		:type timeout: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._timeout = cast(int, kwargs.get("timeout"))
	@property
	def timeout(self) -> "int":
		"""Number of seconds after which the operation will timeout and be cancelled."""
		return self._timeout
	@timeout.setter
	def timeout(self, value: "int") -> None:
		"""Number of seconds after which the operation will timeout and be cancelled."""
		self._timeout = value
class ClusterWaiters:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"global_waiter_transaction_count": ("globalWaiterTransactionCount", "int", None),
		"local_waiter_transaction_count": ("localWaiterTransactionCount", "int", None),
		"is_waiting_for_promotion": ("isWaitingForPromotion", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		global_waiter_transaction_count: "int",
		local_waiter_transaction_count: "int",
		is_waiting_for_promotion: "bool",
	) -> None:
		"""
		:param global_waiter_transaction_count: The number of database write transactions that are not fully applied
		:type global_waiter_transaction_count: int
		:param local_waiter_transaction_count: The number of database read requests that are waiting on a transaction to complete
		:type local_waiter_transaction_count: int
		:param is_waiting_for_promotion: If true this membership seeking node is not a voting member because it has not caught up with the transaction log
		:type is_waiting_for_promotion: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._global_waiter_transaction_count = cast(int, kwargs.get("global_waiter_transaction_count"))
		self._local_waiter_transaction_count = cast(int, kwargs.get("local_waiter_transaction_count"))
		self._is_waiting_for_promotion = cast(bool, kwargs.get("is_waiting_for_promotion"))
	@property
	def global_waiter_transaction_count(self) -> "int":
		"""The number of database write transactions that are not fully applied"""
		return self._global_waiter_transaction_count
	@global_waiter_transaction_count.setter
	def global_waiter_transaction_count(self, value: "int") -> None:
		"""The number of database write transactions that are not fully applied"""
		self._global_waiter_transaction_count = value
	@property
	def local_waiter_transaction_count(self) -> "int":
		"""The number of database read requests that are waiting on a transaction to complete"""
		return self._local_waiter_transaction_count
	@local_waiter_transaction_count.setter
	def local_waiter_transaction_count(self, value: "int") -> None:
		"""The number of database read requests that are waiting on a transaction to complete"""
		self._local_waiter_transaction_count = value
	@property
	def is_waiting_for_promotion(self) -> "bool":
		"""If true this membership seeking node is not a voting member because it has not caught up with the transaction log"""
		return self._is_waiting_for_promotion
	@is_waiting_for_promotion.setter
	def is_waiting_for_promotion(self, value: "bool") -> None:
		"""If true this membership seeking node is not a voting member because it has not caught up with the transaction log"""
		self._is_waiting_for_promotion = value
class CodeIssue:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"line": ("line", "int", None),
		"column": ("column", "int", None),
		"path": ("path", "str", None),
		"type_": ("type", "str", None),
		"message": ("message", "str", None),
		"extended_message": ("extendedMessage", "str", None),
		"severity": ("severity", "CodeIssueSeverity", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		severity: "CodeIssueSeverity",
		line: Optional["int"] = None,
		column: Optional["int"] = None,
		path: Optional["str"] = None,
		type_: Optional["str"] = None,
		message: Optional["str"] = None,
		extended_message: Optional["str"] = None,
	) -> None:
		"""
		:param severity:
		:type severity: CodeIssueSeverity
		:param line: The zero-based line number where the issue occurs.
		:type line: int or None
		:param column: The zero-based column number where the issue occurs.
		:type column: int or None
		:param path:
		:type path: str or None
		:param type_:
		:type type_: str or None
		:param message:
		:type message: str or None
		:param extended_message:
		:type extended_message: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._line = cast(Optional[int], kwargs.get("line"))
		self._column = cast(Optional[int], kwargs.get("column"))
		self._path = cast(Optional[str], kwargs.get("path"))
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._message = cast(Optional[str], kwargs.get("message"))
		self._extended_message = cast(Optional[str], kwargs.get("extended_message"))
		self._severity = cast(CodeIssueSeverity, kwargs.get("severity"))
	@property
	def line(self) -> Optional["int"]:
		"""The zero-based line number where the issue occurs."""
		return self._line
	@line.setter
	def line(self, value: Optional["int"]) -> None:
		"""The zero-based line number where the issue occurs."""
		self._line = value
	@property
	def column(self) -> Optional["int"]:
		"""The zero-based column number where the issue occurs."""
		return self._column
	@column.setter
	def column(self, value: Optional["int"]) -> None:
		"""The zero-based column number where the issue occurs."""
		self._column = value
	@property
	def path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._path
	@path.setter
	def path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path = value
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def message(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._message
	@message.setter
	def message(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._message = value
	@property
	def extended_message(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._extended_message
	@extended_message.setter
	def extended_message(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._extended_message = value
	@property
	def severity(self) -> "CodeIssueSeverity":
		# pylint: disable=missing-function-docstring
		return self._severity
	@severity.setter
	def severity(self, value: "CodeIssueSeverity") -> None:
		# pylint: disable=missing-function-docstring
		self._severity = value


class CodeIssueSeverity(str, Enum):
	# pylint: disable=missing-class-docstring
	ERROR = 'error'
	WARNING = 'warning'

class ColorRange:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"min_": ("min", "str", None),
		"max_": ("max", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		min_: "str",
		max_: "str",
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param min_: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type min_: str
		:param max_: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type max_: str
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._min_ = cast(str, kwargs.get("min_"))
		self._max_ = cast(str, kwargs.get("max_"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def min_(self) -> "str":
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._min_
	@min_.setter
	def min_(self, value: "str") -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._min_ = value
	@property
	def max_(self) -> "str":
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._max_
	@max_.setter
	def max_(self, value: "str") -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._max_ = value
class Column:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"name": ("name", "str", None),
		"type_": ("type", "ColumnType", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
		name: "str",
		type_: "ColumnType",
	) -> None:
		"""
		:param id_: The column Id, formatted like "{accountCode}/{tableName}/{tableVersion}/{columnName}".
		:type id_: str
		:param name: The name of the column.
		:type name: str
		:param type_: The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data.
		:type type_: ColumnType
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
		self._name = cast(str, kwargs.get("name"))
		self._type_ = cast(ColumnType, kwargs.get("type_"))
	@property
	def id_(self) -> "str":
		"""The column Id, formatted like "{accountCode}/{tableName}/{tableVersion}/{columnName}"."""
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		"""The column Id, formatted like "{accountCode}/{tableName}/{tableVersion}/{columnName}"."""
		self._id_ = value
	@property
	def name(self) -> "str":
		"""The name of the column."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The name of the column."""
		self._name = value
	@property
	def type_(self) -> "ColumnType":
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		return self._type_
	@type_.setter
	def type_(self, value: "ColumnType") -> None:
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		self._type_ = value
class ColumnAttributeDescription:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"type_": ("type", "str", None),
		"value": ("value", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: Optional["str"] = None,
		type_: Optional["str"] = None,
		value: Optional["str"] = None,
	) -> None:
		"""
		:param name:
		:type name: str or None
		:param type_:
		:type type_: str or None
		:param value:
		:type value: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._value = cast(Optional[str], kwargs.get("value"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def value(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._value
	@value.setter
	def value(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._value = value
class ColumnHint:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"input_field_name": ("inputFieldName", "str", None),
		"output_fieldname": ("outputFieldname", "str", None),
		"output_type": ("outputType", "ColumnType", None),
		"original_type": ("originalType", "ColumnType", None),
		"possible_types": ("possibleTypes", "list", "ColumnTypeAnalysis"),
		"designated": ("designated", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		output_type: "ColumnType",
		original_type: "ColumnType",
		possible_types: "List[ColumnTypeAnalysis]",
		designated: "bool",
		input_field_name: Optional["str"] = None,
		output_fieldname: Optional["str"] = None,
	) -> None:
		"""
		:param output_type: The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data.
		:type output_type: ColumnType
		:param original_type: The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data.
		:type original_type: ColumnType
		:param possible_types:
		:type possible_types: List[ColumnTypeAnalysis]
		:param designated:
		:type designated: bool
		:param input_field_name:
		:type input_field_name: str or None
		:param output_fieldname:
		:type output_fieldname: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._input_field_name = cast(Optional[str], kwargs.get("input_field_name"))
		self._output_fieldname = cast(Optional[str], kwargs.get("output_fieldname"))
		self._output_type = cast(ColumnType, kwargs.get("output_type"))
		self._original_type = cast(ColumnType, kwargs.get("original_type"))
		self._possible_types = cast(List[ColumnTypeAnalysis], kwargs.get("possible_types"))
		self._designated = cast(bool, kwargs.get("designated"))
	@property
	def input_field_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._input_field_name
	@input_field_name.setter
	def input_field_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._input_field_name = value
	@property
	def output_fieldname(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._output_fieldname
	@output_fieldname.setter
	def output_fieldname(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._output_fieldname = value
	@property
	def output_type(self) -> "ColumnType":
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		return self._output_type
	@output_type.setter
	def output_type(self, value: "ColumnType") -> None:
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		self._output_type = value
	@property
	def original_type(self) -> "ColumnType":
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		return self._original_type
	@original_type.setter
	def original_type(self, value: "ColumnType") -> None:
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		self._original_type = value
	@property
	def possible_types(self) -> "List[ColumnTypeAnalysis]":
		# pylint: disable=missing-function-docstring
		return self._possible_types
	@possible_types.setter
	def possible_types(self, value: "List[ColumnTypeAnalysis]") -> None:
		# pylint: disable=missing-function-docstring
		self._possible_types = value
	@property
	def designated(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._designated
	@designated.setter
	def designated(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._designated = value
class ColumnMetaDataTag:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"label": ("label", "str", None),
		"sort_order": ("sortOrder", "int", None),
		"sortable": ("sortable", "bool", None),
		"hidden": ("hidden", "bool", None),
		"tags": ("tags", "list", "str"),
		"related_to": ("relatedTo", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		tags: "List[str]",
		label: Optional["str"] = None,
		sort_order: Optional["int"] = None,
		sortable: Optional["bool"] = None,
		hidden: Optional["bool"] = None,
		related_to: Optional["str"] = None,
	) -> None:
		"""
		:param tags:
		:type tags: List[str]
		:param label:
		:type label: str or None
		:param sort_order:
		:type sort_order: int or None
		:param sortable:
		:type sortable: bool or None
		:param hidden:
		:type hidden: bool or None
		:param related_to:
		:type related_to: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._label = cast(Optional[str], kwargs.get("label"))
		self._sort_order = cast(Optional[int], kwargs.get("sort_order"))
		self._sortable = cast(Optional[bool], kwargs.get("sortable"))
		self._hidden = cast(Optional[bool], kwargs.get("hidden"))
		self._tags = cast(List[str], kwargs.get("tags"))
		self._related_to = cast(Optional[str], kwargs.get("related_to"))
	@property
	def label(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._label
	@label.setter
	def label(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._label = value
	@property
	def sort_order(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._sort_order
	@sort_order.setter
	def sort_order(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._sort_order = value
	@property
	def sortable(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._sortable
	@sortable.setter
	def sortable(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._sortable = value
	@property
	def hidden(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._hidden
	@hidden.setter
	def hidden(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._hidden = value
	@property
	def tags(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._tags
	@tags.setter
	def tags(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._tags = value
	@property
	def related_to(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._related_to
	@related_to.setter
	def related_to(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._related_to = value
class ColumnNameValuePair:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("Name", "str", None),
		"value": ("Value", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: Optional["str"] = None,
		value: Optional["str"] = None,
	) -> None:
		"""
		:param name:
		:type name: str or None
		:param value:
		:type value: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._value = cast(Optional[str], kwargs.get("value"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def value(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._value
	@value.setter
	def value(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._value = value
class ColumnStatOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"requested_buckets": ("requestedBuckets", "int", None),
		"max_unique": ("maxUnique", "int", None),
		"target_max_empty_bucket_ratio": ("targetMaxEmptyBucketRatio", "float", None),
		"outlier_zscore": ("outlierZScore", "float", None),
		"projection": ("projection", "ProjectionMode", None),
		"specific_columns": ("specificColumns", "list", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		requested_buckets: "int",
		max_unique: "int",
		target_max_empty_bucket_ratio: "float",
		outlier_zscore: "float",
		projection: "ProjectionMode",
		specific_columns: "List[str]",
	) -> None:
		"""
		:param requested_buckets:
		:type requested_buckets: int
		:param max_unique:
		:type max_unique: int
		:param target_max_empty_bucket_ratio:
		:type target_max_empty_bucket_ratio: float
		:param outlier_zscore:
		:type outlier_zscore: float
		:param projection: The map projection.
* `mercator` - EPSG:3857
* `wgs84` - EPSG:4326
		:type projection: ProjectionMode
		:param specific_columns:
		:type specific_columns: List[str]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._requested_buckets = cast(int, kwargs.get("requested_buckets"))
		self._max_unique = cast(int, kwargs.get("max_unique"))
		self._target_max_empty_bucket_ratio = cast(float, kwargs.get("target_max_empty_bucket_ratio"))
		self._outlier_zscore = cast(float, kwargs.get("outlier_zscore"))
		self._projection = cast(ProjectionMode, kwargs.get("projection"))
		self._specific_columns = cast(List[str], kwargs.get("specific_columns"))
	@property
	def requested_buckets(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._requested_buckets
	@requested_buckets.setter
	def requested_buckets(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._requested_buckets = value
	@property
	def max_unique(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._max_unique
	@max_unique.setter
	def max_unique(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._max_unique = value
	@property
	def target_max_empty_bucket_ratio(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._target_max_empty_bucket_ratio
	@target_max_empty_bucket_ratio.setter
	def target_max_empty_bucket_ratio(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._target_max_empty_bucket_ratio = value
	@property
	def outlier_zscore(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._outlier_zscore
	@outlier_zscore.setter
	def outlier_zscore(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._outlier_zscore = value
	@property
	def projection(self) -> "ProjectionMode":
		"""The map projection.
* `mercator` - EPSG:3857
* `wgs84` - EPSG:4326"""
		return self._projection
	@projection.setter
	def projection(self, value: "ProjectionMode") -> None:
		"""The map projection.
* `mercator` - EPSG:3857
* `wgs84` - EPSG:4326"""
		self._projection = value
	@property
	def specific_columns(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._specific_columns
	@specific_columns.setter
	def specific_columns(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._specific_columns = value
class ColumnStatOutputs:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"original_count": ("OriginalCount", "int", None),
		"count": ("Count", "int", None),
		"outliers_removed": ("OutliersRemoved", "int", None),
		"mean": ("Mean", "float", None),
		"variance": ("Variance", "float", None),
		"min_": ("Min", "float", None),
		"max_": ("Max", "float", None),
		"bucket_size": ("BucketSize", "float", None),
		"empty_bucket_count": ("EmptyBucketCount", "float", None),
		"empty_bucket_ratio": ("EmptyBucketRatio", "float", None),
		"unique_value_count": ("UniqueValueCount", "int", None),
		"histogram": ("Histogram", "list", "int"),
		"min_x": ("MinX", "float", None),
		"max_x": ("MaxX", "float", None),
		"min_y": ("MinY", "float", None),
		"max_y": ("MaxY", "float", None),
		"max_length": ("MaxLength", "float", None),
		"min_length": ("MinLength", "float", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		histogram: "List[int]",
		original_count: Optional["int"] = None,
		count: Optional["int"] = None,
		outliers_removed: Optional["int"] = None,
		mean: Optional["float"] = None,
		variance: Optional["float"] = None,
		min_: Optional["float"] = None,
		max_: Optional["float"] = None,
		bucket_size: Optional["float"] = None,
		empty_bucket_count: Optional["float"] = None,
		empty_bucket_ratio: Optional["float"] = None,
		unique_value_count: Optional["int"] = None,
		min_x: Optional["float"] = None,
		max_x: Optional["float"] = None,
		min_y: Optional["float"] = None,
		max_y: Optional["float"] = None,
		max_length: Optional["float"] = None,
		min_length: Optional["float"] = None,
	) -> None:
		"""
		:param histogram:
		:type histogram: List[int]
		:param original_count:
		:type original_count: int or None
		:param count:
		:type count: int or None
		:param outliers_removed:
		:type outliers_removed: int or None
		:param mean:
		:type mean: float or None
		:param variance:
		:type variance: float or None
		:param min_:
		:type min_: float or None
		:param max_:
		:type max_: float or None
		:param bucket_size:
		:type bucket_size: float or None
		:param empty_bucket_count:
		:type empty_bucket_count: float or None
		:param empty_bucket_ratio:
		:type empty_bucket_ratio: float or None
		:param unique_value_count:
		:type unique_value_count: int or None
		:param min_x:
		:type min_x: float or None
		:param max_x:
		:type max_x: float or None
		:param min_y:
		:type min_y: float or None
		:param max_y:
		:type max_y: float or None
		:param max_length:
		:type max_length: float or None
		:param min_length:
		:type min_length: float or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._original_count = cast(Optional[int], kwargs.get("original_count"))
		self._count = cast(Optional[int], kwargs.get("count"))
		self._outliers_removed = cast(Optional[int], kwargs.get("outliers_removed"))
		self._mean = cast(Optional[float], kwargs.get("mean"))
		self._variance = cast(Optional[float], kwargs.get("variance"))
		self._min_ = cast(Optional[float], kwargs.get("min_"))
		self._max_ = cast(Optional[float], kwargs.get("max_"))
		self._bucket_size = cast(Optional[float], kwargs.get("bucket_size"))
		self._empty_bucket_count = cast(Optional[float], kwargs.get("empty_bucket_count"))
		self._empty_bucket_ratio = cast(Optional[float], kwargs.get("empty_bucket_ratio"))
		self._unique_value_count = cast(Optional[int], kwargs.get("unique_value_count"))
		self._histogram = cast(List[int], kwargs.get("histogram"))
		self._min_x = cast(Optional[float], kwargs.get("min_x"))
		self._max_x = cast(Optional[float], kwargs.get("max_x"))
		self._min_y = cast(Optional[float], kwargs.get("min_y"))
		self._max_y = cast(Optional[float], kwargs.get("max_y"))
		self._max_length = cast(Optional[float], kwargs.get("max_length"))
		self._min_length = cast(Optional[float], kwargs.get("min_length"))
	@property
	def original_count(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._original_count
	@original_count.setter
	def original_count(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._original_count = value
	@property
	def count(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._count
	@count.setter
	def count(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._count = value
	@property
	def outliers_removed(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._outliers_removed
	@outliers_removed.setter
	def outliers_removed(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._outliers_removed = value
	@property
	def mean(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._mean
	@mean.setter
	def mean(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._mean = value
	@property
	def variance(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._variance
	@variance.setter
	def variance(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._variance = value
	@property
	def min_(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._min_
	@min_.setter
	def min_(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_ = value
	@property
	def max_(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._max_
	@max_.setter
	def max_(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_ = value
	@property
	def bucket_size(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._bucket_size
	@bucket_size.setter
	def bucket_size(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._bucket_size = value
	@property
	def empty_bucket_count(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._empty_bucket_count
	@empty_bucket_count.setter
	def empty_bucket_count(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._empty_bucket_count = value
	@property
	def empty_bucket_ratio(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._empty_bucket_ratio
	@empty_bucket_ratio.setter
	def empty_bucket_ratio(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._empty_bucket_ratio = value
	@property
	def unique_value_count(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._unique_value_count
	@unique_value_count.setter
	def unique_value_count(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._unique_value_count = value
	@property
	def histogram(self) -> "List[int]":
		# pylint: disable=missing-function-docstring
		return self._histogram
	@histogram.setter
	def histogram(self, value: "List[int]") -> None:
		# pylint: disable=missing-function-docstring
		self._histogram = value
	@property
	def min_x(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._min_x
	@min_x.setter
	def min_x(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_x = value
	@property
	def max_x(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._max_x
	@max_x.setter
	def max_x(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_x = value
	@property
	def min_y(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._min_y
	@min_y.setter
	def min_y(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_y = value
	@property
	def max_y(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._max_y
	@max_y.setter
	def max_y(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_y = value
	@property
	def max_length(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._max_length
	@max_length.setter
	def max_length(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_length = value
	@property
	def min_length(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._min_length
	@min_length.setter
	def min_length(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_length = value


class ColumnType(str, Enum):
	"""The type of data contained in the column."""
	NONE = 'None'
	INT_32 = 'Int32'
	INT_64 = 'Int64'
	GUID = 'Guid'
	DOUBLE = 'Double'
	VECTOR = 'Vector'
	JSON = 'Json'
	STRING = 'String'
	MESSAGING_SHARD = 'MessagingShard'
	POLY = 'Poly'
	LINE = 'Line'
	XY = 'XY'
	MULTIPOINT = 'Multipoint'
	DATE_TIME = 'DateTime'
	GRAPH = 'Graph'
	BINARY = 'Binary'
	NERF = 'NERF'
	MEDIA = 'Media'
	MESH = 'Mesh'
	SATELLITE_TLE = 'SatelliteTLE'
	VECTOR_3 = 'Vector3'
	GRAPH_EDGE = 'GraphEdge'
	RECURRENCE = 'Recurrence'
	RASTER = 'Raster'
	IMAGE = 'Image'
	RESOURCE = 'Resource'
	RESOURCE_FOLDER = 'ResourceFolder'
	ROUTING_RULE = 'RoutingRule'
	EXEC_ITEM = 'ExecItem'
	DELETED = 'Deleted'
	DATA_PIPE = 'DataPipe'
	ANY = 'Any'
	DYNAMIC_STRING = 'DynamicString'
	SAVED_JSON = 'SavedJson'
	ALERT = 'Alert'
	TAG_DATA = 'TagData'
	POLICY_FILTER = 'PolicyFilter'
	LOG_ENTRY = 'LogEntry'
	PERSISTENT_JSON = 'PersistentJson'
	WIDGET_DATA = 'WidgetData'
	AUTO_IMPORT = 'AutoImport'
	ACCOUNT = 'Account'
	GROUP = 'Group'
	USER = 'User'
	RECURRING_EXPORT = 'RecurringExport'
	COMMON_COLUMNAR_INDEX = 'CommonColumnarIndex'

ColumnType.NONE.__doc__ = """No data type."""
ColumnType.INT_32.__doc__ = """32 bit signed integer."""
ColumnType.INT_64.__doc__ = """64 bit signed integer."""
ColumnType.GUID.__doc__ = """Globally Unique Identifier"""
ColumnType.DOUBLE.__doc__ = """Floating point number."""
ColumnType.VECTOR.__doc__ = """Floating point number."""
ColumnType.JSON.__doc__ = """Binary Encoded JSON."""
ColumnType.STRING.__doc__ = """Variable length Unicode text."""
ColumnType.MESSAGING_SHARD.__doc__ = """Messaging shard"""
ColumnType.POLY.__doc__ = """Geospatial polygon."""
ColumnType.LINE.__doc__ = """Geospatial line."""
ColumnType.XY.__doc__ = """Geospatial point."""
ColumnType.MULTIPOINT.__doc__ = """Geospatial points."""
ColumnType.DATE_TIME.__doc__ = """Date/time value, with offset relative to UTC."""
ColumnType.GRAPH.__doc__ = """A node in a directed graph."""
ColumnType.BINARY.__doc__ = """An array of bytes."""
ColumnType.RECURRENCE.__doc__ = """Rules describing a date/time recurrence pattern."""
ColumnType.RASTER.__doc__ = """Geospatial raster data."""
class ColumnTypeAnalysis:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"match_type": ("matchType", "str", None),
		"column_type": ("columnType", "ColumnType", None),
		"match_probability": ("matchProbability", "float", None),
		"confidence": ("confidence", "float", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		column_type: "ColumnType",
		match_probability: "float",
		confidence: "float",
		match_type: Optional["str"] = None,
	) -> None:
		"""
		:param column_type: The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data.
		:type column_type: ColumnType
		:param match_probability:
		:type match_probability: float
		:param confidence:
		:type confidence: float
		:param match_type:
		:type match_type: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._match_type = cast(Optional[str], kwargs.get("match_type"))
		self._column_type = cast(ColumnType, kwargs.get("column_type"))
		self._match_probability = cast(float, kwargs.get("match_probability"))
		self._confidence = cast(float, kwargs.get("confidence"))
	@property
	def match_type(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._match_type
	@match_type.setter
	def match_type(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._match_type = value
	@property
	def column_type(self) -> "ColumnType":
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		return self._column_type
	@column_type.setter
	def column_type(self, value: "ColumnType") -> None:
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		self._column_type = value
	@property
	def match_probability(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._match_probability
	@match_probability.setter
	def match_probability(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._match_probability = value
	@property
	def confidence(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._confidence
	@confidence.setter
	def confidence(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._confidence = value


class CompositeBlendMode(str, Enum):
	# pylint: disable=missing-class-docstring
	CLEAR = 'Clear'
	SRC = 'Src'
	DST = 'Dst'
	SRC_OVER = 'SrcOver'
	DST_OVER = 'DstOver'
	SRC_IN = 'SrcIn'
	DST_IN = 'DstIn'
	SRC_OUT = 'SrcOut'
	DST_OUT = 'DstOut'
	SRC_ATOP = 'SrcATop'
	DST_ATOP = 'DstATop'
	XOR = 'Xor'
	PLUS = 'Plus'
	MODULATE = 'Modulate'
	SCREEN = 'Screen'
	OVERLAY = 'Overlay'
	DARKEN = 'Darken'
	LIGHTEN = 'Lighten'
	COLOR_DODGE = 'ColorDodge'
	COLOR_BURN = 'ColorBurn'
	HARD_LIGHT = 'HardLight'
	SOFT_LIGHT = 'SoftLight'
	DIFFERENCE = 'Difference'
	EXCLUSION = 'Exclusion'
	MULTIPLY = 'Multiply'
	HUE = 'Hue'
	SATURATION = 'Saturation'
	COLOR = 'Color'
	LUMINOSITY = 'Luminosity'
	SHOW_CHANGES_LOWER = 'ShowChangesLower'
	SHOW_CHANGES_UPPER = 'ShowChangesUpper'

class ConsensusInfo:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"last_sent_to_state_machine": ("lastSentToStateMachine", "int", None),
		"last_contiguous_applied": ("lastContiguousApplied", "int", None),
		"count_of_out_of_order_persisted_transactions": ("countOfOutOfOrderPersistedTransactions", "int", None),
		"commit_index": ("commitIndex", "int", None),
		"voted_for": ("votedFor", "str", None),
		"snapshot_apply_in_progress": ("snapshotApplyInProgress", "bool", None),
		"snapshot_creation_in_progress": ("snapshotCreationInProgress", "bool", None),
		"transaction_log_length": ("transactionLogLength", "int", None),
		"first_transaction_in_log": ("firstTransactionInLog", "int", None),
		"raft_queue_depth": ("raftQueueDepth", "int", None),
		"time_in_role": ("timeInRole", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		last_sent_to_state_machine: "int",
		last_contiguous_applied: "int",
		count_of_out_of_order_persisted_transactions: "int",
		commit_index: "int",
		snapshot_apply_in_progress: "bool",
		snapshot_creation_in_progress: "bool",
		transaction_log_length: "int",
		first_transaction_in_log: "int",
		raft_queue_depth: "int",
		time_in_role: "str",
		voted_for: Optional["str"] = None,
	) -> None:
		"""
		:param last_sent_to_state_machine: The highest transaction id the consensus algorithm has requested the state machine to apply
		:type last_sent_to_state_machine: int
		:param last_contiguous_applied: The highest transaction id where all prior transactions have been applied (or rejected) by the state machine
		:type last_contiguous_applied: int
		:param count_of_out_of_order_persisted_transactions: The number of transaction id's applied that are higher than LastContiguousApplied
		:type count_of_out_of_order_persisted_transactions: int
		:param commit_index: The highest transaction id agreed by all nodes in the cluster
		:type commit_index: int
		:param snapshot_apply_in_progress: If true, indicates that the node is being restored to a known point
		:type snapshot_apply_in_progress: bool
		:param snapshot_creation_in_progress: If true, indicates that the cluster is in the process of creating a snapshot
		:type snapshot_creation_in_progress: bool
		:param transaction_log_length: The number of transactions committed since the last snapshot
		:type transaction_log_length: int
		:param first_transaction_in_log: The lowest transaction number in the log. Transactions prior to this are in the current snapshot.
		:type first_transaction_in_log: int
		:param raft_queue_depth: The number of pending work items for the consensus logic
		:type raft_queue_depth: int
		:param time_in_role: The amount of time that this node has spent in its current consensus role
		:type time_in_role: str
		:param voted_for: The name of the node that this node voted for in the most recent leader election
		:type voted_for: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._last_sent_to_state_machine = cast(int, kwargs.get("last_sent_to_state_machine"))
		self._last_contiguous_applied = cast(int, kwargs.get("last_contiguous_applied"))
		self._count_of_out_of_order_persisted_transactions = cast(int, kwargs.get("count_of_out_of_order_persisted_transactions"))
		self._commit_index = cast(int, kwargs.get("commit_index"))
		self._voted_for = cast(Optional[str], kwargs.get("voted_for"))
		self._snapshot_apply_in_progress = cast(bool, kwargs.get("snapshot_apply_in_progress"))
		self._snapshot_creation_in_progress = cast(bool, kwargs.get("snapshot_creation_in_progress"))
		self._transaction_log_length = cast(int, kwargs.get("transaction_log_length"))
		self._first_transaction_in_log = cast(int, kwargs.get("first_transaction_in_log"))
		self._raft_queue_depth = cast(int, kwargs.get("raft_queue_depth"))
		self._time_in_role = cast(str, kwargs.get("time_in_role"))
	@property
	def last_sent_to_state_machine(self) -> "int":
		"""The highest transaction id the consensus algorithm has requested the state machine to apply"""
		return self._last_sent_to_state_machine
	@last_sent_to_state_machine.setter
	def last_sent_to_state_machine(self, value: "int") -> None:
		"""The highest transaction id the consensus algorithm has requested the state machine to apply"""
		self._last_sent_to_state_machine = value
	@property
	def last_contiguous_applied(self) -> "int":
		"""The highest transaction id where all prior transactions have been applied (or rejected) by the state machine"""
		return self._last_contiguous_applied
	@last_contiguous_applied.setter
	def last_contiguous_applied(self, value: "int") -> None:
		"""The highest transaction id where all prior transactions have been applied (or rejected) by the state machine"""
		self._last_contiguous_applied = value
	@property
	def count_of_out_of_order_persisted_transactions(self) -> "int":
		"""The number of transaction id's applied that are higher than LastContiguousApplied"""
		return self._count_of_out_of_order_persisted_transactions
	@count_of_out_of_order_persisted_transactions.setter
	def count_of_out_of_order_persisted_transactions(self, value: "int") -> None:
		"""The number of transaction id's applied that are higher than LastContiguousApplied"""
		self._count_of_out_of_order_persisted_transactions = value
	@property
	def commit_index(self) -> "int":
		"""The highest transaction id agreed by all nodes in the cluster"""
		return self._commit_index
	@commit_index.setter
	def commit_index(self, value: "int") -> None:
		"""The highest transaction id agreed by all nodes in the cluster"""
		self._commit_index = value
	@property
	def voted_for(self) -> Optional["str"]:
		"""The name of the node that this node voted for in the most recent leader election"""
		return self._voted_for
	@voted_for.setter
	def voted_for(self, value: Optional["str"]) -> None:
		"""The name of the node that this node voted for in the most recent leader election"""
		self._voted_for = value
	@property
	def snapshot_apply_in_progress(self) -> "bool":
		"""If true, indicates that the node is being restored to a known point"""
		return self._snapshot_apply_in_progress
	@snapshot_apply_in_progress.setter
	def snapshot_apply_in_progress(self, value: "bool") -> None:
		"""If true, indicates that the node is being restored to a known point"""
		self._snapshot_apply_in_progress = value
	@property
	def snapshot_creation_in_progress(self) -> "bool":
		"""If true, indicates that the cluster is in the process of creating a snapshot"""
		return self._snapshot_creation_in_progress
	@snapshot_creation_in_progress.setter
	def snapshot_creation_in_progress(self, value: "bool") -> None:
		"""If true, indicates that the cluster is in the process of creating a snapshot"""
		self._snapshot_creation_in_progress = value
	@property
	def transaction_log_length(self) -> "int":
		"""The number of transactions committed since the last snapshot"""
		return self._transaction_log_length
	@transaction_log_length.setter
	def transaction_log_length(self, value: "int") -> None:
		"""The number of transactions committed since the last snapshot"""
		self._transaction_log_length = value
	@property
	def first_transaction_in_log(self) -> "int":
		"""The lowest transaction number in the log. Transactions prior to this are in the current snapshot."""
		return self._first_transaction_in_log
	@first_transaction_in_log.setter
	def first_transaction_in_log(self, value: "int") -> None:
		"""The lowest transaction number in the log. Transactions prior to this are in the current snapshot."""
		self._first_transaction_in_log = value
	@property
	def raft_queue_depth(self) -> "int":
		"""The number of pending work items for the consensus logic"""
		return self._raft_queue_depth
	@raft_queue_depth.setter
	def raft_queue_depth(self, value: "int") -> None:
		"""The number of pending work items for the consensus logic"""
		self._raft_queue_depth = value
	@property
	def time_in_role(self) -> "str":
		"""The amount of time that this node has spent in its current consensus role"""
		return self._time_in_role
	@time_in_role.setter
	def time_in_role(self, value: "str") -> None:
		"""The amount of time that this node has spent in its current consensus role"""
		self._time_in_role = value
class ConstraintOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"column_name": ("ColumnName", "str", None),
		"type_": ("Type", "str", None),
		"parameters": ("Parameters", "list", "ColumnNameValuePair"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		parameters: "List[ColumnNameValuePair]",
		column_name: Optional["str"] = None,
		type_: Optional["str"] = None,
	) -> None:
		"""
		:param parameters:
		:type parameters: List[ColumnNameValuePair]
		:param column_name:
		:type column_name: str or None
		:param type_:
		:type type_: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._column_name = cast(Optional[str], kwargs.get("column_name"))
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._parameters = cast(List[ColumnNameValuePair], kwargs.get("parameters"))
	@property
	def column_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._column_name
	@column_name.setter
	def column_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column_name = value
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def parameters(self) -> "List[ColumnNameValuePair]":
		# pylint: disable=missing-function-docstring
		return self._parameters
	@parameters.setter
	def parameters(self, value: "List[ColumnNameValuePair]") -> None:
		# pylint: disable=missing-function-docstring
		self._parameters = value
class ContainerImage:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"image": ("image", "str", None),
		"supports_nvidia_gpu": ("supportsNvidiaGpu", "bool", None),
		"account_code": ("accountCode", "str", None),
		"owner_user_id": ("ownerUserId", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		supports_nvidia_gpu: "bool",
		owner_user_id: "int",
		id_: Optional["str"] = None,
		image: Optional["str"] = None,
		account_code: Optional["str"] = None,
	) -> None:
		"""
		:param supports_nvidia_gpu:
		:type supports_nvidia_gpu: bool
		:param owner_user_id:
		:type owner_user_id: int
		:param id_:
		:type id_: str or None
		:param image:
		:type image: str or None
		:param account_code:
		:type account_code: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._image = cast(Optional[str], kwargs.get("image"))
		self._supports_nvidia_gpu = cast(bool, kwargs.get("supports_nvidia_gpu"))
		self._account_code = cast(Optional[str], kwargs.get("account_code"))
		self._owner_user_id = cast(int, kwargs.get("owner_user_id"))
	@property
	def id_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value
	@property
	def image(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._image
	@image.setter
	def image(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._image = value
	@property
	def supports_nvidia_gpu(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._supports_nvidia_gpu
	@supports_nvidia_gpu.setter
	def supports_nvidia_gpu(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._supports_nvidia_gpu = value
	@property
	def account_code(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._account_code
	@account_code.setter
	def account_code(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._account_code = value
	@property
	def owner_user_id(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._owner_user_id
	@owner_user_id.setter
	def owner_user_id(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._owner_user_id = value
class CoordinateConversion:
	"""For rasters, this will convert the coordinates from one CRS to another. For vector based data, the coordinate operations are recommended."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"source_proj_spec": ("sourceProjSpec", "str", None),
		"target_proj_spec": ("targetProjSpec", "str", None),
		"keep_native_projection": ("keepNativeProjection", "bool", None),
		"input_columns": ("inputColumns", "list", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		keep_native_projection: "bool",
		input_columns: "List[str]",
		source_proj_spec: Optional["str"] = None,
		target_proj_spec: Optional["str"] = None,
	) -> None:
		"""
		:param keep_native_projection: Keeps the coordinate system detected from the original file. Works for rasters and shapefiles.
		:type keep_native_projection: bool
		:param input_columns:
		:type input_columns: List[str]
		:param source_proj_spec:
		:type source_proj_spec: str or None
		:param target_proj_spec:
		:type target_proj_spec: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._source_proj_spec = cast(Optional[str], kwargs.get("source_proj_spec"))
		self._target_proj_spec = cast(Optional[str], kwargs.get("target_proj_spec"))
		self._keep_native_projection = cast(bool, kwargs.get("keep_native_projection"))
		self._input_columns = cast(List[str], kwargs.get("input_columns"))
	@property
	def source_proj_spec(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._source_proj_spec
	@source_proj_spec.setter
	def source_proj_spec(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._source_proj_spec = value
	@property
	def target_proj_spec(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._target_proj_spec
	@target_proj_spec.setter
	def target_proj_spec(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._target_proj_spec = value
	@property
	def keep_native_projection(self) -> "bool":
		"""Keeps the coordinate system detected from the original file. Works for rasters and shapefiles."""
		return self._keep_native_projection
	@keep_native_projection.setter
	def keep_native_projection(self, value: "bool") -> None:
		"""Keeps the coordinate system detected from the original file. Works for rasters and shapefiles."""
		self._keep_native_projection = value
	@property
	def input_columns(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._input_columns
	@input_columns.setter
	def input_columns(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._input_columns = value
class CoordinateOperation:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"source_column_name": ("SourceColumnName", "str", None),
		"output_column_name": ("OutputColumnName", "str", None),
		"source_projection": ("SourceProjection", "str", None),
		"output_projection": ("OutputProjection", "str", None),
		"strict": ("Strict", "OperationStrictMode", None),
		"operation": ("Operation", "QueryProjectionOperation", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		strict: "OperationStrictMode",
		operation: "QueryProjectionOperation",
		source_column_name: Optional["str"] = None,
		output_column_name: Optional["str"] = None,
		source_projection: Optional["str"] = None,
		output_projection: Optional["str"] = None,
	) -> None:
		"""
		:param strict:
		:type strict: OperationStrictMode
		:param operation:
		:type operation: QueryProjectionOperation
		:param source_column_name:
		:type source_column_name: str or None
		:param output_column_name:
		:type output_column_name: str or None
		:param source_projection:
		:type source_projection: str or None
		:param output_projection:
		:type output_projection: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._source_column_name = cast(Optional[str], kwargs.get("source_column_name"))
		self._output_column_name = cast(Optional[str], kwargs.get("output_column_name"))
		self._source_projection = cast(Optional[str], kwargs.get("source_projection"))
		self._output_projection = cast(Optional[str], kwargs.get("output_projection"))
		self._strict = cast(OperationStrictMode, kwargs.get("strict"))
		self._operation = cast(QueryProjectionOperation, kwargs.get("operation"))
	@property
	def source_column_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._source_column_name
	@source_column_name.setter
	def source_column_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._source_column_name = value
	@property
	def output_column_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._output_column_name
	@output_column_name.setter
	def output_column_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._output_column_name = value
	@property
	def source_projection(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._source_projection
	@source_projection.setter
	def source_projection(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._source_projection = value
	@property
	def output_projection(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._output_projection
	@output_projection.setter
	def output_projection(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._output_projection = value
	@property
	def strict(self) -> "OperationStrictMode":
		# pylint: disable=missing-function-docstring
		return self._strict
	@strict.setter
	def strict(self, value: "OperationStrictMode") -> None:
		# pylint: disable=missing-function-docstring
		self._strict = value
	@property
	def operation(self) -> "QueryProjectionOperation":
		# pylint: disable=missing-function-docstring
		return self._operation
	@operation.setter
	def operation(self, value: "QueryProjectionOperation") -> None:
		# pylint: disable=missing-function-docstring
		self._operation = value
class CreateAccountRequest:
	"""Account object to be created"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"code": ("code", "str", None),
		"name": ("name", "str", None),
		"description": ("description", "str", None),
		"estimated_size_limit": ("estimatedSizeLimit", "int", None),
		"max_row_limit": ("maxRowLimit", "int", None),
		"max_cell_limit": ("maxCellLimit", "int", None),
		"allow_anonymous_downloads": ("allowAnonymousDownloads", "bool", None),
		"use_resource_permissions": ("useResourcePermissions", "bool", None),
		"is_organization": ("isOrganization", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		code: "str",
		name: "str",
		description: "str",
		estimated_size_limit: Optional["int"] = None,
		max_row_limit: Optional["int"] = None,
		max_cell_limit: Optional["int"] = None,
		allow_anonymous_downloads: Optional["bool"] = None,
		use_resource_permissions: Optional["bool"] = None,
		is_organization: Optional["bool"] = None,
	) -> None:
		"""
		:param code: Text that uniquely identifies this account. Required.
		:type code: str
		:param name: Account name. Usually matches `code`. Required.
		:type name: str
		:param description: Account description. Required.
		:type description: str
		:param estimated_size_limit: The number of table cells this account is allowed to store, across all tables.
		:type estimated_size_limit: int or None
		:param max_row_limit: Maximum number of rows this account may export at one time.
		:type max_row_limit: int or None
		:param max_cell_limit: Maximum number of cells this account may export from a raster at one time.
		:type max_cell_limit: int or None
		:param allow_anonymous_downloads: Allow downloads from this account without authentication.
		:type allow_anonymous_downloads: bool or None
		:param use_resource_permissions: Set to true to enable fine-grained access control over tables and other resources.
		:type use_resource_permissions: bool or None
		:param is_organization: Set to true if this account is an organization and adminstrators can issue public registration links from it.
		:type is_organization: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._code = cast(str, kwargs.get("code"))
		self._name = cast(str, kwargs.get("name"))
		self._description = cast(str, kwargs.get("description"))
		self._estimated_size_limit = cast(Optional[int], kwargs.get("estimated_size_limit"))
		self._max_row_limit = cast(Optional[int], kwargs.get("max_row_limit"))
		self._max_cell_limit = cast(Optional[int], kwargs.get("max_cell_limit"))
		self._allow_anonymous_downloads = cast(Optional[bool], kwargs.get("allow_anonymous_downloads"))
		self._use_resource_permissions = cast(Optional[bool], kwargs.get("use_resource_permissions"))
		self._is_organization = cast(Optional[bool], kwargs.get("is_organization"))
	@property
	def code(self) -> "str":
		"""Text that uniquely identifies this account. Required."""
		return self._code
	@code.setter
	def code(self, value: "str") -> None:
		"""Text that uniquely identifies this account. Required."""
		self._code = value
	@property
	def name(self) -> "str":
		"""Account name. Usually matches `code`. Required."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""Account name. Usually matches `code`. Required."""
		self._name = value
	@property
	def description(self) -> "str":
		"""Account description. Required."""
		return self._description
	@description.setter
	def description(self, value: "str") -> None:
		"""Account description. Required."""
		self._description = value
	@property
	def estimated_size_limit(self) -> Optional["int"]:
		"""The number of table cells this account is allowed to store, across all tables."""
		return self._estimated_size_limit
	@estimated_size_limit.setter
	def estimated_size_limit(self, value: Optional["int"]) -> None:
		"""The number of table cells this account is allowed to store, across all tables."""
		self._estimated_size_limit = value
	@property
	def max_row_limit(self) -> Optional["int"]:
		"""Maximum number of rows this account may export at one time."""
		return self._max_row_limit
	@max_row_limit.setter
	def max_row_limit(self, value: Optional["int"]) -> None:
		"""Maximum number of rows this account may export at one time."""
		self._max_row_limit = value
	@property
	def max_cell_limit(self) -> Optional["int"]:
		"""Maximum number of cells this account may export from a raster at one time."""
		return self._max_cell_limit
	@max_cell_limit.setter
	def max_cell_limit(self, value: Optional["int"]) -> None:
		"""Maximum number of cells this account may export from a raster at one time."""
		self._max_cell_limit = value
	@property
	def allow_anonymous_downloads(self) -> Optional["bool"]:
		"""Allow downloads from this account without authentication."""
		return self._allow_anonymous_downloads
	@allow_anonymous_downloads.setter
	def allow_anonymous_downloads(self, value: Optional["bool"]) -> None:
		"""Allow downloads from this account without authentication."""
		self._allow_anonymous_downloads = value
	@property
	def use_resource_permissions(self) -> Optional["bool"]:
		"""Set to true to enable fine-grained access control over tables and other resources."""
		return self._use_resource_permissions
	@use_resource_permissions.setter
	def use_resource_permissions(self, value: Optional["bool"]) -> None:
		"""Set to true to enable fine-grained access control over tables and other resources."""
		self._use_resource_permissions = value
	@property
	def is_organization(self) -> Optional["bool"]:
		"""Set to true if this account is an organization and adminstrators can issue public registration links from it."""
		return self._is_organization
	@is_organization.setter
	def is_organization(self, value: Optional["bool"]) -> None:
		"""Set to true if this account is an organization and adminstrators can issue public registration links from it."""
		self._is_organization = value
class CreateBandwidthLimitRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"entity_id": ("entityId", "str", None),
		"limit_bytes": ("limitBytes", "int", None),
		"period": ("period", "str", None),
		"bandwidth_limit_type": ("bandwidthLimitType", "BandwidthLimitType", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		limit_bytes: "int",
		period: "str",
		entity_id: Optional["str"] = None,
		bandwidth_limit_type: Optional["BandwidthLimitType"] = None,
	) -> None:
		"""
		:param limit_bytes: The target number of bytes to send or receive in the defined Period.
		:type limit_bytes: int
		:param period: The amount of time that the bandwidth limit applies to.  Specified in HH:MM:SS or DD.HH:MM:SS formats
		:type period: str
		:param entity_id: The unique id of the central server or synced table pair for entity limits. Empty string for global limits.
		:type entity_id: str or None
		:param bandwidth_limit_type: Defines how the bandwidth limit is applied. Options are 'Additional' or 'Exception'
		:type bandwidth_limit_type: BandwidthLimitType or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._entity_id = cast(Optional[str], kwargs.get("entity_id"))
		self._limit_bytes = cast(int, kwargs.get("limit_bytes"))
		self._period = cast(str, kwargs.get("period"))
		self._bandwidth_limit_type = cast(Optional[BandwidthLimitType], kwargs.get("bandwidth_limit_type"))
	@property
	def entity_id(self) -> Optional["str"]:
		"""The unique id of the central server or synced table pair for entity limits. Empty string for global limits."""
		return self._entity_id
	@entity_id.setter
	def entity_id(self, value: Optional["str"]) -> None:
		"""The unique id of the central server or synced table pair for entity limits. Empty string for global limits."""
		self._entity_id = value
	@property
	def limit_bytes(self) -> "int":
		"""The target number of bytes to send or receive in the defined Period."""
		return self._limit_bytes
	@limit_bytes.setter
	def limit_bytes(self, value: "int") -> None:
		"""The target number of bytes to send or receive in the defined Period."""
		self._limit_bytes = value
	@property
	def period(self) -> "str":
		"""The amount of time that the bandwidth limit applies to.  Specified in HH:MM:SS or DD.HH:MM:SS formats"""
		return self._period
	@period.setter
	def period(self, value: "str") -> None:
		"""The amount of time that the bandwidth limit applies to.  Specified in HH:MM:SS or DD.HH:MM:SS formats"""
		self._period = value
	@property
	def bandwidth_limit_type(self) -> Optional["BandwidthLimitType"]:
		"""Defines how the bandwidth limit is applied. Options are 'Additional' or 'Exception'"""
		return self._bandwidth_limit_type
	@bandwidth_limit_type.setter
	def bandwidth_limit_type(self, value: Optional["BandwidthLimitType"]) -> None:
		"""Defines how the bandwidth limit is applied. Options are 'Additional' or 'Exception'"""
		self._bandwidth_limit_type = value
class CreateCentralServerRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"target_url": ("targetURL", "str", None),
		"auth_provider_type": ("authProviderType", "AuthProviderType", None),
		"auth_url": ("authURL", "str", None),
		"auth_username": ("authUsername", "str", None),
		"auth_password": ("authPassword", "str", None),
		"tag_behavior": ("tagBehavior", None, None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		target_url: "str",
		auth_provider_type: "AuthProviderType",
		auth_username: "str",
		name: Optional["str"] = None,
		auth_url: Optional["str"] = None,
		auth_password: Optional["str"] = None,
		tag_behavior: Optional["Any"] = None,
	) -> None:
		"""
		:param target_url:
		:type target_url: str
		:param auth_provider_type: 
* `Basic` - Standard MapLarge authentication.
		:type auth_provider_type: AuthProviderType
		:param auth_username:
		:type auth_username: str
		:param name:
		:type name: str or None
		:param auth_url:
		:type auth_url: str or None
		:param auth_password:
		:type auth_password: str or None
		:param tag_behavior:
		:type tag_behavior: Any or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._target_url = cast(str, kwargs.get("target_url"))
		self._auth_provider_type = cast(AuthProviderType, kwargs.get("auth_provider_type"))
		self._auth_url = cast(Optional[str], kwargs.get("auth_url"))
		self._auth_username = cast(str, kwargs.get("auth_username"))
		self._auth_password = cast(Optional[str], kwargs.get("auth_password"))
		self._tag_behavior = kwargs.get("tag_behavior")
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def target_url(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._target_url
	@target_url.setter
	def target_url(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._target_url = value
	@property
	def auth_provider_type(self) -> "AuthProviderType":
		"""
* `Basic` - Standard MapLarge authentication."""
		return self._auth_provider_type
	@auth_provider_type.setter
	def auth_provider_type(self, value: "AuthProviderType") -> None:
		"""
* `Basic` - Standard MapLarge authentication."""
		self._auth_provider_type = value
	@property
	def auth_url(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._auth_url
	@auth_url.setter
	def auth_url(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._auth_url = value
	@property
	def auth_username(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._auth_username
	@auth_username.setter
	def auth_username(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._auth_username = value
	@property
	def auth_password(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._auth_password
	@auth_password.setter
	def auth_password(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._auth_password = value
	@property
	def tag_behavior(self) -> Optional["Any"]:
		# pylint: disable=missing-function-docstring
		return self._tag_behavior
	@tag_behavior.setter
	def tag_behavior(self, value: Optional["Any"]) -> None:
		# pylint: disable=missing-function-docstring
		self._tag_behavior = value
class CreateDataStreamResourceRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"resource_definition": ("resourceDefinition", "str", None),
		"resource_bytes": ("resourceBytes", "File", None),
		"is_binary_resource": ("isBinaryResource", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		resource_bytes: "File",
		is_binary_resource: "bool",
		resource_definition: Optional["str"] = None,
	) -> None:
		"""
		:param name: The resource's unique human friendly identifier
		:type name: str
		:param resource_bytes: A binary resource byte array
		:type resource_bytes: File
		:param is_binary_resource: A string indicating whether or not a resource is binary. 'true' for binary, 'false' for plain text
		:type is_binary_resource: bool
		:param resource_definition: A plain text resource
		:type resource_definition: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._resource_definition = cast(Optional[str], kwargs.get("resource_definition"))
		self._resource_bytes = cast(File, kwargs.get("resource_bytes"))
		self._is_binary_resource = cast(bool, kwargs.get("is_binary_resource"))
	@property
	def name(self) -> "str":
		"""The resource's unique human friendly identifier"""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The resource's unique human friendly identifier"""
		self._name = value
	@property
	def resource_definition(self) -> Optional["str"]:
		"""A plain text resource"""
		return self._resource_definition
	@resource_definition.setter
	def resource_definition(self, value: Optional["str"]) -> None:
		"""A plain text resource"""
		self._resource_definition = value
	@property
	def resource_bytes(self) -> "File":
		"""A binary resource byte array"""
		return self._resource_bytes
	@resource_bytes.setter
	def resource_bytes(self, value: "File") -> None:
		"""A binary resource byte array"""
		self._resource_bytes = value
	@property
	def is_binary_resource(self) -> "bool":
		"""A string indicating whether or not a resource is binary. 'true' for binary, 'false' for plain text"""
		return self._is_binary_resource
	@is_binary_resource.setter
	def is_binary_resource(self, value: "bool") -> None:
		"""A string indicating whether or not a resource is binary. 'true' for binary, 'false' for plain text"""
		self._is_binary_resource = value
class CreateTableRequestBase:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"visibility": ("visibility", "TableVisibility", None),
		"primary_key_column": ("primaryKeyColumn", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		visibility: Optional["TableVisibility"] = None,
		primary_key_column: Optional["str"] = None,
	) -> None:
		"""
		:param visibility: Indicates how accessible the table is.
		:type visibility: TableVisibility or None
		:param primary_key_column: The name of the column to use for row matching when merging with existing data.
		:type primary_key_column: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._visibility = cast(Optional[TableVisibility], kwargs.get("visibility"))
		self._primary_key_column = cast(Optional[str], kwargs.get("primary_key_column"))
	@property
	def visibility(self) -> Optional["TableVisibility"]:
		"""Indicates how accessible the table is."""
		return self._visibility
	@visibility.setter
	def visibility(self, value: Optional["TableVisibility"]) -> None:
		"""Indicates how accessible the table is."""
		self._visibility = value
	@property
	def primary_key_column(self) -> Optional["str"]:
		"""The name of the column to use for row matching when merging with existing data."""
		return self._primary_key_column
	@primary_key_column.setter
	def primary_key_column(self, value: Optional["str"]) -> None:
		"""The name of the column to use for row matching when merging with existing data."""
		self._primary_key_column = value
class CreateEmptyTableRequest(CreateTableRequestBase):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"schema": ("schema", "dict", "ColumnType"),
		"options": ("options", "EmptyTableOptions", None),
		"visibility": ("visibility", "TableVisibility", None),
		"primary_key_column": ("primaryKeyColumn", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		schema: "Dict[str, ColumnType]",
		options: Optional["EmptyTableOptions"] = None,
		visibility: Optional["TableVisibility"] = None,
		primary_key_column: Optional["str"] = None,
	) -> None:
		"""
		:param schema: Specify the table schema. Dictionary keys are column names, dictionary values are column data types.
		:type schema: Dict[str, ColumnType]
		:param options:
		:type options: EmptyTableOptions or None
		:param visibility: Indicates how accessible the table is.
		:type visibility: TableVisibility or None
		:param primary_key_column: The name of the column to use for row matching when merging with existing data.
		:type primary_key_column: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		CreateTableRequestBase.__init__(self,
			visibility=kwargs.get("visibility"),
			primary_key_column=kwargs.get("primary_key_column"),
		)
		self._schema = cast(Dict[str, ColumnType], kwargs.get("schema"))
		self._options = cast(Optional[EmptyTableOptions], kwargs.get("options"))
	@property
	def schema(self) -> "Dict[str, ColumnType]":
		"""Specify the table schema. Dictionary keys are column names, dictionary values are column data types."""
		return self._schema
	@schema.setter
	def schema(self, value: "Dict[str, ColumnType]") -> None:
		"""Specify the table schema. Dictionary keys are column names, dictionary values are column data types."""
		self._schema = value
	@property
	def options(self) -> Optional["EmptyTableOptions"]:
		# pylint: disable=missing-function-docstring
		return self._options
	@options.setter
	def options(self, value: Optional["EmptyTableOptions"]) -> None:
		# pylint: disable=missing-function-docstring
		self._options = value
class CreateGroupRequest:
	"""Group object to be created"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"description": ("description", "str", None),
		"permission_level": ("permissionLevel", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		description: Optional["str"] = None,
		permission_level: Optional["str"] = None,
	) -> None:
		"""
		:param name: The name of the group. Unique within an account. Required.
		:type name: str
		:param description: The group description.
		:type description: str or None
		:param permission_level: The level of access assigned to this group. Typical values are: viewer, editor, admin, and custom. The possible values are configurable.
		:type permission_level: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._permission_level = cast(Optional[str], kwargs.get("permission_level"))
	@property
	def name(self) -> "str":
		"""The name of the group. Unique within an account. Required."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The name of the group. Unique within an account. Required."""
		self._name = value
	@property
	def description(self) -> Optional["str"]:
		"""The group description."""
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		"""The group description."""
		self._description = value
	@property
	def permission_level(self) -> Optional["str"]:
		"""The level of access assigned to this group. Typical values are: viewer, editor, admin, and custom. The possible values are configurable."""
		return self._permission_level
	@permission_level.setter
	def permission_level(self, value: Optional["str"]) -> None:
		"""The level of access assigned to this group. Typical values are: viewer, editor, admin, and custom. The possible values are configurable."""
		self._permission_level = value
class CreateGroupWithAccountRequest(CreateGroupRequest):
	"""Group object to be created"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "AccountReference", None),
		"name": ("name", "str", None),
		"description": ("description", "str", None),
		"permission_level": ("permissionLevel", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "AccountReference",
		name: "str",
		description: Optional["str"] = None,
		permission_level: Optional["str"] = None,
	) -> None:
		"""
		:param account: The account this group belongs to. Required.
		:type account: AccountReference
		:param name: The name of the group. Unique within an account. Required.
		:type name: str
		:param description: The group description.
		:type description: str or None
		:param permission_level: The level of access assigned to this group. Typical values are: viewer, editor, admin, and custom. The possible values are configurable.
		:type permission_level: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		CreateGroupRequest.__init__(self,
			name=kwargs.get("name"),
			description=kwargs.get("description"),
			permission_level=kwargs.get("permission_level"),
		)
		self._account = cast(AccountReference, kwargs.get("account"))
	@property
	def account(self) -> "AccountReference":
		"""The account this group belongs to. Required."""
		return self._account
	@account.setter
	def account(self, value: "AccountReference") -> None:
		"""The account this group belongs to. Required."""
		self._account = value
class CreateIndexRequestOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"indexed_columns": ("indexedColumns", "list", "str"),
		"parameters": ("parameters", "list", "ColumnNameValuePair"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		indexed_columns: "List[str]",
		parameters: "List[ColumnNameValuePair]",
	) -> None:
		"""
		:param indexed_columns: A comma-delimited list of the columns to include in the index
		:type indexed_columns: List[str]
		:param parameters: The parameters to be used when creating the new index
		:type parameters: List[ColumnNameValuePair]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._indexed_columns = cast(List[str], kwargs.get("indexed_columns"))
		self._parameters = cast(List[ColumnNameValuePair], kwargs.get("parameters"))
	@property
	def indexed_columns(self) -> "List[str]":
		"""A comma-delimited list of the columns to include in the index"""
		return self._indexed_columns
	@indexed_columns.setter
	def indexed_columns(self, value: "List[str]") -> None:
		"""A comma-delimited list of the columns to include in the index"""
		self._indexed_columns = value
	@property
	def parameters(self) -> "List[ColumnNameValuePair]":
		"""The parameters to be used when creating the new index"""
		return self._parameters
	@parameters.setter
	def parameters(self, value: "List[ColumnNameValuePair]") -> None:
		"""The parameters to be used when creating the new index"""
		self._parameters = value
class CreateOrUpdateTileSetRequestBase:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"append": ("append", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		append: Optional["bool"] = None,
	) -> None:
		"""
		:param append: If a tile set with the same name already exists, indicates whether these tiles should replace (append = false) or be merged (if append = true, then insert and update, no delete) with the existing tiles.
		:type append: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._append = cast(Optional[bool], kwargs.get("append"))
	@property
	def append(self) -> Optional["bool"]:
		"""If a tile set with the same name already exists, indicates whether these tiles should replace (append = false) or be merged (if append = true, then insert and update, no delete) with the existing tiles."""
		return self._append
	@append.setter
	def append(self, value: Optional["bool"]) -> None:
		"""If a tile set with the same name already exists, indicates whether these tiles should replace (append = false) or be merged (if append = true, then insert and update, no delete) with the existing tiles."""
		self._append = value
class CreateOrUpdateTileSetFromFileUploadRequest(CreateOrUpdateTileSetRequestBase):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"files": ("files", "list", "File"),
		"append": ("append", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		files: "List[File]",
		append: Optional["bool"] = None,
	) -> None:
		"""
		:param files: Specify the files to import.
		:type files: List[File]
		:param append: If a tile set with the same name already exists, indicates whether these tiles should replace (append = false) or be merged (if append = true, then insert and update, no delete) with the existing tiles.
		:type append: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		CreateOrUpdateTileSetRequestBase.__init__(self,
			append=kwargs.get("append"),
		)
		self._files = cast(List[File], kwargs.get("files"))
	@property
	def files(self) -> "List[File]":
		"""Specify the files to import."""
		return self._files
	@files.setter
	def files(self, value: "List[File]") -> None:
		"""Specify the files to import."""
		self._files = value
class CreateOrUpdateTileSetRequest(CreateOrUpdateTileSetRequestBase):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"file_url": ("fileURL", "str", None),
		"append": ("append", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		file_url: "str",
		append: Optional["bool"] = None,
	) -> None:
		"""
		:param file_url: Specify the URL of the file to import.
		:type file_url: str
		:param append: If a tile set with the same name already exists, indicates whether these tiles should replace (append = false) or be merged (if append = true, then insert and update, no delete) with the existing tiles.
		:type append: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		CreateOrUpdateTileSetRequestBase.__init__(self,
			append=kwargs.get("append"),
		)
		self._file_url = cast(str, kwargs.get("file_url"))
	@property
	def file_url(self) -> "str":
		"""Specify the URL of the file to import."""
		return self._file_url
	@file_url.setter
	def file_url(self, value: "str") -> None:
		"""Specify the URL of the file to import."""
		self._file_url = value
class CreatePipelineRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"pipeline_definition": ("pipelineDefinition", None, None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		pipeline_definition: Optional["Any"] = None,
	) -> None:
		"""
		:param name: The ramp's unique human friendly identifier
		:type name: str
		:param pipeline_definition: A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified.
		:type pipeline_definition: Any or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._pipeline_definition = kwargs.get("pipeline_definition")
	@property
	def name(self) -> "str":
		"""The ramp's unique human friendly identifier"""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The ramp's unique human friendly identifier"""
		self._name = value
	@property
	def pipeline_definition(self) -> Optional["Any"]:
		"""A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified."""
		return self._pipeline_definition
	@pipeline_definition.setter
	def pipeline_definition(self, value: Optional["Any"]) -> None:
		"""A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified."""
		self._pipeline_definition = value
class CreateRampRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"well_known_pipeline_id": ("wellKnownPipelineId", "str", None),
		"name": ("name", "str", None),
		"requested_status": ("requestedStatus", "str", None),
		"connector_app_name": ("connectorAppName", "str", None),
		"connector_plugin_name": ("connectorPluginName", "str", None),
		"connector_options": ("connectorOptions", None, None),
		"pipeline_definition": ("pipelineDefinition", None, None),
		"required_cluster_role": ("requiredClusterRole", "str", None),
		"pipeline_parameters": ("pipelineParameters", "dict", "str"),
		"verbose_logging": ("verboseLogging", "bool", None),
		"table_logging": ("tableLogging", "bool", None),
		"faulted_retry_attempts": ("faultedRetryAttempts", "int", None),
		"faulted_retry_delay": ("faultedRetryDelay", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		connector_app_name: "str",
		connector_plugin_name: "str",
		pipeline_parameters: "Dict[str, str]",
		verbose_logging: "bool",
		table_logging: "bool",
		well_known_pipeline_id: Optional["str"] = None,
		requested_status: Optional["str"] = None,
		connector_options: Optional["Any"] = None,
		pipeline_definition: Optional["Any"] = None,
		required_cluster_role: Optional["str"] = None,
		faulted_retry_attempts: Optional["int"] = None,
		faulted_retry_delay: Optional["int"] = None,
	) -> None:
		"""
		:param name: The ramp's unique human friendly identifier
		:type name: str
		:param connector_app_name: The name of the Maplarge application that contains the connector or observer plugin. Either 'MapLargeCore' or the name of a custom application build with the Maplarge Development Kit (ADK).'
		:type connector_app_name: str
		:param connector_plugin_name: The name of the connector or observer plugin.
		:type connector_plugin_name: str
		:param pipeline_parameters: A collection of key value pairs containing specific pipeline run options and their values
		:type pipeline_parameters: Dict[str, str]
		:param verbose_logging: If true, detailed pipeline execution results are added to the server log if Information level logging is enabled.
		:type verbose_logging: bool
		:param table_logging: If true, detailed pipeline execution results are logged to a table.
		:type table_logging: bool
		:param well_known_pipeline_id: The id of an existing pipeline. Either this or PipelineDefinition must be specified.
		:type well_known_pipeline_id: str or None
		:param requested_status: The ramp's desired execution state. Either 'Started' or 'Stopped'
		:type requested_status: str or None
		:param connector_options: A JSON object containing parameters for the specified connector or observer.
		:type connector_options: Any or None
		:param pipeline_definition: A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified.
		:type pipeline_definition: Any or None
		:param required_cluster_role: The required role of node within a cluster required to execute the ramp, if any. May be required if duplicates are possible in the pipeline input.
		:type required_cluster_role: str or None
		:param faulted_retry_attempts: The number of times that MapLarge will automatically retry when the ramp encounters an error.
		:type faulted_retry_attempts: int or None
		:param faulted_retry_delay: The minimum delay (in seconds) before the ramp will automatically retry when the ramp encounters an error.
		:type faulted_retry_delay: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._well_known_pipeline_id = cast(Optional[str], kwargs.get("well_known_pipeline_id"))
		self._name = cast(str, kwargs.get("name"))
		self._requested_status = cast(Optional[str], kwargs.get("requested_status"))
		self._connector_app_name = cast(str, kwargs.get("connector_app_name"))
		self._connector_plugin_name = cast(str, kwargs.get("connector_plugin_name"))
		self._connector_options = kwargs.get("connector_options")
		self._pipeline_definition = kwargs.get("pipeline_definition")
		self._required_cluster_role = cast(Optional[str], kwargs.get("required_cluster_role"))
		self._pipeline_parameters = cast(Dict[str, str], kwargs.get("pipeline_parameters"))
		self._verbose_logging = cast(bool, kwargs.get("verbose_logging"))
		self._table_logging = cast(bool, kwargs.get("table_logging"))
		self._faulted_retry_attempts = cast(Optional[int], kwargs.get("faulted_retry_attempts"))
		self._faulted_retry_delay = cast(Optional[int], kwargs.get("faulted_retry_delay"))
	@property
	def well_known_pipeline_id(self) -> Optional["str"]:
		"""The id of an existing pipeline. Either this or PipelineDefinition must be specified."""
		return self._well_known_pipeline_id
	@well_known_pipeline_id.setter
	def well_known_pipeline_id(self, value: Optional["str"]) -> None:
		"""The id of an existing pipeline. Either this or PipelineDefinition must be specified."""
		self._well_known_pipeline_id = value
	@property
	def name(self) -> "str":
		"""The ramp's unique human friendly identifier"""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The ramp's unique human friendly identifier"""
		self._name = value
	@property
	def requested_status(self) -> Optional["str"]:
		"""The ramp's desired execution state. Either 'Started' or 'Stopped'"""
		return self._requested_status
	@requested_status.setter
	def requested_status(self, value: Optional["str"]) -> None:
		"""The ramp's desired execution state. Either 'Started' or 'Stopped'"""
		self._requested_status = value
	@property
	def connector_app_name(self) -> "str":
		"""The name of the Maplarge application that contains the connector or observer plugin. Either 'MapLargeCore' or the name of a custom application build with the Maplarge Development Kit (ADK).'"""
		return self._connector_app_name
	@connector_app_name.setter
	def connector_app_name(self, value: "str") -> None:
		"""The name of the Maplarge application that contains the connector or observer plugin. Either 'MapLargeCore' or the name of a custom application build with the Maplarge Development Kit (ADK).'"""
		self._connector_app_name = value
	@property
	def connector_plugin_name(self) -> "str":
		"""The name of the connector or observer plugin."""
		return self._connector_plugin_name
	@connector_plugin_name.setter
	def connector_plugin_name(self, value: "str") -> None:
		"""The name of the connector or observer plugin."""
		self._connector_plugin_name = value
	@property
	def connector_options(self) -> Optional["Any"]:
		"""A JSON object containing parameters for the specified connector or observer."""
		return self._connector_options
	@connector_options.setter
	def connector_options(self, value: Optional["Any"]) -> None:
		"""A JSON object containing parameters for the specified connector or observer."""
		self._connector_options = value
	@property
	def pipeline_definition(self) -> Optional["Any"]:
		"""A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified."""
		return self._pipeline_definition
	@pipeline_definition.setter
	def pipeline_definition(self, value: Optional["Any"]) -> None:
		"""A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified."""
		self._pipeline_definition = value
	@property
	def required_cluster_role(self) -> Optional["str"]:
		"""The required role of node within a cluster required to execute the ramp, if any. May be required if duplicates are possible in the pipeline input."""
		return self._required_cluster_role
	@required_cluster_role.setter
	def required_cluster_role(self, value: Optional["str"]) -> None:
		"""The required role of node within a cluster required to execute the ramp, if any. May be required if duplicates are possible in the pipeline input."""
		self._required_cluster_role = value
	@property
	def pipeline_parameters(self) -> "Dict[str, str]":
		"""A collection of key value pairs containing specific pipeline run options and their values"""
		return self._pipeline_parameters
	@pipeline_parameters.setter
	def pipeline_parameters(self, value: "Dict[str, str]") -> None:
		"""A collection of key value pairs containing specific pipeline run options and their values"""
		self._pipeline_parameters = value
	@property
	def verbose_logging(self) -> "bool":
		"""If true, detailed pipeline execution results are added to the server log if Information level logging is enabled."""
		return self._verbose_logging
	@verbose_logging.setter
	def verbose_logging(self, value: "bool") -> None:
		"""If true, detailed pipeline execution results are added to the server log if Information level logging is enabled."""
		self._verbose_logging = value
	@property
	def table_logging(self) -> "bool":
		"""If true, detailed pipeline execution results are logged to a table."""
		return self._table_logging
	@table_logging.setter
	def table_logging(self, value: "bool") -> None:
		"""If true, detailed pipeline execution results are logged to a table."""
		self._table_logging = value
	@property
	def faulted_retry_attempts(self) -> Optional["int"]:
		"""The number of times that MapLarge will automatically retry when the ramp encounters an error."""
		return self._faulted_retry_attempts
	@faulted_retry_attempts.setter
	def faulted_retry_attempts(self, value: Optional["int"]) -> None:
		"""The number of times that MapLarge will automatically retry when the ramp encounters an error."""
		self._faulted_retry_attempts = value
	@property
	def faulted_retry_delay(self) -> Optional["int"]:
		"""The minimum delay (in seconds) before the ramp will automatically retry when the ramp encounters an error."""
		return self._faulted_retry_delay
	@faulted_retry_delay.setter
	def faulted_retry_delay(self, value: Optional["int"]) -> None:
		"""The minimum delay (in seconds) before the ramp will automatically retry when the ramp encounters an error."""
		self._faulted_retry_delay = value
class CreateSyncedAccountPairRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"central_account": ("centralAccount", "str", None),
		"edge_account": ("edgeAccount", "str", None),
		"sync_mode": ("syncMode", "list", "SyncModeEnum"),
		"execute_immediately": ("executeImmediately", "bool", None),
		"transfer_table_index_information": ("transferTableIndexInformation", "bool", None),
		"transfer_table_strictness": ("transferTableStrictness", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		central_account: "str",
		edge_account: "str",
		sync_mode: "SyncMode",
		execute_immediately: "bool",
		transfer_table_index_information: "bool",
		transfer_table_strictness: "bool",
	) -> None:
		"""
		:param central_account: Account on the central (remote) server.
		:type central_account: str
		:param edge_account: Account on the edge (local) server.
		:type edge_account: str
		:param sync_mode:
		:type sync_mode: SyncMode
		:param execute_immediately:
		:type execute_immediately: bool
		:param transfer_table_index_information: Determines if index information is transferred between Edge and Central server.
		:type transfer_table_index_information: bool
		:param transfer_table_strictness: Determines if schema strictness is transferred between Edge and Central server.
		:type transfer_table_strictness: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._central_account = cast(str, kwargs.get("central_account"))
		self._edge_account = cast(str, kwargs.get("edge_account"))
		self._sync_mode = cast(SyncMode, kwargs.get("sync_mode"))
		self._execute_immediately = cast(bool, kwargs.get("execute_immediately"))
		self._transfer_table_index_information = cast(bool, kwargs.get("transfer_table_index_information"))
		self._transfer_table_strictness = cast(bool, kwargs.get("transfer_table_strictness"))
	@property
	def central_account(self) -> "str":
		"""Account on the central (remote) server."""
		return self._central_account
	@central_account.setter
	def central_account(self, value: "str") -> None:
		"""Account on the central (remote) server."""
		self._central_account = value
	@property
	def edge_account(self) -> "str":
		"""Account on the edge (local) server."""
		return self._edge_account
	@edge_account.setter
	def edge_account(self, value: "str") -> None:
		"""Account on the edge (local) server."""
		self._edge_account = value
	@property
	def sync_mode(self) -> "SyncMode":
		# pylint: disable=missing-function-docstring
		return self._sync_mode
	@sync_mode.setter
	def sync_mode(self, value: "SyncMode") -> None:
		# pylint: disable=missing-function-docstring
		self._sync_mode = value
	@property
	def execute_immediately(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._execute_immediately
	@execute_immediately.setter
	def execute_immediately(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._execute_immediately = value
	@property
	def transfer_table_index_information(self) -> "bool":
		"""Determines if index information is transferred between Edge and Central server."""
		return self._transfer_table_index_information
	@transfer_table_index_information.setter
	def transfer_table_index_information(self, value: "bool") -> None:
		"""Determines if index information is transferred between Edge and Central server."""
		self._transfer_table_index_information = value
	@property
	def transfer_table_strictness(self) -> "bool":
		"""Determines if schema strictness is transferred between Edge and Central server."""
		return self._transfer_table_strictness
	@transfer_table_strictness.setter
	def transfer_table_strictness(self, value: "bool") -> None:
		"""Determines if schema strictness is transferred between Edge and Central server."""
		self._transfer_table_strictness = value
class CreateSyncedTablePairRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"central_table": ("centralTable", "TableReference", None),
		"edge_table": ("edgeTable", "TableReference", None),
		"sync_mode": ("syncMode", "list", "SyncModeEnum"),
		"priority": ("priority", "int", None),
		"filter_": ("filter", "QueryWhere", None),
		"push_filter": ("pushFilter", "QueryWhere", None),
		"tags_to_ignore": ("tagsToIgnore", "list", "str"),
		"transfer_index_information": ("transferIndexInformation", "bool", None),
		"transfer_strictness": ("transferStrictness", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		central_table: "TableReference",
		edge_table: "TableReference",
		sync_mode: "SyncMode",
		filter_: "QueryWhere",
		tags_to_ignore: "List[str]",
		priority: Optional["int"] = None,
		push_filter: Optional["QueryWhere"] = None,
		transfer_index_information: Optional["bool"] = None,
		transfer_strictness: Optional["bool"] = None,
	) -> None:
		"""
		:param central_table: Table on the central (remote) server. account.id is ignored. Account must be specified by code in either account.code or shortId.
		:type central_table: TableReference
		:param edge_table: Table on the edge (local) server. account.id is ignored. Account must be specified by code in either account.code or shortId.
		:type edge_table: TableReference
		:param sync_mode:
		:type sync_mode: SyncMode
		:param filter_: Filters what data is synchronized between Central (remote) and Edge (local) server.
		:type filter_: QueryWhere
		:param tags_to_ignore: List of keys of table tags that the edge (local) server will not push to the central (remote) server and not process if pulled from the central server.
		:type tags_to_ignore: List[str]
		:param priority: The relative priority of this pair. Lower priority items will wait for higher priority items. Default is 0.
		:type priority: int or None
		:param push_filter: Filters what data is synchronized between Edge (local) and Central (remote) server.
		:type push_filter: QueryWhere or None
		:param transfer_index_information: Determines if index information is transferred between Edge and Central server.
		:type transfer_index_information: bool or None
		:param transfer_strictness: Determines if schema strictness is transferred between Edge and Central server.
		:type transfer_strictness: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._central_table = cast(TableReference, kwargs.get("central_table"))
		self._edge_table = cast(TableReference, kwargs.get("edge_table"))
		self._sync_mode = cast(SyncMode, kwargs.get("sync_mode"))
		self._priority = cast(Optional[int], kwargs.get("priority"))
		self._filter_ = cast(QueryWhere, kwargs.get("filter_"))
		self._push_filter = cast(Optional[QueryWhere], kwargs.get("push_filter"))
		self._tags_to_ignore = cast(List[str], kwargs.get("tags_to_ignore"))
		self._transfer_index_information = cast(Optional[bool], kwargs.get("transfer_index_information"))
		self._transfer_strictness = cast(Optional[bool], kwargs.get("transfer_strictness"))
	@property
	def central_table(self) -> "TableReference":
		"""Table on the central (remote) server. account.id is ignored. Account must be specified by code in either account.code or shortId."""
		return self._central_table
	@central_table.setter
	def central_table(self, value: "TableReference") -> None:
		"""Table on the central (remote) server. account.id is ignored. Account must be specified by code in either account.code or shortId."""
		self._central_table = value
	@property
	def edge_table(self) -> "TableReference":
		"""Table on the edge (local) server. account.id is ignored. Account must be specified by code in either account.code or shortId."""
		return self._edge_table
	@edge_table.setter
	def edge_table(self, value: "TableReference") -> None:
		"""Table on the edge (local) server. account.id is ignored. Account must be specified by code in either account.code or shortId."""
		self._edge_table = value
	@property
	def sync_mode(self) -> "SyncMode":
		# pylint: disable=missing-function-docstring
		return self._sync_mode
	@sync_mode.setter
	def sync_mode(self, value: "SyncMode") -> None:
		# pylint: disable=missing-function-docstring
		self._sync_mode = value
	@property
	def priority(self) -> Optional["int"]:
		"""The relative priority of this pair. Lower priority items will wait for higher priority items. Default is 0."""
		return self._priority
	@priority.setter
	def priority(self, value: Optional["int"]) -> None:
		"""The relative priority of this pair. Lower priority items will wait for higher priority items. Default is 0."""
		self._priority = value
	@property
	def filter_(self) -> "QueryWhere":
		"""Filters what data is synchronized between Central (remote) and Edge (local) server."""
		return self._filter_
	@filter_.setter
	def filter_(self, value: "QueryWhere") -> None:
		"""Filters what data is synchronized between Central (remote) and Edge (local) server."""
		self._filter_ = value
	@property
	def push_filter(self) -> Optional["QueryWhere"]:
		"""Filters what data is synchronized between Edge (local) and Central (remote) server."""
		return self._push_filter
	@push_filter.setter
	def push_filter(self, value: Optional["QueryWhere"]) -> None:
		"""Filters what data is synchronized between Edge (local) and Central (remote) server."""
		self._push_filter = value
	@property
	def tags_to_ignore(self) -> "List[str]":
		"""List of keys of table tags that the edge (local) server will not push to the central (remote) server and not process if pulled from the central server."""
		return self._tags_to_ignore
	@tags_to_ignore.setter
	def tags_to_ignore(self, value: "List[str]") -> None:
		"""List of keys of table tags that the edge (local) server will not push to the central (remote) server and not process if pulled from the central server."""
		self._tags_to_ignore = value
	@property
	def transfer_index_information(self) -> Optional["bool"]:
		"""Determines if index information is transferred between Edge and Central server."""
		return self._transfer_index_information
	@transfer_index_information.setter
	def transfer_index_information(self, value: Optional["bool"]) -> None:
		"""Determines if index information is transferred between Edge and Central server."""
		self._transfer_index_information = value
	@property
	def transfer_strictness(self) -> Optional["bool"]:
		"""Determines if schema strictness is transferred between Edge and Central server."""
		return self._transfer_strictness
	@transfer_strictness.setter
	def transfer_strictness(self, value: Optional["bool"]) -> None:
		"""Determines if schema strictness is transferred between Edge and Central server."""
		self._transfer_strictness = value
class CreateTableWithDataRequest(CreateTableRequestBase):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"append": ("append", "bool", None),
		"overwrite_existing_primary_key": ("overwriteExistingPrimaryKey", "bool", None),
		"options": ("options", "FileImportOptions", None),
		"visibility": ("visibility", "TableVisibility", None),
		"primary_key_column": ("primaryKeyColumn", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		append: Optional["bool"] = None,
		overwrite_existing_primary_key: Optional["bool"] = None,
		options: Optional["FileImportOptions"] = None,
		visibility: Optional["TableVisibility"] = None,
		primary_key_column: Optional["str"] = None,
	) -> None:
		"""
		:param append: If a table with the same name already exists, indicates whether this data should replace (append = false) or be merged (if append = true, then insert and update, no delete) with the existing data.
		:type append: bool or None
		:param overwrite_existing_primary_key: If this import uses a different primaryKeyColumn than previous imports, this must be set to true.
		:type overwrite_existing_primary_key: bool or None
		:param options: Various options that affect the import operation.
		:type options: FileImportOptions or None
		:param visibility: Indicates how accessible the table is.
		:type visibility: TableVisibility or None
		:param primary_key_column: The name of the column to use for row matching when merging with existing data.
		:type primary_key_column: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		CreateTableRequestBase.__init__(self,
			visibility=kwargs.get("visibility"),
			primary_key_column=kwargs.get("primary_key_column"),
		)
		self._append = cast(Optional[bool], kwargs.get("append"))
		self._overwrite_existing_primary_key = cast(Optional[bool], kwargs.get("overwrite_existing_primary_key"))
		self._options = cast(Optional[FileImportOptions], kwargs.get("options"))
	@property
	def append(self) -> Optional["bool"]:
		"""If a table with the same name already exists, indicates whether this data should replace (append = false) or be merged (if append = true, then insert and update, no delete) with the existing data."""
		return self._append
	@append.setter
	def append(self, value: Optional["bool"]) -> None:
		"""If a table with the same name already exists, indicates whether this data should replace (append = false) or be merged (if append = true, then insert and update, no delete) with the existing data."""
		self._append = value
	@property
	def overwrite_existing_primary_key(self) -> Optional["bool"]:
		"""If this import uses a different primaryKeyColumn than previous imports, this must be set to true."""
		return self._overwrite_existing_primary_key
	@overwrite_existing_primary_key.setter
	def overwrite_existing_primary_key(self, value: Optional["bool"]) -> None:
		"""If this import uses a different primaryKeyColumn than previous imports, this must be set to true."""
		self._overwrite_existing_primary_key = value
	@property
	def options(self) -> Optional["FileImportOptions"]:
		"""Various options that affect the import operation."""
		return self._options
	@options.setter
	def options(self, value: Optional["FileImportOptions"]) -> None:
		"""Various options that affect the import operation."""
		self._options = value
class CreateTableFromFileUploadRequest(CreateTableWithDataRequest):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"files": ("files", "list", "File"),
		"visibility": ("visibility", "TableVisibility", None),
		"primary_key_column": ("primaryKeyColumn", "str", None),
		"append": ("append", "bool", None),
		"overwrite_existing_primary_key": ("overwriteExistingPrimaryKey", "bool", None),
		"options": ("options", "FileImportOptions", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		files: "List[File]",
		visibility: Optional["TableVisibility"] = None,
		primary_key_column: Optional["str"] = None,
		append: Optional["bool"] = None,
		overwrite_existing_primary_key: Optional["bool"] = None,
		options: Optional["FileImportOptions"] = None,
	) -> None:
		"""
		:param files: Specify the files to import.
		:type files: List[File]
		:param visibility: Indicates how accessible the table is.
		:type visibility: TableVisibility or None
		:param primary_key_column: The name of the column to use for row matching when merging with existing data.
		:type primary_key_column: str or None
		:param append: If a table with the same name already exists, indicates whether this data should replace (append = false) or be merged (if append = true, then insert and update, no delete) with the existing data.
		:type append: bool or None
		:param overwrite_existing_primary_key: If this import uses a different primaryKeyColumn than previous imports, this must be set to true.
		:type overwrite_existing_primary_key: bool or None
		:param options: Various options that affect the import operation.
		:type options: FileImportOptions or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		CreateTableWithDataRequest.__init__(self,
			visibility=kwargs.get("visibility"),
			primary_key_column=kwargs.get("primary_key_column"),
			append=kwargs.get("append"),
			overwrite_existing_primary_key=kwargs.get("overwrite_existing_primary_key"),
			options=kwargs.get("options"),
		)
		self._files = cast(List[File], kwargs.get("files"))
		self._visibility = cast(Optional[TableVisibility], kwargs.get("visibility"))
		self._primary_key_column = cast(Optional[str], kwargs.get("primary_key_column"))
	@property
	def files(self) -> "List[File]":
		"""Specify the files to import."""
		return self._files
	@files.setter
	def files(self, value: "List[File]") -> None:
		"""Specify the files to import."""
		self._files = value
	@property
	def visibility(self) -> Optional["TableVisibility"]:
		"""Indicates how accessible the table is."""
		return self._visibility
	@visibility.setter
	def visibility(self, value: Optional["TableVisibility"]) -> None:
		"""Indicates how accessible the table is."""
		self._visibility = value
	@property
	def primary_key_column(self) -> Optional["str"]:
		"""The name of the column to use for row matching when merging with existing data."""
		return self._primary_key_column
	@primary_key_column.setter
	def primary_key_column(self, value: Optional["str"]) -> None:
		"""The name of the column to use for row matching when merging with existing data."""
		self._primary_key_column = value
class CreateTableRequest(CreateTableWithDataRequest):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"datasource": ("datasource", "QueryDatasource", None),
		"file_url": ("fileURL", "str", None),
		"data_import_adapter_type": ("dataImportAdapterType", "str", None),
		"data_import_adapter_parameters": ("dataImportAdapterParameters", "dict", None),
		"data": ("data", None, None),
		"data_filename": ("dataFilename", "str", None),
		"visibility": ("visibility", "TableVisibility", None),
		"primary_key_column": ("primaryKeyColumn", "str", None),
		"append": ("append", "bool", None),
		"overwrite_existing_primary_key": ("overwriteExistingPrimaryKey", "bool", None),
		"options": ("options", "FileImportOptions", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		datasource: Optional["QueryDatasource"] = None,
		file_url: Optional["str"] = None,
		data_import_adapter_type: Optional["str"] = None,
		data_import_adapter_parameters: Optional["Dict[str, Any]"] = None,
		data: Optional["Union[str, List[str], Dict[str, Any], List[Dict[str, Any]]]"] = None,
		data_filename: Optional["str"] = None,
		visibility: Optional["TableVisibility"] = None,
		primary_key_column: Optional["str"] = None,
		append: Optional["bool"] = None,
		overwrite_existing_primary_key: Optional["bool"] = None,
		options: Optional["FileImportOptions"] = None,
	) -> None:
		"""
		:param datasource: Specify the remote database to populate the table from. Only one of `datasource`, `fileUrl`, `dataImportAdapterType`, or `data` should be specified.
		:type datasource: QueryDatasource or None
		:param file_url: Specify the URL of the file to import. Only one of `datasource`, `fileUrl`, `dataImportAdapterType`, or `data` should be specified.
		:type file_url: str or None
		:param data_import_adapter_type:
		:type data_import_adapter_type: str or None
		:param data_import_adapter_parameters:
		:type data_import_adapter_parameters: Dict[str, Any] or None
		:param data: Specify the data to be imported. Only one of `datasource`, `fileUrl`, `dataImportAdapterType`, or `data` should be specified.
		:type data: Union[str, List[str], Dict[str, Any], List[Dict[str, Any]]] or None
		:param data_filename: Specify a filename for the data to be imported.
		:type data_filename: str or None
		:param visibility: Indicates how accessible the table is.
		:type visibility: TableVisibility or None
		:param primary_key_column: The name of the column to use for row matching when merging with existing data.
		:type primary_key_column: str or None
		:param append: If a table with the same name already exists, indicates whether this data should replace (append = false) or be merged (if append = true, then insert and update, no delete) with the existing data.
		:type append: bool or None
		:param overwrite_existing_primary_key: If this import uses a different primaryKeyColumn than previous imports, this must be set to true.
		:type overwrite_existing_primary_key: bool or None
		:param options: Various options that affect the import operation.
		:type options: FileImportOptions or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		CreateTableWithDataRequest.__init__(self,
			visibility=kwargs.get("visibility"),
			primary_key_column=kwargs.get("primary_key_column"),
			append=kwargs.get("append"),
			overwrite_existing_primary_key=kwargs.get("overwrite_existing_primary_key"),
			options=kwargs.get("options"),
		)
		self._datasource = cast(Optional[QueryDatasource], kwargs.get("datasource"))
		self._file_url = cast(Optional[str], kwargs.get("file_url"))
		self._data_import_adapter_type = cast(Optional[str], kwargs.get("data_import_adapter_type"))
		self._data_import_adapter_parameters = cast(Optional[Dict[str, Any]], kwargs.get("data_import_adapter_parameters"))
		self._data = cast(Optional[Union[str, List[str], Dict[str, Any], List[Dict[str, Any]]]], kwargs.get("data"))
		self._data_filename = cast(Optional[str], kwargs.get("data_filename"))
		self._visibility = cast(Optional[TableVisibility], kwargs.get("visibility"))
		self._primary_key_column = cast(Optional[str], kwargs.get("primary_key_column"))
	@property
	def datasource(self) -> Optional["QueryDatasource"]:
		"""Specify the remote database to populate the table from. Only one of `datasource`, `fileUrl`, `dataImportAdapterType`, or `data` should be specified."""
		return self._datasource
	@datasource.setter
	def datasource(self, value: Optional["QueryDatasource"]) -> None:
		"""Specify the remote database to populate the table from. Only one of `datasource`, `fileUrl`, `dataImportAdapterType`, or `data` should be specified."""
		self._datasource = value
	@property
	def file_url(self) -> Optional["str"]:
		"""Specify the URL of the file to import. Only one of `datasource`, `fileUrl`, `dataImportAdapterType`, or `data` should be specified."""
		return self._file_url
	@file_url.setter
	def file_url(self, value: Optional["str"]) -> None:
		"""Specify the URL of the file to import. Only one of `datasource`, `fileUrl`, `dataImportAdapterType`, or `data` should be specified."""
		self._file_url = value
	@property
	def data_import_adapter_type(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._data_import_adapter_type
	@data_import_adapter_type.setter
	def data_import_adapter_type(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._data_import_adapter_type = value
	@property
	def data_import_adapter_parameters(self) -> Optional["Dict[str, Any]"]:
		# pylint: disable=missing-function-docstring
		return self._data_import_adapter_parameters
	@data_import_adapter_parameters.setter
	def data_import_adapter_parameters(self, value: Optional["Dict[str, Any]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._data_import_adapter_parameters = value
	@property
	def data(self) -> Optional["Union[str, List[str], Dict[str, Any], List[Dict[str, Any]]]"]:
		"""Specify the data to be imported. Only one of `datasource`, `fileUrl`, `dataImportAdapterType`, or `data` should be specified."""
		return self._data
	@data.setter
	def data(self, value: Optional["Union[str, List[str], Dict[str, Any], List[Dict[str, Any]]]"]) -> None:
		"""Specify the data to be imported. Only one of `datasource`, `fileUrl`, `dataImportAdapterType`, or `data` should be specified."""
		self._data = value
	@property
	def data_filename(self) -> Optional["str"]:
		"""Specify a filename for the data to be imported."""
		return self._data_filename
	@data_filename.setter
	def data_filename(self, value: Optional["str"]) -> None:
		"""Specify a filename for the data to be imported."""
		self._data_filename = value
	@property
	def visibility(self) -> Optional["TableVisibility"]:
		"""Indicates how accessible the table is."""
		return self._visibility
	@visibility.setter
	def visibility(self, value: Optional["TableVisibility"]) -> None:
		"""Indicates how accessible the table is."""
		self._visibility = value
	@property
	def primary_key_column(self) -> Optional["str"]:
		"""The name of the column to use for row matching when merging with existing data."""
		return self._primary_key_column
	@primary_key_column.setter
	def primary_key_column(self, value: Optional["str"]) -> None:
		"""The name of the column to use for row matching when merging with existing data."""
		self._primary_key_column = value
class CreateUserRequest:
	"""User object to be created"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"email": ("email", "str", None),
		"first_name": ("firstName", "str", None),
		"last_name": ("lastName", "str", None),
		"password": ("password", "str", None),
		"groups": ("groups", "list", "GroupReference"),
		"tags": ("tags", "list", "str"),
		"force_password_change": ("forcePasswordChange", "bool", None),
		"phone_number": ("phoneNumber", "str", None),
		"friendly_name": ("friendlyName", "str", None),
		"user_disabled": ("userDisabled", "bool", None),
		"imports_disabled": ("importsDisabled", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		email: "str",
		password: "str",
		first_name: Optional["str"] = None,
		last_name: Optional["str"] = None,
		groups: Optional["List[GroupReference]"] = None,
		tags: Optional["List[str]"] = None,
		force_password_change: Optional["bool"] = None,
		phone_number: Optional["str"] = None,
		friendly_name: Optional["str"] = None,
		user_disabled: Optional["bool"] = None,
		imports_disabled: Optional["bool"] = None,
	) -> None:
		"""
		:param name: The name of the user. Required.
		:type name: str
		:param email: The user's email address. Must be unique. Required.
		:type email: str
		:param password: The user's password. Required.
		:type password: str
		:param first_name: The first name of the user.
		:type first_name: str or None
		:param last_name: The last name of the user.
		:type last_name: str or None
		:param groups: The initial groups the user belongs to.
		:type groups: List[GroupReference] or None
		:param tags: A collection of string identifiers applied to a user, which can be used for a variety of purposes. This property is not available in the `users/self` response.
		:type tags: List[str] or None
		:param force_password_change: Flag that indicates whether the user should be required to change their password on first log-in.
		:type force_password_change: bool or None
		:param phone_number: The user's phone number.
		:type phone_number: str or None
		:param friendly_name: The name used in eamils sent to the user.
		:type friendly_name: str or None
		:param user_disabled: Disabled users are not allowed to successfully authenticate.
		:type user_disabled: bool or None
		:param imports_disabled: Flag indicating whether this user may currently import new tables.
		:type imports_disabled: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._email = cast(str, kwargs.get("email"))
		self._first_name = cast(Optional[str], kwargs.get("first_name"))
		self._last_name = cast(Optional[str], kwargs.get("last_name"))
		self._password = cast(str, kwargs.get("password"))
		self._groups = cast(Optional[List[GroupReference]], kwargs.get("groups"))
		self._tags = cast(Optional[List[str]], kwargs.get("tags"))
		self._force_password_change = cast(Optional[bool], kwargs.get("force_password_change"))
		self._phone_number = cast(Optional[str], kwargs.get("phone_number"))
		self._friendly_name = cast(Optional[str], kwargs.get("friendly_name"))
		self._user_disabled = cast(Optional[bool], kwargs.get("user_disabled"))
		self._imports_disabled = cast(Optional[bool], kwargs.get("imports_disabled"))
	@property
	def name(self) -> "str":
		"""The name of the user. Required."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The name of the user. Required."""
		self._name = value
	@property
	def email(self) -> "str":
		"""The user's email address. Must be unique. Required."""
		return self._email
	@email.setter
	def email(self, value: "str") -> None:
		"""The user's email address. Must be unique. Required."""
		self._email = value
	@property
	def first_name(self) -> Optional["str"]:
		"""The first name of the user."""
		return self._first_name
	@first_name.setter
	def first_name(self, value: Optional["str"]) -> None:
		"""The first name of the user."""
		self._first_name = value
	@property
	def last_name(self) -> Optional["str"]:
		"""The last name of the user."""
		return self._last_name
	@last_name.setter
	def last_name(self, value: Optional["str"]) -> None:
		"""The last name of the user."""
		self._last_name = value
	@property
	def password(self) -> "str":
		"""The user's password. Required."""
		return self._password
	@password.setter
	def password(self, value: "str") -> None:
		"""The user's password. Required."""
		self._password = value
	@property
	def groups(self) -> Optional["List[GroupReference]"]:
		"""The initial groups the user belongs to."""
		return self._groups
	@groups.setter
	def groups(self, value: Optional["List[GroupReference]"]) -> None:
		"""The initial groups the user belongs to."""
		self._groups = value
	@property
	def tags(self) -> Optional["List[str]"]:
		"""A collection of string identifiers applied to a user, which can be used for a variety of purposes. This property is not available in the `users/self` response."""
		return self._tags
	@tags.setter
	def tags(self, value: Optional["List[str]"]) -> None:
		"""A collection of string identifiers applied to a user, which can be used for a variety of purposes. This property is not available in the `users/self` response."""
		self._tags = value
	@property
	def force_password_change(self) -> Optional["bool"]:
		"""Flag that indicates whether the user should be required to change their password on first log-in."""
		return self._force_password_change
	@force_password_change.setter
	def force_password_change(self, value: Optional["bool"]) -> None:
		"""Flag that indicates whether the user should be required to change their password on first log-in."""
		self._force_password_change = value
	@property
	def phone_number(self) -> Optional["str"]:
		"""The user's phone number."""
		return self._phone_number
	@phone_number.setter
	def phone_number(self, value: Optional["str"]) -> None:
		"""The user's phone number."""
		self._phone_number = value
	@property
	def friendly_name(self) -> Optional["str"]:
		"""The name used in eamils sent to the user."""
		return self._friendly_name
	@friendly_name.setter
	def friendly_name(self, value: Optional["str"]) -> None:
		"""The name used in eamils sent to the user."""
		self._friendly_name = value
	@property
	def user_disabled(self) -> Optional["bool"]:
		"""Disabled users are not allowed to successfully authenticate."""
		return self._user_disabled
	@user_disabled.setter
	def user_disabled(self, value: Optional["bool"]) -> None:
		"""Disabled users are not allowed to successfully authenticate."""
		self._user_disabled = value
	@property
	def imports_disabled(self) -> Optional["bool"]:
		"""Flag indicating whether this user may currently import new tables."""
		return self._imports_disabled
	@imports_disabled.setter
	def imports_disabled(self, value: Optional["bool"]) -> None:
		"""Flag indicating whether this user may currently import new tables."""
		self._imports_disabled = value
class CreateWorkflowNodeRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("Id", "str", None),
		"name": ("Name", "str", None),
		"action_type": ("ActionType", "str", None),
		"sources": ("Sources", "list", "str"),
		"options": ("Options", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
		sources: "List[str]",
		name: Optional["str"] = None,
		action_type: Optional["str"] = None,
		options: Optional["str"] = None,
	) -> None:
		"""
		:param id_:
		:type id_: str
		:param sources:
		:type sources: List[str]
		:param name:
		:type name: str or None
		:param action_type:
		:type action_type: str or None
		:param options:
		:type options: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._action_type = cast(Optional[str], kwargs.get("action_type"))
		self._sources = cast(List[str], kwargs.get("sources"))
		self._options = cast(Optional[str], kwargs.get("options"))
	@property
	def id_(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def action_type(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._action_type
	@action_type.setter
	def action_type(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._action_type = value
	@property
	def sources(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._sources
	@sources.setter
	def sources(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._sources = value
	@property
	def options(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._options
	@options.setter
	def options(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._options = value
class CreateWorkflowRequest:
	"""Workflow object to be created"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"name": ("name", "str", None),
		"enabled": ("enabled", "bool", None),
		"options": ("options", "str", None),
		"account_name": ("accountName", "str", None),
		"user_id": ("userId", "int", None),
		"project_id": ("projectId", "str", None),
		"nodes": ("nodes", "list", "CreateWorkflowNodeRequest"),
		"created": ("created", "datetime", None),
		"version": ("version", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
		enabled: "bool",
		user_id: "int",
		project_id: "str",
		nodes: "List[CreateWorkflowNodeRequest]",
		created: "datetime",
		name: Optional["str"] = None,
		options: Optional["str"] = None,
		account_name: Optional["str"] = None,
		version: Optional["str"] = None,
	) -> None:
		"""
		:param id_:
		:type id_: str
		:param enabled:
		:type enabled: bool
		:param user_id:
		:type user_id: int
		:param project_id:
		:type project_id: str
		:param nodes:
		:type nodes: List[CreateWorkflowNodeRequest]
		:param created:
		:type created: datetime
		:param name:
		:type name: str or None
		:param options:
		:type options: str or None
		:param account_name:
		:type account_name: str or None
		:param version:
		:type version: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._enabled = cast(bool, kwargs.get("enabled"))
		self._options = cast(Optional[str], kwargs.get("options"))
		self._account_name = cast(Optional[str], kwargs.get("account_name"))
		self._user_id = cast(int, kwargs.get("user_id"))
		self._project_id = cast(str, kwargs.get("project_id"))
		self._nodes = cast(List[CreateWorkflowNodeRequest], kwargs.get("nodes"))
		self._created = cast(datetime, kwargs.get("created"))
		self._version = cast(Optional[str], kwargs.get("version"))
	@property
	def id_(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def enabled(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def options(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._options
	@options.setter
	def options(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._options = value
	@property
	def account_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._account_name
	@account_name.setter
	def account_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._account_name = value
	@property
	def user_id(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._user_id
	@user_id.setter
	def user_id(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._user_id = value
	@property
	def project_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._project_id
	@project_id.setter
	def project_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._project_id = value
	@property
	def nodes(self) -> "List[CreateWorkflowNodeRequest]":
		# pylint: disable=missing-function-docstring
		return self._nodes
	@nodes.setter
	def nodes(self, value: "List[CreateWorkflowNodeRequest]") -> None:
		# pylint: disable=missing-function-docstring
		self._nodes = value
	@property
	def created(self) -> "datetime":
		# pylint: disable=missing-function-docstring
		return self._created
	@created.setter
	def created(self, value: "datetime") -> None:
		# pylint: disable=missing-function-docstring
		self._created = value
	@property
	def version(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._version
	@version.setter
	def version(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._version = value
class DataPaging:
	"""Config class to hold pagination values for remote data"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"native_paging": ("nativePaging", "bool", None),
		"page_span": ("pageSpan", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		native_paging: "bool",
		page_span: Optional["str"] = None,
	) -> None:
		"""
		:param native_paging: When true, use the native (built-in) paging capabilities of the remote server, if available.
		:type native_paging: bool
		:param page_span: Field upon which to apply the date range queries
		:type page_span: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._native_paging = cast(bool, kwargs.get("native_paging"))
		self._page_span = cast(Optional[str], kwargs.get("page_span"))
	@property
	def native_paging(self) -> "bool":
		"""When true, use the native (built-in) paging capabilities of the remote server, if available."""
		return self._native_paging
	@native_paging.setter
	def native_paging(self, value: "bool") -> None:
		"""When true, use the native (built-in) paging capabilities of the remote server, if available."""
		self._native_paging = value
	@property
	def page_span(self) -> Optional["str"]:
		"""Field upon which to apply the date range queries"""
		return self._page_span
	@page_span.setter
	def page_span(self, value: Optional["str"]) -> None:
		"""Field upon which to apply the date range queries"""
		self._page_span = value
class DataSetSchedule:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"start": ("start", "datetime", None),
		"interval_seconds": ("intervalSeconds", "int", None),
		"iterations_to_keep": ("iterationsToKeep", "int", None),
		"ignore_last_successful_run": ("ignoreLastSuccessfulRun", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		start: "datetime",
		interval_seconds: "int",
		iterations_to_keep: "int",
		ignore_last_successful_run: "bool",
	) -> None:
		"""
		:param start:
		:type start: datetime
		:param interval_seconds:
		:type interval_seconds: int
		:param iterations_to_keep:
		:type iterations_to_keep: int
		:param ignore_last_successful_run:
		:type ignore_last_successful_run: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._start = cast(datetime, kwargs.get("start"))
		self._interval_seconds = cast(int, kwargs.get("interval_seconds"))
		self._iterations_to_keep = cast(int, kwargs.get("iterations_to_keep"))
		self._ignore_last_successful_run = cast(bool, kwargs.get("ignore_last_successful_run"))
	@property
	def start(self) -> "datetime":
		# pylint: disable=missing-function-docstring
		return self._start
	@start.setter
	def start(self, value: "datetime") -> None:
		# pylint: disable=missing-function-docstring
		self._start = value
	@property
	def interval_seconds(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._interval_seconds
	@interval_seconds.setter
	def interval_seconds(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._interval_seconds = value
	@property
	def iterations_to_keep(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._iterations_to_keep
	@iterations_to_keep.setter
	def iterations_to_keep(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._iterations_to_keep = value
	@property
	def ignore_last_successful_run(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._ignore_last_successful_run
	@ignore_last_successful_run.setter
	def ignore_last_successful_run(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._ignore_last_successful_run = value
class DataStreamResource:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"links": ("links", "DataStreamResourceLinks", None),
		"unique_id": ("uniqueID", "str", None),
		"name": ("name", "str", None),
		"last_edit_user": ("lastEditUser", "str", None),
		"resource_definition": ("resourceDefinition", "str", None),
		"resource_bytes": ("resourceBytes", "File", None),
		"is_binary_resource": ("isBinaryResource", "bool", None),
		"last_edited": ("lastEdited", "datetime", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		links: "DataStreamResourceLinks",
		resource_bytes: "File",
		is_binary_resource: "bool",
		last_edited: "datetime",
		unique_id: Optional["str"] = None,
		name: Optional["str"] = None,
		last_edit_user: Optional["str"] = None,
		resource_definition: Optional["str"] = None,
	) -> None:
		"""
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: DataStreamResourceLinks
		:param resource_bytes: A binary resource byte array
		:type resource_bytes: File
		:param is_binary_resource: A string indicating whether or not a resource is binary. 'true' for binary, 'false' for plain text
		:type is_binary_resource: bool
		:param last_edited:
		:type last_edited: datetime
		:param unique_id: The resource's unique id
		:type unique_id: str or None
		:param name: The resource's unique human friendly identifier
		:type name: str or None
		:param last_edit_user:
		:type last_edit_user: str or None
		:param resource_definition: A plain text resource
		:type resource_definition: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._links = cast(DataStreamResourceLinks, kwargs.get("links"))
		self._unique_id = cast(Optional[str], kwargs.get("unique_id"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._last_edit_user = cast(Optional[str], kwargs.get("last_edit_user"))
		self._resource_definition = cast(Optional[str], kwargs.get("resource_definition"))
		self._resource_bytes = cast(File, kwargs.get("resource_bytes"))
		self._is_binary_resource = cast(bool, kwargs.get("is_binary_resource"))
		self._last_edited = cast(datetime, kwargs.get("last_edited"))
	@property
	def links(self) -> "DataStreamResourceLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "DataStreamResourceLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
	@property
	def unique_id(self) -> Optional["str"]:
		"""The resource's unique id"""
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: Optional["str"]) -> None:
		"""The resource's unique id"""
		self._unique_id = value
	@property
	def name(self) -> Optional["str"]:
		"""The resource's unique human friendly identifier"""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""The resource's unique human friendly identifier"""
		self._name = value
	@property
	def last_edit_user(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._last_edit_user
	@last_edit_user.setter
	def last_edit_user(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._last_edit_user = value
	@property
	def resource_definition(self) -> Optional["str"]:
		"""A plain text resource"""
		return self._resource_definition
	@resource_definition.setter
	def resource_definition(self, value: Optional["str"]) -> None:
		"""A plain text resource"""
		self._resource_definition = value
	@property
	def resource_bytes(self) -> "File":
		"""A binary resource byte array"""
		return self._resource_bytes
	@resource_bytes.setter
	def resource_bytes(self, value: "File") -> None:
		"""A binary resource byte array"""
		self._resource_bytes = value
	@property
	def is_binary_resource(self) -> "bool":
		"""A string indicating whether or not a resource is binary. 'true' for binary, 'false' for plain text"""
		return self._is_binary_resource
	@is_binary_resource.setter
	def is_binary_resource(self, value: "bool") -> None:
		"""A string indicating whether or not a resource is binary. 'true' for binary, 'false' for plain text"""
		self._is_binary_resource = value
	@property
	def last_edited(self) -> "datetime":
		# pylint: disable=missing-function-docstring
		return self._last_edited
	@last_edited.setter
	def last_edited(self, value: "datetime") -> None:
		# pylint: disable=missing-function-docstring
		self._last_edited = value
class DataStreamResourceLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class DataTransform:
	"""URL- or source-specific schema values.  Used when a layer- (ArcGIS) or endpoint-specific transformation is needed."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"data_fields": ("dataFields", "list", "str"),
		"hints": ("hints", "list", "ColumnHint"),
		"structure": ("structure", "HeadlessSchema", None),
		"headers": ("headers", "list", "FieldDefinition"),
		"directives": ("directives", "list", "TransformDirective"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		data_fields: Optional["List[str]"] = None,
		hints: Optional["List[ColumnHint]"] = None,
		structure: Optional["HeadlessSchema"] = None,
		headers: Optional["List[FieldDefinition]"] = None,
		directives: Optional["List[TransformDirective]"] = None,
	) -> None:
		"""
		:param data_fields: Original fields or column names on import data.
		:type data_fields: List[str] or None
		:param hints: List of transformation hints with their underlying analysis, if any.
		:type hints: List[ColumnHint] or None
		:param structure:
		:type structure: HeadlessSchema or None
		:param headers:
		:type headers: List[FieldDefinition] or None
		:param directives: List of user- and system-configured transform directives, which is used on imports to designate final column usage.
		:type directives: List[TransformDirective] or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._data_fields = cast(Optional[List[str]], kwargs.get("data_fields"))
		self._hints = cast(Optional[List[ColumnHint]], kwargs.get("hints"))
		self._structure = cast(Optional[HeadlessSchema], kwargs.get("structure"))
		self._headers = cast(Optional[List[FieldDefinition]], kwargs.get("headers"))
		self._directives = cast(Optional[List[TransformDirective]], kwargs.get("directives"))
	@property
	def data_fields(self) -> Optional["List[str]"]:
		"""Original fields or column names on import data."""
		return self._data_fields
	@data_fields.setter
	def data_fields(self, value: Optional["List[str]"]) -> None:
		"""Original fields or column names on import data."""
		self._data_fields = value
	@property
	def hints(self) -> Optional["List[ColumnHint]"]:
		"""List of transformation hints with their underlying analysis, if any."""
		return self._hints
	@hints.setter
	def hints(self, value: Optional["List[ColumnHint]"]) -> None:
		"""List of transformation hints with their underlying analysis, if any."""
		self._hints = value
	@property
	def structure(self) -> Optional["HeadlessSchema"]:
		# pylint: disable=missing-function-docstring
		return self._structure
	@structure.setter
	def structure(self, value: Optional["HeadlessSchema"]) -> None:
		# pylint: disable=missing-function-docstring
		self._structure = value
	@property
	def headers(self) -> Optional["List[FieldDefinition]"]:
		# pylint: disable=missing-function-docstring
		return self._headers
	@headers.setter
	def headers(self, value: Optional["List[FieldDefinition]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._headers = value
	@property
	def directives(self) -> Optional["List[TransformDirective]"]:
		"""List of user- and system-configured transform directives, which is used on imports to designate final column usage."""
		return self._directives
	@directives.setter
	def directives(self, value: Optional["List[TransformDirective]"]) -> None:
		"""List of user- and system-configured transform directives, which is used on imports to designate final column usage."""
		self._directives = value


class DBClientQueryMode(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	RUN_LOCALLY = 'RunLocally'
	RUN_ON_HOST = 'RunOnHost'

class DBResult:
	"""An object containing the data returned by executing a query."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"data": ("data", "dict", "list"),
		"geo_json": ("geoJson", None, None),
		"all_geo": ("allGeo", "dict", "list"),
		"totals": ("totals", "dict", None),
		"tablename": ("tablename", "str", None),
		"stats": ("stats", "QueryStats", None),
		"removed_column_names": ("removedColumnNames", "list", "str"),
		"warnings": ("warnings", "list", "str"),
		"column_meta_data": ("columnMetaData", "dict", "ColumnMetaDataTag"),
		"column_attributes": ("columnAttributes", "dict", "list"),
		"column_statistics": ("columnStatistics", "dict", "ColumnStatOutputs"),
		"return_geo_by_reference": ("returnGeoByReference", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		data: "Dict[str, List[Any]]",
		geo_json: "Any",
		all_geo: "Dict[str, List[Any]]",
		totals: "Dict[str, Any]",
		stats: "QueryStats",
		removed_column_names: "List[str]",
		warnings: "List[str]",
		column_meta_data: "Dict[str, ColumnMetaDataTag]",
		column_attributes: "Dict[str, List[ColumnAttributeDescription]]",
		column_statistics: "Dict[str, ColumnStatOutputs]",
		return_geo_by_reference: "bool",
		tablename: Optional["str"] = None,
	) -> None:
		"""
		:param data: The data returned by the query - organized by column first, then row.
		:type data: Dict[str, List[Any]]
		:param geo_json:
		:type geo_json: Any
		:param all_geo:
		:type all_geo: Dict[str, List[Any]]
		:param totals:
		:type totals: Dict[str, Any]
		:param stats:
		:type stats: QueryStats
		:param removed_column_names:
		:type removed_column_names: List[str]
		:param warnings:
		:type warnings: List[str]
		:param column_meta_data:
		:type column_meta_data: Dict[str, ColumnMetaDataTag]
		:param column_attributes:
		:type column_attributes: Dict[str, List[ColumnAttributeDescription]]
		:param column_statistics:
		:type column_statistics: Dict[str, ColumnStatOutputs]
		:param return_geo_by_reference:
		:type return_geo_by_reference: bool
		:param tablename:
		:type tablename: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._data = cast(Dict[str, List[Any]], kwargs.get("data"))
		self._geo_json = cast(Any, kwargs.get("geo_json"))
		self._all_geo = cast(Dict[str, List[Any]], kwargs.get("all_geo"))
		self._totals = cast(Dict[str, Any], kwargs.get("totals"))
		self._tablename = cast(Optional[str], kwargs.get("tablename"))
		self._stats = cast(QueryStats, kwargs.get("stats"))
		self._removed_column_names = cast(List[str], kwargs.get("removed_column_names"))
		self._warnings = cast(List[str], kwargs.get("warnings"))
		self._column_meta_data = cast(Dict[str, ColumnMetaDataTag], kwargs.get("column_meta_data"))
		self._column_attributes = cast(Dict[str, List[ColumnAttributeDescription]], kwargs.get("column_attributes"))
		self._column_statistics = cast(Dict[str, ColumnStatOutputs], kwargs.get("column_statistics"))
		self._return_geo_by_reference = cast(bool, kwargs.get("return_geo_by_reference"))
	@property
	def data(self) -> "Dict[str, List[Any]]":
		"""The data returned by the query - organized by column first, then row."""
		return self._data
	@data.setter
	def data(self, value: "Dict[str, List[Any]]") -> None:
		"""The data returned by the query - organized by column first, then row."""
		self._data = value
	@property
	def geo_json(self) -> "Any":
		# pylint: disable=missing-function-docstring
		return self._geo_json
	@geo_json.setter
	def geo_json(self, value: "Any") -> None:
		# pylint: disable=missing-function-docstring
		self._geo_json = value
	@property
	def all_geo(self) -> "Dict[str, List[Any]]":
		# pylint: disable=missing-function-docstring
		return self._all_geo
	@all_geo.setter
	def all_geo(self, value: "Dict[str, List[Any]]") -> None:
		# pylint: disable=missing-function-docstring
		self._all_geo = value
	@property
	def totals(self) -> "Dict[str, Any]":
		# pylint: disable=missing-function-docstring
		return self._totals
	@totals.setter
	def totals(self, value: "Dict[str, Any]") -> None:
		# pylint: disable=missing-function-docstring
		self._totals = value
	@property
	def tablename(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._tablename
	@tablename.setter
	def tablename(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._tablename = value
	@property
	def stats(self) -> "QueryStats":
		# pylint: disable=missing-function-docstring
		return self._stats
	@stats.setter
	def stats(self, value: "QueryStats") -> None:
		# pylint: disable=missing-function-docstring
		self._stats = value
	@property
	def removed_column_names(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._removed_column_names
	@removed_column_names.setter
	def removed_column_names(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._removed_column_names = value
	@property
	def warnings(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._warnings
	@warnings.setter
	def warnings(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._warnings = value
	@property
	def column_meta_data(self) -> "Dict[str, ColumnMetaDataTag]":
		# pylint: disable=missing-function-docstring
		return self._column_meta_data
	@column_meta_data.setter
	def column_meta_data(self, value: "Dict[str, ColumnMetaDataTag]") -> None:
		# pylint: disable=missing-function-docstring
		self._column_meta_data = value
	@property
	def column_attributes(self) -> "Dict[str, List[ColumnAttributeDescription]]":
		# pylint: disable=missing-function-docstring
		return self._column_attributes
	@column_attributes.setter
	def column_attributes(self, value: "Dict[str, List[ColumnAttributeDescription]]") -> None:
		# pylint: disable=missing-function-docstring
		self._column_attributes = value
	@property
	def column_statistics(self) -> "Dict[str, ColumnStatOutputs]":
		# pylint: disable=missing-function-docstring
		return self._column_statistics
	@column_statistics.setter
	def column_statistics(self, value: "Dict[str, ColumnStatOutputs]") -> None:
		# pylint: disable=missing-function-docstring
		self._column_statistics = value
	@property
	def return_geo_by_reference(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._return_geo_by_reference
	@return_geo_by_reference.setter
	def return_geo_by_reference(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._return_geo_by_reference = value
class DimensionalData:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"column_name": ("columnName", "str", None),
		"dimension_name": ("dimensionName", "str", None),
		"column_type": ("columnType", "str", None),
		"max_value": ("maxValue", "str", None),
		"min_value": ("minValue", "str", None),
		"units": ("units", "str", None),
		"precision": ("precision", "str", None),
		"allow_current": ("allowCurrent", "bool", None),
		"defined_max": ("definedMax", "str", None),
		"defined_min": ("definedMin", "str", None),
		"default_value": ("defaultValue", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		column_name: Optional["str"] = None,
		dimension_name: Optional["str"] = None,
		column_type: Optional["str"] = None,
		max_value: Optional["str"] = None,
		min_value: Optional["str"] = None,
		units: Optional["str"] = None,
		precision: Optional["str"] = None,
		allow_current: Optional["bool"] = None,
		defined_max: Optional["str"] = None,
		defined_min: Optional["str"] = None,
		default_value: Optional["str"] = None,
	) -> None:
		"""
		:param column_name:
		:type column_name: str or None
		:param dimension_name:
		:type dimension_name: str or None
		:param column_type:
		:type column_type: str or None
		:param max_value:
		:type max_value: str or None
		:param min_value:
		:type min_value: str or None
		:param units:
		:type units: str or None
		:param precision:
		:type precision: str or None
		:param allow_current:
		:type allow_current: bool or None
		:param defined_max:
		:type defined_max: str or None
		:param defined_min:
		:type defined_min: str or None
		:param default_value:
		:type default_value: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._column_name = cast(Optional[str], kwargs.get("column_name"))
		self._dimension_name = cast(Optional[str], kwargs.get("dimension_name"))
		self._column_type = cast(Optional[str], kwargs.get("column_type"))
		self._max_value = cast(Optional[str], kwargs.get("max_value"))
		self._min_value = cast(Optional[str], kwargs.get("min_value"))
		self._units = cast(Optional[str], kwargs.get("units"))
		self._precision = cast(Optional[str], kwargs.get("precision"))
		self._allow_current = cast(Optional[bool], kwargs.get("allow_current"))
		self._defined_max = cast(Optional[str], kwargs.get("defined_max"))
		self._defined_min = cast(Optional[str], kwargs.get("defined_min"))
		self._default_value = cast(Optional[str], kwargs.get("default_value"))
	@property
	def column_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._column_name
	@column_name.setter
	def column_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column_name = value
	@property
	def dimension_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._dimension_name
	@dimension_name.setter
	def dimension_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._dimension_name = value
	@property
	def column_type(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._column_type
	@column_type.setter
	def column_type(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column_type = value
	@property
	def max_value(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._max_value
	@max_value.setter
	def max_value(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_value = value
	@property
	def min_value(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._min_value
	@min_value.setter
	def min_value(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_value = value
	@property
	def units(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._units
	@units.setter
	def units(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._units = value
	@property
	def precision(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._precision
	@precision.setter
	def precision(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._precision = value
	@property
	def allow_current(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._allow_current
	@allow_current.setter
	def allow_current(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._allow_current = value
	@property
	def defined_max(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._defined_max
	@defined_max.setter
	def defined_max(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._defined_max = value
	@property
	def defined_min(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._defined_min
	@defined_min.setter
	def defined_min(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._defined_min = value
	@property
	def default_value(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._default_value
	@default_value.setter
	def default_value(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._default_value = value


class DirectedOutputs(str, Enum):
	# pylint: disable=missing-class-docstring
	NOT_SET = 'NotSet'
	PRIMARY_LAT = 'PrimaryLat'
	PRIMARY_LON = 'PrimaryLon'
	GEO_SHAPE = 'GeoShape'
	GEO_LINE = 'GeoLine'
	GEO_POINT = 'GeoPoint'
	STRING = 'String'
	JSON_STRING = 'JsonString'
	DATE_TIME = 'DateTime'
	DATE_TIME_PARSE = 'DateTimeParse'
	DATE_TIME_PARSE_INPUT = 'DateTimeParseInput'
	DATE_TIME_PARSE_OFFSET = 'DateTimeParseOffset'
	DATE_TIME_ZONE = 'DateTimeZone'
	INTEGER = 'Integer'
	LONG_INTEGER = 'LongInteger'
	DOUBLE = 'Double'
	DO_NOT_IMPORT = 'DoNotImport'
	ALLOWED = 'Allowed'
	WKT = 'WKT'
	CONSTANT_VALUE = 'ConstantValue'
	UTMMGRS = 'UTM_MGRS'
	UTMMGRSGARS = 'UTM_MGRS_GARS'
	GUID = 'Guid'
	ENCRYPTED = 'Encrypted'
	ENCODED_JSON = 'EncodedJson'
	GEO_MULTIPOINT = 'GeoMultipoint'
	REMAP = 'Remap'
	VECTOR = 'Vector'



class DotGradientStyle(str, Enum):
	# pylint: disable=missing-class-docstring
	LINEAR = 'Linear'
	RADIAL = 'Radial'

class EffectiveResourcePermissions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"read": ("read", "bool", None),
		"write": ("write", "bool", None),
		"share": ("share", "bool", None),
		"is_shared": ("isShared", "bool", None),
		"sharing_enabled_for_account": ("sharingEnabledForAccount", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		read: "bool",
		write: "bool",
		share: "bool",
		is_shared: "bool",
		sharing_enabled_for_account: "bool",
	) -> None:
		"""
		:param read: Indicates whether the user can read the resource.
		:type read: bool
		:param write: Indicates whether the user can modify the resource.
		:type write: bool
		:param share:
		:type share: bool
		:param is_shared:
		:type is_shared: bool
		:param sharing_enabled_for_account:
		:type sharing_enabled_for_account: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._read = cast(bool, kwargs.get("read"))
		self._write = cast(bool, kwargs.get("write"))
		self._share = cast(bool, kwargs.get("share"))
		self._is_shared = cast(bool, kwargs.get("is_shared"))
		self._sharing_enabled_for_account = cast(bool, kwargs.get("sharing_enabled_for_account"))
	@property
	def read(self) -> "bool":
		"""Indicates whether the user can read the resource."""
		return self._read
	@read.setter
	def read(self, value: "bool") -> None:
		"""Indicates whether the user can read the resource."""
		self._read = value
	@property
	def write(self) -> "bool":
		"""Indicates whether the user can modify the resource."""
		return self._write
	@write.setter
	def write(self, value: "bool") -> None:
		"""Indicates whether the user can modify the resource."""
		self._write = value
	@property
	def share(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._share
	@share.setter
	def share(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._share = value
	@property
	def is_shared(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_shared
	@is_shared.setter
	def is_shared(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_shared = value
	@property
	def sharing_enabled_for_account(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._sharing_enabled_for_account
	@sharing_enabled_for_account.setter
	def sharing_enabled_for_account(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._sharing_enabled_for_account = value
class GenericAdapterConfig:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"config_guid": ("configGuid", "str", None),
		"transports": ("transports", "list", "AdapterTransportsEnum"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		transports: "AdapterTransports",
		name: Optional["str"] = None,
		config_guid: Optional["str"] = None,
	) -> None:
		"""
		:param transports:
		:type transports: AdapterTransports
		:param name:
		:type name: str or None
		:param config_guid:
		:type config_guid: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._config_guid = cast(Optional[str], kwargs.get("config_guid"))
		self._transports = cast(AdapterTransports, kwargs.get("transports"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def config_guid(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._config_guid
	@config_guid.setter
	def config_guid(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._config_guid = value
	@property
	def transports(self) -> "AdapterTransports":
		# pylint: disable=missing-function-docstring
		return self._transports
	@transports.setter
	def transports(self, value: "AdapterTransports") -> None:
		# pylint: disable=missing-function-docstring
		self._transports = value
class ElasticSearchConfig(GenericAdapterConfig):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"uri_field": ("uriField", "str", None),
		"search_body": ("searchBody", "str", None),
		"name_field": ("nameField", "str", None),
		"authorization": ("authorization", "str", None),
		"name": ("name", "str", None),
		"config_guid": ("configGuid", "str", None),
		"transports": ("transports", "list", "AdapterTransportsEnum"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		transports: "AdapterTransports",
		uri_field: Optional["str"] = None,
		search_body: Optional["str"] = None,
		name_field: Optional["str"] = None,
		authorization: Optional["str"] = None,
		name: Optional["str"] = None,
		config_guid: Optional["str"] = None,
	) -> None:
		"""
		:param transports:
		:type transports: AdapterTransports
		:param uri_field:
		:type uri_field: str or None
		:param search_body:
		:type search_body: str or None
		:param name_field:
		:type name_field: str or None
		:param authorization:
		:type authorization: str or None
		:param name:
		:type name: str or None
		:param config_guid:
		:type config_guid: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		GenericAdapterConfig.__init__(self,
			name=kwargs.get("name"),
			config_guid=kwargs.get("config_guid"),
			transports=kwargs.get("transports"),
		)
		self._uri_field = cast(Optional[str], kwargs.get("uri_field"))
		self._search_body = cast(Optional[str], kwargs.get("search_body"))
		self._name_field = cast(Optional[str], kwargs.get("name_field"))
		self._authorization = cast(Optional[str], kwargs.get("authorization"))
	@property
	def uri_field(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._uri_field
	@uri_field.setter
	def uri_field(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._uri_field = value
	@property
	def search_body(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._search_body
	@search_body.setter
	def search_body(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._search_body = value
	@property
	def name_field(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name_field
	@name_field.setter
	def name_field(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name_field = value
	@property
	def authorization(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._authorization
	@authorization.setter
	def authorization(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._authorization = value
class EmptyTableOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"schema_strictness": ("schemaStrictness", "TransactedTableHandleSchemaStrictMode", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		schema_strictness: Optional["TransactedTableHandleSchemaStrictMode"] = None,
	) -> None:
		"""
		:param schema_strictness:
		:type schema_strictness: TransactedTableHandleSchemaStrictMode or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._schema_strictness = cast(Optional[TransactedTableHandleSchemaStrictMode], kwargs.get("schema_strictness"))
	@property
	def schema_strictness(self) -> Optional["TransactedTableHandleSchemaStrictMode"]:
		# pylint: disable=missing-function-docstring
		return self._schema_strictness
	@schema_strictness.setter
	def schema_strictness(self, value: Optional["TransactedTableHandleSchemaStrictMode"]) -> None:
		# pylint: disable=missing-function-docstring
		self._schema_strictness = value
class EntryReference:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
	) -> None:
		"""
		:param id_: Tag identifier
		:type id_: str
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
	@property
	def id_(self) -> "str":
		"""Tag identifier"""
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		"""Tag identifier"""
		self._id_ = value
class ExportSettings:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"geo_format": ("geoFormat", "GeoFormat", None),
		"include_policies": ("includePolicies", "bool", None),
		"message_identifier": ("messageIdentifier", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		geo_format: Optional["GeoFormat"] = None,
		include_policies: Optional["bool"] = None,
		message_identifier: Optional["str"] = None,
	) -> None:
		"""
		:param geo_format: If the Accept header is text/csv, specify the desired format for the geospatial data. Defaults to WKT.
		:type geo_format: GeoFormat or None
		:param include_policies:
		:type include_policies: bool or None
		:param message_identifier:
		:type message_identifier: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._geo_format = cast(Optional[GeoFormat], kwargs.get("geo_format"))
		self._include_policies = cast(Optional[bool], kwargs.get("include_policies"))
		self._message_identifier = cast(Optional[str], kwargs.get("message_identifier"))
	@property
	def geo_format(self) -> Optional["GeoFormat"]:
		"""If the Accept header is text/csv, specify the desired format for the geospatial data. Defaults to WKT."""
		return self._geo_format
	@geo_format.setter
	def geo_format(self, value: Optional["GeoFormat"]) -> None:
		"""If the Accept header is text/csv, specify the desired format for the geospatial data. Defaults to WKT."""
		self._geo_format = value
	@property
	def include_policies(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._include_policies
	@include_policies.setter
	def include_policies(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._include_policies = value
	@property
	def message_identifier(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._message_identifier
	@message_identifier.setter
	def message_identifier(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._message_identifier = value
class FailedTransaction:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"term_number": ("termNumber", "int", None),
		"transaction_number": ("transactionNumber", "int", None),
		"timestamp": ("timestamp", "str", None),
		"change_type": ("changeType", "str", None),
		"details": ("details", "str", None),
		"error_message": ("errorMessage", "str", None),
		"last_failure_consistency": ("lastFailureConsistency", "TransactionConsistencyStatus", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		term_number: "int",
		transaction_number: "int",
		last_failure_consistency: "TransactionConsistencyStatus",
		timestamp: Optional["str"] = None,
		change_type: Optional["str"] = None,
		details: Optional["str"] = None,
		error_message: Optional["str"] = None,
	) -> None:
		"""
		:param term_number: The term number of the failed transaction
		:type term_number: int
		:param transaction_number: The failed transaction number
		:type transaction_number: int
		:param last_failure_consistency: Indicates whether the last failure was Ambient or Logical
		:type last_failure_consistency: TransactionConsistencyStatus
		:param timestamp: The date and time when the failure occurred
		:type timestamp: str or None
		:param change_type: The type of transaction that caused the failure
		:type change_type: str or None
		:param details: Description of the transaction
		:type details: str or None
		:param error_message: An error message describing why the transaction failed
		:type error_message: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._term_number = cast(int, kwargs.get("term_number"))
		self._transaction_number = cast(int, kwargs.get("transaction_number"))
		self._timestamp = cast(Optional[str], kwargs.get("timestamp"))
		self._change_type = cast(Optional[str], kwargs.get("change_type"))
		self._details = cast(Optional[str], kwargs.get("details"))
		self._error_message = cast(Optional[str], kwargs.get("error_message"))
		self._last_failure_consistency = cast(TransactionConsistencyStatus, kwargs.get("last_failure_consistency"))
	@property
	def term_number(self) -> "int":
		"""The term number of the failed transaction"""
		return self._term_number
	@term_number.setter
	def term_number(self, value: "int") -> None:
		"""The term number of the failed transaction"""
		self._term_number = value
	@property
	def transaction_number(self) -> "int":
		"""The failed transaction number"""
		return self._transaction_number
	@transaction_number.setter
	def transaction_number(self, value: "int") -> None:
		"""The failed transaction number"""
		self._transaction_number = value
	@property
	def timestamp(self) -> Optional["str"]:
		"""The date and time when the failure occurred"""
		return self._timestamp
	@timestamp.setter
	def timestamp(self, value: Optional["str"]) -> None:
		"""The date and time when the failure occurred"""
		self._timestamp = value
	@property
	def change_type(self) -> Optional["str"]:
		"""The type of transaction that caused the failure"""
		return self._change_type
	@change_type.setter
	def change_type(self, value: Optional["str"]) -> None:
		"""The type of transaction that caused the failure"""
		self._change_type = value
	@property
	def details(self) -> Optional["str"]:
		"""Description of the transaction"""
		return self._details
	@details.setter
	def details(self, value: Optional["str"]) -> None:
		"""Description of the transaction"""
		self._details = value
	@property
	def error_message(self) -> Optional["str"]:
		"""An error message describing why the transaction failed"""
		return self._error_message
	@error_message.setter
	def error_message(self, value: Optional["str"]) -> None:
		"""An error message describing why the transaction failed"""
		self._error_message = value
	@property
	def last_failure_consistency(self) -> "TransactionConsistencyStatus":
		"""Indicates whether the last failure was Ambient or Logical"""
		return self._last_failure_consistency
	@last_failure_consistency.setter
	def last_failure_consistency(self, value: "TransactionConsistencyStatus") -> None:
		"""Indicates whether the last failure was Ambient or Logical"""
		self._last_failure_consistency = value
class FailedTransactionsOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"max_failed_transactions": ("maxFailedTransactions", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		max_failed_transactions: "int",
	) -> None:
		"""
		:param max_failed_transactions: Maximum number of transactions to report
		:type max_failed_transactions: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._max_failed_transactions = cast(int, kwargs.get("max_failed_transactions"))
	@property
	def max_failed_transactions(self) -> "int":
		"""Maximum number of transactions to report"""
		return self._max_failed_transactions
	@max_failed_transactions.setter
	def max_failed_transactions(self, value: "int") -> None:
		"""Maximum number of transactions to report"""
		self._max_failed_transactions = value
class FieldDefinition:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"field_name": ("fieldName", "str", None),
		"field_order": ("fieldOrder", "int", None),
		"start_index": ("startIndex", "int", None),
		"field_length": ("fieldLength", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		field_order: "int",
		start_index: "int",
		field_length: "int",
		field_name: Optional["str"] = None,
	) -> None:
		"""
		:param field_order:
		:type field_order: int
		:param start_index:
		:type start_index: int
		:param field_length:
		:type field_length: int
		:param field_name:
		:type field_name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._field_name = cast(Optional[str], kwargs.get("field_name"))
		self._field_order = cast(int, kwargs.get("field_order"))
		self._start_index = cast(int, kwargs.get("start_index"))
		self._field_length = cast(int, kwargs.get("field_length"))
	@property
	def field_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._field_name
	@field_name.setter
	def field_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._field_name = value
	@property
	def field_order(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._field_order
	@field_order.setter
	def field_order(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._field_order = value
	@property
	def start_index(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._start_index
	@start_index.setter
	def start_index(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._start_index = value
	@property
	def field_length(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._field_length
	@field_length.setter
	def field_length(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._field_length = value
class FileImportAuth:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"type_": ("type", "str", None),
		"user": ("user", "str", None),
		"pass_": ("pass", "str", None),
		"region": ("region", "str", None),
		"token": ("token", "str", None),
		"role": ("role", "str", None),
		"mfa": ("mfa", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		type_: Optional["str"] = None,
		user: Optional["str"] = None,
		pass_: Optional["str"] = None,
		region: Optional["str"] = None,
		token: Optional["str"] = None,
		role: Optional["str"] = None,
		mfa: Optional["str"] = None,
	) -> None:
		"""
		:param type_:
		:type type_: str or None
		:param user:
		:type user: str or None
		:param pass_:
		:type pass_: str or None
		:param region:
		:type region: str or None
		:param token:
		:type token: str or None
		:param role:
		:type role: str or None
		:param mfa:
		:type mfa: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._user = cast(Optional[str], kwargs.get("user"))
		self._pass_ = cast(Optional[str], kwargs.get("pass_"))
		self._region = cast(Optional[str], kwargs.get("region"))
		self._token = cast(Optional[str], kwargs.get("token"))
		self._role = cast(Optional[str], kwargs.get("role"))
		self._mfa = cast(Optional[str], kwargs.get("mfa"))
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def user(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._user
	@user.setter
	def user(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._user = value
	@property
	def pass_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._pass_
	@pass_.setter
	def pass_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._pass_ = value
	@property
	def region(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._region
	@region.setter
	def region(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._region = value
	@property
	def token(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._token
	@token.setter
	def token(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._token = value
	@property
	def role(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._role
	@role.setter
	def role(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._role = value
	@property
	def mfa(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._mfa
	@mfa.setter
	def mfa(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._mfa = value
class FileImportOptions:
	"""Various options that affect the import operation."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"suppress_replication": ("suppressReplication", "bool", None),
		"in_progress_change_set_id": ("inProgressChangeSetID", "str", None),
		"archive_password": ("archivePassword", "str", None),
		"request_id": ("requestID", "str", None),
		"auth": ("auth", "FileImportAuth", None),
		"remote_paging": ("remotePaging", "DataPaging", None),
		"active_mq": ("activeMQ", "dict", "str"),
		"rabbit_mq": ("rabbitMQ", "dict", "str"),
		"kafka": ("kafka", "dict", "str"),
		"flight_aware": ("flightAware", "dict", "str"),
		"schema_strictness": ("schemaStrictness", "TransactedTableHandleSchemaStrictMode", None),
		"coerce_columns_to_strict_schema": ("coerceColumnsToStrictSchema", "bool", None),
		"require_all_columns": ("requireAllColumns", "bool", None),
		"schema": ("schema", "DataTransform", None),
		"record_transforms": ("recordTransforms", "RecordTransformOptions", None),
		"nexrad": ("nexrad", "NexradLevel2Request", None),
		"grib": ("grib", "GribConfig", None),
		"imagery": ("imagery", "ImageryConfig", None),
		"net_cdf": ("netCDF", "NetCDFConfig", None),
		"schedule": ("schedule", "DataSetSchedule", None),
		"point_conversion": ("pointConversion", "CoordinateConversion", None),
		"json_mode": ("jsonMode", "JsonFlattenMode", None),
		"in_memory_json_flattening": ("inMemoryJsonFlattening", "bool", None),
		"json_import_roots": ("jsonImportRoots", "list", "str"),
		"json_import_path": ("jsonImportPath", "str", None),
		"delete_remote_data": ("deleteRemoteData", "bool", None),
		"json_geometry_node": ("jsonGeometryNode", "str", None),
		"simplify_column_names": ("simplifyColumnNames", "bool", None),
		"xml_import_roots": ("xmlImportRoots", "list", "str"),
		"xml_xpath_root": ("xmlXPathRoot", "str", None),
		"xml_xpath_columns": ("xmlXPathColumns", "list", "list"),
		"xml_xpath_columns_v2": ("xmlXPathColumnsV2", "list", "XPathItem"),
		"xml_xpath_namespaces": ("xmlXPathNamespaces", "list", "list"),
		"force_geocode": ("forceGeocode", "bool", None),
		"geocode_do_not_include_match_scoring": ("geocodeDoNotIncludeMatchScoring", "bool", None),
		"force_split_wkt": ("forceSplitWKT", "bool", None),
		"swap_coordinates": ("swapCoordinates", "bool", None),
		"multi_geo_table": ("multiGeoTable", "bool", None),
		"multi_table_suffix": ("multiTableSuffix", "str", None),
		"multi_table_prefix": ("multiTablePrefix", "str", None),
		"split_at_date_line": ("splitAtDateLine", "bool", None),
		"hole_mode": ("holeMode", "HoleMode", None),
		"enable_s2_index_for_table": ("enableS2IndexForTable", "bool", None),
		"primary_key_append": ("primaryKeyAppend", "bool", None),
		"add_timestamp": ("addTimestamp", "bool", None),
		"add_source_file_column": ("addSourceFileColumn", "bool", None),
		"ephemeral": ("ephemeral", "bool", None),
		"preserve_geometry_as_string": ("preserveGeometryAsString", "bool", None),
		"contains_arinc_424": ("containsArinc424", "bool", None),
		"arc_gis_exclude_layers": ("arcGISExcludeLayers", "list", "str"),
		"arc_gis_add_second_to_additional_tracking_fields": ("arcGISAddSecondToAdditionalTrackingFields", "bool", None),
		"excluded_properties": ("excludedProperties", "list", "str"),
		"gpx_data": ("gpxData", "GPXImportData", None),
		"http_timeout_seconds": ("httpTimeoutSeconds", "int", None),
		"http_retry_count": ("httpRetryCount", "int", None),
		"http_retry_delay_seconds": ("httpRetryDelaySeconds", "int", None),
		"http_request_total_timeout_seconds": ("httpRequestTotalTimeoutSeconds", "int", None),
		"http_completion_option": ("httpCompletionOption", "HttpCompletionOption", None),
		"raster_cell_size": ("rasterCellSize", "float", None),
		"raster_hole_threshold": ("rasterHoleThreshold", "int", None),
		"transform": ("transform", "RasterTransform", None),
		"raster_aggregate_mode": ("rasterAggregateMode", "AggregateMode", None),
		"raster_interpolate_mode": ("rasterInterpolateMode", "InterpolateMode", None),
		"raster_preserve_bounding_box": ("rasterPreserveBoundingBox", "bool", None),
		"raster_dimension_limit": ("rasterDimensionLimit", "int", None),
		"raster_mode_downsample": ("rasterModeDownsample", "bool", None),
		"s3_connection": ("s3Connection", "S3Config", None),
		"s57": ("s57", "S57Config", None),
		"fs_connection": ("fsConnection", "FilesystemConfig", None),
		"es_connection": ("esConnection", "ElasticSearchConfig", None),
		"skip_header_rows": ("skipHeaderRows", "int", None),
		"explicit_column_headers": ("explicitColumnHeaders", "list", "str"),
		"explicit_delimiter": ("explicitDelimiter", "str", None),
		"explicit_column_types": ("explicitColumnTypes", "dict", "str"),
		"arc_gis_auth": ("arcGisAuth", "ArcGisAuth", None),
		"http_headers": ("httpHeaders", "dict", "str"),
		"realtime": ("realtime", "RealtimeOptions", None),
		"parallel_opts": ("parallelOpts", "ParallelOpts", None),
		"data_import_adapter_type": ("dataImportAdapterType", "str", None),
		"data_import_adapter_parameters": ("dataImportAdapterParameters", "dict", None),
		"json_from_remote": ("jsonFromRemote", "dict", "str"),
		"gdb_ingest_options": ("gdbIngestOptions", "GDBImportOptions", None),
		"suppress_auto_center_point": ("suppressAutoCenterPoint", "bool", None),
		"ignore_cols_with_no_directive": ("ignoreColsWithNoDirective", "bool", None),
		"plugin_config": ("pluginConfig", "dict", None),
		"filter_date_column": ("filterDateColumn", "str", None),
		"filter_date_start": ("filterDateStart", "str", None),
		"filter_date_end": ("filterDateEnd", "str", None),
		"post_import_transforms": ("postImportTransforms", "list", "Query"),
		"pbf_options": ("pbfOptions", "PBFImportOptions", None),
		"las_options": ("lasOptions", "LASImportOptions", None),
		"write_parameters": ("writeParameters", "CCFFWriteParameters", None),
		"keep_new_line": ("keepNewLine", "bool", None),
		"wait_for_full_replication": ("waitForFullReplication", "bool", None),
		"wait_timeout_ms": ("waitTimeoutMS", "int", None),
		"ignore_partitioning": ("ignorePartitioning", "bool", None),
		"partition": ("partition", "MLPartitionedTableTag", None),
		"table_tags": ("tableTags", "list", "MLImportTagData"),
		"unique_constraints": ("uniqueConstraints", "list", "list"),
		"indexes": ("indexes", "list", "IndexCreationOptions"),
		"constraints": ("constraints", "list", "ConstraintOptions"),
		"suppress_index_detection_on_import": ("suppressIndexDetectionOnImport", "bool", None),
		"scheduled_dataset_subtract_minutes": ("scheduledDatasetSubtractMinutes", "int", None),
		"check_files_exist_at_endpoint": ("checkFilesExistAtEndpoint", "CheckFilesExistMode", None),
		"parallel_import": ("parallelImport", "PxImport", None),
		"use_parallel_apply": ("useParallelApply", "bool", None),
		"replication_factor": ("replicationFactor", "int", None),
		"replication_grouping_key": ("replicationGroupingKey", "str", None),
		"insert_only": ("insertOnly", "bool", None),
		"pk_update_constraints": ("pkUpdateConstraints", "UpdateConstraint", None),
		"update_only": ("updateOnly", "bool", None),
		"coordinate_operations": ("coordinateOperations", "list", "CoordinateOperation"),
		"file_type_handler": ("fileTypeHandler", "str", None),
		"system_table_attributes": ("systemTableAttributes", "dict", "str"),
		"user_table_attributes": ("userTableAttributes", "dict", "str"),
		"centroid_max_error_percent_override": ("centroidMaxErrorPercentOverride", "float", None),
		"centroid_mode": ("centroidMode", "CentroidMode", None),
		"guid_identity_column_name": ("guidIdentityColumnName", "str", None),
		"map_tile_coordinates": ("mapTileCoordinates", "MapTileCoordinates", None),
		"video_import_flags": ("videoImportFlags", "str", None),
		"video": ("video", "VideoConfig", None),
		"pipeline_definition": ("pipelineDefinition", "PipelineDefinition", None),
		"well_known_pipeline_name": ("wellKnownPipelineName", "str", None),
		"pipeline_start_step": ("pipelineStartStep", "str", None),
		"pipeline_verbose_logging": ("pipelineVerboseLogging", "bool", None),
		"pipeline_parameters": ("pipelineParameters", "dict", "str"),
		"geocoder_import_header": ("geocoderImportHeader", "GeocoderImportHeaderConfig", None),
		"skip_geocode": ("skipGeocode", "bool", None),
		"force_multipoint_import": ("forceMultipointImport", "bool", None),
		"split_zip_multiple_tables": ("splitZipMultipleTables", "bool", None),
		"use_kml_direct_importer": ("useKmlDirectImporter", "bool", None),
		"detect_nulls": ("detectNulls", "bool", None),
		"file_extension": ("fileExtension", "str", None),
		"index_organized": ("indexOrganized", "IndexOrganizedTableConfig", None),
		"canonical_geometry_column": ("canonicalGeometryColumn", "str", None),
		"exclude_non_canonical_geometries": ("excludeNonCanonicalGeometries", "bool", None),
		"fail_on_nodes": ("failOnNodes", "list", "str"),
		"fail_for_testing": ("failForTesting", "TransactionConsistencyStatus", None),
		"start": ("start", "int", None),
		"take": ("take", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		suppress_replication: Optional["bool"] = None,
		in_progress_change_set_id: Optional["str"] = None,
		archive_password: Optional["str"] = None,
		request_id: Optional["str"] = None,
		auth: Optional["FileImportAuth"] = None,
		remote_paging: Optional["DataPaging"] = None,
		active_mq: Optional["Dict[str, str]"] = None,
		rabbit_mq: Optional["Dict[str, str]"] = None,
		kafka: Optional["Dict[str, str]"] = None,
		flight_aware: Optional["Dict[str, str]"] = None,
		schema_strictness: Optional["TransactedTableHandleSchemaStrictMode"] = None,
		coerce_columns_to_strict_schema: Optional["bool"] = None,
		require_all_columns: Optional["bool"] = None,
		schema: Optional["DataTransform"] = None,
		record_transforms: Optional["RecordTransformOptions"] = None,
		nexrad: Optional["NexradLevel2Request"] = None,
		grib: Optional["GribConfig"] = None,
		imagery: Optional["ImageryConfig"] = None,
		net_cdf: Optional["NetCDFConfig"] = None,
		schedule: Optional["DataSetSchedule"] = None,
		point_conversion: Optional["CoordinateConversion"] = None,
		json_mode: Optional["JsonFlattenMode"] = None,
		in_memory_json_flattening: Optional["bool"] = None,
		json_import_roots: Optional["List[str]"] = None,
		json_import_path: Optional["str"] = None,
		delete_remote_data: Optional["bool"] = None,
		json_geometry_node: Optional["str"] = None,
		simplify_column_names: Optional["bool"] = None,
		xml_import_roots: Optional["List[str]"] = None,
		xml_xpath_root: Optional["str"] = None,
		xml_xpath_columns: Optional["List[List[str]]"] = None,
		xml_xpath_columns_v2: Optional["List[XPathItem]"] = None,
		xml_xpath_namespaces: Optional["List[List[str]]"] = None,
		force_geocode: Optional["bool"] = None,
		geocode_do_not_include_match_scoring: Optional["bool"] = None,
		force_split_wkt: Optional["bool"] = None,
		swap_coordinates: Optional["bool"] = None,
		multi_geo_table: Optional["bool"] = None,
		multi_table_suffix: Optional["str"] = None,
		multi_table_prefix: Optional["str"] = None,
		split_at_date_line: Optional["bool"] = None,
		hole_mode: Optional["HoleMode"] = None,
		enable_s2_index_for_table: Optional["bool"] = None,
		primary_key_append: Optional["bool"] = None,
		add_timestamp: Optional["bool"] = None,
		add_source_file_column: Optional["bool"] = None,
		ephemeral: Optional["bool"] = None,
		preserve_geometry_as_string: Optional["bool"] = None,
		contains_arinc_424: Optional["bool"] = None,
		arc_gis_exclude_layers: Optional["List[str]"] = None,
		arc_gis_add_second_to_additional_tracking_fields: Optional["bool"] = None,
		excluded_properties: Optional["List[str]"] = None,
		gpx_data: Optional["GPXImportData"] = None,
		http_timeout_seconds: Optional["int"] = None,
		http_retry_count: Optional["int"] = None,
		http_retry_delay_seconds: Optional["int"] = None,
		http_request_total_timeout_seconds: Optional["int"] = None,
		http_completion_option: Optional["HttpCompletionOption"] = None,
		raster_cell_size: Optional["float"] = None,
		raster_hole_threshold: Optional["int"] = None,
		transform: Optional["RasterTransform"] = None,
		raster_aggregate_mode: Optional["AggregateMode"] = None,
		raster_interpolate_mode: Optional["InterpolateMode"] = None,
		raster_preserve_bounding_box: Optional["bool"] = None,
		raster_dimension_limit: Optional["int"] = None,
		raster_mode_downsample: Optional["bool"] = None,
		s3_connection: Optional["S3Config"] = None,
		s57: Optional["S57Config"] = None,
		fs_connection: Optional["FilesystemConfig"] = None,
		es_connection: Optional["ElasticSearchConfig"] = None,
		skip_header_rows: Optional["int"] = None,
		explicit_column_headers: Optional["List[str]"] = None,
		explicit_delimiter: Optional["str"] = None,
		explicit_column_types: Optional["Dict[str, str]"] = None,
		arc_gis_auth: Optional["ArcGisAuth"] = None,
		http_headers: Optional["Dict[str, str]"] = None,
		realtime: Optional["RealtimeOptions"] = None,
		parallel_opts: Optional["ParallelOpts"] = None,
		data_import_adapter_type: Optional["str"] = None,
		data_import_adapter_parameters: Optional["Dict[str, Any]"] = None,
		json_from_remote: Optional["Dict[str, str]"] = None,
		gdb_ingest_options: Optional["GDBImportOptions"] = None,
		suppress_auto_center_point: Optional["bool"] = None,
		ignore_cols_with_no_directive: Optional["bool"] = None,
		plugin_config: Optional["Dict[str, Any]"] = None,
		filter_date_column: Optional["str"] = None,
		filter_date_start: Optional["str"] = None,
		filter_date_end: Optional["str"] = None,
		post_import_transforms: Optional["List[Query]"] = None,
		pbf_options: Optional["PBFImportOptions"] = None,
		las_options: Optional["LASImportOptions"] = None,
		write_parameters: Optional["CCFFWriteParameters"] = None,
		keep_new_line: Optional["bool"] = None,
		wait_for_full_replication: Optional["bool"] = None,
		wait_timeout_ms: Optional["int"] = None,
		ignore_partitioning: Optional["bool"] = None,
		partition: Optional["MLPartitionedTableTag"] = None,
		table_tags: Optional["List[MLImportTagData]"] = None,
		unique_constraints: Optional["List[List[str]]"] = None,
		indexes: Optional["List[IndexCreationOptions]"] = None,
		constraints: Optional["List[ConstraintOptions]"] = None,
		suppress_index_detection_on_import: Optional["bool"] = None,
		scheduled_dataset_subtract_minutes: Optional["int"] = None,
		check_files_exist_at_endpoint: Optional["CheckFilesExistMode"] = None,
		parallel_import: Optional["PxImport"] = None,
		use_parallel_apply: Optional["bool"] = None,
		replication_factor: Optional["int"] = None,
		replication_grouping_key: Optional["str"] = None,
		insert_only: Optional["bool"] = None,
		pk_update_constraints: Optional["UpdateConstraint"] = None,
		update_only: Optional["bool"] = None,
		coordinate_operations: Optional["List[CoordinateOperation]"] = None,
		file_type_handler: Optional["str"] = None,
		system_table_attributes: Optional["Dict[str, str]"] = None,
		user_table_attributes: Optional["Dict[str, str]"] = None,
		centroid_max_error_percent_override: Optional["float"] = None,
		centroid_mode: Optional["CentroidMode"] = None,
		guid_identity_column_name: Optional["str"] = None,
		map_tile_coordinates: Optional["MapTileCoordinates"] = None,
		video_import_flags: Optional["str"] = None,
		video: Optional["VideoConfig"] = None,
		pipeline_definition: Optional["PipelineDefinition"] = None,
		well_known_pipeline_name: Optional["str"] = None,
		pipeline_start_step: Optional["str"] = None,
		pipeline_verbose_logging: Optional["bool"] = None,
		pipeline_parameters: Optional["Dict[str, str]"] = None,
		geocoder_import_header: Optional["GeocoderImportHeaderConfig"] = None,
		skip_geocode: Optional["bool"] = None,
		force_multipoint_import: Optional["bool"] = None,
		split_zip_multiple_tables: Optional["bool"] = None,
		use_kml_direct_importer: Optional["bool"] = None,
		detect_nulls: Optional["bool"] = None,
		file_extension: Optional["str"] = None,
		index_organized: Optional["IndexOrganizedTableConfig"] = None,
		canonical_geometry_column: Optional["str"] = None,
		exclude_non_canonical_geometries: Optional["bool"] = None,
		fail_on_nodes: Optional["List[str]"] = None,
		fail_for_testing: Optional["TransactionConsistencyStatus"] = None,
		start: Optional["int"] = None,
		take: Optional["int"] = None,
	) -> None:
		"""
		:param suppress_replication:
		:type suppress_replication: bool or None
		:param in_progress_change_set_id:
		:type in_progress_change_set_id: str or None
		:param archive_password:
		:type archive_password: str or None
		:param request_id:
		:type request_id: str or None
		:param auth:
		:type auth: FileImportAuth or None
		:param remote_paging: Config class to hold pagination values for remote data
		:type remote_paging: DataPaging or None
		:param active_mq:
		:type active_mq: Dict[str, str] or None
		:param rabbit_mq:
		:type rabbit_mq: Dict[str, str] or None
		:param kafka:
		:type kafka: Dict[str, str] or None
		:param flight_aware:
		:type flight_aware: Dict[str, str] or None
		:param schema_strictness:
		:type schema_strictness: TransactedTableHandleSchemaStrictMode or None
		:param coerce_columns_to_strict_schema:
		:type coerce_columns_to_strict_schema: bool or None
		:param require_all_columns:
		:type require_all_columns: bool or None
		:param schema: URL- or source-specific schema values.  Used when a layer- (ArcGIS) or endpoint-specific transformation is needed.
		:type schema: DataTransform or None
		:param record_transforms: Allows for record transforms to the imported data
		:type record_transforms: RecordTransformOptions or None
		:param nexrad:
		:type nexrad: NexradLevel2Request or None
		:param grib:
		:type grib: GribConfig or None
		:param imagery:
		:type imagery: ImageryConfig or None
		:param net_cdf:
		:type net_cdf: NetCDFConfig or None
		:param schedule:
		:type schedule: DataSetSchedule or None
		:param point_conversion: For rasters, this will convert the coordinates from one CRS to another.For vector based data, the coordinate operations are recommended if an explicit conversion is requested.If the import format has information about the CRS, there is a 'KeepNativeProjection' option to use this information (default off)
		:type point_conversion: CoordinateConversion or None
		:param json_mode: Specifies how JSON objects should be flattened.
* `None` - No flattening.
* `FlattenToSingle` - Flatten to a single file (nested arrays get squashed).
* `FlattenToMultiple` - Flatten to multiple files (nested arrays become child tables).
		:type json_mode: JsonFlattenMode or None
		:param in_memory_json_flattening: Flatten to in-memory structures (the JSON itself is already parsed, this just holds it and leverages it further) rather than to intermediate CSV files.
		:type in_memory_json_flattening: bool or None
		:param json_import_roots: Specify one or more paths /a/b/c in the json which represent an array to be consumed.  Useful for nested structures.
		:type json_import_roots: List[str] or None
		:param json_import_path: Specify a path using the https://goessner.net/articles/JsonPath/ syntax to define the import roots.
		:type json_import_path: str or None
		:param delete_remote_data: Specify this to delete remote data read during the import
		:type delete_remote_data: bool or None
		:param json_geometry_node: Specify the node in the JSON that contains the geometry.
		:type json_geometry_node: str or None
		:param simplify_column_names: If true, composite column names from JSON, XML, etc. will be simplified to remove parent prefixes.
		:type simplify_column_names: bool or None
		:param xml_import_roots:
		:type xml_import_roots: List[str] or None
		:param xml_xpath_root:
		:type xml_xpath_root: str or None
		:param xml_xpath_columns:
		:type xml_xpath_columns: List[List[str]] or None
		:param xml_xpath_columns_v2: If XmlXPathColumnsV2 options are used then XmlXPathColumns setting is not used.
		:type xml_xpath_columns_v2: List[XPathItem] or None
		:param xml_xpath_namespaces:
		:type xml_xpath_namespaces: List[List[str]] or None
		:param force_geocode: Even if the import provides lat/lng columns, always run the geocoder.  Geocoder must be enabled.
		:type force_geocode: bool or None
		:param geocode_do_not_include_match_scoring: Don't produce the MatchType, NumMatch, MatchScore columns if this is set and the Geocoder is enabled.
		:type geocode_do_not_include_match_scoring: bool or None
		:param force_split_wkt: If multiple geometry types are detected, they will always be put in individual tables (or columns if MultiGeoTable is set) with Point, Line, Poly suffixes, even if this is not strictly required. Useful for ensuring consistent table naming across import runs.
		:type force_split_wkt: bool or None
		:param swap_coordinates: Swap the x and y coordinates of the incoming data.
		:type swap_coordinates: bool or None
		:param multi_geo_table: If multiple geometry types are split, they will be kept in the same table instead of creating multiple tables (multiple tables is the default).
		:type multi_geo_table: bool or None
		:param multi_table_suffix: Optional MultiTable Suffix.
		:type multi_table_suffix: str or None
		:param multi_table_prefix: Optional MultiTable Prefix.
		:type multi_table_prefix: str or None
		:param split_at_date_line: If true, shapes and lines with segments crossing the dateline will be split so that the length of these segments is less than half the world.
		:type split_at_date_line: bool or None
		:param hole_mode: Specifies how holes will be detected in shapes. Defaults to collision.
		:type hole_mode: HoleMode or None
		:param enable_s2_index_for_table: If true, pre-compute the S2 index for the table at import time and store it on disk. If false, for now the S2 index will not be used for this table.
		:type enable_s2_index_for_table: bool or None
		:param primary_key_append:
		:type primary_key_append: bool or None
		:param add_timestamp: Add a ml_capture_timestamp in UTC to the imported data.
		:type add_timestamp: bool or None
		:param add_source_file_column:
		:type add_source_file_column: bool or None
		:param ephemeral:
		:type ephemeral: bool or None
		:param preserve_geometry_as_string: If specified, and the source JSON contains raw geometry data, preserve it in addition to the generated WKT.
		:type preserve_geometry_as_string: bool or None
		:param contains_arinc_424: Notify the import system that this file or set of files contains ARINC-424 data, and that process should be attempted.
		:type contains_arinc_424: bool or None
		:param arc_gis_exclude_layers: Specific layers to exclude from the pull, if pulling a MapServer URL.
		:type arc_gis_exclude_layers: List[str] or None
		:param arc_gis_add_second_to_additional_tracking_fields:
		:type arc_gis_add_second_to_additional_tracking_fields: bool or None
		:param excluded_properties: Properties from the source which should not be imported. Currently applies to JSON only.
		:type excluded_properties: List[str] or None
		:param gpx_data: Specify what type of data to import from GPX source file.
* `TrackPoints` - Import the points of the tracks as a point layer.
* `Tracks` - Import the tracks as a line layer.
* `Routes` - Import the routes as a line layer.
* `RoutePoints` - Import the points of the routes as a point layer.
		:type gpx_data: GPXImportData or None
		:param http_timeout_seconds:
		:type http_timeout_seconds: int or None
		:param http_retry_count:
		:type http_retry_count: int or None
		:param http_retry_delay_seconds:
		:type http_retry_delay_seconds: int or None
		:param http_request_total_timeout_seconds:
		:type http_request_total_timeout_seconds: int or None
		:param http_completion_option:
		:type http_completion_option: HttpCompletionOption or None
		:param raster_cell_size:
		:type raster_cell_size: float or None
		:param raster_hole_threshold:
		:type raster_hole_threshold: int or None
		:param transform:
		:type transform: RasterTransform or None
		:param raster_aggregate_mode: Defines the behavior when multiple values are in a single cell
* `Avg` - Uses the mean average of the values
* `Min` - Uses the minimum of the values
* `Max` - Uses the maximum of the values
* `TopOnly` - The highest value based on a sort column
		:type raster_aggregate_mode: AggregateMode or None
		:param raster_interpolate_mode: Defines the interpolation method used to calculate the values in between the known data points
* `None` - No interpolation
* `Nearest` - Nearest-neighbor interpolation
* `Linear` - Bilinear interpolation
* `Cubic` - Bicubic interpolation
* `IDW` - Inverse distance weighted interpolation
* `Auto` - Attempts to set the interpolation mode based on the raster band data type
		:type raster_interpolate_mode: InterpolateMode or None
		:param raster_preserve_bounding_box:
		:type raster_preserve_bounding_box: bool or None
		:param raster_dimension_limit:
		:type raster_dimension_limit: int or None
		:param raster_mode_downsample:
		:type raster_mode_downsample: bool or None
		:param s3_connection:
		:type s3_connection: S3Config or None
		:param s57: Use when importing S57 archives
		:type s57: S57Config or None
		:param fs_connection:
		:type fs_connection: FilesystemConfig or None
		:param es_connection:
		:type es_connection: ElasticSearchConfig or None
		:param skip_header_rows:
		:type skip_header_rows: int or None
		:param explicit_column_headers:
		:type explicit_column_headers: List[str] or None
		:param explicit_delimiter:
		:type explicit_delimiter: str or None
		:param explicit_column_types:
		:type explicit_column_types: Dict[str, str] or None
		:param arc_gis_auth:
		:type arc_gis_auth: ArcGisAuth or None
		:param http_headers:
		:type http_headers: Dict[str, str] or None
		:param realtime:
		:type realtime: RealtimeOptions or None
		:param parallel_opts:
		:type parallel_opts: ParallelOpts or None
		:param data_import_adapter_type:
		:type data_import_adapter_type: str or None
		:param data_import_adapter_parameters:
		:type data_import_adapter_parameters: Dict[str, Any] or None
		:param json_from_remote:
		:type json_from_remote: Dict[str, str] or None
		:param gdb_ingest_options: Specify options for GDB Import
		:type gdb_ingest_options: GDBImportOptions or None
		:param suppress_auto_center_point: When a line geometry is imported, a new XY column is created to hold the center point of the line segment. Set to true to suppress auto creation.
		:type suppress_auto_center_point: bool or None
		:param ignore_cols_with_no_directive: Went set to true, columns with no schema directives will be ignored and NOT imported.
		:type ignore_cols_with_no_directive: bool or None
		:param plugin_config:
		:type plugin_config: Dict[str, Any] or None
		:param filter_date_column:
		:type filter_date_column: str or None
		:param filter_date_start:
		:type filter_date_start: str or None
		:param filter_date_end:
		:type filter_date_end: str or None
		:param post_import_transforms:
		:type post_import_transforms: List[Query] or None
		:param pbf_options:
		:type pbf_options: PBFImportOptions or None
		:param las_options:
		:type las_options: LASImportOptions or None
		:param write_parameters:
		:type write_parameters: CCFFWriteParameters or None
		:param keep_new_line: Keep the new line character in the imported data instead of removing it.
		:type keep_new_line: bool or None
		:param wait_for_full_replication:
		:type wait_for_full_replication: bool or None
		:param wait_timeout_ms:
		:type wait_timeout_ms: int or None
		:param ignore_partitioning:
		:type ignore_partitioning: bool or None
		:param partition:
		:type partition: MLPartitionedTableTag or None
		:param table_tags:
		:type table_tags: List[MLImportTagData] or None
		:param unique_constraints:
		:type unique_constraints: List[List[str]] or None
		:param indexes:
		:type indexes: List[IndexCreationOptions] or None
		:param constraints:
		:type constraints: List[ConstraintOptions] or None
		:param suppress_index_detection_on_import:
		:type suppress_index_detection_on_import: bool or None
		:param scheduled_dataset_subtract_minutes:
		:type scheduled_dataset_subtract_minutes: int or None
		:param check_files_exist_at_endpoint:
		:type check_files_exist_at_endpoint: CheckFilesExistMode or None
		:param parallel_import:
		:type parallel_import: PxImport or None
		:param use_parallel_apply:
		:type use_parallel_apply: bool or None
		:param replication_factor:
		:type replication_factor: int or None
		:param replication_grouping_key:
		:type replication_grouping_key: str or None
		:param insert_only:
		:type insert_only: bool or None
		:param pk_update_constraints:
		:type pk_update_constraints: UpdateConstraint or None
		:param update_only:
		:type update_only: bool or None
		:param coordinate_operations: If set, this will allow per column to define the CRS and (if required) perform a conversion to another CRS.
		:type coordinate_operations: List[CoordinateOperation] or None
		:param file_type_handler:
		:type file_type_handler: str or None
		:param system_table_attributes:
		:type system_table_attributes: Dict[str, str] or None
		:param user_table_attributes:
		:type user_table_attributes: Dict[str, str] or None
		:param centroid_max_error_percent_override:
		:type centroid_max_error_percent_override: float or None
		:param centroid_mode: 
* `POI` - Pole Of Inaccessiblity
* `BoundingBox` - Bounding Box
* `Classic` - Classic
* `InscribedCircle` - Inscribed Circle
		:type centroid_mode: CentroidMode or None
		:param guid_identity_column_name:
		:type guid_identity_column_name: str or None
		:param map_tile_coordinates:
		:type map_tile_coordinates: MapTileCoordinates or None
		:param video_import_flags:
		:type video_import_flags: str or None
		:param video:
		:type video: VideoConfig or None
		:param pipeline_definition:
		:type pipeline_definition: PipelineDefinition or None
		:param well_known_pipeline_name:
		:type well_known_pipeline_name: str or None
		:param pipeline_start_step:
		:type pipeline_start_step: str or None
		:param pipeline_verbose_logging:
		:type pipeline_verbose_logging: bool or None
		:param pipeline_parameters:
		:type pipeline_parameters: Dict[str, str] or None
		:param geocoder_import_header:
		:type geocoder_import_header: GeocoderImportHeaderConfig or None
		:param skip_geocode:
		:type skip_geocode: bool or None
		:param force_multipoint_import:
		:type force_multipoint_import: bool or None
		:param split_zip_multiple_tables:
		:type split_zip_multiple_tables: bool or None
		:param use_kml_direct_importer:
		:type use_kml_direct_importer: bool or None
		:param detect_nulls:
		:type detect_nulls: bool or None
		:param file_extension: Specify an intended file extension, either to correct incorrect file extensions, or to force the usage of a different import file handler other than the default one used for the file's extension. Applies to either the imported file itself, or to files within an archive.
		:type file_extension: str or None
		:param index_organized:
		:type index_organized: IndexOrganizedTableConfig or None
		:param canonical_geometry_column: Specifies the name of a canonical geometry column.
		:type canonical_geometry_column: str or None
		:param exclude_non_canonical_geometries: Specifies how non-canonical geometry columns should be handled.
		:type exclude_non_canonical_geometries: bool or None
		:param fail_on_nodes: For testing.  When specified the resulting transaction will fail on nodes with the specified addresses.
		:type fail_on_nodes: List[str] or None
		:param fail_for_testing: For testing.  When specified the resulting transaction will fail in the manner specified.
		:type fail_for_testing: TransactionConsistencyStatus or None
		:param start: Starting offset for records in the input file. Supported by parquet imports.
		:type start: int or None
		:param take: Take at most this many records from the input file. Supported by parquet imports.
		:type take: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._suppress_replication = cast(Optional[bool], kwargs.get("suppress_replication"))
		self._in_progress_change_set_id = cast(Optional[str], kwargs.get("in_progress_change_set_id"))
		self._archive_password = cast(Optional[str], kwargs.get("archive_password"))
		self._request_id = cast(Optional[str], kwargs.get("request_id"))
		self._auth = cast(Optional[FileImportAuth], kwargs.get("auth"))
		self._remote_paging = cast(Optional[DataPaging], kwargs.get("remote_paging"))
		self._active_mq = cast(Optional[Dict[str, str]], kwargs.get("active_mq"))
		self._rabbit_mq = cast(Optional[Dict[str, str]], kwargs.get("rabbit_mq"))
		self._kafka = cast(Optional[Dict[str, str]], kwargs.get("kafka"))
		self._flight_aware = cast(Optional[Dict[str, str]], kwargs.get("flight_aware"))
		self._schema_strictness = cast(Optional[TransactedTableHandleSchemaStrictMode], kwargs.get("schema_strictness"))
		self._coerce_columns_to_strict_schema = cast(Optional[bool], kwargs.get("coerce_columns_to_strict_schema"))
		self._require_all_columns = cast(Optional[bool], kwargs.get("require_all_columns"))
		self._schema = cast(Optional[DataTransform], kwargs.get("schema"))
		self._record_transforms = cast(Optional[RecordTransformOptions], kwargs.get("record_transforms"))
		self._nexrad = cast(Optional[NexradLevel2Request], kwargs.get("nexrad"))
		self._grib = cast(Optional[GribConfig], kwargs.get("grib"))
		self._imagery = cast(Optional[ImageryConfig], kwargs.get("imagery"))
		self._net_cdf = cast(Optional[NetCDFConfig], kwargs.get("net_cdf"))
		self._schedule = cast(Optional[DataSetSchedule], kwargs.get("schedule"))
		self._point_conversion = cast(Optional[CoordinateConversion], kwargs.get("point_conversion"))
		self._json_mode = cast(Optional[JsonFlattenMode], kwargs.get("json_mode"))
		self._in_memory_json_flattening = cast(Optional[bool], kwargs.get("in_memory_json_flattening"))
		self._json_import_roots = cast(Optional[List[str]], kwargs.get("json_import_roots"))
		self._json_import_path = cast(Optional[str], kwargs.get("json_import_path"))
		self._delete_remote_data = cast(Optional[bool], kwargs.get("delete_remote_data"))
		self._json_geometry_node = cast(Optional[str], kwargs.get("json_geometry_node"))
		self._simplify_column_names = cast(Optional[bool], kwargs.get("simplify_column_names"))
		self._xml_import_roots = cast(Optional[List[str]], kwargs.get("xml_import_roots"))
		self._xml_xpath_root = cast(Optional[str], kwargs.get("xml_xpath_root"))
		self._xml_xpath_columns = cast(Optional[List[List[str]]], kwargs.get("xml_xpath_columns"))
		self._xml_xpath_columns_v2 = cast(Optional[List[XPathItem]], kwargs.get("xml_xpath_columns_v2"))
		self._xml_xpath_namespaces = cast(Optional[List[List[str]]], kwargs.get("xml_xpath_namespaces"))
		self._force_geocode = cast(Optional[bool], kwargs.get("force_geocode"))
		self._geocode_do_not_include_match_scoring = cast(Optional[bool], kwargs.get("geocode_do_not_include_match_scoring"))
		self._force_split_wkt = cast(Optional[bool], kwargs.get("force_split_wkt"))
		self._swap_coordinates = cast(Optional[bool], kwargs.get("swap_coordinates"))
		self._multi_geo_table = cast(Optional[bool], kwargs.get("multi_geo_table"))
		self._multi_table_suffix = cast(Optional[str], kwargs.get("multi_table_suffix"))
		self._multi_table_prefix = cast(Optional[str], kwargs.get("multi_table_prefix"))
		self._split_at_date_line = cast(Optional[bool], kwargs.get("split_at_date_line"))
		self._hole_mode = cast(Optional[HoleMode], kwargs.get("hole_mode"))
		self._enable_s2_index_for_table = cast(Optional[bool], kwargs.get("enable_s2_index_for_table"))
		self._primary_key_append = cast(Optional[bool], kwargs.get("primary_key_append"))
		self._add_timestamp = cast(Optional[bool], kwargs.get("add_timestamp"))
		self._add_source_file_column = cast(Optional[bool], kwargs.get("add_source_file_column"))
		self._ephemeral = cast(Optional[bool], kwargs.get("ephemeral"))
		self._preserve_geometry_as_string = cast(Optional[bool], kwargs.get("preserve_geometry_as_string"))
		self._contains_arinc_424 = cast(Optional[bool], kwargs.get("contains_arinc_424"))
		self._arc_gis_exclude_layers = cast(Optional[List[str]], kwargs.get("arc_gis_exclude_layers"))
		self._arc_gis_add_second_to_additional_tracking_fields = cast(Optional[bool], kwargs.get("arc_gis_add_second_to_additional_tracking_fields"))
		self._excluded_properties = cast(Optional[List[str]], kwargs.get("excluded_properties"))
		self._gpx_data = cast(Optional[GPXImportData], kwargs.get("gpx_data"))
		self._http_timeout_seconds = cast(Optional[int], kwargs.get("http_timeout_seconds"))
		self._http_retry_count = cast(Optional[int], kwargs.get("http_retry_count"))
		self._http_retry_delay_seconds = cast(Optional[int], kwargs.get("http_retry_delay_seconds"))
		self._http_request_total_timeout_seconds = cast(Optional[int], kwargs.get("http_request_total_timeout_seconds"))
		self._http_completion_option = cast(Optional[HttpCompletionOption], kwargs.get("http_completion_option"))
		self._raster_cell_size = cast(Optional[float], kwargs.get("raster_cell_size"))
		self._raster_hole_threshold = cast(Optional[int], kwargs.get("raster_hole_threshold"))
		self._transform = cast(Optional[RasterTransform], kwargs.get("transform"))
		self._raster_aggregate_mode = cast(Optional[AggregateMode], kwargs.get("raster_aggregate_mode"))
		self._raster_interpolate_mode = cast(Optional[InterpolateMode], kwargs.get("raster_interpolate_mode"))
		self._raster_preserve_bounding_box = cast(Optional[bool], kwargs.get("raster_preserve_bounding_box"))
		self._raster_dimension_limit = cast(Optional[int], kwargs.get("raster_dimension_limit"))
		self._raster_mode_downsample = cast(Optional[bool], kwargs.get("raster_mode_downsample"))
		self._s3_connection = cast(Optional[S3Config], kwargs.get("s3_connection"))
		self._s57 = cast(Optional[S57Config], kwargs.get("s57"))
		self._fs_connection = cast(Optional[FilesystemConfig], kwargs.get("fs_connection"))
		self._es_connection = cast(Optional[ElasticSearchConfig], kwargs.get("es_connection"))
		self._skip_header_rows = cast(Optional[int], kwargs.get("skip_header_rows"))
		self._explicit_column_headers = cast(Optional[List[str]], kwargs.get("explicit_column_headers"))
		self._explicit_delimiter = cast(Optional[str], kwargs.get("explicit_delimiter"))
		self._explicit_column_types = cast(Optional[Dict[str, str]], kwargs.get("explicit_column_types"))
		self._arc_gis_auth = cast(Optional[ArcGisAuth], kwargs.get("arc_gis_auth"))
		self._http_headers = cast(Optional[Dict[str, str]], kwargs.get("http_headers"))
		self._realtime = cast(Optional[RealtimeOptions], kwargs.get("realtime"))
		self._parallel_opts = cast(Optional[ParallelOpts], kwargs.get("parallel_opts"))
		self._data_import_adapter_type = cast(Optional[str], kwargs.get("data_import_adapter_type"))
		self._data_import_adapter_parameters = cast(Optional[Dict[str, Any]], kwargs.get("data_import_adapter_parameters"))
		self._json_from_remote = cast(Optional[Dict[str, str]], kwargs.get("json_from_remote"))
		self._gdb_ingest_options = cast(Optional[GDBImportOptions], kwargs.get("gdb_ingest_options"))
		self._suppress_auto_center_point = cast(Optional[bool], kwargs.get("suppress_auto_center_point"))
		self._ignore_cols_with_no_directive = cast(Optional[bool], kwargs.get("ignore_cols_with_no_directive"))
		self._plugin_config = cast(Optional[Dict[str, Any]], kwargs.get("plugin_config"))
		self._filter_date_column = cast(Optional[str], kwargs.get("filter_date_column"))
		self._filter_date_start = cast(Optional[str], kwargs.get("filter_date_start"))
		self._filter_date_end = cast(Optional[str], kwargs.get("filter_date_end"))
		self._post_import_transforms = cast(Optional[List[Query]], kwargs.get("post_import_transforms"))
		self._pbf_options = cast(Optional[PBFImportOptions], kwargs.get("pbf_options"))
		self._las_options = cast(Optional[LASImportOptions], kwargs.get("las_options"))
		self._write_parameters = cast(Optional[CCFFWriteParameters], kwargs.get("write_parameters"))
		self._keep_new_line = cast(Optional[bool], kwargs.get("keep_new_line"))
		self._wait_for_full_replication = cast(Optional[bool], kwargs.get("wait_for_full_replication"))
		self._wait_timeout_ms = cast(Optional[int], kwargs.get("wait_timeout_ms"))
		self._ignore_partitioning = cast(Optional[bool], kwargs.get("ignore_partitioning"))
		self._partition = cast(Optional[MLPartitionedTableTag], kwargs.get("partition"))
		self._table_tags = cast(Optional[List[MLImportTagData]], kwargs.get("table_tags"))
		self._unique_constraints = cast(Optional[List[List[str]]], kwargs.get("unique_constraints"))
		self._indexes = cast(Optional[List[IndexCreationOptions]], kwargs.get("indexes"))
		self._constraints = cast(Optional[List[ConstraintOptions]], kwargs.get("constraints"))
		self._suppress_index_detection_on_import = cast(Optional[bool], kwargs.get("suppress_index_detection_on_import"))
		self._scheduled_dataset_subtract_minutes = cast(Optional[int], kwargs.get("scheduled_dataset_subtract_minutes"))
		self._check_files_exist_at_endpoint = cast(Optional[CheckFilesExistMode], kwargs.get("check_files_exist_at_endpoint"))
		self._parallel_import = cast(Optional[PxImport], kwargs.get("parallel_import"))
		self._use_parallel_apply = cast(Optional[bool], kwargs.get("use_parallel_apply"))
		self._replication_factor = cast(Optional[int], kwargs.get("replication_factor"))
		self._replication_grouping_key = cast(Optional[str], kwargs.get("replication_grouping_key"))
		self._insert_only = cast(Optional[bool], kwargs.get("insert_only"))
		self._pk_update_constraints = cast(Optional[UpdateConstraint], kwargs.get("pk_update_constraints"))
		self._update_only = cast(Optional[bool], kwargs.get("update_only"))
		self._coordinate_operations = cast(Optional[List[CoordinateOperation]], kwargs.get("coordinate_operations"))
		self._file_type_handler = cast(Optional[str], kwargs.get("file_type_handler"))
		self._system_table_attributes = cast(Optional[Dict[str, str]], kwargs.get("system_table_attributes"))
		self._user_table_attributes = cast(Optional[Dict[str, str]], kwargs.get("user_table_attributes"))
		self._centroid_max_error_percent_override = cast(Optional[float], kwargs.get("centroid_max_error_percent_override"))
		self._centroid_mode = cast(Optional[CentroidMode], kwargs.get("centroid_mode"))
		self._guid_identity_column_name = cast(Optional[str], kwargs.get("guid_identity_column_name"))
		self._map_tile_coordinates = cast(Optional[MapTileCoordinates], kwargs.get("map_tile_coordinates"))
		self._video_import_flags = cast(Optional[str], kwargs.get("video_import_flags"))
		self._video = cast(Optional[VideoConfig], kwargs.get("video"))
		self._pipeline_definition = cast(Optional[PipelineDefinition], kwargs.get("pipeline_definition"))
		self._well_known_pipeline_name = cast(Optional[str], kwargs.get("well_known_pipeline_name"))
		self._pipeline_start_step = cast(Optional[str], kwargs.get("pipeline_start_step"))
		self._pipeline_verbose_logging = cast(Optional[bool], kwargs.get("pipeline_verbose_logging"))
		self._pipeline_parameters = cast(Optional[Dict[str, str]], kwargs.get("pipeline_parameters"))
		self._geocoder_import_header = cast(Optional[GeocoderImportHeaderConfig], kwargs.get("geocoder_import_header"))
		self._skip_geocode = cast(Optional[bool], kwargs.get("skip_geocode"))
		self._force_multipoint_import = cast(Optional[bool], kwargs.get("force_multipoint_import"))
		self._split_zip_multiple_tables = cast(Optional[bool], kwargs.get("split_zip_multiple_tables"))
		self._use_kml_direct_importer = cast(Optional[bool], kwargs.get("use_kml_direct_importer"))
		self._detect_nulls = cast(Optional[bool], kwargs.get("detect_nulls"))
		self._file_extension = cast(Optional[str], kwargs.get("file_extension"))
		self._index_organized = cast(Optional[IndexOrganizedTableConfig], kwargs.get("index_organized"))
		self._canonical_geometry_column = cast(Optional[str], kwargs.get("canonical_geometry_column"))
		self._exclude_non_canonical_geometries = cast(Optional[bool], kwargs.get("exclude_non_canonical_geometries"))
		self._fail_on_nodes = cast(Optional[List[str]], kwargs.get("fail_on_nodes"))
		self._fail_for_testing = cast(Optional[TransactionConsistencyStatus], kwargs.get("fail_for_testing"))
		self._start = cast(Optional[int], kwargs.get("start"))
		self._take = cast(Optional[int], kwargs.get("take"))
	@property
	def suppress_replication(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._suppress_replication
	@suppress_replication.setter
	def suppress_replication(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._suppress_replication = value
	@property
	def in_progress_change_set_id(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._in_progress_change_set_id
	@in_progress_change_set_id.setter
	def in_progress_change_set_id(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._in_progress_change_set_id = value
	@property
	def archive_password(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._archive_password
	@archive_password.setter
	def archive_password(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._archive_password = value
	@property
	def request_id(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._request_id
	@request_id.setter
	def request_id(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._request_id = value
	@property
	def auth(self) -> Optional["FileImportAuth"]:
		# pylint: disable=missing-function-docstring
		return self._auth
	@auth.setter
	def auth(self, value: Optional["FileImportAuth"]) -> None:
		# pylint: disable=missing-function-docstring
		self._auth = value
	@property
	def remote_paging(self) -> Optional["DataPaging"]:
		"""Config class to hold pagination values for remote data"""
		return self._remote_paging
	@remote_paging.setter
	def remote_paging(self, value: Optional["DataPaging"]) -> None:
		"""Config class to hold pagination values for remote data"""
		self._remote_paging = value
	@property
	def active_mq(self) -> Optional["Dict[str, str]"]:
		# pylint: disable=missing-function-docstring
		return self._active_mq
	@active_mq.setter
	def active_mq(self, value: Optional["Dict[str, str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._active_mq = value
	@property
	def rabbit_mq(self) -> Optional["Dict[str, str]"]:
		# pylint: disable=missing-function-docstring
		return self._rabbit_mq
	@rabbit_mq.setter
	def rabbit_mq(self, value: Optional["Dict[str, str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rabbit_mq = value
	@property
	def kafka(self) -> Optional["Dict[str, str]"]:
		# pylint: disable=missing-function-docstring
		return self._kafka
	@kafka.setter
	def kafka(self, value: Optional["Dict[str, str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._kafka = value
	@property
	def flight_aware(self) -> Optional["Dict[str, str]"]:
		# pylint: disable=missing-function-docstring
		return self._flight_aware
	@flight_aware.setter
	def flight_aware(self, value: Optional["Dict[str, str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._flight_aware = value
	@property
	def schema_strictness(self) -> Optional["TransactedTableHandleSchemaStrictMode"]:
		# pylint: disable=missing-function-docstring
		return self._schema_strictness
	@schema_strictness.setter
	def schema_strictness(self, value: Optional["TransactedTableHandleSchemaStrictMode"]) -> None:
		# pylint: disable=missing-function-docstring
		self._schema_strictness = value
	@property
	def coerce_columns_to_strict_schema(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._coerce_columns_to_strict_schema
	@coerce_columns_to_strict_schema.setter
	def coerce_columns_to_strict_schema(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._coerce_columns_to_strict_schema = value
	@property
	def require_all_columns(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._require_all_columns
	@require_all_columns.setter
	def require_all_columns(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._require_all_columns = value
	@property
	def schema(self) -> Optional["DataTransform"]:
		"""URL- or source-specific schema values.  Used when a layer- (ArcGIS) or endpoint-specific transformation is needed."""
		return self._schema
	@schema.setter
	def schema(self, value: Optional["DataTransform"]) -> None:
		"""URL- or source-specific schema values.  Used when a layer- (ArcGIS) or endpoint-specific transformation is needed."""
		self._schema = value
	@property
	def record_transforms(self) -> Optional["RecordTransformOptions"]:
		"""Allows for record transforms to the imported data"""
		return self._record_transforms
	@record_transforms.setter
	def record_transforms(self, value: Optional["RecordTransformOptions"]) -> None:
		"""Allows for record transforms to the imported data"""
		self._record_transforms = value
	@property
	def nexrad(self) -> Optional["NexradLevel2Request"]:
		# pylint: disable=missing-function-docstring
		return self._nexrad
	@nexrad.setter
	def nexrad(self, value: Optional["NexradLevel2Request"]) -> None:
		# pylint: disable=missing-function-docstring
		self._nexrad = value
	@property
	def grib(self) -> Optional["GribConfig"]:
		# pylint: disable=missing-function-docstring
		return self._grib
	@grib.setter
	def grib(self, value: Optional["GribConfig"]) -> None:
		# pylint: disable=missing-function-docstring
		self._grib = value
	@property
	def imagery(self) -> Optional["ImageryConfig"]:
		# pylint: disable=missing-function-docstring
		return self._imagery
	@imagery.setter
	def imagery(self, value: Optional["ImageryConfig"]) -> None:
		# pylint: disable=missing-function-docstring
		self._imagery = value
	@property
	def net_cdf(self) -> Optional["NetCDFConfig"]:
		# pylint: disable=missing-function-docstring
		return self._net_cdf
	@net_cdf.setter
	def net_cdf(self, value: Optional["NetCDFConfig"]) -> None:
		# pylint: disable=missing-function-docstring
		self._net_cdf = value
	@property
	def schedule(self) -> Optional["DataSetSchedule"]:
		# pylint: disable=missing-function-docstring
		return self._schedule
	@schedule.setter
	def schedule(self, value: Optional["DataSetSchedule"]) -> None:
		# pylint: disable=missing-function-docstring
		self._schedule = value
	@property
	def point_conversion(self) -> Optional["CoordinateConversion"]:
		"""For rasters, this will convert the coordinates from one CRS to another.For vector based data, the coordinate operations are recommended if an explicit conversion is requested.If the import format has information about the CRS, there is a 'KeepNativeProjection' option to use this information (default off)"""
		return self._point_conversion
	@point_conversion.setter
	def point_conversion(self, value: Optional["CoordinateConversion"]) -> None:
		"""For rasters, this will convert the coordinates from one CRS to another.For vector based data, the coordinate operations are recommended if an explicit conversion is requested.If the import format has information about the CRS, there is a 'KeepNativeProjection' option to use this information (default off)"""
		self._point_conversion = value
	@property
	def json_mode(self) -> Optional["JsonFlattenMode"]:
		"""Specifies how JSON objects should be flattened.
* `None` - No flattening.
* `FlattenToSingle` - Flatten to a single file (nested arrays get squashed).
* `FlattenToMultiple` - Flatten to multiple files (nested arrays become child tables)."""
		return self._json_mode
	@json_mode.setter
	def json_mode(self, value: Optional["JsonFlattenMode"]) -> None:
		"""Specifies how JSON objects should be flattened.
* `None` - No flattening.
* `FlattenToSingle` - Flatten to a single file (nested arrays get squashed).
* `FlattenToMultiple` - Flatten to multiple files (nested arrays become child tables)."""
		self._json_mode = value
	@property
	def in_memory_json_flattening(self) -> Optional["bool"]:
		"""Flatten to in-memory structures (the JSON itself is already parsed, this just holds it and leverages it further) rather than to intermediate CSV files."""
		return self._in_memory_json_flattening
	@in_memory_json_flattening.setter
	def in_memory_json_flattening(self, value: Optional["bool"]) -> None:
		"""Flatten to in-memory structures (the JSON itself is already parsed, this just holds it and leverages it further) rather than to intermediate CSV files."""
		self._in_memory_json_flattening = value
	@property
	def json_import_roots(self) -> Optional["List[str]"]:
		"""Specify one or more paths /a/b/c in the json which represent an array to be consumed.  Useful for nested structures."""
		return self._json_import_roots
	@json_import_roots.setter
	def json_import_roots(self, value: Optional["List[str]"]) -> None:
		"""Specify one or more paths /a/b/c in the json which represent an array to be consumed.  Useful for nested structures."""
		self._json_import_roots = value
	@property
	def json_import_path(self) -> Optional["str"]:
		"""Specify a path using the https://goessner.net/articles/JsonPath/ syntax to define the import roots."""
		return self._json_import_path
	@json_import_path.setter
	def json_import_path(self, value: Optional["str"]) -> None:
		"""Specify a path using the https://goessner.net/articles/JsonPath/ syntax to define the import roots."""
		self._json_import_path = value
	@property
	def delete_remote_data(self) -> Optional["bool"]:
		"""Specify this to delete remote data read during the import"""
		return self._delete_remote_data
	@delete_remote_data.setter
	def delete_remote_data(self, value: Optional["bool"]) -> None:
		"""Specify this to delete remote data read during the import"""
		self._delete_remote_data = value
	@property
	def json_geometry_node(self) -> Optional["str"]:
		"""Specify the node in the JSON that contains the geometry."""
		return self._json_geometry_node
	@json_geometry_node.setter
	def json_geometry_node(self, value: Optional["str"]) -> None:
		"""Specify the node in the JSON that contains the geometry."""
		self._json_geometry_node = value
	@property
	def simplify_column_names(self) -> Optional["bool"]:
		"""If true, composite column names from JSON, XML, etc. will be simplified to remove parent prefixes."""
		return self._simplify_column_names
	@simplify_column_names.setter
	def simplify_column_names(self, value: Optional["bool"]) -> None:
		"""If true, composite column names from JSON, XML, etc. will be simplified to remove parent prefixes."""
		self._simplify_column_names = value
	@property
	def xml_import_roots(self) -> Optional["List[str]"]:
		# pylint: disable=missing-function-docstring
		return self._xml_import_roots
	@xml_import_roots.setter
	def xml_import_roots(self, value: Optional["List[str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xml_import_roots = value
	@property
	def xml_xpath_root(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._xml_xpath_root
	@xml_xpath_root.setter
	def xml_xpath_root(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xml_xpath_root = value
	@property
	def xml_xpath_columns(self) -> Optional["List[List[str]]"]:
		# pylint: disable=missing-function-docstring
		return self._xml_xpath_columns
	@xml_xpath_columns.setter
	def xml_xpath_columns(self, value: Optional["List[List[str]]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xml_xpath_columns = value
	@property
	def xml_xpath_columns_v2(self) -> Optional["List[XPathItem]"]:
		"""If XmlXPathColumnsV2 options are used then XmlXPathColumns setting is not used."""
		return self._xml_xpath_columns_v2
	@xml_xpath_columns_v2.setter
	def xml_xpath_columns_v2(self, value: Optional["List[XPathItem]"]) -> None:
		"""If XmlXPathColumnsV2 options are used then XmlXPathColumns setting is not used."""
		self._xml_xpath_columns_v2 = value
	@property
	def xml_xpath_namespaces(self) -> Optional["List[List[str]]"]:
		# pylint: disable=missing-function-docstring
		return self._xml_xpath_namespaces
	@xml_xpath_namespaces.setter
	def xml_xpath_namespaces(self, value: Optional["List[List[str]]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xml_xpath_namespaces = value
	@property
	def force_geocode(self) -> Optional["bool"]:
		"""Even if the import provides lat/lng columns, always run the geocoder.  Geocoder must be enabled."""
		return self._force_geocode
	@force_geocode.setter
	def force_geocode(self, value: Optional["bool"]) -> None:
		"""Even if the import provides lat/lng columns, always run the geocoder.  Geocoder must be enabled."""
		self._force_geocode = value
	@property
	def geocode_do_not_include_match_scoring(self) -> Optional["bool"]:
		"""Don't produce the MatchType, NumMatch, MatchScore columns if this is set and the Geocoder is enabled."""
		return self._geocode_do_not_include_match_scoring
	@geocode_do_not_include_match_scoring.setter
	def geocode_do_not_include_match_scoring(self, value: Optional["bool"]) -> None:
		"""Don't produce the MatchType, NumMatch, MatchScore columns if this is set and the Geocoder is enabled."""
		self._geocode_do_not_include_match_scoring = value
	@property
	def force_split_wkt(self) -> Optional["bool"]:
		"""If multiple geometry types are detected, they will always be put in individual tables (or columns if MultiGeoTable is set) with Point, Line, Poly suffixes, even if this is not strictly required. Useful for ensuring consistent table naming across import runs."""
		return self._force_split_wkt
	@force_split_wkt.setter
	def force_split_wkt(self, value: Optional["bool"]) -> None:
		"""If multiple geometry types are detected, they will always be put in individual tables (or columns if MultiGeoTable is set) with Point, Line, Poly suffixes, even if this is not strictly required. Useful for ensuring consistent table naming across import runs."""
		self._force_split_wkt = value
	@property
	def swap_coordinates(self) -> Optional["bool"]:
		"""Swap the x and y coordinates of the incoming data."""
		return self._swap_coordinates
	@swap_coordinates.setter
	def swap_coordinates(self, value: Optional["bool"]) -> None:
		"""Swap the x and y coordinates of the incoming data."""
		self._swap_coordinates = value
	@property
	def multi_geo_table(self) -> Optional["bool"]:
		"""If multiple geometry types are split, they will be kept in the same table instead of creating multiple tables (multiple tables is the default)."""
		return self._multi_geo_table
	@multi_geo_table.setter
	def multi_geo_table(self, value: Optional["bool"]) -> None:
		"""If multiple geometry types are split, they will be kept in the same table instead of creating multiple tables (multiple tables is the default)."""
		self._multi_geo_table = value
	@property
	def multi_table_suffix(self) -> Optional["str"]:
		"""Optional MultiTable Suffix."""
		return self._multi_table_suffix
	@multi_table_suffix.setter
	def multi_table_suffix(self, value: Optional["str"]) -> None:
		"""Optional MultiTable Suffix."""
		self._multi_table_suffix = value
	@property
	def multi_table_prefix(self) -> Optional["str"]:
		"""Optional MultiTable Prefix."""
		return self._multi_table_prefix
	@multi_table_prefix.setter
	def multi_table_prefix(self, value: Optional["str"]) -> None:
		"""Optional MultiTable Prefix."""
		self._multi_table_prefix = value
	@property
	def split_at_date_line(self) -> Optional["bool"]:
		"""If true, shapes and lines with segments crossing the dateline will be split so that the length of these segments is less than half the world."""
		return self._split_at_date_line
	@split_at_date_line.setter
	def split_at_date_line(self, value: Optional["bool"]) -> None:
		"""If true, shapes and lines with segments crossing the dateline will be split so that the length of these segments is less than half the world."""
		self._split_at_date_line = value
	@property
	def hole_mode(self) -> Optional["HoleMode"]:
		"""Specifies how holes will be detected in shapes. Defaults to collision."""
		return self._hole_mode
	@hole_mode.setter
	def hole_mode(self, value: Optional["HoleMode"]) -> None:
		"""Specifies how holes will be detected in shapes. Defaults to collision."""
		self._hole_mode = value
	@property
	def enable_s2_index_for_table(self) -> Optional["bool"]:
		"""If true, pre-compute the S2 index for the table at import time and store it on disk. If false, for now the S2 index will not be used for this table."""
		return self._enable_s2_index_for_table
	@enable_s2_index_for_table.setter
	def enable_s2_index_for_table(self, value: Optional["bool"]) -> None:
		"""If true, pre-compute the S2 index for the table at import time and store it on disk. If false, for now the S2 index will not be used for this table."""
		self._enable_s2_index_for_table = value
	@property
	def primary_key_append(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._primary_key_append
	@primary_key_append.setter
	def primary_key_append(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._primary_key_append = value
	@property
	def add_timestamp(self) -> Optional["bool"]:
		"""Add a ml_capture_timestamp in UTC to the imported data."""
		return self._add_timestamp
	@add_timestamp.setter
	def add_timestamp(self, value: Optional["bool"]) -> None:
		"""Add a ml_capture_timestamp in UTC to the imported data."""
		self._add_timestamp = value
	@property
	def add_source_file_column(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._add_source_file_column
	@add_source_file_column.setter
	def add_source_file_column(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._add_source_file_column = value
	@property
	def ephemeral(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._ephemeral
	@ephemeral.setter
	def ephemeral(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._ephemeral = value
	@property
	def preserve_geometry_as_string(self) -> Optional["bool"]:
		"""If specified, and the source JSON contains raw geometry data, preserve it in addition to the generated WKT."""
		return self._preserve_geometry_as_string
	@preserve_geometry_as_string.setter
	def preserve_geometry_as_string(self, value: Optional["bool"]) -> None:
		"""If specified, and the source JSON contains raw geometry data, preserve it in addition to the generated WKT."""
		self._preserve_geometry_as_string = value
	@property
	def contains_arinc_424(self) -> Optional["bool"]:
		"""Notify the import system that this file or set of files contains ARINC-424 data, and that process should be attempted."""
		return self._contains_arinc_424
	@contains_arinc_424.setter
	def contains_arinc_424(self, value: Optional["bool"]) -> None:
		"""Notify the import system that this file or set of files contains ARINC-424 data, and that process should be attempted."""
		self._contains_arinc_424 = value
	@property
	def arc_gis_exclude_layers(self) -> Optional["List[str]"]:
		"""Specific layers to exclude from the pull, if pulling a MapServer URL."""
		return self._arc_gis_exclude_layers
	@arc_gis_exclude_layers.setter
	def arc_gis_exclude_layers(self, value: Optional["List[str]"]) -> None:
		"""Specific layers to exclude from the pull, if pulling a MapServer URL."""
		self._arc_gis_exclude_layers = value
	@property
	def arc_gis_add_second_to_additional_tracking_fields(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._arc_gis_add_second_to_additional_tracking_fields
	@arc_gis_add_second_to_additional_tracking_fields.setter
	def arc_gis_add_second_to_additional_tracking_fields(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._arc_gis_add_second_to_additional_tracking_fields = value
	@property
	def excluded_properties(self) -> Optional["List[str]"]:
		"""Properties from the source which should not be imported. Currently applies to JSON only."""
		return self._excluded_properties
	@excluded_properties.setter
	def excluded_properties(self, value: Optional["List[str]"]) -> None:
		"""Properties from the source which should not be imported. Currently applies to JSON only."""
		self._excluded_properties = value
	@property
	def gpx_data(self) -> Optional["GPXImportData"]:
		"""Specify what type of data to import from GPX source file.
* `TrackPoints` - Import the points of the tracks as a point layer.
* `Tracks` - Import the tracks as a line layer.
* `Routes` - Import the routes as a line layer.
* `RoutePoints` - Import the points of the routes as a point layer."""
		return self._gpx_data
	@gpx_data.setter
	def gpx_data(self, value: Optional["GPXImportData"]) -> None:
		"""Specify what type of data to import from GPX source file.
* `TrackPoints` - Import the points of the tracks as a point layer.
* `Tracks` - Import the tracks as a line layer.
* `Routes` - Import the routes as a line layer.
* `RoutePoints` - Import the points of the routes as a point layer."""
		self._gpx_data = value
	@property
	def http_timeout_seconds(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._http_timeout_seconds
	@http_timeout_seconds.setter
	def http_timeout_seconds(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._http_timeout_seconds = value
	@property
	def http_retry_count(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._http_retry_count
	@http_retry_count.setter
	def http_retry_count(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._http_retry_count = value
	@property
	def http_retry_delay_seconds(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._http_retry_delay_seconds
	@http_retry_delay_seconds.setter
	def http_retry_delay_seconds(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._http_retry_delay_seconds = value
	@property
	def http_request_total_timeout_seconds(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._http_request_total_timeout_seconds
	@http_request_total_timeout_seconds.setter
	def http_request_total_timeout_seconds(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._http_request_total_timeout_seconds = value
	@property
	def http_completion_option(self) -> Optional["HttpCompletionOption"]:
		# pylint: disable=missing-function-docstring
		return self._http_completion_option
	@http_completion_option.setter
	def http_completion_option(self, value: Optional["HttpCompletionOption"]) -> None:
		# pylint: disable=missing-function-docstring
		self._http_completion_option = value
	@property
	def raster_cell_size(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._raster_cell_size
	@raster_cell_size.setter
	def raster_cell_size(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_cell_size = value
	@property
	def raster_hole_threshold(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._raster_hole_threshold
	@raster_hole_threshold.setter
	def raster_hole_threshold(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_hole_threshold = value
	@property
	def transform(self) -> Optional["RasterTransform"]:
		# pylint: disable=missing-function-docstring
		return self._transform
	@transform.setter
	def transform(self, value: Optional["RasterTransform"]) -> None:
		# pylint: disable=missing-function-docstring
		self._transform = value
	@property
	def raster_aggregate_mode(self) -> Optional["AggregateMode"]:
		"""Defines the behavior when multiple values are in a single cell
* `Avg` - Uses the mean average of the values
* `Min` - Uses the minimum of the values
* `Max` - Uses the maximum of the values
* `TopOnly` - The highest value based on a sort column"""
		return self._raster_aggregate_mode
	@raster_aggregate_mode.setter
	def raster_aggregate_mode(self, value: Optional["AggregateMode"]) -> None:
		"""Defines the behavior when multiple values are in a single cell
* `Avg` - Uses the mean average of the values
* `Min` - Uses the minimum of the values
* `Max` - Uses the maximum of the values
* `TopOnly` - The highest value based on a sort column"""
		self._raster_aggregate_mode = value
	@property
	def raster_interpolate_mode(self) -> Optional["InterpolateMode"]:
		"""Defines the interpolation method used to calculate the values in between the known data points
* `None` - No interpolation
* `Nearest` - Nearest-neighbor interpolation
* `Linear` - Bilinear interpolation
* `Cubic` - Bicubic interpolation
* `IDW` - Inverse distance weighted interpolation
* `Auto` - Attempts to set the interpolation mode based on the raster band data type"""
		return self._raster_interpolate_mode
	@raster_interpolate_mode.setter
	def raster_interpolate_mode(self, value: Optional["InterpolateMode"]) -> None:
		"""Defines the interpolation method used to calculate the values in between the known data points
* `None` - No interpolation
* `Nearest` - Nearest-neighbor interpolation
* `Linear` - Bilinear interpolation
* `Cubic` - Bicubic interpolation
* `IDW` - Inverse distance weighted interpolation
* `Auto` - Attempts to set the interpolation mode based on the raster band data type"""
		self._raster_interpolate_mode = value
	@property
	def raster_preserve_bounding_box(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._raster_preserve_bounding_box
	@raster_preserve_bounding_box.setter
	def raster_preserve_bounding_box(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_preserve_bounding_box = value
	@property
	def raster_dimension_limit(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._raster_dimension_limit
	@raster_dimension_limit.setter
	def raster_dimension_limit(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_dimension_limit = value
	@property
	def raster_mode_downsample(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._raster_mode_downsample
	@raster_mode_downsample.setter
	def raster_mode_downsample(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_mode_downsample = value
	@property
	def s3_connection(self) -> Optional["S3Config"]:
		# pylint: disable=missing-function-docstring
		return self._s3_connection
	@s3_connection.setter
	def s3_connection(self, value: Optional["S3Config"]) -> None:
		# pylint: disable=missing-function-docstring
		self._s3_connection = value
	@property
	def s57(self) -> Optional["S57Config"]:
		"""Use when importing S57 archives"""
		return self._s57
	@s57.setter
	def s57(self, value: Optional["S57Config"]) -> None:
		"""Use when importing S57 archives"""
		self._s57 = value
	@property
	def fs_connection(self) -> Optional["FilesystemConfig"]:
		# pylint: disable=missing-function-docstring
		return self._fs_connection
	@fs_connection.setter
	def fs_connection(self, value: Optional["FilesystemConfig"]) -> None:
		# pylint: disable=missing-function-docstring
		self._fs_connection = value
	@property
	def es_connection(self) -> Optional["ElasticSearchConfig"]:
		# pylint: disable=missing-function-docstring
		return self._es_connection
	@es_connection.setter
	def es_connection(self, value: Optional["ElasticSearchConfig"]) -> None:
		# pylint: disable=missing-function-docstring
		self._es_connection = value
	@property
	def skip_header_rows(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._skip_header_rows
	@skip_header_rows.setter
	def skip_header_rows(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._skip_header_rows = value
	@property
	def explicit_column_headers(self) -> Optional["List[str]"]:
		# pylint: disable=missing-function-docstring
		return self._explicit_column_headers
	@explicit_column_headers.setter
	def explicit_column_headers(self, value: Optional["List[str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._explicit_column_headers = value
	@property
	def explicit_delimiter(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._explicit_delimiter
	@explicit_delimiter.setter
	def explicit_delimiter(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._explicit_delimiter = value
	@property
	def explicit_column_types(self) -> Optional["Dict[str, str]"]:
		# pylint: disable=missing-function-docstring
		return self._explicit_column_types
	@explicit_column_types.setter
	def explicit_column_types(self, value: Optional["Dict[str, str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._explicit_column_types = value
	@property
	def arc_gis_auth(self) -> Optional["ArcGisAuth"]:
		# pylint: disable=missing-function-docstring
		return self._arc_gis_auth
	@arc_gis_auth.setter
	def arc_gis_auth(self, value: Optional["ArcGisAuth"]) -> None:
		# pylint: disable=missing-function-docstring
		self._arc_gis_auth = value
	@property
	def http_headers(self) -> Optional["Dict[str, str]"]:
		# pylint: disable=missing-function-docstring
		return self._http_headers
	@http_headers.setter
	def http_headers(self, value: Optional["Dict[str, str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._http_headers = value
	@property
	def realtime(self) -> Optional["RealtimeOptions"]:
		# pylint: disable=missing-function-docstring
		return self._realtime
	@realtime.setter
	def realtime(self, value: Optional["RealtimeOptions"]) -> None:
		# pylint: disable=missing-function-docstring
		self._realtime = value
	@property
	def parallel_opts(self) -> Optional["ParallelOpts"]:
		# pylint: disable=missing-function-docstring
		return self._parallel_opts
	@parallel_opts.setter
	def parallel_opts(self, value: Optional["ParallelOpts"]) -> None:
		# pylint: disable=missing-function-docstring
		self._parallel_opts = value
	@property
	def data_import_adapter_type(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._data_import_adapter_type
	@data_import_adapter_type.setter
	def data_import_adapter_type(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._data_import_adapter_type = value
	@property
	def data_import_adapter_parameters(self) -> Optional["Dict[str, Any]"]:
		# pylint: disable=missing-function-docstring
		return self._data_import_adapter_parameters
	@data_import_adapter_parameters.setter
	def data_import_adapter_parameters(self, value: Optional["Dict[str, Any]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._data_import_adapter_parameters = value
	@property
	def json_from_remote(self) -> Optional["Dict[str, str]"]:
		# pylint: disable=missing-function-docstring
		return self._json_from_remote
	@json_from_remote.setter
	def json_from_remote(self, value: Optional["Dict[str, str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._json_from_remote = value
	@property
	def gdb_ingest_options(self) -> Optional["GDBImportOptions"]:
		"""Specify options for GDB Import"""
		return self._gdb_ingest_options
	@gdb_ingest_options.setter
	def gdb_ingest_options(self, value: Optional["GDBImportOptions"]) -> None:
		"""Specify options for GDB Import"""
		self._gdb_ingest_options = value
	@property
	def suppress_auto_center_point(self) -> Optional["bool"]:
		"""When a line geometry is imported, a new XY column is created to hold the center point of the line segment. Set to true to suppress auto creation."""
		return self._suppress_auto_center_point
	@suppress_auto_center_point.setter
	def suppress_auto_center_point(self, value: Optional["bool"]) -> None:
		"""When a line geometry is imported, a new XY column is created to hold the center point of the line segment. Set to true to suppress auto creation."""
		self._suppress_auto_center_point = value
	@property
	def ignore_cols_with_no_directive(self) -> Optional["bool"]:
		"""Went set to true, columns with no schema directives will be ignored and NOT imported."""
		return self._ignore_cols_with_no_directive
	@ignore_cols_with_no_directive.setter
	def ignore_cols_with_no_directive(self, value: Optional["bool"]) -> None:
		"""Went set to true, columns with no schema directives will be ignored and NOT imported."""
		self._ignore_cols_with_no_directive = value
	@property
	def plugin_config(self) -> Optional["Dict[str, Any]"]:
		# pylint: disable=missing-function-docstring
		return self._plugin_config
	@plugin_config.setter
	def plugin_config(self, value: Optional["Dict[str, Any]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._plugin_config = value
	@property
	def filter_date_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._filter_date_column
	@filter_date_column.setter
	def filter_date_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._filter_date_column = value
	@property
	def filter_date_start(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._filter_date_start
	@filter_date_start.setter
	def filter_date_start(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._filter_date_start = value
	@property
	def filter_date_end(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._filter_date_end
	@filter_date_end.setter
	def filter_date_end(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._filter_date_end = value
	@property
	def post_import_transforms(self) -> Optional["List[Query]"]:
		# pylint: disable=missing-function-docstring
		return self._post_import_transforms
	@post_import_transforms.setter
	def post_import_transforms(self, value: Optional["List[Query]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._post_import_transforms = value
	@property
	def pbf_options(self) -> Optional["PBFImportOptions"]:
		# pylint: disable=missing-function-docstring
		return self._pbf_options
	@pbf_options.setter
	def pbf_options(self, value: Optional["PBFImportOptions"]) -> None:
		# pylint: disable=missing-function-docstring
		self._pbf_options = value
	@property
	def las_options(self) -> Optional["LASImportOptions"]:
		# pylint: disable=missing-function-docstring
		return self._las_options
	@las_options.setter
	def las_options(self, value: Optional["LASImportOptions"]) -> None:
		# pylint: disable=missing-function-docstring
		self._las_options = value
	@property
	def write_parameters(self) -> Optional["CCFFWriteParameters"]:
		# pylint: disable=missing-function-docstring
		return self._write_parameters
	@write_parameters.setter
	def write_parameters(self, value: Optional["CCFFWriteParameters"]) -> None:
		# pylint: disable=missing-function-docstring
		self._write_parameters = value
	@property
	def keep_new_line(self) -> Optional["bool"]:
		"""Keep the new line character in the imported data instead of removing it."""
		return self._keep_new_line
	@keep_new_line.setter
	def keep_new_line(self, value: Optional["bool"]) -> None:
		"""Keep the new line character in the imported data instead of removing it."""
		self._keep_new_line = value
	@property
	def wait_for_full_replication(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._wait_for_full_replication
	@wait_for_full_replication.setter
	def wait_for_full_replication(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._wait_for_full_replication = value
	@property
	def wait_timeout_ms(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._wait_timeout_ms
	@wait_timeout_ms.setter
	def wait_timeout_ms(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._wait_timeout_ms = value
	@property
	def ignore_partitioning(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._ignore_partitioning
	@ignore_partitioning.setter
	def ignore_partitioning(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._ignore_partitioning = value
	@property
	def partition(self) -> Optional["MLPartitionedTableTag"]:
		# pylint: disable=missing-function-docstring
		return self._partition
	@partition.setter
	def partition(self, value: Optional["MLPartitionedTableTag"]) -> None:
		# pylint: disable=missing-function-docstring
		self._partition = value
	@property
	def table_tags(self) -> Optional["List[MLImportTagData]"]:
		# pylint: disable=missing-function-docstring
		return self._table_tags
	@table_tags.setter
	def table_tags(self, value: Optional["List[MLImportTagData]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._table_tags = value
	@property
	def unique_constraints(self) -> Optional["List[List[str]]"]:
		# pylint: disable=missing-function-docstring
		return self._unique_constraints
	@unique_constraints.setter
	def unique_constraints(self, value: Optional["List[List[str]]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._unique_constraints = value
	@property
	def indexes(self) -> Optional["List[IndexCreationOptions]"]:
		# pylint: disable=missing-function-docstring
		return self._indexes
	@indexes.setter
	def indexes(self, value: Optional["List[IndexCreationOptions]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._indexes = value
	@property
	def constraints(self) -> Optional["List[ConstraintOptions]"]:
		# pylint: disable=missing-function-docstring
		return self._constraints
	@constraints.setter
	def constraints(self, value: Optional["List[ConstraintOptions]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._constraints = value
	@property
	def suppress_index_detection_on_import(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._suppress_index_detection_on_import
	@suppress_index_detection_on_import.setter
	def suppress_index_detection_on_import(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._suppress_index_detection_on_import = value
	@property
	def scheduled_dataset_subtract_minutes(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._scheduled_dataset_subtract_minutes
	@scheduled_dataset_subtract_minutes.setter
	def scheduled_dataset_subtract_minutes(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._scheduled_dataset_subtract_minutes = value
	@property
	def check_files_exist_at_endpoint(self) -> Optional["CheckFilesExistMode"]:
		# pylint: disable=missing-function-docstring
		return self._check_files_exist_at_endpoint
	@check_files_exist_at_endpoint.setter
	def check_files_exist_at_endpoint(self, value: Optional["CheckFilesExistMode"]) -> None:
		# pylint: disable=missing-function-docstring
		self._check_files_exist_at_endpoint = value
	@property
	def parallel_import(self) -> Optional["PxImport"]:
		# pylint: disable=missing-function-docstring
		return self._parallel_import
	@parallel_import.setter
	def parallel_import(self, value: Optional["PxImport"]) -> None:
		# pylint: disable=missing-function-docstring
		self._parallel_import = value
	@property
	def use_parallel_apply(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._use_parallel_apply
	@use_parallel_apply.setter
	def use_parallel_apply(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._use_parallel_apply = value
	@property
	def replication_factor(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._replication_factor
	@replication_factor.setter
	def replication_factor(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._replication_factor = value
	@property
	def replication_grouping_key(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._replication_grouping_key
	@replication_grouping_key.setter
	def replication_grouping_key(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._replication_grouping_key = value
	@property
	def insert_only(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._insert_only
	@insert_only.setter
	def insert_only(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._insert_only = value
	@property
	def pk_update_constraints(self) -> Optional["UpdateConstraint"]:
		# pylint: disable=missing-function-docstring
		return self._pk_update_constraints
	@pk_update_constraints.setter
	def pk_update_constraints(self, value: Optional["UpdateConstraint"]) -> None:
		# pylint: disable=missing-function-docstring
		self._pk_update_constraints = value
	@property
	def update_only(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._update_only
	@update_only.setter
	def update_only(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._update_only = value
	@property
	def coordinate_operations(self) -> Optional["List[CoordinateOperation]"]:
		"""If set, this will allow per column to define the CRS and (if required) perform a conversion to another CRS."""
		return self._coordinate_operations
	@coordinate_operations.setter
	def coordinate_operations(self, value: Optional["List[CoordinateOperation]"]) -> None:
		"""If set, this will allow per column to define the CRS and (if required) perform a conversion to another CRS."""
		self._coordinate_operations = value
	@property
	def file_type_handler(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._file_type_handler
	@file_type_handler.setter
	def file_type_handler(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._file_type_handler = value
	@property
	def system_table_attributes(self) -> Optional["Dict[str, str]"]:
		# pylint: disable=missing-function-docstring
		return self._system_table_attributes
	@system_table_attributes.setter
	def system_table_attributes(self, value: Optional["Dict[str, str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._system_table_attributes = value
	@property
	def user_table_attributes(self) -> Optional["Dict[str, str]"]:
		# pylint: disable=missing-function-docstring
		return self._user_table_attributes
	@user_table_attributes.setter
	def user_table_attributes(self, value: Optional["Dict[str, str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._user_table_attributes = value
	@property
	def centroid_max_error_percent_override(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._centroid_max_error_percent_override
	@centroid_max_error_percent_override.setter
	def centroid_max_error_percent_override(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._centroid_max_error_percent_override = value
	@property
	def centroid_mode(self) -> Optional["CentroidMode"]:
		"""
* `POI` - Pole Of Inaccessiblity
* `BoundingBox` - Bounding Box
* `Classic` - Classic
* `InscribedCircle` - Inscribed Circle"""
		return self._centroid_mode
	@centroid_mode.setter
	def centroid_mode(self, value: Optional["CentroidMode"]) -> None:
		"""
* `POI` - Pole Of Inaccessiblity
* `BoundingBox` - Bounding Box
* `Classic` - Classic
* `InscribedCircle` - Inscribed Circle"""
		self._centroid_mode = value
	@property
	def guid_identity_column_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._guid_identity_column_name
	@guid_identity_column_name.setter
	def guid_identity_column_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._guid_identity_column_name = value
	@property
	def map_tile_coordinates(self) -> Optional["MapTileCoordinates"]:
		# pylint: disable=missing-function-docstring
		return self._map_tile_coordinates
	@map_tile_coordinates.setter
	def map_tile_coordinates(self, value: Optional["MapTileCoordinates"]) -> None:
		# pylint: disable=missing-function-docstring
		self._map_tile_coordinates = value
	@property
	def video_import_flags(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._video_import_flags
	@video_import_flags.setter
	def video_import_flags(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._video_import_flags = value
	@property
	def video(self) -> Optional["VideoConfig"]:
		# pylint: disable=missing-function-docstring
		return self._video
	@video.setter
	def video(self, value: Optional["VideoConfig"]) -> None:
		# pylint: disable=missing-function-docstring
		self._video = value
	@property
	def pipeline_definition(self) -> Optional["PipelineDefinition"]:
		# pylint: disable=missing-function-docstring
		return self._pipeline_definition
	@pipeline_definition.setter
	def pipeline_definition(self, value: Optional["PipelineDefinition"]) -> None:
		# pylint: disable=missing-function-docstring
		self._pipeline_definition = value
	@property
	def well_known_pipeline_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._well_known_pipeline_name
	@well_known_pipeline_name.setter
	def well_known_pipeline_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._well_known_pipeline_name = value
	@property
	def pipeline_start_step(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._pipeline_start_step
	@pipeline_start_step.setter
	def pipeline_start_step(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._pipeline_start_step = value
	@property
	def pipeline_verbose_logging(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._pipeline_verbose_logging
	@pipeline_verbose_logging.setter
	def pipeline_verbose_logging(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._pipeline_verbose_logging = value
	@property
	def pipeline_parameters(self) -> Optional["Dict[str, str]"]:
		# pylint: disable=missing-function-docstring
		return self._pipeline_parameters
	@pipeline_parameters.setter
	def pipeline_parameters(self, value: Optional["Dict[str, str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._pipeline_parameters = value
	@property
	def geocoder_import_header(self) -> Optional["GeocoderImportHeaderConfig"]:
		# pylint: disable=missing-function-docstring
		return self._geocoder_import_header
	@geocoder_import_header.setter
	def geocoder_import_header(self, value: Optional["GeocoderImportHeaderConfig"]) -> None:
		# pylint: disable=missing-function-docstring
		self._geocoder_import_header = value
	@property
	def skip_geocode(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._skip_geocode
	@skip_geocode.setter
	def skip_geocode(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._skip_geocode = value
	@property
	def force_multipoint_import(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._force_multipoint_import
	@force_multipoint_import.setter
	def force_multipoint_import(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._force_multipoint_import = value
	@property
	def split_zip_multiple_tables(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._split_zip_multiple_tables
	@split_zip_multiple_tables.setter
	def split_zip_multiple_tables(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._split_zip_multiple_tables = value
	@property
	def use_kml_direct_importer(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._use_kml_direct_importer
	@use_kml_direct_importer.setter
	def use_kml_direct_importer(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._use_kml_direct_importer = value
	@property
	def detect_nulls(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._detect_nulls
	@detect_nulls.setter
	def detect_nulls(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._detect_nulls = value
	@property
	def file_extension(self) -> Optional["str"]:
		"""Specify an intended file extension, either to correct incorrect file extensions, or to force the usage of a different import file handler other than the default one used for the file's extension. Applies to either the imported file itself, or to files within an archive."""
		return self._file_extension
	@file_extension.setter
	def file_extension(self, value: Optional["str"]) -> None:
		"""Specify an intended file extension, either to correct incorrect file extensions, or to force the usage of a different import file handler other than the default one used for the file's extension. Applies to either the imported file itself, or to files within an archive."""
		self._file_extension = value
	@property
	def index_organized(self) -> Optional["IndexOrganizedTableConfig"]:
		# pylint: disable=missing-function-docstring
		return self._index_organized
	@index_organized.setter
	def index_organized(self, value: Optional["IndexOrganizedTableConfig"]) -> None:
		# pylint: disable=missing-function-docstring
		self._index_organized = value
	@property
	def canonical_geometry_column(self) -> Optional["str"]:
		"""Specifies the name of a canonical geometry column."""
		return self._canonical_geometry_column
	@canonical_geometry_column.setter
	def canonical_geometry_column(self, value: Optional["str"]) -> None:
		"""Specifies the name of a canonical geometry column."""
		self._canonical_geometry_column = value
	@property
	def exclude_non_canonical_geometries(self) -> Optional["bool"]:
		"""Specifies how non-canonical geometry columns should be handled."""
		return self._exclude_non_canonical_geometries
	@exclude_non_canonical_geometries.setter
	def exclude_non_canonical_geometries(self, value: Optional["bool"]) -> None:
		"""Specifies how non-canonical geometry columns should be handled."""
		self._exclude_non_canonical_geometries = value
	@property
	def fail_on_nodes(self) -> Optional["List[str]"]:
		"""For testing.  When specified the resulting transaction will fail on nodes with the specified addresses."""
		return self._fail_on_nodes
	@fail_on_nodes.setter
	def fail_on_nodes(self, value: Optional["List[str]"]) -> None:
		"""For testing.  When specified the resulting transaction will fail on nodes with the specified addresses."""
		self._fail_on_nodes = value
	@property
	def fail_for_testing(self) -> Optional["TransactionConsistencyStatus"]:
		"""For testing.  When specified the resulting transaction will fail in the manner specified."""
		return self._fail_for_testing
	@fail_for_testing.setter
	def fail_for_testing(self, value: Optional["TransactionConsistencyStatus"]) -> None:
		"""For testing.  When specified the resulting transaction will fail in the manner specified."""
		self._fail_for_testing = value
	@property
	def start(self) -> Optional["int"]:
		"""Starting offset for records in the input file. Supported by parquet imports."""
		return self._start
	@start.setter
	def start(self, value: Optional["int"]) -> None:
		"""Starting offset for records in the input file. Supported by parquet imports."""
		self._start = value
	@property
	def take(self) -> Optional["int"]:
		"""Take at most this many records from the input file. Supported by parquet imports."""
		return self._take
	@take.setter
	def take(self, value: Optional["int"]) -> None:
		"""Take at most this many records from the input file. Supported by parquet imports."""
		self._take = value
class FilesystemConfig(GenericAdapterConfig):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"root_path": ("rootPath", "str", None),
		"name": ("name", "str", None),
		"config_guid": ("configGuid", "str", None),
		"transports": ("transports", "list", "AdapterTransportsEnum"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		transports: "AdapterTransports",
		root_path: Optional["str"] = None,
		name: Optional["str"] = None,
		config_guid: Optional["str"] = None,
	) -> None:
		"""
		:param transports:
		:type transports: AdapterTransports
		:param root_path:
		:type root_path: str or None
		:param name:
		:type name: str or None
		:param config_guid:
		:type config_guid: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		GenericAdapterConfig.__init__(self,
			name=kwargs.get("name"),
			config_guid=kwargs.get("config_guid"),
			transports=kwargs.get("transports"),
		)
		self._root_path = cast(Optional[str], kwargs.get("root_path"))
	@property
	def root_path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._root_path
	@root_path.setter
	def root_path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._root_path = value
class FilteredTable:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"table": ("table", "str", None),
		"where": ("where", "QueryWhere", None),
		"query": ("query", "Query", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		where: "QueryWhere",
		query: "Query",
		table: Optional["str"] = None,
	) -> None:
		"""
		:param where:
		:type where: QueryWhere
		:param query:
		:type query: Query
		:param table:
		:type table: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._table = cast(Optional[str], kwargs.get("table"))
		self._where = cast(QueryWhere, kwargs.get("where"))
		self._query = cast(Query, kwargs.get("query"))
	@property
	def table(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._table
	@table.setter
	def table(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._table = value
	@property
	def where(self) -> "QueryWhere":
		# pylint: disable=missing-function-docstring
		return self._where
	@where.setter
	def where(self, value: "QueryWhere") -> None:
		# pylint: disable=missing-function-docstring
		self._where = value
	@property
	def query(self) -> "Query":
		# pylint: disable=missing-function-docstring
		return self._query
	@query.setter
	def query(self, value: "Query") -> None:
		# pylint: disable=missing-function-docstring
		self._query = value
class FilterNode:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"bounding_box": ("BoundingBox", "OgcBoundingBox", None),
		"wkt_val": ("wktVal", "str", None),
		"col": ("col", "str", None),
		"test": ("test", "MLQueryTests", None),
		"value": ("value", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		bounding_box: "OgcBoundingBox",
		test: "MLQueryTests",
		wkt_val: Optional["str"] = None,
		col: Optional["str"] = None,
		value: Optional["str"] = None,
	) -> None:
		"""
		:param bounding_box:
		:type bounding_box: OgcBoundingBox
		:param test:
		:type test: MLQueryTests
		:param wkt_val:
		:type wkt_val: str or None
		:param col:
		:type col: str or None
		:param value:
		:type value: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._bounding_box = cast(OgcBoundingBox, kwargs.get("bounding_box"))
		self._wkt_val = cast(Optional[str], kwargs.get("wkt_val"))
		self._col = cast(Optional[str], kwargs.get("col"))
		self._test = cast(MLQueryTests, kwargs.get("test"))
		self._value = cast(Optional[str], kwargs.get("value"))
	@property
	def bounding_box(self) -> "OgcBoundingBox":
		# pylint: disable=missing-function-docstring
		return self._bounding_box
	@bounding_box.setter
	def bounding_box(self, value: "OgcBoundingBox") -> None:
		# pylint: disable=missing-function-docstring
		self._bounding_box = value
	@property
	def wkt_val(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._wkt_val
	@wkt_val.setter
	def wkt_val(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._wkt_val = value
	@property
	def col(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._col
	@col.setter
	def col(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._col = value
	@property
	def test(self) -> "MLQueryTests":
		# pylint: disable=missing-function-docstring
		return self._test
	@test.setter
	def test(self, value: "MLQueryTests") -> None:
		# pylint: disable=missing-function-docstring
		self._test = value
	@property
	def value(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._value
	@value.setter
	def value(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._value = value
class FootprintsCollection:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"descriptors": ("descriptors", "dict", "BuildingStyleDescriptor"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		descriptors: "Dict[str, BuildingStyleDescriptor]",
	) -> None:
		"""
		:param descriptors:
		:type descriptors: Dict[str, BuildingStyleDescriptor]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._descriptors = cast(Dict[str, BuildingStyleDescriptor], kwargs.get("descriptors"))
	@property
	def descriptors(self) -> "Dict[str, BuildingStyleDescriptor]":
		# pylint: disable=missing-function-docstring
		return self._descriptors
	@descriptors.setter
	def descriptors(self, value: "Dict[str, BuildingStyleDescriptor]") -> None:
		# pylint: disable=missing-function-docstring
		self._descriptors = value
class GDBImportOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"advanced_import": ("advancedImport", "bool", None),
		"ingest_relationships": ("ingestRelationships", "bool", None),
		"ingest_meta": ("ingestMeta", "bool", None),
		"ingest_meta_xpaths": ("ingestMetaXPaths", "list", "XPathItem"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		advanced_import: "bool",
		ingest_relationships: "bool",
		ingest_meta: "bool",
		ingest_meta_xpaths: "List[XPathItem]",
	) -> None:
		"""
		:param advanced_import:
		:type advanced_import: bool
		:param ingest_relationships:
		:type ingest_relationships: bool
		:param ingest_meta:
		:type ingest_meta: bool
		:param ingest_meta_xpaths:
		:type ingest_meta_xpaths: List[XPathItem]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._advanced_import = cast(bool, kwargs.get("advanced_import"))
		self._ingest_relationships = cast(bool, kwargs.get("ingest_relationships"))
		self._ingest_meta = cast(bool, kwargs.get("ingest_meta"))
		self._ingest_meta_xpaths = cast(List[XPathItem], kwargs.get("ingest_meta_xpaths"))
	@property
	def advanced_import(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._advanced_import
	@advanced_import.setter
	def advanced_import(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._advanced_import = value
	@property
	def ingest_relationships(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._ingest_relationships
	@ingest_relationships.setter
	def ingest_relationships(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._ingest_relationships = value
	@property
	def ingest_meta(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._ingest_meta
	@ingest_meta.setter
	def ingest_meta(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._ingest_meta = value
	@property
	def ingest_meta_xpaths(self) -> "List[XPathItem]":
		# pylint: disable=missing-function-docstring
		return self._ingest_meta_xpaths
	@ingest_meta_xpaths.setter
	def ingest_meta_xpaths(self, value: "List[XPathItem]") -> None:
		# pylint: disable=missing-function-docstring
		self._ingest_meta_xpaths = value
class GeocoderImportHeaderConfig:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"case_sensitive": ("CaseSensitive", "bool", None),
		"all_required": ("AllRequired", "bool", None),
		"address_label": ("AddressLabel", "str", None),
		"city_label": ("CityLabel", "str", None),
		"county_label": ("CountyLabel", "str", None),
		"state_label": ("StateLabel", "str", None),
		"zip_label": ("ZipLabel", "str", None),
		"lat_label": ("LatLabel", "str", None),
		"lng_label": ("LngLabel", "str", None),
		"country_label": ("CountryLabel", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		case_sensitive: "bool",
		all_required: "bool",
		address_label: Optional["str"] = None,
		city_label: Optional["str"] = None,
		county_label: Optional["str"] = None,
		state_label: Optional["str"] = None,
		zip_label: Optional["str"] = None,
		lat_label: Optional["str"] = None,
		lng_label: Optional["str"] = None,
		country_label: Optional["str"] = None,
	) -> None:
		"""
		:param case_sensitive:
		:type case_sensitive: bool
		:param all_required:
		:type all_required: bool
		:param address_label:
		:type address_label: str or None
		:param city_label:
		:type city_label: str or None
		:param county_label:
		:type county_label: str or None
		:param state_label:
		:type state_label: str or None
		:param zip_label:
		:type zip_label: str or None
		:param lat_label:
		:type lat_label: str or None
		:param lng_label:
		:type lng_label: str or None
		:param country_label:
		:type country_label: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._case_sensitive = cast(bool, kwargs.get("case_sensitive"))
		self._all_required = cast(bool, kwargs.get("all_required"))
		self._address_label = cast(Optional[str], kwargs.get("address_label"))
		self._city_label = cast(Optional[str], kwargs.get("city_label"))
		self._county_label = cast(Optional[str], kwargs.get("county_label"))
		self._state_label = cast(Optional[str], kwargs.get("state_label"))
		self._zip_label = cast(Optional[str], kwargs.get("zip_label"))
		self._lat_label = cast(Optional[str], kwargs.get("lat_label"))
		self._lng_label = cast(Optional[str], kwargs.get("lng_label"))
		self._country_label = cast(Optional[str], kwargs.get("country_label"))
	@property
	def case_sensitive(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._case_sensitive
	@case_sensitive.setter
	def case_sensitive(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._case_sensitive = value
	@property
	def all_required(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._all_required
	@all_required.setter
	def all_required(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._all_required = value
	@property
	def address_label(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._address_label
	@address_label.setter
	def address_label(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._address_label = value
	@property
	def city_label(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._city_label
	@city_label.setter
	def city_label(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._city_label = value
	@property
	def county_label(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._county_label
	@county_label.setter
	def county_label(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._county_label = value
	@property
	def state_label(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._state_label
	@state_label.setter
	def state_label(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._state_label = value
	@property
	def zip_label(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._zip_label
	@zip_label.setter
	def zip_label(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._zip_label = value
	@property
	def lat_label(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._lat_label
	@lat_label.setter
	def lat_label(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._lat_label = value
	@property
	def lng_label(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._lng_label
	@lng_label.setter
	def lng_label(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._lng_label = value
	@property
	def country_label(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._country_label
	@country_label.setter
	def country_label(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._country_label = value


class GeoFormat(str, Enum):
	# pylint: disable=missing-class-docstring
	WKT = 'WKT'
	MGRS = 'MGRS'
	UTM = 'UTM'

GeoFormat.WKT.__doc__ = """Return geospatial data in WKT (Well-known text) format."""
GeoFormat.MGRS.__doc__ = """Return geospatial data in MGRS (Military Grid Reference System) format."""
GeoFormat.UTM.__doc__ = """Return geospatial data in UTM (Universal Transverse Mercator) format."""
class GetImportOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"ml_server_fwd": ("mlServerFwd", "str", None),
		"no_redirect": ("noRedirect", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		ml_server_fwd: Optional["str"] = None,
		no_redirect: Optional["bool"] = None,
	) -> None:
		"""
		:param ml_server_fwd: The cluster node that this request should ultimately be executed on.
		:type ml_server_fwd: str or None
		:param no_redirect: Override the default response behavior. By default, when the import is complete, this method will respond with 303 See Other, redirecting to the import result. If you need to see the final import status, but your HTTP client automatically follows redirects, then specify `?noRedirect=true`, and then fetch the result with a subsequent GET request. The result URL is available in the response's `_links.result.href` property.
		:type no_redirect: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._ml_server_fwd = cast(Optional[str], kwargs.get("ml_server_fwd"))
		self._no_redirect = cast(Optional[bool], kwargs.get("no_redirect"))
	@property
	def ml_server_fwd(self) -> Optional["str"]:
		"""The cluster node that this request should ultimately be executed on."""
		return self._ml_server_fwd
	@ml_server_fwd.setter
	def ml_server_fwd(self, value: Optional["str"]) -> None:
		"""The cluster node that this request should ultimately be executed on."""
		self._ml_server_fwd = value
	@property
	def no_redirect(self) -> Optional["bool"]:
		"""Override the default response behavior. By default, when the import is complete, this method will respond with 303 See Other, redirecting to the import result. If you need to see the final import status, but your HTTP client automatically follows redirects, then specify `?noRedirect=true`, and then fetch the result with a subsequent GET request. The result URL is available in the response's `_links.result.href` property."""
		return self._no_redirect
	@no_redirect.setter
	def no_redirect(self, value: Optional["bool"]) -> None:
		"""Override the default response behavior. By default, when the import is complete, this method will respond with 303 See Other, redirecting to the import result. If you need to see the final import status, but your HTTP client automatically follows redirects, then specify `?noRedirect=true`, and then fetch the result with a subsequent GET request. The result URL is available in the response's `_links.result.href` property."""
		self._no_redirect = value
class GetOnboardingOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"ml_server_fwd": ("mlServerFwd", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		ml_server_fwd: Optional["str"] = None,
	) -> None:
		"""
		:param ml_server_fwd: The cluster node that this request should ultimately be executed on.
		:type ml_server_fwd: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._ml_server_fwd = cast(Optional[str], kwargs.get("ml_server_fwd"))
	@property
	def ml_server_fwd(self) -> Optional["str"]:
		"""The cluster node that this request should ultimately be executed on."""
		return self._ml_server_fwd
	@ml_server_fwd.setter
	def ml_server_fwd(self, value: Optional["str"]) -> None:
		"""The cluster node that this request should ultimately be executed on."""
		self._ml_server_fwd = value


class GPXImportData(str, Enum):
	"""Specify what type of data to import from GPX source file."""
	WAYPOINTS = 'Waypoints'
	TRACK_POINTS = 'TrackPoints'
	TRACKS = 'Tracks'
	ROUTES = 'Routes'
	ROUTE_POINTS = 'RoutePoints'

GPXImportData.TRACK_POINTS.__doc__ = """Import the points of the tracks as a point layer."""
GPXImportData.TRACKS.__doc__ = """Import the tracks as a line layer."""
GPXImportData.ROUTES.__doc__ = """Import the routes as a line layer."""
GPXImportData.ROUTE_POINTS.__doc__ = """Import the points of the routes as a point layer."""
class GradientPair:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"position": ("position", "str", None),
		"value": ("value", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		position: "str",
		value: "str",
	) -> None:
		"""
		:param position:
		:type position: str
		:param value: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type value: str
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._position = cast(str, kwargs.get("position"))
		self._value = cast(str, kwargs.get("value"))
	@property
	def position(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._position
	@position.setter
	def position(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._position = value
	@property
	def value(self) -> "str":
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._value
	@value.setter
	def value(self, value: "str") -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._value = value


class GraphInteractivity(str, Enum):
	# pylint: disable=missing-class-docstring
	ALL = 'All'
	NODE = 'Node'
	EDGE = 'Edge'

class GraphOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"interactivity": ("interactivity", "GraphInteractivity", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		interactivity: "GraphInteractivity",
	) -> None:
		"""
		:param interactivity:
		:type interactivity: GraphInteractivity
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._interactivity = cast(GraphInteractivity, kwargs.get("interactivity"))
	@property
	def interactivity(self) -> "GraphInteractivity":
		# pylint: disable=missing-function-docstring
		return self._interactivity
	@interactivity.setter
	def interactivity(self, value: "GraphInteractivity") -> None:
		# pylint: disable=missing-function-docstring
		self._interactivity = value


class GraphType(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	NODE = 'Node'
	EDGE = 'Edge'

class GribConfig:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"import_as_raster": ("importAsRaster", "bool", None),
		"variable_name_key": ("variableNameKey", "str", None),
		"xstride": ("xStride", "int", None),
		"ystride": ("yStride", "int", None),
		"data_variables": ("dataVariables", "list", "GribConfigVariableOptions"),
		"other_variables": ("otherVariables", "list", "GribConfigVariableOptions"),
		"keep_in_memory_during_import": ("keepInMemoryDuringImport", "bool", None),
		"omit_when_less_than": ("omitWhenLessThan", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		import_as_raster: "bool",
		xstride: "int",
		ystride: "int",
		data_variables: "List[GribConfigVariableOptions]",
		other_variables: "List[GribConfigVariableOptions]",
		keep_in_memory_during_import: "bool",
		variable_name_key: Optional["str"] = None,
		omit_when_less_than: Optional["str"] = None,
	) -> None:
		"""
		:param import_as_raster: If true, each GRIB message will represent a row and the data will be included in a binary column.
		:type import_as_raster: bool
		:param xstride: Sampling step size for the X dimension.
		:type xstride: int
		:param ystride: Sampling step size for the Y dimension.
		:type ystride: int
		:param data_variables: Sets up the names of the array variables were interested in.  Can also explicitly exclude.
		:type data_variables: List[GribConfigVariableOptions]
		:param other_variables: Sets up the names of the scalar metadata variables were interested in.  Can also explicitly exclude.
		:type other_variables: List[GribConfigVariableOptions]
		:param keep_in_memory_during_import:
		:type keep_in_memory_during_import: bool
		:param variable_name_key: The GRIB attribute used to automatically name variables. 'shortName' is a common value here.
		:type variable_name_key: str or None
		:param omit_when_less_than: Condition for omitting an entire message, For example: 'Variable_00000, 0'
		:type omit_when_less_than: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._import_as_raster = cast(bool, kwargs.get("import_as_raster"))
		self._variable_name_key = cast(Optional[str], kwargs.get("variable_name_key"))
		self._xstride = cast(int, kwargs.get("xstride"))
		self._ystride = cast(int, kwargs.get("ystride"))
		self._data_variables = cast(List[GribConfigVariableOptions], kwargs.get("data_variables"))
		self._other_variables = cast(List[GribConfigVariableOptions], kwargs.get("other_variables"))
		self._keep_in_memory_during_import = cast(bool, kwargs.get("keep_in_memory_during_import"))
		self._omit_when_less_than = cast(Optional[str], kwargs.get("omit_when_less_than"))
	@property
	def import_as_raster(self) -> "bool":
		"""If true, each GRIB message will represent a row and the data will be included in a binary column."""
		return self._import_as_raster
	@import_as_raster.setter
	def import_as_raster(self, value: "bool") -> None:
		"""If true, each GRIB message will represent a row and the data will be included in a binary column."""
		self._import_as_raster = value
	@property
	def variable_name_key(self) -> Optional["str"]:
		"""The GRIB attribute used to automatically name variables. 'shortName' is a common value here."""
		return self._variable_name_key
	@variable_name_key.setter
	def variable_name_key(self, value: Optional["str"]) -> None:
		"""The GRIB attribute used to automatically name variables. 'shortName' is a common value here."""
		self._variable_name_key = value
	@property
	def xstride(self) -> "int":
		"""Sampling step size for the X dimension."""
		return self._xstride
	@xstride.setter
	def xstride(self, value: "int") -> None:
		"""Sampling step size for the X dimension."""
		self._xstride = value
	@property
	def ystride(self) -> "int":
		"""Sampling step size for the Y dimension."""
		return self._ystride
	@ystride.setter
	def ystride(self, value: "int") -> None:
		"""Sampling step size for the Y dimension."""
		self._ystride = value
	@property
	def data_variables(self) -> "List[GribConfigVariableOptions]":
		"""Sets up the names of the array variables were interested in.  Can also explicitly exclude."""
		return self._data_variables
	@data_variables.setter
	def data_variables(self, value: "List[GribConfigVariableOptions]") -> None:
		"""Sets up the names of the array variables were interested in.  Can also explicitly exclude."""
		self._data_variables = value
	@property
	def other_variables(self) -> "List[GribConfigVariableOptions]":
		"""Sets up the names of the scalar metadata variables were interested in.  Can also explicitly exclude."""
		return self._other_variables
	@other_variables.setter
	def other_variables(self, value: "List[GribConfigVariableOptions]") -> None:
		"""Sets up the names of the scalar metadata variables were interested in.  Can also explicitly exclude."""
		self._other_variables = value
	@property
	def keep_in_memory_during_import(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._keep_in_memory_during_import
	@keep_in_memory_during_import.setter
	def keep_in_memory_during_import(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._keep_in_memory_during_import = value
	@property
	def omit_when_less_than(self) -> Optional["str"]:
		"""Condition for omitting an entire message, For example: 'Variable_00000, 0'"""
		return self._omit_when_less_than
	@omit_when_less_than.setter
	def omit_when_less_than(self, value: Optional["str"]) -> None:
		"""Condition for omitting an entire message, For example: 'Variable_00000, 0'"""
		self._omit_when_less_than = value
class GribConfigVariableOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"exclude": ("exclude", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		exclude: "bool",
		name: Optional["str"] = None,
	) -> None:
		"""
		:param exclude:
		:type exclude: bool
		:param name:
		:type name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._exclude = cast(bool, kwargs.get("exclude"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def exclude(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._exclude
	@exclude.setter
	def exclude(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._exclude = value
class Group:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "int", None),
		"account": ("account", "AccountReference", None),
		"name": ("name", "str", None),
		"description": ("description", "str", None),
		"permission_level": ("permissionLevel", "str", None),
		"actions": ("actions", "list", "str"),
		"links": ("_links", "GroupLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "int",
		account: "AccountReference",
		name: "str",
		actions: "List[str]",
		links: "GroupLinks",
		description: Optional["str"] = None,
		permission_level: Optional["str"] = None,
	) -> None:
		"""
		:param id_: The unique numeric ID of the group.
		:type id_: int
		:param account: The account this group belongs to.
		:type account: AccountReference
		:param name: The name of the group. Unique within an account.
		:type name: str
		:param actions: A list of actions that members of this group are allowed to perform.
		:type actions: List[str]
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: GroupLinks
		:param description: The group description.
		:type description: str or None
		:param permission_level: The level of access assigned to this group. Typical values are: viewer, editor, admin, and custom. The possible values are configurable.
		:type permission_level: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(int, kwargs.get("id_"))
		self._account = cast(AccountReference, kwargs.get("account"))
		self._name = cast(str, kwargs.get("name"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._permission_level = cast(Optional[str], kwargs.get("permission_level"))
		self._actions = cast(List[str], kwargs.get("actions"))
		self._links = cast(GroupLinks, kwargs.get("links"))
	@property
	def id_(self) -> "int":
		"""The unique numeric ID of the group."""
		return self._id_
	@id_.setter
	def id_(self, value: "int") -> None:
		"""The unique numeric ID of the group."""
		self._id_ = value
	@property
	def account(self) -> "AccountReference":
		"""The account this group belongs to."""
		return self._account
	@account.setter
	def account(self, value: "AccountReference") -> None:
		"""The account this group belongs to."""
		self._account = value
	@property
	def name(self) -> "str":
		"""The name of the group. Unique within an account."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The name of the group. Unique within an account."""
		self._name = value
	@property
	def description(self) -> Optional["str"]:
		"""The group description."""
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		"""The group description."""
		self._description = value
	@property
	def permission_level(self) -> Optional["str"]:
		"""The level of access assigned to this group. Typical values are: viewer, editor, admin, and custom. The possible values are configurable."""
		return self._permission_level
	@permission_level.setter
	def permission_level(self, value: Optional["str"]) -> None:
		"""The level of access assigned to this group. Typical values are: viewer, editor, admin, and custom. The possible values are configurable."""
		self._permission_level = value
	@property
	def actions(self) -> "List[str]":
		"""A list of actions that members of this group are allowed to perform."""
		return self._actions
	@actions.setter
	def actions(self, value: "List[str]") -> None:
		"""A list of actions that members of this group are allowed to perform."""
		self._actions = value
	@property
	def links(self) -> "GroupLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "GroupLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class GroupLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "Link",
		self_: "Link",
	) -> None:
		"""
		:param account: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type account: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._account = cast(Link, kwargs.get("account"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def account(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._account
	@account.setter
	def account(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._account = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class GroupReference:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "int", None),
		"account": ("account", "AccountReference", None),
		"name": ("name", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "AccountReference",
		id_: Optional["int"] = None,
		name: Optional["str"] = None,
	) -> None:
		"""
		:param account: The account this group belongs to. Either `id` or both `account` and `name` must be specified. `id` takes precedence if specified.
		:type account: AccountReference
		:param id_: The unique numeric ID of the group. Either `id` or both `account` and `name` must be specified. `id` takes precedence if specified.
		:type id_: int or None
		:param name: The name of the group. Unique within an account. Either `id` or both `account` and `name` must be specified. `id` takes precedence if specified.
		:type name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(Optional[int], kwargs.get("id_"))
		self._account = cast(AccountReference, kwargs.get("account"))
		self._name = cast(Optional[str], kwargs.get("name"))
	@property
	def id_(self) -> Optional["int"]:
		"""The unique numeric ID of the group. Either `id` or both `account` and `name` must be specified. `id` takes precedence if specified."""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["int"]) -> None:
		"""The unique numeric ID of the group. Either `id` or both `account` and `name` must be specified. `id` takes precedence if specified."""
		self._id_ = value
	@property
	def account(self) -> "AccountReference":
		"""The account this group belongs to. Either `id` or both `account` and `name` must be specified. `id` takes precedence if specified."""
		return self._account
	@account.setter
	def account(self, value: "AccountReference") -> None:
		"""The account this group belongs to. Either `id` or both `account` and `name` must be specified. `id` takes precedence if specified."""
		self._account = value
	@property
	def name(self) -> Optional["str"]:
		"""The name of the group. Unique within an account. Either `id` or both `account` and `name` must be specified. `id` takes precedence if specified."""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""The name of the group. Unique within an account. Either `id` or both `account` and `name` must be specified. `id` takes precedence if specified."""
		self._name = value


class HAlign(str, Enum):
	# pylint: disable=missing-class-docstring
	LEFT = 'Left'
	CENTER = 'Center'
	CENTER_BBOX = 'CenterBBox'
	RIGHT = 'Right'

class HardwareStats:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"uptime_seconds": ("uptimeSeconds", "int", None),
		"time_collected": ("timeCollected", "datetime", None),
		"cpu_total_cores": ("cpuTotalCores", "int", None),
		"cpu_usage_percent": ("cpuUsagePercent", "int", None),
		"memory_total_in_use_mb": ("memoryTotalInUseMB", "int", None),
		"memory_heap_total_mb": ("memoryHeapTotalMB", "int", None),
		"memory_heap_active_mb": ("memoryHeapActiveMB", "int", None),
		"memory_free_mb": ("memoryFreeMB", "int", None),
		"memory_total_mb": ("memoryTotalMB", "int", None),
		"disk_total_mb": ("diskTotalMB", "int", None),
		"disk_free_mb": ("diskFreeMB", "int", None),
		"gpu_total_cards": ("gpuTotalCards", "int", None),
		"gpu_total_memory_mb": ("gpuTotalMemoryMB", "int", None),
		"gpu_free_memory_mb": ("gpuFreeMemoryMB", "int", None),
		"gpu_free_percent_cpu": ("gpuFreePercentCPU", "float", None),
		"network_total_bandwidth_bytes": ("networkTotalBandwidthBytes", "int", None),
		"network_free_bytes": ("networkFreeBytes", "int", None),
		"ping_time_ms": ("pingTimeMs", "int", None),
		"pending_queries": ("pendingQueries", "int", None),
		"pending_imports": ("pendingImports", "int", None),
		"tables": ("tables", "int", None),
		"pages": ("pages", "int", None),
		"records": ("records", "int", None),
		"active_tcp_connections": ("activeTcpConnections", "int", None),
		"active_tcp_listeners": ("activeTcpListeners", "int", None),
		"active_udp_listeners": ("activeUdpListeners", "int", None),
		"app_start_last_24_hours": ("appStartLast24Hours", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		uptime_seconds: "int",
		time_collected: "datetime",
		cpu_total_cores: "int",
		cpu_usage_percent: "int",
		memory_total_in_use_mb: "int",
		memory_heap_total_mb: "int",
		memory_heap_active_mb: "int",
		memory_free_mb: "int",
		memory_total_mb: "int",
		disk_total_mb: "int",
		disk_free_mb: "int",
		gpu_total_cards: "int",
		gpu_total_memory_mb: "int",
		gpu_free_memory_mb: "int",
		gpu_free_percent_cpu: "float",
		network_total_bandwidth_bytes: "int",
		network_free_bytes: "int",
		ping_time_ms: "int",
		pending_queries: "int",
		pending_imports: "int",
		tables: "int",
		pages: "int",
		records: "int",
		active_tcp_connections: "int",
		active_tcp_listeners: "int",
		active_udp_listeners: "int",
		app_start_last_24_hours: "int",
	) -> None:
		"""
		:param uptime_seconds: The amount of time since this node started
		:type uptime_seconds: int
		:param time_collected: The UTC time that this information was retrieved
		:type time_collected: datetime
		:param cpu_total_cores: The amount of CPU cores available to this node
		:type cpu_total_cores: int
		:param cpu_usage_percent: The percentage of CPU capacity used by this node
		:type cpu_usage_percent: int
		:param memory_total_in_use_mb: The amount of memory consumed by this node
		:type memory_total_in_use_mb: int
		:param memory_heap_total_mb: The total heap size (fragmentation included) of this node at last garbage collection
		:type memory_heap_total_mb: int
		:param memory_heap_active_mb: The active heap size (fragmentation excluded) of this node
		:type memory_heap_active_mb: int
		:param memory_free_mb: The amount of memory available to this node
		:type memory_free_mb: int
		:param memory_total_mb: The amount of physical memory on this node
		:type memory_total_mb: int
		:param disk_total_mb: The amount of storage space available on this node
		:type disk_total_mb: int
		:param disk_free_mb: The amount of unused storage space availble on this node
		:type disk_free_mb: int
		:param gpu_total_cards: The number of graphics cards available on this node
		:type gpu_total_cards: int
		:param gpu_total_memory_mb: The amount of graphic card memory availble on this node
		:type gpu_total_memory_mb: int
		:param gpu_free_memory_mb: The amount of unused graphic card memory on this node
		:type gpu_free_memory_mb: int
		:param gpu_free_percent_cpu: The percentage of total graphic card memory that is not unused on this node
		:type gpu_free_percent_cpu: float
		:param network_total_bandwidth_bytes: The maximum speed of the network measured in bytes per second on this node
		:type network_total_bandwidth_bytes: int
		:param network_free_bytes: The amount of unused bandwith on the network
		:type network_free_bytes: int
		:param ping_time_ms: Trace this
		:type ping_time_ms: int
		:param pending_queries: The number of queries in progress
		:type pending_queries: int
		:param pending_imports: The number of imports in progress
		:type pending_imports: int
		:param tables: The number of tables in the database
		:type tables: int
		:param pages: The number of database table pages in the database
		:type pages: int
		:param records: The total number of records in the database
		:type records: int
		:param active_tcp_connections: The current number of TCP connections used by the host OS
		:type active_tcp_connections: int
		:param active_tcp_listeners: The number of TCP listeners used by the host OS
		:type active_tcp_listeners: int
		:param active_udp_listeners: The number of UDP listeners used by the host OS
		:type active_udp_listeners: int
		:param app_start_last_24_hours: The number of times that the node has started or restarted in the last 24 hours
		:type app_start_last_24_hours: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._uptime_seconds = cast(int, kwargs.get("uptime_seconds"))
		self._time_collected = cast(datetime, kwargs.get("time_collected"))
		self._cpu_total_cores = cast(int, kwargs.get("cpu_total_cores"))
		self._cpu_usage_percent = cast(int, kwargs.get("cpu_usage_percent"))
		self._memory_total_in_use_mb = cast(int, kwargs.get("memory_total_in_use_mb"))
		self._memory_heap_total_mb = cast(int, kwargs.get("memory_heap_total_mb"))
		self._memory_heap_active_mb = cast(int, kwargs.get("memory_heap_active_mb"))
		self._memory_free_mb = cast(int, kwargs.get("memory_free_mb"))
		self._memory_total_mb = cast(int, kwargs.get("memory_total_mb"))
		self._disk_total_mb = cast(int, kwargs.get("disk_total_mb"))
		self._disk_free_mb = cast(int, kwargs.get("disk_free_mb"))
		self._gpu_total_cards = cast(int, kwargs.get("gpu_total_cards"))
		self._gpu_total_memory_mb = cast(int, kwargs.get("gpu_total_memory_mb"))
		self._gpu_free_memory_mb = cast(int, kwargs.get("gpu_free_memory_mb"))
		self._gpu_free_percent_cpu = cast(float, kwargs.get("gpu_free_percent_cpu"))
		self._network_total_bandwidth_bytes = cast(int, kwargs.get("network_total_bandwidth_bytes"))
		self._network_free_bytes = cast(int, kwargs.get("network_free_bytes"))
		self._ping_time_ms = cast(int, kwargs.get("ping_time_ms"))
		self._pending_queries = cast(int, kwargs.get("pending_queries"))
		self._pending_imports = cast(int, kwargs.get("pending_imports"))
		self._tables = cast(int, kwargs.get("tables"))
		self._pages = cast(int, kwargs.get("pages"))
		self._records = cast(int, kwargs.get("records"))
		self._active_tcp_connections = cast(int, kwargs.get("active_tcp_connections"))
		self._active_tcp_listeners = cast(int, kwargs.get("active_tcp_listeners"))
		self._active_udp_listeners = cast(int, kwargs.get("active_udp_listeners"))
		self._app_start_last_24_hours = cast(int, kwargs.get("app_start_last_24_hours"))
	@property
	def uptime_seconds(self) -> "int":
		"""The amount of time since this node started"""
		return self._uptime_seconds
	@uptime_seconds.setter
	def uptime_seconds(self, value: "int") -> None:
		"""The amount of time since this node started"""
		self._uptime_seconds = value
	@property
	def time_collected(self) -> "datetime":
		"""The UTC time that this information was retrieved"""
		return self._time_collected
	@time_collected.setter
	def time_collected(self, value: "datetime") -> None:
		"""The UTC time that this information was retrieved"""
		self._time_collected = value
	@property
	def cpu_total_cores(self) -> "int":
		"""The amount of CPU cores available to this node"""
		return self._cpu_total_cores
	@cpu_total_cores.setter
	def cpu_total_cores(self, value: "int") -> None:
		"""The amount of CPU cores available to this node"""
		self._cpu_total_cores = value
	@property
	def cpu_usage_percent(self) -> "int":
		"""The percentage of CPU capacity used by this node"""
		return self._cpu_usage_percent
	@cpu_usage_percent.setter
	def cpu_usage_percent(self, value: "int") -> None:
		"""The percentage of CPU capacity used by this node"""
		self._cpu_usage_percent = value
	@property
	def memory_total_in_use_mb(self) -> "int":
		"""The amount of memory consumed by this node"""
		return self._memory_total_in_use_mb
	@memory_total_in_use_mb.setter
	def memory_total_in_use_mb(self, value: "int") -> None:
		"""The amount of memory consumed by this node"""
		self._memory_total_in_use_mb = value
	@property
	def memory_heap_total_mb(self) -> "int":
		"""The total heap size (fragmentation included) of this node at last garbage collection"""
		return self._memory_heap_total_mb
	@memory_heap_total_mb.setter
	def memory_heap_total_mb(self, value: "int") -> None:
		"""The total heap size (fragmentation included) of this node at last garbage collection"""
		self._memory_heap_total_mb = value
	@property
	def memory_heap_active_mb(self) -> "int":
		"""The active heap size (fragmentation excluded) of this node"""
		return self._memory_heap_active_mb
	@memory_heap_active_mb.setter
	def memory_heap_active_mb(self, value: "int") -> None:
		"""The active heap size (fragmentation excluded) of this node"""
		self._memory_heap_active_mb = value
	@property
	def memory_free_mb(self) -> "int":
		"""The amount of memory available to this node"""
		return self._memory_free_mb
	@memory_free_mb.setter
	def memory_free_mb(self, value: "int") -> None:
		"""The amount of memory available to this node"""
		self._memory_free_mb = value
	@property
	def memory_total_mb(self) -> "int":
		"""The amount of physical memory on this node"""
		return self._memory_total_mb
	@memory_total_mb.setter
	def memory_total_mb(self, value: "int") -> None:
		"""The amount of physical memory on this node"""
		self._memory_total_mb = value
	@property
	def disk_total_mb(self) -> "int":
		"""The amount of storage space available on this node"""
		return self._disk_total_mb
	@disk_total_mb.setter
	def disk_total_mb(self, value: "int") -> None:
		"""The amount of storage space available on this node"""
		self._disk_total_mb = value
	@property
	def disk_free_mb(self) -> "int":
		"""The amount of unused storage space availble on this node"""
		return self._disk_free_mb
	@disk_free_mb.setter
	def disk_free_mb(self, value: "int") -> None:
		"""The amount of unused storage space availble on this node"""
		self._disk_free_mb = value
	@property
	def gpu_total_cards(self) -> "int":
		"""The number of graphics cards available on this node"""
		return self._gpu_total_cards
	@gpu_total_cards.setter
	def gpu_total_cards(self, value: "int") -> None:
		"""The number of graphics cards available on this node"""
		self._gpu_total_cards = value
	@property
	def gpu_total_memory_mb(self) -> "int":
		"""The amount of graphic card memory availble on this node"""
		return self._gpu_total_memory_mb
	@gpu_total_memory_mb.setter
	def gpu_total_memory_mb(self, value: "int") -> None:
		"""The amount of graphic card memory availble on this node"""
		self._gpu_total_memory_mb = value
	@property
	def gpu_free_memory_mb(self) -> "int":
		"""The amount of unused graphic card memory on this node"""
		return self._gpu_free_memory_mb
	@gpu_free_memory_mb.setter
	def gpu_free_memory_mb(self, value: "int") -> None:
		"""The amount of unused graphic card memory on this node"""
		self._gpu_free_memory_mb = value
	@property
	def gpu_free_percent_cpu(self) -> "float":
		"""The percentage of total graphic card memory that is not unused on this node"""
		return self._gpu_free_percent_cpu
	@gpu_free_percent_cpu.setter
	def gpu_free_percent_cpu(self, value: "float") -> None:
		"""The percentage of total graphic card memory that is not unused on this node"""
		self._gpu_free_percent_cpu = value
	@property
	def network_total_bandwidth_bytes(self) -> "int":
		"""The maximum speed of the network measured in bytes per second on this node"""
		return self._network_total_bandwidth_bytes
	@network_total_bandwidth_bytes.setter
	def network_total_bandwidth_bytes(self, value: "int") -> None:
		"""The maximum speed of the network measured in bytes per second on this node"""
		self._network_total_bandwidth_bytes = value
	@property
	def network_free_bytes(self) -> "int":
		"""The amount of unused bandwith on the network"""
		return self._network_free_bytes
	@network_free_bytes.setter
	def network_free_bytes(self, value: "int") -> None:
		"""The amount of unused bandwith on the network"""
		self._network_free_bytes = value
	@property
	def ping_time_ms(self) -> "int":
		"""Trace this"""
		return self._ping_time_ms
	@ping_time_ms.setter
	def ping_time_ms(self, value: "int") -> None:
		"""Trace this"""
		self._ping_time_ms = value
	@property
	def pending_queries(self) -> "int":
		"""The number of queries in progress"""
		return self._pending_queries
	@pending_queries.setter
	def pending_queries(self, value: "int") -> None:
		"""The number of queries in progress"""
		self._pending_queries = value
	@property
	def pending_imports(self) -> "int":
		"""The number of imports in progress"""
		return self._pending_imports
	@pending_imports.setter
	def pending_imports(self, value: "int") -> None:
		"""The number of imports in progress"""
		self._pending_imports = value
	@property
	def tables(self) -> "int":
		"""The number of tables in the database"""
		return self._tables
	@tables.setter
	def tables(self, value: "int") -> None:
		"""The number of tables in the database"""
		self._tables = value
	@property
	def pages(self) -> "int":
		"""The number of database table pages in the database"""
		return self._pages
	@pages.setter
	def pages(self, value: "int") -> None:
		"""The number of database table pages in the database"""
		self._pages = value
	@property
	def records(self) -> "int":
		"""The total number of records in the database"""
		return self._records
	@records.setter
	def records(self, value: "int") -> None:
		"""The total number of records in the database"""
		self._records = value
	@property
	def active_tcp_connections(self) -> "int":
		"""The current number of TCP connections used by the host OS"""
		return self._active_tcp_connections
	@active_tcp_connections.setter
	def active_tcp_connections(self, value: "int") -> None:
		"""The current number of TCP connections used by the host OS"""
		self._active_tcp_connections = value
	@property
	def active_tcp_listeners(self) -> "int":
		"""The number of TCP listeners used by the host OS"""
		return self._active_tcp_listeners
	@active_tcp_listeners.setter
	def active_tcp_listeners(self, value: "int") -> None:
		"""The number of TCP listeners used by the host OS"""
		self._active_tcp_listeners = value
	@property
	def active_udp_listeners(self) -> "int":
		"""The number of UDP listeners used by the host OS"""
		return self._active_udp_listeners
	@active_udp_listeners.setter
	def active_udp_listeners(self, value: "int") -> None:
		"""The number of UDP listeners used by the host OS"""
		self._active_udp_listeners = value
	@property
	def app_start_last_24_hours(self) -> "int":
		"""The number of times that the node has started or restarted in the last 24 hours"""
		return self._app_start_last_24_hours
	@app_start_last_24_hours.setter
	def app_start_last_24_hours(self, value: "int") -> None:
		"""The number of times that the node has started or restarted in the last 24 hours"""
		self._app_start_last_24_hours = value
class HashJoinDataLR:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"left": ("left", "str", None),
		"right": ("right", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		left: Optional["str"] = None,
		right: Optional["str"] = None,
	) -> None:
		"""
		:param left:
		:type left: str or None
		:param right:
		:type right: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._left = cast(Optional[str], kwargs.get("left"))
		self._right = cast(Optional[str], kwargs.get("right"))
	@property
	def left(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._left
	@left.setter
	def left(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._left = value
	@property
	def right(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._right
	@right.setter
	def right(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._right = value


class HatchStyle(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	DEFAULT = 'Default'
	HORIZONTAL = 'Horizontal'
	MIN = 'Min'
	VERTICAL = 'Vertical'
	FORWARD_DIAGONAL = 'ForwardDiagonal'
	BACKWARD_DIAGONAL = 'BackwardDiagonal'
	CROSS = 'Cross'
	LARGE_GRID = 'LargeGrid'
	MAX = 'Max'
	DIAGONAL_CROSS = 'DiagonalCross'
	PERCENT_05 = 'Percent05'
	PERCENT_10 = 'Percent10'
	PERCENT_20 = 'Percent20'
	PERCENT_25 = 'Percent25'
	PERCENT_30 = 'Percent30'
	PERCENT_40 = 'Percent40'
	PERCENT_50 = 'Percent50'
	PERCENT_60 = 'Percent60'
	PERCENT_70 = 'Percent70'
	PERCENT_75 = 'Percent75'
	PERCENT_80 = 'Percent80'
	PERCENT_90 = 'Percent90'
	LIGHT_DOWNWARD_DIAGONAL = 'LightDownwardDiagonal'
	LIGHT_UPWARD_DIAGONAL = 'LightUpwardDiagonal'
	DARK_DOWNWARD_DIAGONAL = 'DarkDownwardDiagonal'
	DARK_UPWARD_DIAGONAL = 'DarkUpwardDiagonal'
	WIDE_DOWNWARD_DIAGONAL = 'WideDownwardDiagonal'
	WIDE_UPWARD_DIAGONAL = 'WideUpwardDiagonal'
	LIGHT_VERTICAL = 'LightVertical'
	LIGHT_HORIZONTAL = 'LightHorizontal'
	NARROW_VERTICAL = 'NarrowVertical'
	NARROW_HORIZONTAL = 'NarrowHorizontal'
	DARK_VERTICAL = 'DarkVertical'
	DARK_HORIZONTAL = 'DarkHorizontal'
	DASHED_DOWNWARD_DIAGONAL = 'DashedDownwardDiagonal'
	DASHED_UPWARD_DIAGONAL = 'DashedUpwardDiagonal'
	DASHED_HORIZONTAL = 'DashedHorizontal'
	DASHED_VERTICAL = 'DashedVertical'
	SMALL_CONFETTI = 'SmallConfetti'
	LARGE_CONFETTI = 'LargeConfetti'
	ZIG_ZAG = 'ZigZag'
	WAVE = 'Wave'
	DIAGONAL_BRICK = 'DiagonalBrick'
	HORIZONTAL_BRICK = 'HorizontalBrick'
	WEAVE = 'Weave'
	PLAID = 'Plaid'
	DIVOT = 'Divot'
	DOTTED_GRID = 'DottedGrid'
	DOTTED_DIAMOND = 'DottedDiamond'
	SHINGLE = 'Shingle'
	TRELLIS = 'Trellis'
	SPHERE = 'Sphere'
	SMALL_GRID = 'SmallGrid'
	SMALL_CHECKER_BOARD = 'SmallCheckerBoard'
	LARGE_CHECKER_BOARD = 'LargeCheckerBoard'
	OUTLINED_DIAMOND = 'OutlinedDiamond'
	SOLID_DIAMOND = 'SolidDiamond'



class HeadlessSchema(str, Enum):
	# pylint: disable=missing-class-docstring
	UNSPECIFIED = 'UNSPECIFIED'
	CSV = 'CSV'
	TSV = 'TSV'
	FIXEDWIDTH = 'FIXEDWIDTH'



class HoleMode(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	COLLISION = 'Collision'
	ORDERED = 'Ordered'

class HoverGridData:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"index": ("index", "list", "int"),
		"data": ("data", "dict", "list"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		index: "List[int]",
		data: "Dict[str, List[Any]]",
	) -> None:
		"""
		:param index: An array with 64 * 64 = 4096 elements - one for each 4x4 pixel square in the 256x256 pixel tile. -1 means there is no data on this layer in the 4x4 pixel square. Otherwise the value is a key in the `data` dictionary.
		:type index: List[int]
		:param data: A dictionary of the geospatial data elements present in this tile on this layer. Values in this dictionary are arrays with 6 elements in the following order: lat, lng, hoverText, preText, wkt, graphEntryType.
		:type data: Dict[str, List[Any]]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._index = cast(List[int], kwargs.get("index"))
		self._data = cast(Dict[str, List[Any]], kwargs.get("data"))
	@property
	def index(self) -> "List[int]":
		"""An array with 64 * 64 = 4096 elements - one for each 4x4 pixel square in the 256x256 pixel tile. -1 means there is no data on this layer in the 4x4 pixel square. Otherwise the value is a key in the `data` dictionary."""
		return self._index
	@index.setter
	def index(self, value: "List[int]") -> None:
		"""An array with 64 * 64 = 4096 elements - one for each 4x4 pixel square in the 256x256 pixel tile. -1 means there is no data on this layer in the 4x4 pixel square. Otherwise the value is a key in the `data` dictionary."""
		self._index = value
	@property
	def data(self) -> "Dict[str, List[Any]]":
		"""A dictionary of the geospatial data elements present in this tile on this layer. Values in this dictionary are arrays with 6 elements in the following order: lat, lng, hoverText, preText, wkt, graphEntryType."""
		return self._data
	@data.setter
	def data(self, value: "Dict[str, List[Any]]") -> None:
		"""A dictionary of the geospatial data elements present in this tile on this layer. Values in this dictionary are arrays with 6 elements in the following order: lat, lng, hoverText, preText, wkt, graphEntryType."""
		self._data = value


class HttpCompletionOption(str, Enum):
	# pylint: disable=missing-class-docstring
	RESPONSE_CONTENT_READ = 'ResponseContentRead'
	RESPONSE_HEADERS_READ = 'ResponseHeadersRead'

class IconBadge:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"enabled": ("enabled", "bool", None),
		"position": ("position", "Position", None),
		"text": ("text", "str", None),
		"color": ("color", "str", None),
		"border_color": ("borderColor", "str", None),
		"fill_color": ("fillColor", "str", None),
		"size": ("size", "int", None),
		"text_scale": ("textScale", "float", None),
		"allow_long_text": ("allowLongText", "bool", None),
		"text_size": ("textSize", "int", None),
		"x": ("x", "int", None),
		"y": ("y", "int", None),
		"font_family": ("fontFamily", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		enabled: Optional["bool"] = None,
		position: Optional["Position"] = None,
		text: Optional["str"] = None,
		color: Optional["str"] = None,
		border_color: Optional["str"] = None,
		fill_color: Optional["str"] = None,
		size: Optional["int"] = None,
		text_scale: Optional["float"] = None,
		allow_long_text: Optional["bool"] = None,
		text_size: Optional["int"] = None,
		x: Optional["int"] = None,
		y: Optional["int"] = None,
		font_family: Optional["str"] = None,
	) -> None:
		"""
		:param enabled:
		:type enabled: bool or None
		:param position:
		:type position: Position or None
		:param text:
		:type text: str or None
		:param color: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type color: str or None
		:param border_color: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type border_color: str or None
		:param fill_color: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type fill_color: str or None
		:param size:
		:type size: int or None
		:param text_scale:
		:type text_scale: float or None
		:param allow_long_text:
		:type allow_long_text: bool or None
		:param text_size:
		:type text_size: int or None
		:param x:
		:type x: int or None
		:param y:
		:type y: int or None
		:param font_family:
		:type font_family: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._enabled = cast(Optional[bool], kwargs.get("enabled"))
		self._position = cast(Optional[Position], kwargs.get("position"))
		self._text = cast(Optional[str], kwargs.get("text"))
		self._color = cast(Optional[str], kwargs.get("color"))
		self._border_color = cast(Optional[str], kwargs.get("border_color"))
		self._fill_color = cast(Optional[str], kwargs.get("fill_color"))
		self._size = cast(Optional[int], kwargs.get("size"))
		self._text_scale = cast(Optional[float], kwargs.get("text_scale"))
		self._allow_long_text = cast(Optional[bool], kwargs.get("allow_long_text"))
		self._text_size = cast(Optional[int], kwargs.get("text_size"))
		self._x = cast(Optional[int], kwargs.get("x"))
		self._y = cast(Optional[int], kwargs.get("y"))
		self._font_family = cast(Optional[str], kwargs.get("font_family"))
	@property
	def enabled(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def position(self) -> Optional["Position"]:
		# pylint: disable=missing-function-docstring
		return self._position
	@position.setter
	def position(self, value: Optional["Position"]) -> None:
		# pylint: disable=missing-function-docstring
		self._position = value
	@property
	def text(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._text
	@text.setter
	def text(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._text = value
	@property
	def color(self) -> Optional["str"]:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._color = value
	@property
	def border_color(self) -> Optional["str"]:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._border_color
	@border_color.setter
	def border_color(self, value: Optional["str"]) -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._border_color = value
	@property
	def fill_color(self) -> Optional["str"]:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._fill_color
	@fill_color.setter
	def fill_color(self, value: Optional["str"]) -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._fill_color = value
	@property
	def size(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._size
	@size.setter
	def size(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._size = value
	@property
	def text_scale(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._text_scale
	@text_scale.setter
	def text_scale(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._text_scale = value
	@property
	def allow_long_text(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._allow_long_text
	@allow_long_text.setter
	def allow_long_text(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._allow_long_text = value
	@property
	def text_size(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._text_size
	@text_size.setter
	def text_size(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._text_size = value
	@property
	def x(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._x
	@x.setter
	def x(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._x = value
	@property
	def y(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._y
	@y.setter
	def y(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._y = value
	@property
	def font_family(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._font_family
	@font_family.setter
	def font_family(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._font_family = value


class IconDataColorType(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	CENTER_PIXEL = 'CenterPixel'
	DOMINANT_COLOR = 'DominantColor'
	DOMINANT_COLOR_IN_PALETTE = 'DominantColorInPalette'

class IconIdentifier:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"set_": ("set", "str", None),
		"path": ("path", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: Optional["str"] = None,
		set_: Optional["str"] = None,
		path: Optional["str"] = None,
	) -> None:
		"""
		:param id_:
		:type id_: str or None
		:param set_:
		:type set_: str or None
		:param path:
		:type path: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._set_ = cast(Optional[str], kwargs.get("set_"))
		self._path = cast(Optional[str], kwargs.get("path"))
	@property
	def id_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value
	@property
	def set_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._set_
	@set_.setter
	def set_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._set_ = value
	@property
	def path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._path
	@path.setter
	def path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path = value
class IconLayer(IconIdentifier):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"enabled": ("enabled", "bool", None),
		"position": ("position", "Position", None),
		"size": ("size", "int", None),
		"color": ("color", "str", None),
		"x": ("x", "int", None),
		"y": ("y", "int", None),
		"svg_attributes": ("svgAttributes", "list", "StyleSvgAttribute"),
		"id_": ("id", "str", None),
		"set_": ("set", "str", None),
		"path": ("path", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		enabled: Optional["bool"] = None,
		position: Optional["Position"] = None,
		size: Optional["int"] = None,
		color: Optional["str"] = None,
		x: Optional["int"] = None,
		y: Optional["int"] = None,
		svg_attributes: Optional["List[StyleSvgAttribute]"] = None,
		id_: Optional["str"] = None,
		set_: Optional["str"] = None,
		path: Optional["str"] = None,
	) -> None:
		"""
		:param enabled:
		:type enabled: bool or None
		:param position:
		:type position: Position or None
		:param size:
		:type size: int or None
		:param color: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type color: str or None
		:param x:
		:type x: int or None
		:param y:
		:type y: int or None
		:param svg_attributes:
		:type svg_attributes: List[StyleSvgAttribute] or None
		:param id_:
		:type id_: str or None
		:param set_:
		:type set_: str or None
		:param path:
		:type path: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		IconIdentifier.__init__(self,
			id_=kwargs.get("id_"),
			set_=kwargs.get("set_"),
			path=kwargs.get("path"),
		)
		self._enabled = cast(Optional[bool], kwargs.get("enabled"))
		self._position = cast(Optional[Position], kwargs.get("position"))
		self._size = cast(Optional[int], kwargs.get("size"))
		self._color = cast(Optional[str], kwargs.get("color"))
		self._x = cast(Optional[int], kwargs.get("x"))
		self._y = cast(Optional[int], kwargs.get("y"))
		self._svg_attributes = cast(Optional[List[StyleSvgAttribute]], kwargs.get("svg_attributes"))
	@property
	def enabled(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def position(self) -> Optional["Position"]:
		# pylint: disable=missing-function-docstring
		return self._position
	@position.setter
	def position(self, value: Optional["Position"]) -> None:
		# pylint: disable=missing-function-docstring
		self._position = value
	@property
	def size(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._size
	@size.setter
	def size(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._size = value
	@property
	def color(self) -> Optional["str"]:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._color = value
	@property
	def x(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._x
	@x.setter
	def x(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._x = value
	@property
	def y(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._y
	@y.setter
	def y(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._y = value
	@property
	def svg_attributes(self) -> Optional["List[StyleSvgAttribute]"]:
		# pylint: disable=missing-function-docstring
		return self._svg_attributes
	@svg_attributes.setter
	def svg_attributes(self, value: Optional["List[StyleSvgAttribute]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._svg_attributes = value


class ImageFormatType(str, Enum):
	"""The file type of the image."""
	PNG = 'png'
	JPEG = 'jpeg'
	WEBP = 'webp'

class ImageRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "str", None),
		"data": ("data", "str", None),
		"data_column": ("dataColumn", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: Optional["str"] = None,
		data: Optional["str"] = None,
		data_column: Optional["str"] = None,
	) -> None:
		"""
		:param account:
		:type account: str or None
		:param data:
		:type data: str or None
		:param data_column:
		:type data_column: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._account = cast(Optional[str], kwargs.get("account"))
		self._data = cast(Optional[str], kwargs.get("data"))
		self._data_column = cast(Optional[str], kwargs.get("data_column"))
	@property
	def account(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._account
	@account.setter
	def account(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._account = value
	@property
	def data(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._data
	@data.setter
	def data(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._data = value
	@property
	def data_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._data_column
	@data_column.setter
	def data_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._data_column = value
class ImageryConfig:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"cutout": ("cutout", "str", None),
		"import_as_raster": ("importAsRaster", "bool", None),
		"rgb_fan_out": ("rgbFanOut", "bool", None),
		"rgb_squash": ("rgbSquash", "bool", None),
		"stitch_images": ("stitchImages", "bool", None),
		"image_stitch_base_url": ("imageStitchBaseURL", "str", None),
		"image_stitch_user": ("imageStitchUser", "str", None),
		"image_stitch_password": ("imageStitchPassword", "str", None),
		"image_stitch_project": ("imageStitchProject", "str", None),
		"import_split_factor": ("importSplitFactor", "int", None),
		"preprocessed_raster": ("preprocessedRaster", "bool", None),
		"imagery_format": ("imageryFormat", "ImageryFormat", None),
		"image_quality": ("imageQuality", "int", None),
		"resolution_cm_per_px": ("resolutionCmPerPx", "float", None),
		"band_name_format": ("bandNameFormat", "str", None),
		"band_name_sequence_start": ("bandNameSequenceStart", "int", None),
		"stitch_options": ("stitchOptions", "list", "ImageryConfigImageStitchOption"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		import_as_raster: "bool",
		rgb_fan_out: "bool",
		rgb_squash: "bool",
		stitch_images: "bool",
		import_split_factor: "int",
		preprocessed_raster: "bool",
		image_quality: "int",
		resolution_cm_per_px: "float",
		band_name_sequence_start: "int",
		stitch_options: "List[ImageryConfigImageStitchOption]",
		cutout: Optional["str"] = None,
		image_stitch_base_url: Optional["str"] = None,
		image_stitch_user: Optional["str"] = None,
		image_stitch_password: Optional["str"] = None,
		image_stitch_project: Optional["str"] = None,
		imagery_format: Optional["ImageryFormat"] = None,
		band_name_format: Optional["str"] = None,
	) -> None:
		"""
		:param import_as_raster:
		:type import_as_raster: bool
		:param rgb_fan_out:
		:type rgb_fan_out: bool
		:param rgb_squash:
		:type rgb_squash: bool
		:param stitch_images:
		:type stitch_images: bool
		:param import_split_factor:
		:type import_split_factor: int
		:param preprocessed_raster:
		:type preprocessed_raster: bool
		:param image_quality:
		:type image_quality: int
		:param resolution_cm_per_px:
		:type resolution_cm_per_px: float
		:param band_name_sequence_start:
		:type band_name_sequence_start: int
		:param stitch_options:
		:type stitch_options: List[ImageryConfigImageStitchOption]
		:param cutout: Polygon WKT for trimming the imported image to a specific geo area, leaving out parts external to this polygon
		:type cutout: str or None
		:param image_stitch_base_url:
		:type image_stitch_base_url: str or None
		:param image_stitch_user:
		:type image_stitch_user: str or None
		:param image_stitch_password:
		:type image_stitch_password: str or None
		:param image_stitch_project:
		:type image_stitch_project: str or None
		:param imagery_format:
		:type imagery_format: ImageryFormat or None
		:param band_name_format:
		:type band_name_format: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._cutout = cast(Optional[str], kwargs.get("cutout"))
		self._import_as_raster = cast(bool, kwargs.get("import_as_raster"))
		self._rgb_fan_out = cast(bool, kwargs.get("rgb_fan_out"))
		self._rgb_squash = cast(bool, kwargs.get("rgb_squash"))
		self._stitch_images = cast(bool, kwargs.get("stitch_images"))
		self._image_stitch_base_url = cast(Optional[str], kwargs.get("image_stitch_base_url"))
		self._image_stitch_user = cast(Optional[str], kwargs.get("image_stitch_user"))
		self._image_stitch_password = cast(Optional[str], kwargs.get("image_stitch_password"))
		self._image_stitch_project = cast(Optional[str], kwargs.get("image_stitch_project"))
		self._import_split_factor = cast(int, kwargs.get("import_split_factor"))
		self._preprocessed_raster = cast(bool, kwargs.get("preprocessed_raster"))
		self._imagery_format = cast(Optional[ImageryFormat], kwargs.get("imagery_format"))
		self._image_quality = cast(int, kwargs.get("image_quality"))
		self._resolution_cm_per_px = cast(float, kwargs.get("resolution_cm_per_px"))
		self._band_name_format = cast(Optional[str], kwargs.get("band_name_format"))
		self._band_name_sequence_start = cast(int, kwargs.get("band_name_sequence_start"))
		self._stitch_options = cast(List[ImageryConfigImageStitchOption], kwargs.get("stitch_options"))
	@property
	def cutout(self) -> Optional["str"]:
		"""Polygon WKT for trimming the imported image to a specific geo area, leaving out parts external to this polygon"""
		return self._cutout
	@cutout.setter
	def cutout(self, value: Optional["str"]) -> None:
		"""Polygon WKT for trimming the imported image to a specific geo area, leaving out parts external to this polygon"""
		self._cutout = value
	@property
	def import_as_raster(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._import_as_raster
	@import_as_raster.setter
	def import_as_raster(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._import_as_raster = value
	@property
	def rgb_fan_out(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._rgb_fan_out
	@rgb_fan_out.setter
	def rgb_fan_out(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._rgb_fan_out = value
	@property
	def rgb_squash(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._rgb_squash
	@rgb_squash.setter
	def rgb_squash(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._rgb_squash = value
	@property
	def stitch_images(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._stitch_images
	@stitch_images.setter
	def stitch_images(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._stitch_images = value
	@property
	def image_stitch_base_url(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._image_stitch_base_url
	@image_stitch_base_url.setter
	def image_stitch_base_url(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._image_stitch_base_url = value
	@property
	def image_stitch_user(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._image_stitch_user
	@image_stitch_user.setter
	def image_stitch_user(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._image_stitch_user = value
	@property
	def image_stitch_password(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._image_stitch_password
	@image_stitch_password.setter
	def image_stitch_password(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._image_stitch_password = value
	@property
	def image_stitch_project(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._image_stitch_project
	@image_stitch_project.setter
	def image_stitch_project(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._image_stitch_project = value
	@property
	def import_split_factor(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._import_split_factor
	@import_split_factor.setter
	def import_split_factor(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._import_split_factor = value
	@property
	def preprocessed_raster(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._preprocessed_raster
	@preprocessed_raster.setter
	def preprocessed_raster(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._preprocessed_raster = value
	@property
	def imagery_format(self) -> Optional["ImageryFormat"]:
		# pylint: disable=missing-function-docstring
		return self._imagery_format
	@imagery_format.setter
	def imagery_format(self, value: Optional["ImageryFormat"]) -> None:
		# pylint: disable=missing-function-docstring
		self._imagery_format = value
	@property
	def image_quality(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._image_quality
	@image_quality.setter
	def image_quality(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._image_quality = value
	@property
	def resolution_cm_per_px(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._resolution_cm_per_px
	@resolution_cm_per_px.setter
	def resolution_cm_per_px(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._resolution_cm_per_px = value
	@property
	def band_name_format(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._band_name_format
	@band_name_format.setter
	def band_name_format(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._band_name_format = value
	@property
	def band_name_sequence_start(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._band_name_sequence_start
	@band_name_sequence_start.setter
	def band_name_sequence_start(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._band_name_sequence_start = value
	@property
	def stitch_options(self) -> "List[ImageryConfigImageStitchOption]":
		# pylint: disable=missing-function-docstring
		return self._stitch_options
	@stitch_options.setter
	def stitch_options(self, value: "List[ImageryConfigImageStitchOption]") -> None:
		# pylint: disable=missing-function-docstring
		self._stitch_options = value
class ImageryConfigImageStitchOption:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"value": ("value", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: Optional["str"] = None,
		value: Optional["str"] = None,
	) -> None:
		"""
		:param name:
		:type name: str or None
		:param value:
		:type value: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._value = cast(Optional[str], kwargs.get("value"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def value(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._value
	@value.setter
	def value(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._value = value


class ImageryFormat(str, Enum):
	# pylint: disable=missing-class-docstring
	TIFF = 'TIFF'
	PNG = 'PNG'
	JPEG = 'JPEG'

class IMapLargeBaseMapTheme:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"is_user_defined": ("isUserDefined", "bool", None),
		"roads": ("roads", "RoadBaseMapTheme", None),
		"background": ("background", "BackgroundBaseMapTheme", None),
		"buildings": ("buildings", "BuildingBaseMapTheme", None),
		"borders": ("borders", "BorderBaseMapTheme", None),
		"placenames": ("placenames", "PlacenameBaseMapTheme", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		is_user_defined: "bool",
		roads: "RoadBaseMapTheme",
		background: "BackgroundBaseMapTheme",
		buildings: "BuildingBaseMapTheme",
		borders: "BorderBaseMapTheme",
		placenames: "PlacenameBaseMapTheme",
	) -> None:
		"""
		:param is_user_defined:
		:type is_user_defined: bool
		:param roads:
		:type roads: RoadBaseMapTheme
		:param background:
		:type background: BackgroundBaseMapTheme
		:param buildings:
		:type buildings: BuildingBaseMapTheme
		:param borders:
		:type borders: BorderBaseMapTheme
		:param placenames:
		:type placenames: PlacenameBaseMapTheme
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._is_user_defined = cast(bool, kwargs.get("is_user_defined"))
		self._roads = cast(RoadBaseMapTheme, kwargs.get("roads"))
		self._background = cast(BackgroundBaseMapTheme, kwargs.get("background"))
		self._buildings = cast(BuildingBaseMapTheme, kwargs.get("buildings"))
		self._borders = cast(BorderBaseMapTheme, kwargs.get("borders"))
		self._placenames = cast(PlacenameBaseMapTheme, kwargs.get("placenames"))
	@property
	def is_user_defined(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_user_defined
	@is_user_defined.setter
	def is_user_defined(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_user_defined = value
	@property
	def roads(self) -> "RoadBaseMapTheme":
		# pylint: disable=missing-function-docstring
		return self._roads
	@roads.setter
	def roads(self, value: "RoadBaseMapTheme") -> None:
		# pylint: disable=missing-function-docstring
		self._roads = value
	@property
	def background(self) -> "BackgroundBaseMapTheme":
		# pylint: disable=missing-function-docstring
		return self._background
	@background.setter
	def background(self, value: "BackgroundBaseMapTheme") -> None:
		# pylint: disable=missing-function-docstring
		self._background = value
	@property
	def buildings(self) -> "BuildingBaseMapTheme":
		# pylint: disable=missing-function-docstring
		return self._buildings
	@buildings.setter
	def buildings(self, value: "BuildingBaseMapTheme") -> None:
		# pylint: disable=missing-function-docstring
		self._buildings = value
	@property
	def borders(self) -> "BorderBaseMapTheme":
		# pylint: disable=missing-function-docstring
		return self._borders
	@borders.setter
	def borders(self, value: "BorderBaseMapTheme") -> None:
		# pylint: disable=missing-function-docstring
		self._borders = value
	@property
	def placenames(self) -> "PlacenameBaseMapTheme":
		# pylint: disable=missing-function-docstring
		return self._placenames
	@placenames.setter
	def placenames(self, value: "PlacenameBaseMapTheme") -> None:
		# pylint: disable=missing-function-docstring
		self._placenames = value
class Import:
	"""A long-running import process."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"target_account": ("targetAccount", "AccountReference", None),
		"type_": ("type", "str", None),
		"start": ("start", "datetime", None),
		"finish": ("finish", "datetime", None),
		"message": ("message", "str", None),
		"source": ("source", "str", None),
		"target": ("target", "str", None),
		"progress": ("progress", "ImportProgress", None),
		"successful": ("successful", "bool", None),
		"errors": ("errors", "list", "str"),
		"last_update": ("lastUpdate", "datetime", None),
		"most_recent_activity": ("mostRecentActivity", "ImportStepSummary", None),
		"links": ("_links", "ImportLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
		start: "datetime",
		progress: "ImportProgress",
		errors: "List[str]",
		links: "ImportLinks",
		target_account: Optional["AccountReference"] = None,
		type_: Optional["str"] = None,
		finish: Optional["datetime"] = None,
		message: Optional["str"] = None,
		source: Optional["str"] = None,
		target: Optional["str"] = None,
		successful: Optional["bool"] = None,
		last_update: Optional["datetime"] = None,
		most_recent_activity: Optional["ImportStepSummary"] = None,
	) -> None:
		"""
		:param id_: Unique string id of the import. A guid with no dashes, 32 hexadecimal digits.
		:type id_: str
		:param start: Start time for the import.
		:type start: datetime
		:param progress: Numeric progress, if available.
		:type progress: ImportProgress
		:param errors: Cumulative error messages for the import. If the import completes successfully, but there are error messages, they should be treated as warnings.
		:type errors: List[str]
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: ImportLinks
		:param target_account: Requested destination account.
		:type target_account: AccountReference or None
		:param type_: The type of import being performed. Examples: "File URL Async", "Tile Set", "Adapter Import", "DynamoDB", "Kinesis", etc.
		:type type_: str or None
		:param finish: Finish time for the import.
		:type finish: datetime or None
		:param message: A description of the current activity of this import.
		:type message: str or None
		:param source: Source data for the import.
		:type source: str or None
		:param target: Requested destination table or tile set.
		:type target: str or None
		:param successful: If the import has completed, indicates whether it succeeded or failed. Otherwise the value is null.
		:type successful: bool or None
		:param last_update: Date/time the status of this import was last updated.
		:type last_update: datetime or None
		:param most_recent_activity: A summarized version of the most recent activity.
		:type most_recent_activity: ImportStepSummary or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
		self._target_account = cast(Optional[AccountReference], kwargs.get("target_account"))
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._start = cast(datetime, kwargs.get("start"))
		self._finish = cast(Optional[datetime], kwargs.get("finish"))
		self._message = cast(Optional[str], kwargs.get("message"))
		self._source = cast(Optional[str], kwargs.get("source"))
		self._target = cast(Optional[str], kwargs.get("target"))
		self._progress = cast(ImportProgress, kwargs.get("progress"))
		self._successful = cast(Optional[bool], kwargs.get("successful"))
		self._errors = cast(List[str], kwargs.get("errors"))
		self._last_update = cast(Optional[datetime], kwargs.get("last_update"))
		self._most_recent_activity = cast(Optional[ImportStepSummary], kwargs.get("most_recent_activity"))
		self._links = cast(ImportLinks, kwargs.get("links"))
	@property
	def id_(self) -> "str":
		"""Unique string id of the import. A guid with no dashes, 32 hexadecimal digits."""
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		"""Unique string id of the import. A guid with no dashes, 32 hexadecimal digits."""
		self._id_ = value
	@property
	def target_account(self) -> Optional["AccountReference"]:
		"""Requested destination account."""
		return self._target_account
	@target_account.setter
	def target_account(self, value: Optional["AccountReference"]) -> None:
		"""Requested destination account."""
		self._target_account = value
	@property
	def type_(self) -> Optional["str"]:
		"""The type of import being performed. Examples: "File URL Async", "Tile Set", "Adapter Import", "DynamoDB", "Kinesis", etc."""
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		"""The type of import being performed. Examples: "File URL Async", "Tile Set", "Adapter Import", "DynamoDB", "Kinesis", etc."""
		self._type_ = value
	@property
	def start(self) -> "datetime":
		"""Start time for the import."""
		return self._start
	@start.setter
	def start(self, value: "datetime") -> None:
		"""Start time for the import."""
		self._start = value
	@property
	def finish(self) -> Optional["datetime"]:
		"""Finish time for the import."""
		return self._finish
	@finish.setter
	def finish(self, value: Optional["datetime"]) -> None:
		"""Finish time for the import."""
		self._finish = value
	@property
	def message(self) -> Optional["str"]:
		"""A description of the current activity of this import."""
		return self._message
	@message.setter
	def message(self, value: Optional["str"]) -> None:
		"""A description of the current activity of this import."""
		self._message = value
	@property
	def source(self) -> Optional["str"]:
		"""Source data for the import."""
		return self._source
	@source.setter
	def source(self, value: Optional["str"]) -> None:
		"""Source data for the import."""
		self._source = value
	@property
	def target(self) -> Optional["str"]:
		"""Requested destination table or tile set."""
		return self._target
	@target.setter
	def target(self, value: Optional["str"]) -> None:
		"""Requested destination table or tile set."""
		self._target = value
	@property
	def progress(self) -> "ImportProgress":
		"""Numeric progress, if available."""
		return self._progress
	@progress.setter
	def progress(self, value: "ImportProgress") -> None:
		"""Numeric progress, if available."""
		self._progress = value
	@property
	def successful(self) -> Optional["bool"]:
		"""If the import has completed, indicates whether it succeeded or failed. Otherwise the value is null."""
		return self._successful
	@successful.setter
	def successful(self, value: Optional["bool"]) -> None:
		"""If the import has completed, indicates whether it succeeded or failed. Otherwise the value is null."""
		self._successful = value
	@property
	def errors(self) -> "List[str]":
		"""Cumulative error messages for the import. If the import completes successfully, but there are error messages, they should be treated as warnings."""
		return self._errors
	@errors.setter
	def errors(self, value: "List[str]") -> None:
		"""Cumulative error messages for the import. If the import completes successfully, but there are error messages, they should be treated as warnings."""
		self._errors = value
	@property
	def last_update(self) -> Optional["datetime"]:
		"""Date/time the status of this import was last updated."""
		return self._last_update
	@last_update.setter
	def last_update(self, value: Optional["datetime"]) -> None:
		"""Date/time the status of this import was last updated."""
		self._last_update = value
	@property
	def most_recent_activity(self) -> Optional["ImportStepSummary"]:
		"""A summarized version of the most recent activity."""
		return self._most_recent_activity
	@most_recent_activity.setter
	def most_recent_activity(self, value: Optional["ImportStepSummary"]) -> None:
		"""A summarized version of the most recent activity."""
		self._most_recent_activity = value
	@property
	def links(self) -> "ImportLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "ImportLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class ImportLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"result": ("result", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
		result: Optional["Link"] = None,
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		:param result: When the import is complete, the import results (either the created objects or an error) will be available at this link.
		:type result: Link or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._result = cast(Optional[Link], kwargs.get("result"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def result(self) -> Optional["Link"]:
		"""When the import is complete, the import results (either the created objects or an error) will be available at this link."""
		return self._result
	@result.setter
	def result(self, value: Optional["Link"]) -> None:
		"""When the import is complete, the import results (either the created objects or an error) will be available at this link."""
		self._result = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class ImportProgress:
	"""Numeric progress, if available."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"current": ("current", "int", None),
		"maximum": ("maximum", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		current: "int",
		maximum: Optional["int"] = None,
	) -> None:
		"""
		:param current: The current progress value.
		:type current: int
		:param maximum: The maximum progress value, if available. When current == maximum, the step will be complete.
		:type maximum: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._current = cast(int, kwargs.get("current"))
		self._maximum = cast(Optional[int], kwargs.get("maximum"))
	@property
	def current(self) -> "int":
		"""The current progress value."""
		return self._current
	@current.setter
	def current(self, value: "int") -> None:
		"""The current progress value."""
		self._current = value
	@property
	def maximum(self) -> Optional["int"]:
		"""The maximum progress value, if available. When current == maximum, the step will be complete."""
		return self._maximum
	@maximum.setter
	def maximum(self, value: Optional["int"]) -> None:
		"""The maximum progress value, if available. When current == maximum, the step will be complete."""
		self._maximum = value
class ImportStepSummary:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"phase": ("phase", "str", None),
		"step": ("step", "str", None),
		"message": ("message", "str", None),
		"source": ("source", "str", None),
		"target": ("target", "str", None),
		"progress": ("progress", "ImportProgress", None),
		"total_new_records": ("totalNewRecords", "int", None),
		"successful": ("successful", "bool", None),
		"errors": ("errors", "list", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		progress: "ImportProgress",
		errors: "List[str]",
		phase: Optional["str"] = None,
		step: Optional["str"] = None,
		message: Optional["str"] = None,
		source: Optional["str"] = None,
		target: Optional["str"] = None,
		total_new_records: Optional["int"] = None,
		successful: Optional["bool"] = None,
	) -> None:
		"""
		:param progress: Numeric progress, if available.
		:type progress: ImportProgress
		:param errors: Error messages for this step.
		:type errors: List[str]
		:param phase:
		:type phase: str or None
		:param step:
		:type step: str or None
		:param message: A description of the current activity of this step.
		:type message: str or None
		:param source: Source data for the import.
		:type source: str or None
		:param target: Requested destination table or tile set.
		:type target: str or None
		:param total_new_records: Count of total new records imported.
		:type total_new_records: int or None
		:param successful: If the step has completed, indicates whether the step succeeded or failed. Otherwise the value is null.
		:type successful: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._phase = cast(Optional[str], kwargs.get("phase"))
		self._step = cast(Optional[str], kwargs.get("step"))
		self._message = cast(Optional[str], kwargs.get("message"))
		self._source = cast(Optional[str], kwargs.get("source"))
		self._target = cast(Optional[str], kwargs.get("target"))
		self._progress = cast(ImportProgress, kwargs.get("progress"))
		self._total_new_records = cast(Optional[int], kwargs.get("total_new_records"))
		self._successful = cast(Optional[bool], kwargs.get("successful"))
		self._errors = cast(List[str], kwargs.get("errors"))
	@property
	def phase(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._phase
	@phase.setter
	def phase(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._phase = value
	@property
	def step(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._step
	@step.setter
	def step(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._step = value
	@property
	def message(self) -> Optional["str"]:
		"""A description of the current activity of this step."""
		return self._message
	@message.setter
	def message(self, value: Optional["str"]) -> None:
		"""A description of the current activity of this step."""
		self._message = value
	@property
	def source(self) -> Optional["str"]:
		"""Source data for the import."""
		return self._source
	@source.setter
	def source(self, value: Optional["str"]) -> None:
		"""Source data for the import."""
		self._source = value
	@property
	def target(self) -> Optional["str"]:
		"""Requested destination table or tile set."""
		return self._target
	@target.setter
	def target(self, value: Optional["str"]) -> None:
		"""Requested destination table or tile set."""
		self._target = value
	@property
	def progress(self) -> "ImportProgress":
		"""Numeric progress, if available."""
		return self._progress
	@progress.setter
	def progress(self, value: "ImportProgress") -> None:
		"""Numeric progress, if available."""
		self._progress = value
	@property
	def total_new_records(self) -> Optional["int"]:
		"""Count of total new records imported."""
		return self._total_new_records
	@total_new_records.setter
	def total_new_records(self, value: Optional["int"]) -> None:
		"""Count of total new records imported."""
		self._total_new_records = value
	@property
	def successful(self) -> Optional["bool"]:
		"""If the step has completed, indicates whether the step succeeded or failed. Otherwise the value is null."""
		return self._successful
	@successful.setter
	def successful(self, value: Optional["bool"]) -> None:
		"""If the step has completed, indicates whether the step succeeded or failed. Otherwise the value is null."""
		self._successful = value
	@property
	def errors(self) -> "List[str]":
		"""Error messages for this step."""
		return self._errors
	@errors.setter
	def errors(self, value: "List[str]") -> None:
		"""Error messages for this step."""
		self._errors = value
class IndexCreationOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("Name", "str", None),
		"type_": ("Type", "str", None),
		"indexed_columns": ("IndexedColumns", "list", "str"),
		"parameters": ("Parameters", "list", "ColumnNameValuePair"),
		"synchronous_write": ("SynchronousWrite", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		indexed_columns: "List[str]",
		parameters: "List[ColumnNameValuePair]",
		synchronous_write: "bool",
		name: Optional["str"] = None,
		type_: Optional["str"] = None,
	) -> None:
		"""
		:param indexed_columns:
		:type indexed_columns: List[str]
		:param parameters:
		:type parameters: List[ColumnNameValuePair]
		:param synchronous_write:
		:type synchronous_write: bool
		:param name:
		:type name: str or None
		:param type_:
		:type type_: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._indexed_columns = cast(List[str], kwargs.get("indexed_columns"))
		self._parameters = cast(List[ColumnNameValuePair], kwargs.get("parameters"))
		self._synchronous_write = cast(bool, kwargs.get("synchronous_write"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def indexed_columns(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._indexed_columns
	@indexed_columns.setter
	def indexed_columns(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._indexed_columns = value
	@property
	def parameters(self) -> "List[ColumnNameValuePair]":
		# pylint: disable=missing-function-docstring
		return self._parameters
	@parameters.setter
	def parameters(self, value: "List[ColumnNameValuePair]") -> None:
		# pylint: disable=missing-function-docstring
		self._parameters = value
	@property
	def synchronous_write(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._synchronous_write
	@synchronous_write.setter
	def synchronous_write(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._synchronous_write = value
class IndexDefinition:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"type_": ("type", "str", None),
		"indexed_columns": ("indexedColumns", "list", "str"),
		"parameters": ("parameters", "list", "IndexParameter"),
		"links": ("links", "Links", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		indexed_columns: "List[str]",
		parameters: "List[IndexParameter]",
		links: "Links",
		name: Optional["str"] = None,
		type_: Optional["str"] = None,
	) -> None:
		"""
		:param indexed_columns:
		:type indexed_columns: List[str]
		:param parameters:
		:type parameters: List[IndexParameter]
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: Links
		:param name:
		:type name: str or None
		:param type_:
		:type type_: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._indexed_columns = cast(List[str], kwargs.get("indexed_columns"))
		self._parameters = cast(List[IndexParameter], kwargs.get("parameters"))
		self._links = cast(Links, kwargs.get("links"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def indexed_columns(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._indexed_columns
	@indexed_columns.setter
	def indexed_columns(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._indexed_columns = value
	@property
	def parameters(self) -> "List[IndexParameter]":
		# pylint: disable=missing-function-docstring
		return self._parameters
	@parameters.setter
	def parameters(self, value: "List[IndexParameter]") -> None:
		# pylint: disable=missing-function-docstring
		self._parameters = value
	@property
	def links(self) -> "Links":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "Links") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class IndexOrganizedTableConfig:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"history_window_ticks": ("HistoryWindowTicks", "int", None),
		"history_depth": ("HistoryDepth", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		history_window_ticks: "int",
		history_depth: "int",
	) -> None:
		"""
		:param history_window_ticks:
		:type history_window_ticks: int
		:param history_depth:
		:type history_depth: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._history_window_ticks = cast(int, kwargs.get("history_window_ticks"))
		self._history_depth = cast(int, kwargs.get("history_depth"))
	@property
	def history_window_ticks(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._history_window_ticks
	@history_window_ticks.setter
	def history_window_ticks(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._history_window_ticks = value
	@property
	def history_depth(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._history_depth
	@history_depth.setter
	def history_depth(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._history_depth = value
class IndexParameter:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"value": ("value", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: Optional["str"] = None,
		value: Optional["str"] = None,
	) -> None:
		"""
		:param name:
		:type name: str or None
		:param value:
		:type value: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._value = cast(Optional[str], kwargs.get("value"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def value(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._value
	@value.setter
	def value(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._value = value
class IndexType:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"index_type_key": ("indexTypeKey", "str", None),
		"index_type_parameters": ("indexTypeParameters", "list", "IndexTypeParameter"),
		"links": ("links", "Links", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		index_type_parameters: "List[IndexTypeParameter]",
		links: "Links",
		index_type_key: Optional["str"] = None,
	) -> None:
		"""
		:param index_type_parameters:
		:type index_type_parameters: List[IndexTypeParameter]
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: Links
		:param index_type_key:
		:type index_type_key: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._index_type_key = cast(Optional[str], kwargs.get("index_type_key"))
		self._index_type_parameters = cast(List[IndexTypeParameter], kwargs.get("index_type_parameters"))
		self._links = cast(Links, kwargs.get("links"))
	@property
	def index_type_key(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._index_type_key
	@index_type_key.setter
	def index_type_key(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._index_type_key = value
	@property
	def index_type_parameters(self) -> "List[IndexTypeParameter]":
		# pylint: disable=missing-function-docstring
		return self._index_type_parameters
	@index_type_parameters.setter
	def index_type_parameters(self, value: "List[IndexTypeParameter]") -> None:
		# pylint: disable=missing-function-docstring
		self._index_type_parameters = value
	@property
	def links(self) -> "Links":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "Links") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class IndexTypeParameter:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"description": ("description", "str", None),
		"type_description": ("typeDescription", "str", None),
		"optional": ("optional", "bool", None),
		"possible_values": ("possibleValues", "list", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		optional: "bool",
		possible_values: "List[str]",
		name: Optional["str"] = None,
		description: Optional["str"] = None,
		type_description: Optional["str"] = None,
	) -> None:
		"""
		:param optional:
		:type optional: bool
		:param possible_values:
		:type possible_values: List[str]
		:param name:
		:type name: str or None
		:param description:
		:type description: str or None
		:param type_description:
		:type type_description: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._type_description = cast(Optional[str], kwargs.get("type_description"))
		self._optional = cast(bool, kwargs.get("optional"))
		self._possible_values = cast(List[str], kwargs.get("possible_values"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def description(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._description = value
	@property
	def type_description(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_description
	@type_description.setter
	def type_description(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_description = value
	@property
	def optional(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._optional
	@optional.setter
	def optional(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._optional = value
	@property
	def possible_values(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._possible_values
	@possible_values.setter
	def possible_values(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._possible_values = value


class InterpolateMode(str, Enum):
	"""Defines the interpolation method used to calculate the values in between the known data points"""
	NONE = 'None'
	RASTER_PIXEL = 'RasterPixel'
	NEAREST = 'Nearest'
	LINEAR = 'Linear'
	CUBIC = 'Cubic'
	IDW = 'IDW'
	AUTO = 'Auto'

InterpolateMode.NONE.__doc__ = """No interpolation"""
InterpolateMode.NEAREST.__doc__ = """Nearest-neighbor interpolation"""
InterpolateMode.LINEAR.__doc__ = """Bilinear interpolation"""
InterpolateMode.CUBIC.__doc__ = """Bicubic interpolation"""
InterpolateMode.IDW.__doc__ = """Inverse distance weighted interpolation"""
InterpolateMode.AUTO.__doc__ = """Attempts to set the interpolation mode based on the raster band data type"""
class IntRange:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"min_": ("min", "int", None),
		"max_": ("max", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		min_: "int",
		max_: "int",
	) -> None:
		"""
		:param min_:
		:type min_: int
		:param max_:
		:type max_: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._min_ = cast(int, kwargs.get("min_"))
		self._max_ = cast(int, kwargs.get("max_"))
	@property
	def min_(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._min_
	@min_.setter
	def min_(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._min_ = value
	@property
	def max_(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._max_
	@max_.setter
	def max_(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._max_ = value


class JsonFlattenMode(str, Enum):
	"""Specifies how JSON objects should be flattened."""
	NONE = 'None'
	FLATTEN_TO_SINGLE = 'FlattenToSingle'
	FLATTEN_TO_MULTIPLE = 'FlattenToMultiple'

JsonFlattenMode.NONE.__doc__ = """No flattening."""
JsonFlattenMode.FLATTEN_TO_SINGLE.__doc__ = """Flatten to a single file (nested arrays get squashed)."""
JsonFlattenMode.FLATTEN_TO_MULTIPLE.__doc__ = """Flatten to multiple files (nested arrays become child tables)."""
class Kernel:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"name": ("name", "str", None),
		"execution_state": ("execution_state", "str", None),
		"last_activity": ("last_activity", "datetime", None),
		"connections": ("connections", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		last_activity: "datetime",
		connections: "int",
		id_: Optional["str"] = None,
		name: Optional["str"] = None,
		execution_state: Optional["str"] = None,
	) -> None:
		"""
		:param last_activity:
		:type last_activity: datetime
		:param connections:
		:type connections: int
		:param id_:
		:type id_: str or None
		:param name:
		:type name: str or None
		:param execution_state:
		:type execution_state: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._execution_state = cast(Optional[str], kwargs.get("execution_state"))
		self._last_activity = cast(datetime, kwargs.get("last_activity"))
		self._connections = cast(int, kwargs.get("connections"))
	@property
	def id_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def execution_state(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._execution_state
	@execution_state.setter
	def execution_state(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._execution_state = value
	@property
	def last_activity(self) -> "datetime":
		# pylint: disable=missing-function-docstring
		return self._last_activity
	@last_activity.setter
	def last_activity(self, value: "datetime") -> None:
		# pylint: disable=missing-function-docstring
		self._last_activity = value
	@property
	def connections(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._connections
	@connections.setter
	def connections(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._connections = value
class KernelInfo:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"resources": ("resources", "dict", "str"),
		"spec": ("spec", "KernelInfoSpec", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		resources: "Dict[str, str]",
		spec: "KernelInfoSpec",
		name: Optional["str"] = None,
	) -> None:
		"""
		:param resources:
		:type resources: Dict[str, str]
		:param spec:
		:type spec: KernelInfoSpec
		:param name:
		:type name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._resources = cast(Dict[str, str], kwargs.get("resources"))
		self._spec = cast(KernelInfoSpec, kwargs.get("spec"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def resources(self) -> "Dict[str, str]":
		# pylint: disable=missing-function-docstring
		return self._resources
	@resources.setter
	def resources(self, value: "Dict[str, str]") -> None:
		# pylint: disable=missing-function-docstring
		self._resources = value
	@property
	def spec(self) -> "KernelInfoSpec":
		# pylint: disable=missing-function-docstring
		return self._spec
	@spec.setter
	def spec(self, value: "KernelInfoSpec") -> None:
		# pylint: disable=missing-function-docstring
		self._spec = value
class KernelInfoSpec:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"argv": ("argv", "list", "str"),
		"display_name": ("display_name", "str", None),
		"env": ("env", "dict", "str"),
		"interrupt_mode": ("interrupt_mode", "str", None),
		"language": ("language", "str", None),
		"metadata": ("metadata", "dict", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		argv: "List[str]",
		env: "Dict[str, str]",
		metadata: "Dict[str, str]",
		display_name: Optional["str"] = None,
		interrupt_mode: Optional["str"] = None,
		language: Optional["str"] = None,
	) -> None:
		"""
		:param argv:
		:type argv: List[str]
		:param env:
		:type env: Dict[str, str]
		:param metadata:
		:type metadata: Dict[str, str]
		:param display_name:
		:type display_name: str or None
		:param interrupt_mode:
		:type interrupt_mode: str or None
		:param language:
		:type language: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._argv = cast(List[str], kwargs.get("argv"))
		self._display_name = cast(Optional[str], kwargs.get("display_name"))
		self._env = cast(Dict[str, str], kwargs.get("env"))
		self._interrupt_mode = cast(Optional[str], kwargs.get("interrupt_mode"))
		self._language = cast(Optional[str], kwargs.get("language"))
		self._metadata = cast(Dict[str, str], kwargs.get("metadata"))
	@property
	def argv(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._argv
	@argv.setter
	def argv(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._argv = value
	@property
	def display_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._display_name
	@display_name.setter
	def display_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._display_name = value
	@property
	def env(self) -> "Dict[str, str]":
		# pylint: disable=missing-function-docstring
		return self._env
	@env.setter
	def env(self, value: "Dict[str, str]") -> None:
		# pylint: disable=missing-function-docstring
		self._env = value
	@property
	def interrupt_mode(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._interrupt_mode
	@interrupt_mode.setter
	def interrupt_mode(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._interrupt_mode = value
	@property
	def language(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._language
	@language.setter
	def language(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._language = value
	@property
	def metadata(self) -> "Dict[str, str]":
		# pylint: disable=missing-function-docstring
		return self._metadata
	@metadata.setter
	def metadata(self, value: "Dict[str, str]") -> None:
		# pylint: disable=missing-function-docstring
		self._metadata = value
class KernelSpecsResponse:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"default": ("default", "str", None),
		"kernelspecs": ("kernelspecs", "dict", "KernelInfo"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		kernelspecs: "Dict[str, KernelInfo]",
		default: Optional["str"] = None,
	) -> None:
		"""
		:param kernelspecs:
		:type kernelspecs: Dict[str, KernelInfo]
		:param default:
		:type default: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._default = cast(Optional[str], kwargs.get("default"))
		self._kernelspecs = cast(Dict[str, KernelInfo], kwargs.get("kernelspecs"))
	@property
	def default(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._default
	@default.setter
	def default(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._default = value
	@property
	def kernelspecs(self) -> "Dict[str, KernelInfo]":
		# pylint: disable=missing-function-docstring
		return self._kernelspecs
	@kernelspecs.setter
	def kernelspecs(self, value: "Dict[str, KernelInfo]") -> None:
		# pylint: disable=missing-function-docstring
		self._kernelspecs = value


class LabelFitMode(str, Enum):
	# pylint: disable=missing-class-docstring
	NORMAL = 'Normal'
	CLIPPING = 'Clipping'
	CLIPPING_SHRINK = 'ClippingShrink'



class LabelRotationLock(str, Enum):
	# pylint: disable=missing-class-docstring
	ICON = 'Icon'
	INDEPENDENT = 'Independent'



class LabelRotationType(str, Enum):
	# pylint: disable=missing-class-docstring
	MANUAL = 'Manual'
	LONGEST_EDGE = 'LongestEdge'



class LabelWrapType(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	WORD = 'Word'
	CHARACTER = 'Character'
	WORD_WRAP = 'WordWrap'
	WORD_CHARACTER_WRAP = 'WordCharacterWrap'
	WORD_ELLIPSIS = 'WordEllipsis'
	CHARACTER_ELLIPSIS = 'CharacterEllipsis'
	CHARACTER_WRAP = 'CharacterWrap'
	WORD_TRUNCATE = 'WordTruncate'
	CHARACTER_TRUNCATE = 'CharacterTruncate'

class LASImportOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"vector_import": ("vectorImport", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		vector_import: "bool",
	) -> None:
		"""
		:param vector_import:
		:type vector_import: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._vector_import = cast(bool, kwargs.get("vector_import"))
	@property
	def vector_import(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._vector_import
	@vector_import.setter
	def vector_import(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._vector_import = value
class Layer:
	"""A map layer, consisting of a query defining the data to be displayed, and style information defining how the data should be displayed."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"query": ("query", "Query", None),
		"style": ("style", "Style", None),
		"ignore_errors": ("ignoreErrors", "bool", None),
		"perf_counter_name": ("perfCounterName", "str", None),
		"axes": ("axes", "list", "Axis"),
		"temporal_wms": ("temporalWMS", "TemporalWMS", None),
		"no_cleanup_if_newer_version": ("noCleanupIfNewerVersion", "bool", None),
		"find_options": ("findOptions", "LayerFindOptions", None),
		"disk_cache": ("diskCache", "LayerDiskCache", None),
		"server": ("server", "ProxyRequest", None),
		"markers": ("markers", "LayerMarkerRequest", None),
		"min_zoom": ("minZoom", "float", None),
		"max_zoom": ("maxZoom", "float", None),
		"metadata_cache_level": ("metadataCacheLevel", "LayerStatisticLevel", None),
		"projection_options": ("projectionOptions", "LayerProjectionOptions", None),
		"projection": ("projection", "ProjectionMode", None),
		"trace_opts": ("traceOpts", "TraceLayerModuleTraceOpts", None),
		"graph_opts": ("graphOpts", "GraphOptions", None),
		"name": ("name", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		query: "Query",
		style: "Style",
		projection_options: "LayerProjectionOptions",
		trace_opts: "TraceLayerModuleTraceOpts",
		graph_opts: "GraphOptions",
		ignore_errors: Optional["bool"] = None,
		perf_counter_name: Optional["str"] = None,
		axes: Optional["List[Axis]"] = None,
		temporal_wms: Optional["TemporalWMS"] = None,
		no_cleanup_if_newer_version: Optional["bool"] = None,
		find_options: Optional["LayerFindOptions"] = None,
		disk_cache: Optional["LayerDiskCache"] = None,
		server: Optional["ProxyRequest"] = None,
		markers: Optional["LayerMarkerRequest"] = None,
		min_zoom: Optional["float"] = None,
		max_zoom: Optional["float"] = None,
		metadata_cache_level: Optional["LayerStatisticLevel"] = None,
		projection: Optional["ProjectionMode"] = None,
		name: Optional["str"] = None,
	) -> None:
		"""
		:param query: The query that describes the data to display on the layer.
		:type query: Query
		:param style: Specifies how the layer should be formatted.
		:type style: Style
		:param projection_options:
		:type projection_options: LayerProjectionOptions
		:param trace_opts:
		:type trace_opts: TraceLayerModuleTraceOpts
		:param graph_opts:
		:type graph_opts: GraphOptions
		:param ignore_errors:
		:type ignore_errors: bool or None
		:param perf_counter_name:
		:type perf_counter_name: str or None
		:param axes:
		:type axes: List[Axis] or None
		:param temporal_wms:
		:type temporal_wms: TemporalWMS or None
		:param no_cleanup_if_newer_version:
		:type no_cleanup_if_newer_version: bool or None
		:param find_options:
		:type find_options: LayerFindOptions or None
		:param disk_cache:
		:type disk_cache: LayerDiskCache or None
		:param server:
		:type server: ProxyRequest or None
		:param markers:
		:type markers: LayerMarkerRequest or None
		:param min_zoom:
		:type min_zoom: float or None
		:param max_zoom:
		:type max_zoom: float or None
		:param metadata_cache_level:
		:type metadata_cache_level: LayerStatisticLevel or None
		:param projection: The map projection.
* `mercator` - EPSG:3857
* `wgs84` - EPSG:4326
		:type projection: ProjectionMode or None
		:param name: The name of the layer, as displayed in the Map Editor, map legends, and WMS GetCapabilities responses.
		:type name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._query = cast(Query, kwargs.get("query"))
		self._style = cast(Style, kwargs.get("style"))
		self._ignore_errors = cast(Optional[bool], kwargs.get("ignore_errors"))
		self._perf_counter_name = cast(Optional[str], kwargs.get("perf_counter_name"))
		self._axes = cast(Optional[List[Axis]], kwargs.get("axes"))
		self._temporal_wms = cast(Optional[TemporalWMS], kwargs.get("temporal_wms"))
		self._no_cleanup_if_newer_version = cast(Optional[bool], kwargs.get("no_cleanup_if_newer_version"))
		self._find_options = cast(Optional[LayerFindOptions], kwargs.get("find_options"))
		self._disk_cache = cast(Optional[LayerDiskCache], kwargs.get("disk_cache"))
		self._server = cast(Optional[ProxyRequest], kwargs.get("server"))
		self._markers = cast(Optional[LayerMarkerRequest], kwargs.get("markers"))
		self._min_zoom = cast(Optional[float], kwargs.get("min_zoom"))
		self._max_zoom = cast(Optional[float], kwargs.get("max_zoom"))
		self._metadata_cache_level = cast(Optional[LayerStatisticLevel], kwargs.get("metadata_cache_level"))
		self._projection_options = cast(LayerProjectionOptions, kwargs.get("projection_options"))
		self._projection = cast(Optional[ProjectionMode], kwargs.get("projection"))
		self._trace_opts = cast(TraceLayerModuleTraceOpts, kwargs.get("trace_opts"))
		self._graph_opts = cast(GraphOptions, kwargs.get("graph_opts"))
		self._name = cast(Optional[str], kwargs.get("name"))
	@property
	def query(self) -> "Query":
		"""The query that describes the data to display on the layer."""
		return self._query
	@query.setter
	def query(self, value: "Query") -> None:
		"""The query that describes the data to display on the layer."""
		self._query = value
	@property
	def style(self) -> "Style":
		"""Specifies how the layer should be formatted."""
		return self._style
	@style.setter
	def style(self, value: "Style") -> None:
		"""Specifies how the layer should be formatted."""
		self._style = value
	@property
	def ignore_errors(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._ignore_errors
	@ignore_errors.setter
	def ignore_errors(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._ignore_errors = value
	@property
	def perf_counter_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._perf_counter_name
	@perf_counter_name.setter
	def perf_counter_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._perf_counter_name = value
	@property
	def axes(self) -> Optional["List[Axis]"]:
		# pylint: disable=missing-function-docstring
		return self._axes
	@axes.setter
	def axes(self, value: Optional["List[Axis]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._axes = value
	@property
	def temporal_wms(self) -> Optional["TemporalWMS"]:
		# pylint: disable=missing-function-docstring
		return self._temporal_wms
	@temporal_wms.setter
	def temporal_wms(self, value: Optional["TemporalWMS"]) -> None:
		# pylint: disable=missing-function-docstring
		self._temporal_wms = value
	@property
	def no_cleanup_if_newer_version(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._no_cleanup_if_newer_version
	@no_cleanup_if_newer_version.setter
	def no_cleanup_if_newer_version(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._no_cleanup_if_newer_version = value
	@property
	def find_options(self) -> Optional["LayerFindOptions"]:
		# pylint: disable=missing-function-docstring
		return self._find_options
	@find_options.setter
	def find_options(self, value: Optional["LayerFindOptions"]) -> None:
		# pylint: disable=missing-function-docstring
		self._find_options = value
	@property
	def disk_cache(self) -> Optional["LayerDiskCache"]:
		# pylint: disable=missing-function-docstring
		return self._disk_cache
	@disk_cache.setter
	def disk_cache(self, value: Optional["LayerDiskCache"]) -> None:
		# pylint: disable=missing-function-docstring
		self._disk_cache = value
	@property
	def server(self) -> Optional["ProxyRequest"]:
		# pylint: disable=missing-function-docstring
		return self._server
	@server.setter
	def server(self, value: Optional["ProxyRequest"]) -> None:
		# pylint: disable=missing-function-docstring
		self._server = value
	@property
	def markers(self) -> Optional["LayerMarkerRequest"]:
		# pylint: disable=missing-function-docstring
		return self._markers
	@markers.setter
	def markers(self, value: Optional["LayerMarkerRequest"]) -> None:
		# pylint: disable=missing-function-docstring
		self._markers = value
	@property
	def min_zoom(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._min_zoom
	@min_zoom.setter
	def min_zoom(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_zoom = value
	@property
	def max_zoom(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._max_zoom
	@max_zoom.setter
	def max_zoom(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_zoom = value
	@property
	def metadata_cache_level(self) -> Optional["LayerStatisticLevel"]:
		# pylint: disable=missing-function-docstring
		return self._metadata_cache_level
	@metadata_cache_level.setter
	def metadata_cache_level(self, value: Optional["LayerStatisticLevel"]) -> None:
		# pylint: disable=missing-function-docstring
		self._metadata_cache_level = value
	@property
	def projection_options(self) -> "LayerProjectionOptions":
		# pylint: disable=missing-function-docstring
		return self._projection_options
	@projection_options.setter
	def projection_options(self, value: "LayerProjectionOptions") -> None:
		# pylint: disable=missing-function-docstring
		self._projection_options = value
	@property
	def projection(self) -> Optional["ProjectionMode"]:
		"""The map projection.
* `mercator` - EPSG:3857
* `wgs84` - EPSG:4326"""
		return self._projection
	@projection.setter
	def projection(self, value: Optional["ProjectionMode"]) -> None:
		"""The map projection.
* `mercator` - EPSG:3857
* `wgs84` - EPSG:4326"""
		self._projection = value
	@property
	def trace_opts(self) -> "TraceLayerModuleTraceOpts":
		# pylint: disable=missing-function-docstring
		return self._trace_opts
	@trace_opts.setter
	def trace_opts(self, value: "TraceLayerModuleTraceOpts") -> None:
		# pylint: disable=missing-function-docstring
		self._trace_opts = value
	@property
	def graph_opts(self) -> "GraphOptions":
		# pylint: disable=missing-function-docstring
		return self._graph_opts
	@graph_opts.setter
	def graph_opts(self, value: "GraphOptions") -> None:
		# pylint: disable=missing-function-docstring
		self._graph_opts = value
	@property
	def name(self) -> Optional["str"]:
		"""The name of the layer, as displayed in the Map Editor, map legends, and WMS GetCapabilities responses."""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""The name of the layer, as displayed in the Map Editor, map legends, and WMS GetCapabilities responses."""
		self._name = value
class LayerColorTransformValues:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"is_identity": ("isIdentity", "bool", None),
		"is_red_identity": ("isRedIdentity", "bool", None),
		"is_green_identity": ("isGreenIdentity", "bool", None),
		"is_blue_identity": ("isBlueIdentity", "bool", None),
		"is_alpha_identity": ("isAlphaIdentity", "bool", None),
		"red": ("red", "float", None),
		"green": ("green", "float", None),
		"blue": ("blue", "float", None),
		"alpha": ("alpha", "float", None),
		"r": ("r", "list", "float"),
		"g": ("g", "list", "float"),
		"b": ("b", "list", "float"),
		"a": ("a", "list", "float"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		is_identity: "bool",
		is_red_identity: "bool",
		is_green_identity: "bool",
		is_blue_identity: "bool",
		is_alpha_identity: "bool",
		r: "List[float]",
		g: "List[float]",
		b: "List[float]",
		a: "List[float]",
		red: Optional["float"] = None,
		green: Optional["float"] = None,
		blue: Optional["float"] = None,
		alpha: Optional["float"] = None,
	) -> None:
		"""
		:param is_identity:
		:type is_identity: bool
		:param is_red_identity:
		:type is_red_identity: bool
		:param is_green_identity:
		:type is_green_identity: bool
		:param is_blue_identity:
		:type is_blue_identity: bool
		:param is_alpha_identity:
		:type is_alpha_identity: bool
		:param r:
		:type r: List[float]
		:param g:
		:type g: List[float]
		:param b:
		:type b: List[float]
		:param a:
		:type a: List[float]
		:param red:
		:type red: float or None
		:param green:
		:type green: float or None
		:param blue:
		:type blue: float or None
		:param alpha:
		:type alpha: float or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._is_identity = cast(bool, kwargs.get("is_identity"))
		self._is_red_identity = cast(bool, kwargs.get("is_red_identity"))
		self._is_green_identity = cast(bool, kwargs.get("is_green_identity"))
		self._is_blue_identity = cast(bool, kwargs.get("is_blue_identity"))
		self._is_alpha_identity = cast(bool, kwargs.get("is_alpha_identity"))
		self._red = cast(Optional[float], kwargs.get("red"))
		self._green = cast(Optional[float], kwargs.get("green"))
		self._blue = cast(Optional[float], kwargs.get("blue"))
		self._alpha = cast(Optional[float], kwargs.get("alpha"))
		self._r = cast(List[float], kwargs.get("r"))
		self._g = cast(List[float], kwargs.get("g"))
		self._b = cast(List[float], kwargs.get("b"))
		self._a = cast(List[float], kwargs.get("a"))
	@property
	def is_identity(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_identity
	@is_identity.setter
	def is_identity(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_identity = value
	@property
	def is_red_identity(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_red_identity
	@is_red_identity.setter
	def is_red_identity(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_red_identity = value
	@property
	def is_green_identity(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_green_identity
	@is_green_identity.setter
	def is_green_identity(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_green_identity = value
	@property
	def is_blue_identity(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_blue_identity
	@is_blue_identity.setter
	def is_blue_identity(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_blue_identity = value
	@property
	def is_alpha_identity(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_alpha_identity
	@is_alpha_identity.setter
	def is_alpha_identity(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_alpha_identity = value
	@property
	def red(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._red
	@red.setter
	def red(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._red = value
	@property
	def green(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._green
	@green.setter
	def green(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._green = value
	@property
	def blue(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._blue
	@blue.setter
	def blue(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._blue = value
	@property
	def alpha(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._alpha
	@alpha.setter
	def alpha(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._alpha = value
	@property
	def r(self) -> "List[float]":
		# pylint: disable=missing-function-docstring
		return self._r
	@r.setter
	def r(self, value: "List[float]") -> None:
		# pylint: disable=missing-function-docstring
		self._r = value
	@property
	def g(self) -> "List[float]":
		# pylint: disable=missing-function-docstring
		return self._g
	@g.setter
	def g(self, value: "List[float]") -> None:
		# pylint: disable=missing-function-docstring
		self._g = value
	@property
	def b(self) -> "List[float]":
		# pylint: disable=missing-function-docstring
		return self._b
	@b.setter
	def b(self, value: "List[float]") -> None:
		# pylint: disable=missing-function-docstring
		self._b = value
	@property
	def a(self) -> "List[float]":
		# pylint: disable=missing-function-docstring
		return self._a
	@a.setter
	def a(self, value: "List[float]") -> None:
		# pylint: disable=missing-function-docstring
		self._a = value
class LayerResponse:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"hash_": ("hash", "str", None),
		"links": ("_links", "LayerLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		hash_: "str",
		links: "LayerLinks",
	) -> None:
		"""
		:param hash_: The layer hash. An MD5 hash of a JSON object containing a single 'layer' property containing the Layer object.
		:type hash_: str
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: LayerLinks
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._hash_ = cast(str, kwargs.get("hash_"))
		self._links = cast(LayerLinks, kwargs.get("links"))
	@property
	def hash_(self) -> "str":
		"""The layer hash. An MD5 hash of a JSON object containing a single 'layer' property containing the Layer object."""
		return self._hash_
	@hash_.setter
	def hash_(self, value: "str") -> None:
		"""The layer hash. An MD5 hash of a JSON object containing a single 'layer' property containing the Layer object."""
		self._hash_ = value
	@property
	def links(self) -> "LayerLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "LayerLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class LayerDefinitionResponse(LayerResponse):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"layer": ("layer", "Layer", None),
		"hash_": ("hash", "str", None),
		"links": ("_links", "LayerLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		layer: "Layer",
		hash_: "str",
		links: "LayerLinks",
	) -> None:
		"""
		:param layer: The Layer object. These can potentially be large, so if you wish to just test for the existence of a Layer, call HEAD /layers/{hash} instead of GET.
		:type layer: Layer
		:param hash_: The layer hash. An MD5 hash of a JSON object containing a single 'layer' property containing the Layer object.
		:type hash_: str
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: LayerLinks
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		LayerResponse.__init__(self,
			hash_=kwargs.get("hash_"),
			links=kwargs.get("links"),
		)
		self._layer = cast(Layer, kwargs.get("layer"))
	@property
	def layer(self) -> "Layer":
		"""The Layer object. These can potentially be large, so if you wish to just test for the existence of a Layer, call HEAD /layers/{hash} instead of GET."""
		return self._layer
	@layer.setter
	def layer(self, value: "Layer") -> None:
		"""The Layer object. These can potentially be large, so if you wish to just test for the existence of a Layer, call HEAD /layers/{hash} instead of GET."""
		self._layer = value
class LayerDiskCache:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"min_zoom": ("minZoom", "int", None),
		"max_zoom": ("maxZoom", "int", None),
		"lifetime": ("lifetime", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		min_zoom: "int",
		max_zoom: "int",
		lifetime: "int",
	) -> None:
		"""
		:param min_zoom:
		:type min_zoom: int
		:param max_zoom:
		:type max_zoom: int
		:param lifetime:
		:type lifetime: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._min_zoom = cast(int, kwargs.get("min_zoom"))
		self._max_zoom = cast(int, kwargs.get("max_zoom"))
		self._lifetime = cast(int, kwargs.get("lifetime"))
	@property
	def min_zoom(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._min_zoom
	@min_zoom.setter
	def min_zoom(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._min_zoom = value
	@property
	def max_zoom(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._max_zoom
	@max_zoom.setter
	def max_zoom(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._max_zoom = value
	@property
	def lifetime(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._lifetime
	@lifetime.setter
	def lifetime(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._lifetime = value
class LayerFindOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"edge_only": ("edgeOnly", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		edge_only: "bool",
	) -> None:
		"""
		:param edge_only:
		:type edge_only: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._edge_only = cast(bool, kwargs.get("edge_only"))
	@property
	def edge_only(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._edge_only
	@edge_only.setter
	def edge_only(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._edge_only = value
class LayerLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"tile": ("tile", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		tile: "Link",
		self_: "Link",
	) -> None:
		"""
		:param tile: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type tile: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._tile = cast(Link, kwargs.get("tile"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def tile(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._tile
	@tile.setter
	def tile(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._tile = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class LayerMarkerItem:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"enabled": ("enabled", "bool", None),
		"style": ("style", "Style", None),
		"locations": ("locations", "list", "LayerMarkerItemLocation"),
		"xoffset": ("xOffset", "float", None),
		"yoffset": ("yOffset", "float", None),
		"halign": ("hAlign", "HAlign", None),
		"valign": ("vAlign", "VAlign", None),
		"blend_mode": ("blendMode", "BlendMode", None),
		"debug": ("debug", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		enabled: "bool",
		style: "Style",
		locations: "List[LayerMarkerItemLocation]",
		xoffset: "float",
		yoffset: "float",
		halign: "HAlign",
		valign: "VAlign",
		blend_mode: "BlendMode",
		debug: "bool",
	) -> None:
		"""
		:param enabled:
		:type enabled: bool
		:param style:
		:type style: Style
		:param locations:
		:type locations: List[LayerMarkerItemLocation]
		:param xoffset:
		:type xoffset: float
		:param yoffset:
		:type yoffset: float
		:param halign:
		:type halign: HAlign
		:param valign:
		:type valign: VAlign
		:param blend_mode:
		:type blend_mode: BlendMode
		:param debug:
		:type debug: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._enabled = cast(bool, kwargs.get("enabled"))
		self._style = cast(Style, kwargs.get("style"))
		self._locations = cast(List[LayerMarkerItemLocation], kwargs.get("locations"))
		self._xoffset = cast(float, kwargs.get("xoffset"))
		self._yoffset = cast(float, kwargs.get("yoffset"))
		self._halign = cast(HAlign, kwargs.get("halign"))
		self._valign = cast(VAlign, kwargs.get("valign"))
		self._blend_mode = cast(BlendMode, kwargs.get("blend_mode"))
		self._debug = cast(bool, kwargs.get("debug"))
	@property
	def enabled(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def style(self) -> "Style":
		# pylint: disable=missing-function-docstring
		return self._style
	@style.setter
	def style(self, value: "Style") -> None:
		# pylint: disable=missing-function-docstring
		self._style = value
	@property
	def locations(self) -> "List[LayerMarkerItemLocation]":
		# pylint: disable=missing-function-docstring
		return self._locations
	@locations.setter
	def locations(self, value: "List[LayerMarkerItemLocation]") -> None:
		# pylint: disable=missing-function-docstring
		self._locations = value
	@property
	def xoffset(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._xoffset
	@xoffset.setter
	def xoffset(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._xoffset = value
	@property
	def yoffset(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._yoffset
	@yoffset.setter
	def yoffset(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._yoffset = value
	@property
	def halign(self) -> "HAlign":
		# pylint: disable=missing-function-docstring
		return self._halign
	@halign.setter
	def halign(self, value: "HAlign") -> None:
		# pylint: disable=missing-function-docstring
		self._halign = value
	@property
	def valign(self) -> "VAlign":
		# pylint: disable=missing-function-docstring
		return self._valign
	@valign.setter
	def valign(self, value: "VAlign") -> None:
		# pylint: disable=missing-function-docstring
		self._valign = value
	@property
	def blend_mode(self) -> "BlendMode":
		# pylint: disable=missing-function-docstring
		return self._blend_mode
	@blend_mode.setter
	def blend_mode(self, value: "BlendMode") -> None:
		# pylint: disable=missing-function-docstring
		self._blend_mode = value
	@property
	def debug(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._debug
	@debug.setter
	def debug(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._debug = value
class LayerMarkerItemLocation:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"enabled": ("enabled", "bool", None),
		"is_lat_lng": ("isLatLng", "bool", None),
		"lat": ("lat", "float", None),
		"lng": ("lng", "float", None),
		"x": ("x", "float", None),
		"y": ("y", "float", None),
		"debug": ("debug", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		enabled: "bool",
		is_lat_lng: "bool",
		lat: "float",
		lng: "float",
		x: "float",
		y: "float",
		debug: "bool",
	) -> None:
		"""
		:param enabled:
		:type enabled: bool
		:param is_lat_lng:
		:type is_lat_lng: bool
		:param lat:
		:type lat: float
		:param lng:
		:type lng: float
		:param x:
		:type x: float
		:param y:
		:type y: float
		:param debug:
		:type debug: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._enabled = cast(bool, kwargs.get("enabled"))
		self._is_lat_lng = cast(bool, kwargs.get("is_lat_lng"))
		self._lat = cast(float, kwargs.get("lat"))
		self._lng = cast(float, kwargs.get("lng"))
		self._x = cast(float, kwargs.get("x"))
		self._y = cast(float, kwargs.get("y"))
		self._debug = cast(bool, kwargs.get("debug"))
	@property
	def enabled(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def is_lat_lng(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_lat_lng
	@is_lat_lng.setter
	def is_lat_lng(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_lat_lng = value
	@property
	def lat(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._lat
	@lat.setter
	def lat(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._lat = value
	@property
	def lng(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._lng
	@lng.setter
	def lng(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._lng = value
	@property
	def x(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._x
	@x.setter
	def x(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._x = value
	@property
	def y(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._y
	@y.setter
	def y(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._y = value
	@property
	def debug(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._debug
	@debug.setter
	def debug(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._debug = value
class LayerMarkerRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"enabled": ("enabled", "bool", None),
		"markers": ("markers", "list", "LayerMarkerItem"),
		"debug": ("debug", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		enabled: "bool",
		markers: "List[LayerMarkerItem]",
		debug: "bool",
	) -> None:
		"""
		:param enabled:
		:type enabled: bool
		:param markers:
		:type markers: List[LayerMarkerItem]
		:param debug:
		:type debug: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._enabled = cast(bool, kwargs.get("enabled"))
		self._markers = cast(List[LayerMarkerItem], kwargs.get("markers"))
		self._debug = cast(bool, kwargs.get("debug"))
	@property
	def enabled(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def markers(self) -> "List[LayerMarkerItem]":
		# pylint: disable=missing-function-docstring
		return self._markers
	@markers.setter
	def markers(self, value: "List[LayerMarkerItem]") -> None:
		# pylint: disable=missing-function-docstring
		self._markers = value
	@property
	def debug(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._debug
	@debug.setter
	def debug(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._debug = value
class LayerProjectionOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"origin": ("origin", "list", "float"),
		"resolutions": ("resolutions", "list", "float"),
		"bounds": ("bounds", "list", "list"),
		"lat_lng_bounds": ("latLngBounds", "list", "float"),
		"min_zoom": ("minZoom", "int", None),
		"operation": ("operation", "QueryProjectionOperation", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		origin: "List[float]",
		resolutions: "List[float]",
		bounds: "List[List[float]]",
		lat_lng_bounds: "List[float]",
		min_zoom: "int",
		operation: "QueryProjectionOperation",
	) -> None:
		"""
		:param origin: The top left corner of the tileable area in projected units.
		:type origin: List[float]
		:param resolutions: Projected units per pixel at each zoom level, starting at zoom 0.
		:type resolutions: List[float]
		:param bounds: The bottom left and top right corners of the tileable area, in projected units, in this order: [[left, bottom], [right, top]].
		:type bounds: List[List[float]]
		:param lat_lng_bounds: The tileable area should contain the latitudes and longitudes boxed by these values, in degrees, in this order: [west, south, east, north]
		:type lat_lng_bounds: List[float]
		:param min_zoom: Do not allow the map to be zoomed out beyond this zoom level.
		:type min_zoom: int
		:param operation:
		:type operation: QueryProjectionOperation
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._origin = cast(List[float], kwargs.get("origin"))
		self._resolutions = cast(List[float], kwargs.get("resolutions"))
		self._bounds = cast(List[List[float]], kwargs.get("bounds"))
		self._lat_lng_bounds = cast(List[float], kwargs.get("lat_lng_bounds"))
		self._min_zoom = cast(int, kwargs.get("min_zoom"))
		self._operation = cast(QueryProjectionOperation, kwargs.get("operation"))
	@property
	def origin(self) -> "List[float]":
		"""The top left corner of the tileable area in projected units."""
		return self._origin
	@origin.setter
	def origin(self, value: "List[float]") -> None:
		"""The top left corner of the tileable area in projected units."""
		self._origin = value
	@property
	def resolutions(self) -> "List[float]":
		"""Projected units per pixel at each zoom level, starting at zoom 0."""
		return self._resolutions
	@resolutions.setter
	def resolutions(self, value: "List[float]") -> None:
		"""Projected units per pixel at each zoom level, starting at zoom 0."""
		self._resolutions = value
	@property
	def bounds(self) -> "List[List[float]]":
		"""The bottom left and top right corners of the tileable area, in projected units, in this order: [[left, bottom], [right, top]]."""
		return self._bounds
	@bounds.setter
	def bounds(self, value: "List[List[float]]") -> None:
		"""The bottom left and top right corners of the tileable area, in projected units, in this order: [[left, bottom], [right, top]]."""
		self._bounds = value
	@property
	def lat_lng_bounds(self) -> "List[float]":
		"""The tileable area should contain the latitudes and longitudes boxed by these values, in degrees, in this order: [west, south, east, north]"""
		return self._lat_lng_bounds
	@lat_lng_bounds.setter
	def lat_lng_bounds(self, value: "List[float]") -> None:
		"""The tileable area should contain the latitudes and longitudes boxed by these values, in degrees, in this order: [west, south, east, north]"""
		self._lat_lng_bounds = value
	@property
	def min_zoom(self) -> "int":
		"""Do not allow the map to be zoomed out beyond this zoom level."""
		return self._min_zoom
	@min_zoom.setter
	def min_zoom(self, value: "int") -> None:
		"""Do not allow the map to be zoomed out beyond this zoom level."""
		self._min_zoom = value
	@property
	def operation(self) -> "QueryProjectionOperation":
		# pylint: disable=missing-function-docstring
		return self._operation
	@operation.setter
	def operation(self, value: "QueryProjectionOperation") -> None:
		# pylint: disable=missing-function-docstring
		self._operation = value


class LayerStatisticLevel(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	GEO_AND_DATE = 'GeoAndDate'
	ALL = 'All'



class LayerType(str, Enum):
	"""The type of geospatial data to select."""
	GEO_DOT = 'geo.dot'
	GEO_POLY = 'geo.poly'
	GEO_LINE = 'geo.line'
	GEO_DOTCLUSTER = 'geo.dotcluster'
	GEO_MARKERCLUSTER = 'geo.markercluster'
	GEO_HEAT = 'geo.heat'
	GEO_HEAT_2 = 'geo.heat2'
	GEO_HEAT_2_POLY = 'geo.heat2poly'
	GEO_HEAT_2_LINE = 'geo.heat2line'
	GEO_HEAT_2_MULTIPOINT = 'geo.heat2multipoint'
	GEO_RASTER = 'geo.raster'
	GEO_POINTCLUSTER = 'geo.pointcluster'
	GEO_TRACE = 'geo.trace'
	GEO_IMAGE = 'geo.image'
	GEO_GRAPH = 'geo.graph'
	GEO_DOT_MASK = 'geo.dot.mask'
	GEO_POLY_MASK = 'geo.poly.mask'
	GEO_LINE_MASK = 'geo.line.mask'
	BASE_ROAD = 'base.road'
	BASE_MAP = 'base.map'
	BASE_BUILDING = 'base.building'
	BASE_LANDWATER = 'base.landwater'
	BASE_RIVERS = 'base.rivers'
	BASE_BOUNDARIES = 'base.boundaries'
	BASE_TILESET = 'base.tileset'
	GRID_UTM = 'grid.utm'
	GRID_MGRS = 'grid.mgrs'
	GRID_GARS = 'grid.gars'
	GRID_GEOREF = 'grid.georef'

class Legend:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"label": ("label", "str", None),
		"visible": ("visible", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		label: "str",
		visible: Optional["bool"] = None,
	) -> None:
		"""
		:param label:
		:type label: str
		:param visible: Defaults to true.
		:type visible: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._label = cast(str, kwargs.get("label"))
		self._visible = cast(Optional[bool], kwargs.get("visible"))
	@property
	def label(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._label
	@label.setter
	def label(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._label = value
	@property
	def visible(self) -> Optional["bool"]:
		"""Defaults to true."""
		return self._visible
	@visible.setter
	def visible(self, value: Optional["bool"]) -> None:
		"""Defaults to true."""
		self._visible = value


class LiftMode(str, Enum):
	# pylint: disable=missing-class-docstring
	UNSET = 'UNSET'
	EXTRUDED = 'extruded'
	FLOATING = 'floating'



class LineCapStyle(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	ROUND = 'Round'
	SQUARE = 'Square'
	ROUND_ANCHOR = 'RoundAnchor'



class LineDashStyle(str, Enum):
	# pylint: disable=missing-class-docstring
	SOLID = 'Solid'
	DOTS = 'Dots'
	DASHES = 'Dashes'
	DOT_DASHES = 'DotDashes'



class LineGradientStyle(str, Enum):
	# pylint: disable=missing-class-docstring
	PER_DRAW_SEGMENT = 'PerDrawSegment'
	PER_LINE_SET = 'PerLineSet'
	ENTIRE_LINE = 'EntireLine'



class LineIconMode(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	LEGACY = 'Legacy'
	PATH = 'Path'



class LinePath1DEffectStyle(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	ROTATE = 'Rotate'
	TRANSLATE = 'Translate'
	MORPH = 'Morph'



class LineStrokeJoin(str, Enum):
	# pylint: disable=missing-class-docstring
	MITER = 'Miter'
	ROUND = 'Round'
	BEVEL = 'Bevel'

class Link:
	"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"href": ("href", "str", None),
		"templated": ("templated", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		href: "str",
		templated: Optional["bool"] = None,
	) -> None:
		"""
		:param href: The relative URL of the resource.
		:type href: str
		:param templated: True if `href` is a url template with placeholders that need to be filled.
		:type templated: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._href = cast(str, kwargs.get("href"))
		self._templated = cast(Optional[bool], kwargs.get("templated"))
	@property
	def href(self) -> "str":
		"""The relative URL of the resource."""
		return self._href
	@href.setter
	def href(self, value: "str") -> None:
		"""The relative URL of the resource."""
		self._href = value
	@property
	def templated(self) -> Optional["bool"]:
		"""True if `href` is a url template with placeholders that need to be filled."""
		return self._templated
	@templated.setter
	def templated(self, value: Optional["bool"]) -> None:
		"""True if `href` is a url template with placeholders that need to be filled."""
		self._templated = value
class LiveGroupingOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"history_window": ("historyWindow", "str", None),
		"min_versions": ("minVersions", "int", None),
		"max_versions": ("maxVersions", "int", None),
		"flatten": ("flatten", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		history_window: "str",
		min_versions: "int",
		max_versions: "int",
		flatten: "bool",
	) -> None:
		"""
		:param history_window:
		:type history_window: str
		:param min_versions:
		:type min_versions: int
		:param max_versions:
		:type max_versions: int
		:param flatten:
		:type flatten: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._history_window = cast(str, kwargs.get("history_window"))
		self._min_versions = cast(int, kwargs.get("min_versions"))
		self._max_versions = cast(int, kwargs.get("max_versions"))
		self._flatten = cast(bool, kwargs.get("flatten"))
	@property
	def history_window(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._history_window
	@history_window.setter
	def history_window(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._history_window = value
	@property
	def min_versions(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._min_versions
	@min_versions.setter
	def min_versions(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._min_versions = value
	@property
	def max_versions(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._max_versions
	@max_versions.setter
	def max_versions(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._max_versions = value
	@property
	def flatten(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._flatten
	@flatten.setter
	def flatten(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._flatten = value
class MapImageDimensionsBase:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"wpixel": ("wPixel", "int", None),
		"hpixel": ("hPixel", "int", None),
		"zoom_to_fit": ("zoomToFit", "ZoomToFit", None),
		"padding": ("padding", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		wpixel: Optional["int"] = None,
		hpixel: Optional["int"] = None,
		zoom_to_fit: Optional["ZoomToFit"] = None,
		padding: Optional["int"] = None,
	) -> None:
		"""
		:param wpixel: An integer indicating the width of the image in pixels. Defaults to 750.
		:type wpixel: int or None
		:param hpixel: An integer indicating the height of the image in pixels. Defaults to 750.
		:type hpixel: int or None
		:param zoom_to_fit: If zoomToFit = true, then the image will be expanded to fill the full wPixel x hPixel area. Otherwise it will only by the portion of the image that is needed to display the requested map area. Defaults to false.
		:type zoom_to_fit: ZoomToFit or None
		:param padding: Additional pixels to leave between the edge of the image and the requested map area.
		:type padding: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._wpixel = cast(Optional[int], kwargs.get("wpixel"))
		self._hpixel = cast(Optional[int], kwargs.get("hpixel"))
		self._zoom_to_fit = cast(Optional[ZoomToFit], kwargs.get("zoom_to_fit"))
		self._padding = cast(Optional[int], kwargs.get("padding"))
	@property
	def wpixel(self) -> Optional["int"]:
		"""An integer indicating the width of the image in pixels. Defaults to 750."""
		return self._wpixel
	@wpixel.setter
	def wpixel(self, value: Optional["int"]) -> None:
		"""An integer indicating the width of the image in pixels. Defaults to 750."""
		self._wpixel = value
	@property
	def hpixel(self) -> Optional["int"]:
		"""An integer indicating the height of the image in pixels. Defaults to 750."""
		return self._hpixel
	@hpixel.setter
	def hpixel(self, value: Optional["int"]) -> None:
		"""An integer indicating the height of the image in pixels. Defaults to 750."""
		self._hpixel = value
	@property
	def zoom_to_fit(self) -> Optional["ZoomToFit"]:
		"""If zoomToFit = true, then the image will be expanded to fill the full wPixel x hPixel area. Otherwise it will only by the portion of the image that is needed to display the requested map area. Defaults to false."""
		return self._zoom_to_fit
	@zoom_to_fit.setter
	def zoom_to_fit(self, value: Optional["ZoomToFit"]) -> None:
		"""If zoomToFit = true, then the image will be expanded to fill the full wPixel x hPixel area. Otherwise it will only by the portion of the image that is needed to display the requested map area. Defaults to false."""
		self._zoom_to_fit = value
	@property
	def padding(self) -> Optional["int"]:
		"""Additional pixels to leave between the edge of the image and the requested map area."""
		return self._padding
	@padding.setter
	def padding(self, value: Optional["int"]) -> None:
		"""Additional pixels to leave between the edge of the image and the requested map area."""
		self._padding = value
class MapImageBounds(MapImageDimensionsBase):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"min_lng": ("minLng", "float", None),
		"max_lng": ("maxLng", "float", None),
		"min_lat": ("minLat", "float", None),
		"max_lat": ("maxLat", "float", None),
		"wpixel": ("wPixel", "int", None),
		"hpixel": ("hPixel", "int", None),
		"zoom_to_fit": ("zoomToFit", "ZoomToFit", None),
		"padding": ("padding", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		min_lng: "float",
		max_lng: "float",
		min_lat: "float",
		max_lat: "float",
		wpixel: Optional["int"] = None,
		hpixel: Optional["int"] = None,
		zoom_to_fit: Optional["ZoomToFit"] = None,
		padding: Optional["int"] = None,
	) -> None:
		"""
		:param min_lng: The longitude of the west edge of the bounding box.
		:type min_lng: float
		:param max_lng: The longitude of the east edge of the bounding box.
		:type max_lng: float
		:param min_lat: The latitude of the south edge of the bounding box.
		:type min_lat: float
		:param max_lat: The latitude of the north edge of the bounding box.
		:type max_lat: float
		:param wpixel: An integer indicating the width of the image in pixels. Defaults to 750.
		:type wpixel: int or None
		:param hpixel: An integer indicating the height of the image in pixels. Defaults to 750.
		:type hpixel: int or None
		:param zoom_to_fit: If zoomToFit = true, then the image will be expanded to fill the full wPixel x hPixel area. Otherwise it will only by the portion of the image that is needed to display the requested map area. Defaults to false.
		:type zoom_to_fit: ZoomToFit or None
		:param padding: Additional pixels to leave between the edge of the image and the requested map area.
		:type padding: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		MapImageDimensionsBase.__init__(self,
			wpixel=kwargs.get("wpixel"),
			hpixel=kwargs.get("hpixel"),
			zoom_to_fit=kwargs.get("zoom_to_fit"),
			padding=kwargs.get("padding"),
		)
		self._min_lng = cast(float, kwargs.get("min_lng"))
		self._max_lng = cast(float, kwargs.get("max_lng"))
		self._min_lat = cast(float, kwargs.get("min_lat"))
		self._max_lat = cast(float, kwargs.get("max_lat"))
	@property
	def min_lng(self) -> "float":
		"""The longitude of the west edge of the bounding box."""
		return self._min_lng
	@min_lng.setter
	def min_lng(self, value: "float") -> None:
		"""The longitude of the west edge of the bounding box."""
		self._min_lng = value
	@property
	def max_lng(self) -> "float":
		"""The longitude of the east edge of the bounding box."""
		return self._max_lng
	@max_lng.setter
	def max_lng(self, value: "float") -> None:
		"""The longitude of the east edge of the bounding box."""
		self._max_lng = value
	@property
	def min_lat(self) -> "float":
		"""The latitude of the south edge of the bounding box."""
		return self._min_lat
	@min_lat.setter
	def min_lat(self, value: "float") -> None:
		"""The latitude of the south edge of the bounding box."""
		self._min_lat = value
	@property
	def max_lat(self) -> "float":
		"""The latitude of the north edge of the bounding box."""
		return self._max_lat
	@max_lat.setter
	def max_lat(self, value: "float") -> None:
		"""The latitude of the north edge of the bounding box."""
		self._max_lat = value



MapImageDimensions = Union["MapImageLayerExtents", "MapImageBounds"]
class MapImageLayerExtents(MapImageDimensionsBase):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"extents": ("extents", "int", None),
		"wpixel": ("wPixel", "int", None),
		"hpixel": ("hPixel", "int", None),
		"zoom_to_fit": ("zoomToFit", "ZoomToFit", None),
		"padding": ("padding", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		extents: "int",
		wpixel: Optional["int"] = None,
		hpixel: Optional["int"] = None,
		zoom_to_fit: Optional["ZoomToFit"] = None,
		padding: Optional["int"] = None,
	) -> None:
		"""
		:param extents: The zero-based index of one of the layers for this image request. The image will be sized to include all of the data in the specified layer.
		:type extents: int
		:param wpixel: An integer indicating the width of the image in pixels. Defaults to 750.
		:type wpixel: int or None
		:param hpixel: An integer indicating the height of the image in pixels. Defaults to 750.
		:type hpixel: int or None
		:param zoom_to_fit: If zoomToFit = true, then the image will be expanded to fill the full wPixel x hPixel area. Otherwise it will only by the portion of the image that is needed to display the requested map area. Defaults to false.
		:type zoom_to_fit: ZoomToFit or None
		:param padding: Additional pixels to leave between the edge of the image and the requested map area.
		:type padding: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		MapImageDimensionsBase.__init__(self,
			wpixel=kwargs.get("wpixel"),
			hpixel=kwargs.get("hpixel"),
			zoom_to_fit=kwargs.get("zoom_to_fit"),
			padding=kwargs.get("padding"),
		)
		self._extents = cast(int, kwargs.get("extents"))
	@property
	def extents(self) -> "int":
		"""The zero-based index of one of the layers for this image request. The image will be sized to include all of the data in the specified layer."""
		return self._extents
	@extents.setter
	def extents(self, value: "int") -> None:
		"""The zero-based index of one of the layers for this image request. The image will be sized to include all of the data in the specified layer."""
		self._extents = value
class MapImageOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"debug": ("debug", "bool", None),
		"layer_only": ("layerOnly", "bool", None),
		"projection": ("projection", "str", None),
		"style": ("style", "str", None),
		"url": ("url", "str", None),
		"username": ("username", "str", None),
		"password": ("password", "str", None),
		"quality": ("quality", "int", None),
		"ignore_errors": ("ignoreErrors", "bool", None),
		"tile_error_debug": ("tileErrorDebug", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		debug: Optional["bool"] = None,
		layer_only: Optional["bool"] = None,
		projection: Optional["str"] = None,
		style: Optional["str"] = None,
		url: Optional["str"] = None,
		username: Optional["str"] = None,
		password: Optional["str"] = None,
		quality: Optional["int"] = None,
		ignore_errors: Optional["bool"] = None,
		tile_error_debug: Optional["bool"] = None,
	) -> None:
		"""
		:param debug: Specify `true` to write how long it took to render the image in the lower left corner, write the number of layers in the image in the lower right corner, write the X / Y coordinates and zoom level in the center of the image, and draw on outline around the image. Defaults to `false`.
		:type debug: bool or None
		:param layer_only: Indicates whether base layer imagery should be included in this image (`layeronly = false`) - or if this image should only contain the specified layers(`layeronly = true`). The default value is `false`.
		:type layer_only: bool or None
		:param projection: Optionally override the projection specified by the layer.
		:type projection: str or None
		:param style: The style of base layer tiles to use. 'grey', 'black', and 'color' use tiles derived from OpenStreetMap. 'blueMarble' uses NASA's "Blue Marble" true-color image of the earth.
		:type style: str or None
		:param url: A slippy-map tile image URL template with {z}, {x}, and {y} placeholders to use for fetching base layer tiles.
		:type url: str or None
		:param username: A username to use for authenticating the base layer requests with HTTP Basic authentication.
		:type username: str or None
		:param password: A password to use for authenticating the base layer requests with HTTP Basic authentication.
		:type password: str or None
		:param quality: An integer between 0 and 100 that specifies the quality of the compressed image, if the specified image format supports it.Defaults to 100.
		:type quality: int or None
		:param ignore_errors: When true, layer rendering errors are ignored. Default is false.
		:type ignore_errors: bool or None
		:param tile_error_debug: When true, composite layer rendering errors are ignored and extra debug information is provided in the response. Default is false.
		:type tile_error_debug: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._debug = cast(Optional[bool], kwargs.get("debug"))
		self._layer_only = cast(Optional[bool], kwargs.get("layer_only"))
		self._projection = cast(Optional[str], kwargs.get("projection"))
		self._style = cast(Optional[str], kwargs.get("style"))
		self._url = cast(Optional[str], kwargs.get("url"))
		self._username = cast(Optional[str], kwargs.get("username"))
		self._password = cast(Optional[str], kwargs.get("password"))
		self._quality = cast(Optional[int], kwargs.get("quality"))
		self._ignore_errors = cast(Optional[bool], kwargs.get("ignore_errors"))
		self._tile_error_debug = cast(Optional[bool], kwargs.get("tile_error_debug"))
	@property
	def debug(self) -> Optional["bool"]:
		"""Specify `true` to write how long it took to render the image in the lower left corner, write the number of layers in the image in the lower right corner, write the X / Y coordinates and zoom level in the center of the image, and draw on outline around the image. Defaults to `false`."""
		return self._debug
	@debug.setter
	def debug(self, value: Optional["bool"]) -> None:
		"""Specify `true` to write how long it took to render the image in the lower left corner, write the number of layers in the image in the lower right corner, write the X / Y coordinates and zoom level in the center of the image, and draw on outline around the image. Defaults to `false`."""
		self._debug = value
	@property
	def layer_only(self) -> Optional["bool"]:
		"""Indicates whether base layer imagery should be included in this image (`layeronly = false`) - or if this image should only contain the specified layers(`layeronly = true`). The default value is `false`."""
		return self._layer_only
	@layer_only.setter
	def layer_only(self, value: Optional["bool"]) -> None:
		"""Indicates whether base layer imagery should be included in this image (`layeronly = false`) - or if this image should only contain the specified layers(`layeronly = true`). The default value is `false`."""
		self._layer_only = value
	@property
	def projection(self) -> Optional["str"]:
		"""Optionally override the projection specified by the layer."""
		return self._projection
	@projection.setter
	def projection(self, value: Optional["str"]) -> None:
		"""Optionally override the projection specified by the layer."""
		self._projection = value
	@property
	def style(self) -> Optional["str"]:
		"""The style of base layer tiles to use. 'grey', 'black', and 'color' use tiles derived from OpenStreetMap. 'blueMarble' uses NASA's "Blue Marble" true-color image of the earth."""
		return self._style
	@style.setter
	def style(self, value: Optional["str"]) -> None:
		"""The style of base layer tiles to use. 'grey', 'black', and 'color' use tiles derived from OpenStreetMap. 'blueMarble' uses NASA's "Blue Marble" true-color image of the earth."""
		self._style = value
	@property
	def url(self) -> Optional["str"]:
		"""A slippy-map tile image URL template with {z}, {x}, and {y} placeholders to use for fetching base layer tiles."""
		return self._url
	@url.setter
	def url(self, value: Optional["str"]) -> None:
		"""A slippy-map tile image URL template with {z}, {x}, and {y} placeholders to use for fetching base layer tiles."""
		self._url = value
	@property
	def username(self) -> Optional["str"]:
		"""A username to use for authenticating the base layer requests with HTTP Basic authentication."""
		return self._username
	@username.setter
	def username(self, value: Optional["str"]) -> None:
		"""A username to use for authenticating the base layer requests with HTTP Basic authentication."""
		self._username = value
	@property
	def password(self) -> Optional["str"]:
		"""A password to use for authenticating the base layer requests with HTTP Basic authentication."""
		return self._password
	@password.setter
	def password(self, value: Optional["str"]) -> None:
		"""A password to use for authenticating the base layer requests with HTTP Basic authentication."""
		self._password = value
	@property
	def quality(self) -> Optional["int"]:
		"""An integer between 0 and 100 that specifies the quality of the compressed image, if the specified image format supports it.Defaults to 100."""
		return self._quality
	@quality.setter
	def quality(self, value: Optional["int"]) -> None:
		"""An integer between 0 and 100 that specifies the quality of the compressed image, if the specified image format supports it.Defaults to 100."""
		self._quality = value
	@property
	def ignore_errors(self) -> Optional["bool"]:
		"""When true, layer rendering errors are ignored. Default is false."""
		return self._ignore_errors
	@ignore_errors.setter
	def ignore_errors(self, value: Optional["bool"]) -> None:
		"""When true, layer rendering errors are ignored. Default is false."""
		self._ignore_errors = value
	@property
	def tile_error_debug(self) -> Optional["bool"]:
		"""When true, composite layer rendering errors are ignored and extra debug information is provided in the response. Default is false."""
		return self._tile_error_debug
	@tile_error_debug.setter
	def tile_error_debug(self, value: Optional["bool"]) -> None:
		"""When true, composite layer rendering errors are ignored and extra debug information is provided in the response. Default is false."""
		self._tile_error_debug = value
class MapTileCoordinates:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"use_relative_path": ("useRelativePath", "bool", None),
		"x": ("x", "int", None),
		"y": ("y", "int", None),
		"z": ("z", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		use_relative_path: "bool",
		x: "int",
		y: "int",
		z: "int",
	) -> None:
		"""
		:param use_relative_path:
		:type use_relative_path: bool
		:param x:
		:type x: int
		:param y:
		:type y: int
		:param z:
		:type z: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._use_relative_path = cast(bool, kwargs.get("use_relative_path"))
		self._x = cast(int, kwargs.get("x"))
		self._y = cast(int, kwargs.get("y"))
		self._z = cast(int, kwargs.get("z"))
	@property
	def use_relative_path(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._use_relative_path
	@use_relative_path.setter
	def use_relative_path(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._use_relative_path = value
	@property
	def x(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._x
	@x.setter
	def x(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._x = value
	@property
	def y(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._y
	@y.setter
	def y(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._y = value
	@property
	def z(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._z
	@z.setter
	def z(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._z = value
class MapTileOptions(MapImageOptions):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"w": ("w", "int", None),
		"h": ("h", "int", None),
		"debug": ("debug", "bool", None),
		"layer_only": ("layerOnly", "bool", None),
		"projection": ("projection", "str", None),
		"style": ("style", "str", None),
		"url": ("url", "str", None),
		"username": ("username", "str", None),
		"password": ("password", "str", None),
		"quality": ("quality", "int", None),
		"ignore_errors": ("ignoreErrors", "bool", None),
		"tile_error_debug": ("tileErrorDebug", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		w: Optional["int"] = None,
		h: Optional["int"] = None,
		debug: Optional["bool"] = None,
		layer_only: Optional["bool"] = None,
		projection: Optional["str"] = None,
		style: Optional["str"] = None,
		url: Optional["str"] = None,
		username: Optional["str"] = None,
		password: Optional["str"] = None,
		quality: Optional["int"] = None,
		ignore_errors: Optional["bool"] = None,
		tile_error_debug: Optional["bool"] = None,
	) -> None:
		"""
		:param w: An integer indicating how wide, in 256 pixel tiles, the image should be. Defaults to `1`.
		:type w: int or None
		:param h: An integer indicating how tall, in 256 pixel tiles, the image should be. Defaults to `1`.
		:type h: int or None
		:param debug: Specify `true` to write how long it took to render the image in the lower left corner, write the number of layers in the image in the lower right corner, write the X / Y coordinates and zoom level in the center of the image, and draw on outline around the image. Defaults to `false`.
		:type debug: bool or None
		:param layer_only: Indicates whether base layer imagery should be included in this image (`layeronly = false`) - or if this image should only contain the specified layers(`layeronly = true`). The default value is `false`.
		:type layer_only: bool or None
		:param projection: Optionally override the projection specified by the layer.
		:type projection: str or None
		:param style: The style of base layer tiles to use. 'grey', 'black', and 'color' use tiles derived from OpenStreetMap. 'blueMarble' uses NASA's "Blue Marble" true-color image of the earth.
		:type style: str or None
		:param url: A slippy-map tile image URL template with {z}, {x}, and {y} placeholders to use for fetching base layer tiles.
		:type url: str or None
		:param username: A username to use for authenticating the base layer requests with HTTP Basic authentication.
		:type username: str or None
		:param password: A password to use for authenticating the base layer requests with HTTP Basic authentication.
		:type password: str or None
		:param quality: An integer between 0 and 100 that specifies the quality of the compressed image, if the specified image format supports it.Defaults to 100.
		:type quality: int or None
		:param ignore_errors: When true, layer rendering errors are ignored. Default is false.
		:type ignore_errors: bool or None
		:param tile_error_debug: When true, composite layer rendering errors are ignored and extra debug information is provided in the response. Default is false.
		:type tile_error_debug: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		MapImageOptions.__init__(self,
			debug=kwargs.get("debug"),
			layer_only=kwargs.get("layer_only"),
			projection=kwargs.get("projection"),
			style=kwargs.get("style"),
			url=kwargs.get("url"),
			username=kwargs.get("username"),
			password=kwargs.get("password"),
			quality=kwargs.get("quality"),
			ignore_errors=kwargs.get("ignore_errors"),
			tile_error_debug=kwargs.get("tile_error_debug"),
		)
		self._w = cast(Optional[int], kwargs.get("w"))
		self._h = cast(Optional[int], kwargs.get("h"))
	@property
	def w(self) -> Optional["int"]:
		"""An integer indicating how wide, in 256 pixel tiles, the image should be. Defaults to `1`."""
		return self._w
	@w.setter
	def w(self, value: Optional["int"]) -> None:
		"""An integer indicating how wide, in 256 pixel tiles, the image should be. Defaults to `1`."""
		self._w = value
	@property
	def h(self) -> Optional["int"]:
		"""An integer indicating how tall, in 256 pixel tiles, the image should be. Defaults to `1`."""
		return self._h
	@h.setter
	def h(self, value: Optional["int"]) -> None:
		"""An integer indicating how tall, in 256 pixel tiles, the image should be. Defaults to `1`."""
		self._h = value
class MLImportTagData:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"key": ("key", "str", None),
		"value": ("value", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		key: Optional["str"] = None,
		value: Optional["str"] = None,
	) -> None:
		"""
		:param key:
		:type key: str or None
		:param value:
		:type value: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._key = cast(Optional[str], kwargs.get("key"))
		self._value = cast(Optional[str], kwargs.get("value"))
	@property
	def key(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._key
	@key.setter
	def key(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._key = value
	@property
	def value(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._value
	@value.setter
	def value(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._value = value
class MLPartitionedSchemaColumn:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("Name", "str", None),
		"column_type": ("ColumnType", "ColumnType", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		column_type: "ColumnType",
		name: Optional["str"] = None,
	) -> None:
		"""
		:param column_type: The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data.
		:type column_type: ColumnType
		:param name:
		:type name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._column_type = cast(ColumnType, kwargs.get("column_type"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def column_type(self) -> "ColumnType":
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		return self._column_type
	@column_type.setter
	def column_type(self, value: "ColumnType") -> None:
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		self._column_type = value
class MLPartitionedTableTag:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"partition_col_info": ("partitionColInfo", "list", "TablePartitionerInfo"),
		"partition_cols": ("partitionCols", "list", "str"),
		"sub_tables": ("subTables", "list", "str"),
		"enable_default_partitions": ("enableDefaultPartitions", "bool", None),
		"default_query_partitions": ("defaultQueryPartitions", "int", None),
		"default_partition_ascending_order": ("defaultPartitionAscendingOrder", "bool", None),
		"parallel": ("parallel", "int", None),
		"partition_stats_column": ("partitionStatsColumn", "str", None),
		"partition_stats_result_table": ("partitionStatsResultTable", "str", None),
		"distribution_factor": ("distributionFactor", "int", None),
		"expire_when_not_updated_time_span": ("expireWhenNotUpdatedTimeSpan", "str", None),
		"delete_empty_partitions": ("deleteEmptyPartitions", "bool", None),
		"strict_mode": ("strictMode", "TransactedTableHandleSchemaStrictMode", None),
		"schema": ("schema", "list", "MLPartitionedSchemaColumn"),
		"expire_time_span": ("expireTimeSpan", "str", None),
		"expire_from_end": ("expireFromEnd", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		partition_col_info: "List[TablePartitionerInfo]",
		partition_cols: "List[str]",
		sub_tables: "List[str]",
		enable_default_partitions: "bool",
		default_query_partitions: "int",
		default_partition_ascending_order: "bool",
		parallel: "int",
		distribution_factor: "int",
		delete_empty_partitions: "bool",
		strict_mode: "TransactedTableHandleSchemaStrictMode",
		schema: "List[MLPartitionedSchemaColumn]",
		expire_from_end: "bool",
		partition_stats_column: Optional["str"] = None,
		partition_stats_result_table: Optional["str"] = None,
		expire_when_not_updated_time_span: Optional["str"] = None,
		expire_time_span: Optional["str"] = None,
	) -> None:
		"""
		:param partition_col_info:
		:type partition_col_info: List[TablePartitionerInfo]
		:param partition_cols:
		:type partition_cols: List[str]
		:param sub_tables:
		:type sub_tables: List[str]
		:param enable_default_partitions:
		:type enable_default_partitions: bool
		:param default_query_partitions:
		:type default_query_partitions: int
		:param default_partition_ascending_order:
		:type default_partition_ascending_order: bool
		:param parallel:
		:type parallel: int
		:param distribution_factor:
		:type distribution_factor: int
		:param delete_empty_partitions:
		:type delete_empty_partitions: bool
		:param strict_mode:
		:type strict_mode: TransactedTableHandleSchemaStrictMode
		:param schema:
		:type schema: List[MLPartitionedSchemaColumn]
		:param expire_from_end:
		:type expire_from_end: bool
		:param partition_stats_column:
		:type partition_stats_column: str or None
		:param partition_stats_result_table:
		:type partition_stats_result_table: str or None
		:param expire_when_not_updated_time_span:
		:type expire_when_not_updated_time_span: str or None
		:param expire_time_span:
		:type expire_time_span: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._partition_col_info = cast(List[TablePartitionerInfo], kwargs.get("partition_col_info"))
		self._partition_cols = cast(List[str], kwargs.get("partition_cols"))
		self._sub_tables = cast(List[str], kwargs.get("sub_tables"))
		self._enable_default_partitions = cast(bool, kwargs.get("enable_default_partitions"))
		self._default_query_partitions = cast(int, kwargs.get("default_query_partitions"))
		self._default_partition_ascending_order = cast(bool, kwargs.get("default_partition_ascending_order"))
		self._parallel = cast(int, kwargs.get("parallel"))
		self._partition_stats_column = cast(Optional[str], kwargs.get("partition_stats_column"))
		self._partition_stats_result_table = cast(Optional[str], kwargs.get("partition_stats_result_table"))
		self._distribution_factor = cast(int, kwargs.get("distribution_factor"))
		self._expire_when_not_updated_time_span = cast(Optional[str], kwargs.get("expire_when_not_updated_time_span"))
		self._delete_empty_partitions = cast(bool, kwargs.get("delete_empty_partitions"))
		self._strict_mode = cast(TransactedTableHandleSchemaStrictMode, kwargs.get("strict_mode"))
		self._schema = cast(List[MLPartitionedSchemaColumn], kwargs.get("schema"))
		self._expire_time_span = cast(Optional[str], kwargs.get("expire_time_span"))
		self._expire_from_end = cast(bool, kwargs.get("expire_from_end"))
	@property
	def partition_col_info(self) -> "List[TablePartitionerInfo]":
		# pylint: disable=missing-function-docstring
		return self._partition_col_info
	@partition_col_info.setter
	def partition_col_info(self, value: "List[TablePartitionerInfo]") -> None:
		# pylint: disable=missing-function-docstring
		self._partition_col_info = value
	@property
	def partition_cols(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._partition_cols
	@partition_cols.setter
	def partition_cols(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._partition_cols = value
	@property
	def sub_tables(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._sub_tables
	@sub_tables.setter
	def sub_tables(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._sub_tables = value
	@property
	def enable_default_partitions(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._enable_default_partitions
	@enable_default_partitions.setter
	def enable_default_partitions(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._enable_default_partitions = value
	@property
	def default_query_partitions(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._default_query_partitions
	@default_query_partitions.setter
	def default_query_partitions(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._default_query_partitions = value
	@property
	def default_partition_ascending_order(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._default_partition_ascending_order
	@default_partition_ascending_order.setter
	def default_partition_ascending_order(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._default_partition_ascending_order = value
	@property
	def parallel(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._parallel
	@parallel.setter
	def parallel(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._parallel = value
	@property
	def partition_stats_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._partition_stats_column
	@partition_stats_column.setter
	def partition_stats_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._partition_stats_column = value
	@property
	def partition_stats_result_table(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._partition_stats_result_table
	@partition_stats_result_table.setter
	def partition_stats_result_table(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._partition_stats_result_table = value
	@property
	def distribution_factor(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._distribution_factor
	@distribution_factor.setter
	def distribution_factor(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._distribution_factor = value
	@property
	def expire_when_not_updated_time_span(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._expire_when_not_updated_time_span
	@expire_when_not_updated_time_span.setter
	def expire_when_not_updated_time_span(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._expire_when_not_updated_time_span = value
	@property
	def delete_empty_partitions(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._delete_empty_partitions
	@delete_empty_partitions.setter
	def delete_empty_partitions(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._delete_empty_partitions = value
	@property
	def strict_mode(self) -> "TransactedTableHandleSchemaStrictMode":
		# pylint: disable=missing-function-docstring
		return self._strict_mode
	@strict_mode.setter
	def strict_mode(self, value: "TransactedTableHandleSchemaStrictMode") -> None:
		# pylint: disable=missing-function-docstring
		self._strict_mode = value
	@property
	def schema(self) -> "List[MLPartitionedSchemaColumn]":
		# pylint: disable=missing-function-docstring
		return self._schema
	@schema.setter
	def schema(self, value: "List[MLPartitionedSchemaColumn]") -> None:
		# pylint: disable=missing-function-docstring
		self._schema = value
	@property
	def expire_time_span(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._expire_time_span
	@expire_time_span.setter
	def expire_time_span(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._expire_time_span = value
	@property
	def expire_from_end(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._expire_from_end
	@expire_from_end.setter
	def expire_from_end(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._expire_from_end = value


class MLQueryTests(str, Enum):
	# pylint: disable=missing-class-docstring
	CATCH_ALL = 'CatchAll'
	ALWAYS_FALSE = 'AlwaysFalse'
	GREATER = 'Greater'
	NOT_GREATER = 'Not_Greater'
	GREATER_OR = 'GreaterOR'
	NOT_GREATER_OR = 'Not_GreaterOR'
	LESS = 'Less'
	NOT_LESS = 'Not_Less'
	LESS_OR = 'LessOR'
	NOT_LESS_OR = 'Not_LessOR'
	BETWEEN = 'Between'
	NOT_BETWEEN = 'NotBetween'
	EQUAL = 'Equal'
	EQUAL_ANY = 'EqualAny'
	EQUAL_NONE = 'EqualNone'
	EQUAL_NOT = 'EqualNot'
	EQUAL_ANY_LIST = 'EqualAnyList'
	EQUAL_ALL_LIST = 'EqualAllList'
	CONTAINS = 'Contains'
	CONTAINS_ALL = 'ContainsAll'
	CONTAINS_ANY = 'ContainsAny'
	CONTAINS_NOT = 'ContainsNot'
	CONTAINS_NONE = 'ContainsNone'
	CONTAINS_OR = 'ContainsOr'
	STARTS_WITH = 'StartsWith'
	STARTS_WITH_NOT = 'StartsWithNot'
	ENDS_WITH = 'EndsWith'
	NOT_ENDS_WITH = 'Not_EndsWith'
	FUZZY = 'Fuzzy'
	NOT_FUZZY = 'Not_Fuzzy'
	IS_EMPTY = 'IsEmpty'
	IS_NOT_EMPTY = 'IsNotEmpty'
	REVERSE_CONTAINS_ALL = 'ReverseContainsAll'
	IS_NULL = 'IsNull'
	IS_NOT_NULL = 'IsNotNull'
	DWITHIN = 'DWithin'
	NOT_DWITHIN = 'NotDWithin'
	NOT_CONTAINS = 'NotContains'
	OVERLAPS = 'Overlaps'
	NOT_OVERLAPS = 'NotOverlaps'
	NEAREST = 'Nearest'
	DAY_OF_WEEK = 'DayOfWeek'
	HOUR_OF_DAY = 'HourOfDay'
	WITHIN_LAST = 'WithinLast'
	AND = 'AND'
	OR = 'OR'

class NetCDFConfig:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"is_open_dap": ("isOpenDAP", "bool", None),
		"variable_opts": ("variableOpts", "list", "NetCDFConfigVariableOptions"),
		"dimension_opts": ("dimensionOpts", "dict", "NetCDFConfigDimensionOptions"),
		"raster_slices": ("rasterSlices", "list", "RasterSlice"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		is_open_dap: "bool",
		variable_opts: "List[NetCDFConfigVariableOptions]",
		dimension_opts: "Dict[str, NetCDFConfigDimensionOptions]",
		raster_slices: "List[RasterSlice]",
	) -> None:
		"""
		:param is_open_dap: Use OpenDAP to retrieve the data from a remote source (specified by the import URI).
		:type is_open_dap: bool
		:param variable_opts: The values to set for each named variable we're interested in.
		:type variable_opts: List[NetCDFConfigVariableOptions]
		:param dimension_opts: The values to set for each named dimension we're interested in.
		:type dimension_opts: Dict[str, NetCDFConfigDimensionOptions]
		:param raster_slices:
		:type raster_slices: List[RasterSlice]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._is_open_dap = cast(bool, kwargs.get("is_open_dap"))
		self._variable_opts = cast(List[NetCDFConfigVariableOptions], kwargs.get("variable_opts"))
		self._dimension_opts = cast(Dict[str, NetCDFConfigDimensionOptions], kwargs.get("dimension_opts"))
		self._raster_slices = cast(List[RasterSlice], kwargs.get("raster_slices"))
	@property
	def is_open_dap(self) -> "bool":
		"""Use OpenDAP to retrieve the data from a remote source (specified by the import URI)."""
		return self._is_open_dap
	@is_open_dap.setter
	def is_open_dap(self, value: "bool") -> None:
		"""Use OpenDAP to retrieve the data from a remote source (specified by the import URI)."""
		self._is_open_dap = value
	@property
	def variable_opts(self) -> "List[NetCDFConfigVariableOptions]":
		"""The values to set for each named variable we're interested in."""
		return self._variable_opts
	@variable_opts.setter
	def variable_opts(self, value: "List[NetCDFConfigVariableOptions]") -> None:
		"""The values to set for each named variable we're interested in."""
		self._variable_opts = value
	@property
	def dimension_opts(self) -> "Dict[str, NetCDFConfigDimensionOptions]":
		"""The values to set for each named dimension we're interested in."""
		return self._dimension_opts
	@dimension_opts.setter
	def dimension_opts(self, value: "Dict[str, NetCDFConfigDimensionOptions]") -> None:
		"""The values to set for each named dimension we're interested in."""
		self._dimension_opts = value
	@property
	def raster_slices(self) -> "List[RasterSlice]":
		# pylint: disable=missing-function-docstring
		return self._raster_slices
	@raster_slices.setter
	def raster_slices(self, value: "List[RasterSlice]") -> None:
		# pylint: disable=missing-function-docstring
		self._raster_slices = value


class NetCDFConfigDimensionMode(str, Enum):
	# pylint: disable=missing-class-docstring
	ALL = 'All'
	STRIDE = 'Stride'
	FIRST = 'First'
	LAST = 'Last'

class NetCDFConfigDimensionOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"mode": ("mode", "NetCDFConfigDimensionMode", None),
		"stride": ("stride", "int", None),
		"include_in_result": ("includeInResult", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		mode: "NetCDFConfigDimensionMode",
		stride: "int",
		include_in_result: "bool",
	) -> None:
		"""
		:param mode:
		:type mode: NetCDFConfigDimensionMode
		:param stride: Stride length, when using stride mode.
		:type stride: int
		:param include_in_result: Include the actual dimension ordinal values.
		:type include_in_result: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._mode = cast(NetCDFConfigDimensionMode, kwargs.get("mode"))
		self._stride = cast(int, kwargs.get("stride"))
		self._include_in_result = cast(bool, kwargs.get("include_in_result"))
	@property
	def mode(self) -> "NetCDFConfigDimensionMode":
		# pylint: disable=missing-function-docstring
		return self._mode
	@mode.setter
	def mode(self, value: "NetCDFConfigDimensionMode") -> None:
		# pylint: disable=missing-function-docstring
		self._mode = value
	@property
	def stride(self) -> "int":
		"""Stride length, when using stride mode."""
		return self._stride
	@stride.setter
	def stride(self, value: "int") -> None:
		"""Stride length, when using stride mode."""
		self._stride = value
	@property
	def include_in_result(self) -> "bool":
		"""Include the actual dimension ordinal values."""
		return self._include_in_result
	@include_in_result.setter
	def include_in_result(self, value: "bool") -> None:
		"""Include the actual dimension ordinal values."""
		self._include_in_result = value


class NetCDFConfigTimeUnit(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	DAYS = 'Days'

class NetCDFConfigVariableOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"adjust_longitude": ("adjustLongitude", "bool", None),
		"time_base": ("timeBase", "datetime", None),
		"time_unit": ("timeUnit", "NetCDFConfigTimeUnit", None),
		"alias": ("alias", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		adjust_longitude: "bool",
		time_base: "datetime",
		time_unit: "NetCDFConfigTimeUnit",
		name: Optional["str"] = None,
		alias: Optional["str"] = None,
	) -> None:
		"""
		:param adjust_longitude:
		:type adjust_longitude: bool
		:param time_base: Base time. e.g. UNIX epoch.
		:type time_base: datetime
		:param time_unit:
		:type time_unit: NetCDFConfigTimeUnit
		:param name:
		:type name: str or None
		:param alias: Alias to rename variable.
		:type alias: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._adjust_longitude = cast(bool, kwargs.get("adjust_longitude"))
		self._time_base = cast(datetime, kwargs.get("time_base"))
		self._time_unit = cast(NetCDFConfigTimeUnit, kwargs.get("time_unit"))
		self._alias = cast(Optional[str], kwargs.get("alias"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def adjust_longitude(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._adjust_longitude
	@adjust_longitude.setter
	def adjust_longitude(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._adjust_longitude = value
	@property
	def time_base(self) -> "datetime":
		"""Base time. e.g. UNIX epoch."""
		return self._time_base
	@time_base.setter
	def time_base(self, value: "datetime") -> None:
		"""Base time. e.g. UNIX epoch."""
		self._time_base = value
	@property
	def time_unit(self) -> "NetCDFConfigTimeUnit":
		# pylint: disable=missing-function-docstring
		return self._time_unit
	@time_unit.setter
	def time_unit(self, value: "NetCDFConfigTimeUnit") -> None:
		# pylint: disable=missing-function-docstring
		self._time_unit = value
	@property
	def alias(self) -> Optional["str"]:
		"""Alias to rename variable."""
		return self._alias
	@alias.setter
	def alias(self, value: Optional["str"]) -> None:
		"""Alias to rename variable."""
		self._alias = value
class NexradLevel2Request:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"target_time": ("targetTime", "datetime", None),
		"stations": ("stations", "str", None),
		"min_seconds_before": ("minSecondsBefore", "int", None),
		"max_seconds_before": ("maxSecondsBefore", "int", None),
		"sweep": ("sweep", "str", None),
		"all_sweeps": ("allSweeps", "bool", None),
		"sweeps": ("sweeps", "list", "int"),
		"output_grid_size": ("outputGridSize", "float", None),
		"output_hole_threshold": ("outputHoleThreshold", "int", None),
		"missing_data": ("missingData", "float", None),
		"aggregate_mode": ("aggregateMode", "AggregateMode", None),
		"interpolate_mode": ("interpolateMode", "InterpolateMode", None),
		"min_reflectivity": ("minReflectivity", "float", None),
		"max_reflectivity": ("maxReflectivity", "float", None),
		"min_correlation": ("minCorrelation", "float", None),
		"max_correlation": ("maxCorrelation", "float", None),
		"min_zdr": ("minZDR", "float", None),
		"max_zdr": ("maxZDR", "float", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		target_time: "datetime",
		min_seconds_before: "int",
		max_seconds_before: "int",
		all_sweeps: "bool",
		sweeps: "List[int]",
		output_grid_size: "float",
		output_hole_threshold: "int",
		missing_data: "float",
		aggregate_mode: "AggregateMode",
		interpolate_mode: "InterpolateMode",
		stations: Optional["str"] = None,
		sweep: Optional["str"] = None,
		min_reflectivity: Optional["float"] = None,
		max_reflectivity: Optional["float"] = None,
		min_correlation: Optional["float"] = None,
		max_correlation: Optional["float"] = None,
		min_zdr: Optional["float"] = None,
		max_zdr: Optional["float"] = None,
	) -> None:
		"""
		:param target_time:
		:type target_time: datetime
		:param min_seconds_before:
		:type min_seconds_before: int
		:param max_seconds_before:
		:type max_seconds_before: int
		:param all_sweeps:
		:type all_sweeps: bool
		:param sweeps:
		:type sweeps: List[int]
		:param output_grid_size:
		:type output_grid_size: float
		:param output_hole_threshold:
		:type output_hole_threshold: int
		:param missing_data:
		:type missing_data: float
		:param aggregate_mode: Defines the behavior when multiple values are in a single cell
* `Avg` - Uses the mean average of the values
* `Min` - Uses the minimum of the values
* `Max` - Uses the maximum of the values
* `TopOnly` - The highest value based on a sort column
		:type aggregate_mode: AggregateMode
		:param interpolate_mode: Defines the interpolation method used to calculate the values in between the known data points
* `None` - No interpolation
* `Nearest` - Nearest-neighbor interpolation
* `Linear` - Bilinear interpolation
* `Cubic` - Bicubic interpolation
* `IDW` - Inverse distance weighted interpolation
* `Auto` - Attempts to set the interpolation mode based on the raster band data type
		:type interpolate_mode: InterpolateMode
		:param stations:
		:type stations: str or None
		:param sweep:
		:type sweep: str or None
		:param min_reflectivity:
		:type min_reflectivity: float or None
		:param max_reflectivity:
		:type max_reflectivity: float or None
		:param min_correlation:
		:type min_correlation: float or None
		:param max_correlation:
		:type max_correlation: float or None
		:param min_zdr:
		:type min_zdr: float or None
		:param max_zdr:
		:type max_zdr: float or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._target_time = cast(datetime, kwargs.get("target_time"))
		self._stations = cast(Optional[str], kwargs.get("stations"))
		self._min_seconds_before = cast(int, kwargs.get("min_seconds_before"))
		self._max_seconds_before = cast(int, kwargs.get("max_seconds_before"))
		self._sweep = cast(Optional[str], kwargs.get("sweep"))
		self._all_sweeps = cast(bool, kwargs.get("all_sweeps"))
		self._sweeps = cast(List[int], kwargs.get("sweeps"))
		self._output_grid_size = cast(float, kwargs.get("output_grid_size"))
		self._output_hole_threshold = cast(int, kwargs.get("output_hole_threshold"))
		self._missing_data = cast(float, kwargs.get("missing_data"))
		self._aggregate_mode = cast(AggregateMode, kwargs.get("aggregate_mode"))
		self._interpolate_mode = cast(InterpolateMode, kwargs.get("interpolate_mode"))
		self._min_reflectivity = cast(Optional[float], kwargs.get("min_reflectivity"))
		self._max_reflectivity = cast(Optional[float], kwargs.get("max_reflectivity"))
		self._min_correlation = cast(Optional[float], kwargs.get("min_correlation"))
		self._max_correlation = cast(Optional[float], kwargs.get("max_correlation"))
		self._min_zdr = cast(Optional[float], kwargs.get("min_zdr"))
		self._max_zdr = cast(Optional[float], kwargs.get("max_zdr"))
	@property
	def target_time(self) -> "datetime":
		# pylint: disable=missing-function-docstring
		return self._target_time
	@target_time.setter
	def target_time(self, value: "datetime") -> None:
		# pylint: disable=missing-function-docstring
		self._target_time = value
	@property
	def stations(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._stations
	@stations.setter
	def stations(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._stations = value
	@property
	def min_seconds_before(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._min_seconds_before
	@min_seconds_before.setter
	def min_seconds_before(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._min_seconds_before = value
	@property
	def max_seconds_before(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._max_seconds_before
	@max_seconds_before.setter
	def max_seconds_before(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._max_seconds_before = value
	@property
	def sweep(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._sweep
	@sweep.setter
	def sweep(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._sweep = value
	@property
	def all_sweeps(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._all_sweeps
	@all_sweeps.setter
	def all_sweeps(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._all_sweeps = value
	@property
	def sweeps(self) -> "List[int]":
		# pylint: disable=missing-function-docstring
		return self._sweeps
	@sweeps.setter
	def sweeps(self, value: "List[int]") -> None:
		# pylint: disable=missing-function-docstring
		self._sweeps = value
	@property
	def output_grid_size(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._output_grid_size
	@output_grid_size.setter
	def output_grid_size(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._output_grid_size = value
	@property
	def output_hole_threshold(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._output_hole_threshold
	@output_hole_threshold.setter
	def output_hole_threshold(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._output_hole_threshold = value
	@property
	def missing_data(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._missing_data
	@missing_data.setter
	def missing_data(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._missing_data = value
	@property
	def aggregate_mode(self) -> "AggregateMode":
		"""Defines the behavior when multiple values are in a single cell
* `Avg` - Uses the mean average of the values
* `Min` - Uses the minimum of the values
* `Max` - Uses the maximum of the values
* `TopOnly` - The highest value based on a sort column"""
		return self._aggregate_mode
	@aggregate_mode.setter
	def aggregate_mode(self, value: "AggregateMode") -> None:
		"""Defines the behavior when multiple values are in a single cell
* `Avg` - Uses the mean average of the values
* `Min` - Uses the minimum of the values
* `Max` - Uses the maximum of the values
* `TopOnly` - The highest value based on a sort column"""
		self._aggregate_mode = value
	@property
	def interpolate_mode(self) -> "InterpolateMode":
		"""Defines the interpolation method used to calculate the values in between the known data points
* `None` - No interpolation
* `Nearest` - Nearest-neighbor interpolation
* `Linear` - Bilinear interpolation
* `Cubic` - Bicubic interpolation
* `IDW` - Inverse distance weighted interpolation
* `Auto` - Attempts to set the interpolation mode based on the raster band data type"""
		return self._interpolate_mode
	@interpolate_mode.setter
	def interpolate_mode(self, value: "InterpolateMode") -> None:
		"""Defines the interpolation method used to calculate the values in between the known data points
* `None` - No interpolation
* `Nearest` - Nearest-neighbor interpolation
* `Linear` - Bilinear interpolation
* `Cubic` - Bicubic interpolation
* `IDW` - Inverse distance weighted interpolation
* `Auto` - Attempts to set the interpolation mode based on the raster band data type"""
		self._interpolate_mode = value
	@property
	def min_reflectivity(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._min_reflectivity
	@min_reflectivity.setter
	def min_reflectivity(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_reflectivity = value
	@property
	def max_reflectivity(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._max_reflectivity
	@max_reflectivity.setter
	def max_reflectivity(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_reflectivity = value
	@property
	def min_correlation(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._min_correlation
	@min_correlation.setter
	def min_correlation(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_correlation = value
	@property
	def max_correlation(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._max_correlation
	@max_correlation.setter
	def max_correlation(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_correlation = value
	@property
	def min_zdr(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._min_zdr
	@min_zdr.setter
	def min_zdr(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_zdr = value
	@property
	def max_zdr(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._max_zdr
	@max_zdr.setter
	def max_zdr(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_zdr = value
class Node:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"seeks_membership": ("seeksMembership", "bool", None),
		"is_voting_member": ("isVotingMember", "bool", None),
		"address": ("address", "str", None),
		"id_": ("id", "str", None),
		"is_load_balancer": ("isLoadBalancer", "bool", None),
		"roles": ("roles", "list", "Role"),
		"is_peaking_only": ("isPeakingOnly", "bool", None),
		"is_cluster_peaking": ("isClusterPeaking", "bool", None),
		"boot_step": ("bootStep", "str", None),
		"consensus_role": ("consensusRole", "str", None),
		"is_available": ("isAvailable", "bool", None),
		"failed_transaction_count": ("failedTransactionCount", "int", None),
		"version": ("version", "Version", None),
		"hardware": ("hardware", "HardwareStats", None),
		"transaction_waiters": ("transactionWaiters", "ClusterWaiters", None),
		"state_machine": ("stateMachine", "StateMachine", None),
		"consensus": ("consensus", "ConsensusInfo", None),
		"links": ("links", "NodeLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		seeks_membership: "bool",
		is_voting_member: "bool",
		is_load_balancer: "bool",
		roles: "List[Role]",
		is_peaking_only: "bool",
		is_cluster_peaking: "bool",
		is_available: "bool",
		failed_transaction_count: "int",
		version: "Version",
		hardware: "HardwareStats",
		transaction_waiters: "ClusterWaiters",
		state_machine: "StateMachine",
		consensus: "ConsensusInfo",
		links: "NodeLinks",
		address: Optional["str"] = None,
		id_: Optional["str"] = None,
		boot_step: Optional["str"] = None,
		consensus_role: Optional["str"] = None,
	) -> None:
		"""
		:param seeks_membership: Indicates that this node will try to join a cluster
		:type seeks_membership: bool
		:param is_voting_member: Indicates the node is a voting member of the cluster
		:type is_voting_member: bool
		:param is_load_balancer: If true, this node is solely acting as as load balancer and not otherwise participating in the cluster
		:type is_load_balancer: bool
		:param roles: A list of roles configured for this node
		:type roles: List[Role]
		:param is_peaking_only: If true, indicates that that this node is standby only unless a threshold has been exceeded
		:type is_peaking_only: bool
		:param is_cluster_peaking: If true indicates that the cluster has exceeded the resource threshold and peaking nodes have been recruited
		:type is_cluster_peaking: bool
		:param is_available: If false, indicates that the node is currently disabled
		:type is_available: bool
		:param failed_transaction_count: The number of transactions that have failed
		:type failed_transaction_count: int
		:param version: Information about the node's software
		:type version: Version
		:param hardware: Information about the hardware that the node is running on
		:type hardware: HardwareStats
		:param transaction_waiters: Information about actions that are waiting for transactions to be completed
		:type transaction_waiters: ClusterWaiters
		:param state_machine: State machine details
		:type state_machine: StateMachine
		:param consensus: Cluster participation details
		:type consensus: ConsensusInfo
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: NodeLinks
		:param address: The network address for this node
		:type address: str or None
		:param id_: The unique identifier for this node
		:type id_: str or None
		:param boot_step: Indicates where the node is in its startup sequence
		:type boot_step: str or None
		:param consensus_role: Indicates the node's current function within the cluster
		:type consensus_role: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._seeks_membership = cast(bool, kwargs.get("seeks_membership"))
		self._is_voting_member = cast(bool, kwargs.get("is_voting_member"))
		self._address = cast(Optional[str], kwargs.get("address"))
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._is_load_balancer = cast(bool, kwargs.get("is_load_balancer"))
		self._roles = cast(List[Role], kwargs.get("roles"))
		self._is_peaking_only = cast(bool, kwargs.get("is_peaking_only"))
		self._is_cluster_peaking = cast(bool, kwargs.get("is_cluster_peaking"))
		self._boot_step = cast(Optional[str], kwargs.get("boot_step"))
		self._consensus_role = cast(Optional[str], kwargs.get("consensus_role"))
		self._is_available = cast(bool, kwargs.get("is_available"))
		self._failed_transaction_count = cast(int, kwargs.get("failed_transaction_count"))
		self._version = cast(Version, kwargs.get("version"))
		self._hardware = cast(HardwareStats, kwargs.get("hardware"))
		self._transaction_waiters = cast(ClusterWaiters, kwargs.get("transaction_waiters"))
		self._state_machine = cast(StateMachine, kwargs.get("state_machine"))
		self._consensus = cast(ConsensusInfo, kwargs.get("consensus"))
		self._links = cast(NodeLinks, kwargs.get("links"))
	@property
	def seeks_membership(self) -> "bool":
		"""Indicates that this node will try to join a cluster"""
		return self._seeks_membership
	@seeks_membership.setter
	def seeks_membership(self, value: "bool") -> None:
		"""Indicates that this node will try to join a cluster"""
		self._seeks_membership = value
	@property
	def is_voting_member(self) -> "bool":
		"""Indicates the node is a voting member of the cluster"""
		return self._is_voting_member
	@is_voting_member.setter
	def is_voting_member(self, value: "bool") -> None:
		"""Indicates the node is a voting member of the cluster"""
		self._is_voting_member = value
	@property
	def address(self) -> Optional["str"]:
		"""The network address for this node"""
		return self._address
	@address.setter
	def address(self, value: Optional["str"]) -> None:
		"""The network address for this node"""
		self._address = value
	@property
	def id_(self) -> Optional["str"]:
		"""The unique identifier for this node"""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		"""The unique identifier for this node"""
		self._id_ = value
	@property
	def is_load_balancer(self) -> "bool":
		"""If true, this node is solely acting as as load balancer and not otherwise participating in the cluster"""
		return self._is_load_balancer
	@is_load_balancer.setter
	def is_load_balancer(self, value: "bool") -> None:
		"""If true, this node is solely acting as as load balancer and not otherwise participating in the cluster"""
		self._is_load_balancer = value
	@property
	def roles(self) -> "List[Role]":
		"""A list of roles configured for this node"""
		return self._roles
	@roles.setter
	def roles(self, value: "List[Role]") -> None:
		"""A list of roles configured for this node"""
		self._roles = value
	@property
	def is_peaking_only(self) -> "bool":
		"""If true, indicates that that this node is standby only unless a threshold has been exceeded"""
		return self._is_peaking_only
	@is_peaking_only.setter
	def is_peaking_only(self, value: "bool") -> None:
		"""If true, indicates that that this node is standby only unless a threshold has been exceeded"""
		self._is_peaking_only = value
	@property
	def is_cluster_peaking(self) -> "bool":
		"""If true indicates that the cluster has exceeded the resource threshold and peaking nodes have been recruited"""
		return self._is_cluster_peaking
	@is_cluster_peaking.setter
	def is_cluster_peaking(self, value: "bool") -> None:
		"""If true indicates that the cluster has exceeded the resource threshold and peaking nodes have been recruited"""
		self._is_cluster_peaking = value
	@property
	def boot_step(self) -> Optional["str"]:
		"""Indicates where the node is in its startup sequence"""
		return self._boot_step
	@boot_step.setter
	def boot_step(self, value: Optional["str"]) -> None:
		"""Indicates where the node is in its startup sequence"""
		self._boot_step = value
	@property
	def consensus_role(self) -> Optional["str"]:
		"""Indicates the node's current function within the cluster"""
		return self._consensus_role
	@consensus_role.setter
	def consensus_role(self, value: Optional["str"]) -> None:
		"""Indicates the node's current function within the cluster"""
		self._consensus_role = value
	@property
	def is_available(self) -> "bool":
		"""If false, indicates that the node is currently disabled"""
		return self._is_available
	@is_available.setter
	def is_available(self, value: "bool") -> None:
		"""If false, indicates that the node is currently disabled"""
		self._is_available = value
	@property
	def failed_transaction_count(self) -> "int":
		"""The number of transactions that have failed"""
		return self._failed_transaction_count
	@failed_transaction_count.setter
	def failed_transaction_count(self, value: "int") -> None:
		"""The number of transactions that have failed"""
		self._failed_transaction_count = value
	@property
	def version(self) -> "Version":
		"""Information about the node's software"""
		return self._version
	@version.setter
	def version(self, value: "Version") -> None:
		"""Information about the node's software"""
		self._version = value
	@property
	def hardware(self) -> "HardwareStats":
		"""Information about the hardware that the node is running on"""
		return self._hardware
	@hardware.setter
	def hardware(self, value: "HardwareStats") -> None:
		"""Information about the hardware that the node is running on"""
		self._hardware = value
	@property
	def transaction_waiters(self) -> "ClusterWaiters":
		"""Information about actions that are waiting for transactions to be completed"""
		return self._transaction_waiters
	@transaction_waiters.setter
	def transaction_waiters(self, value: "ClusterWaiters") -> None:
		"""Information about actions that are waiting for transactions to be completed"""
		self._transaction_waiters = value
	@property
	def state_machine(self) -> "StateMachine":
		"""State machine details"""
		return self._state_machine
	@state_machine.setter
	def state_machine(self, value: "StateMachine") -> None:
		"""State machine details"""
		self._state_machine = value
	@property
	def consensus(self) -> "ConsensusInfo":
		"""Cluster participation details"""
		return self._consensus
	@consensus.setter
	def consensus(self, value: "ConsensusInfo") -> None:
		"""Cluster participation details"""
		self._consensus = value
	@property
	def links(self) -> "NodeLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "NodeLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class NodeLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class Notebook:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"path": ("path", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: Optional["str"] = None,
		path: Optional["str"] = None,
	) -> None:
		"""
		:param name:
		:type name: str or None
		:param path:
		:type path: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._path = cast(Optional[str], kwargs.get("path"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._path
	@path.setter
	def path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path = value
class NumberRange:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"min_": ("min", "float", None),
		"max_": ("max", "float", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		min_: "float",
		max_: "float",
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param min_:
		:type min_: float
		:param max_:
		:type max_: float
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._min_ = cast(float, kwargs.get("min_"))
		self._max_ = cast(float, kwargs.get("max_"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def min_(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._min_
	@min_.setter
	def min_(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._min_ = value
	@property
	def max_(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._max_
	@max_.setter
	def max_(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._max_ = value
class OgcAttribute:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"column_name": ("columnName", "str", None),
		"column_type": ("columnType", "str", None),
		"row_count": ("rowCount", "int", None),
		"is_geographic": ("isGeographic", "bool", None),
		"dimension_data": ("dimensionData", "DimensionalData", None),
		"source_ogc_feature": ("SourceOgcFeature", "OgcFeature", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		row_count: "int",
		is_geographic: "bool",
		dimension_data: "DimensionalData",
		source_ogc_feature: "OgcFeature",
		column_name: Optional["str"] = None,
		column_type: Optional["str"] = None,
	) -> None:
		"""
		:param row_count:
		:type row_count: int
		:param is_geographic:
		:type is_geographic: bool
		:param dimension_data:
		:type dimension_data: DimensionalData
		:param source_ogc_feature:
		:type source_ogc_feature: OgcFeature
		:param column_name:
		:type column_name: str or None
		:param column_type:
		:type column_type: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._column_name = cast(Optional[str], kwargs.get("column_name"))
		self._column_type = cast(Optional[str], kwargs.get("column_type"))
		self._row_count = cast(int, kwargs.get("row_count"))
		self._is_geographic = cast(bool, kwargs.get("is_geographic"))
		self._dimension_data = cast(DimensionalData, kwargs.get("dimension_data"))
		self._source_ogc_feature = cast(OgcFeature, kwargs.get("source_ogc_feature"))
	@property
	def column_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._column_name
	@column_name.setter
	def column_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column_name = value
	@property
	def column_type(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._column_type
	@column_type.setter
	def column_type(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column_type = value
	@property
	def row_count(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._row_count
	@row_count.setter
	def row_count(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._row_count = value
	@property
	def is_geographic(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_geographic
	@is_geographic.setter
	def is_geographic(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_geographic = value
	@property
	def dimension_data(self) -> "DimensionalData":
		# pylint: disable=missing-function-docstring
		return self._dimension_data
	@dimension_data.setter
	def dimension_data(self, value: "DimensionalData") -> None:
		# pylint: disable=missing-function-docstring
		self._dimension_data = value
	@property
	def source_ogc_feature(self) -> "OgcFeature":
		# pylint: disable=missing-function-docstring
		return self._source_ogc_feature
	@source_ogc_feature.setter
	def source_ogc_feature(self, value: "OgcFeature") -> None:
		# pylint: disable=missing-function-docstring
		self._source_ogc_feature = value
class OgcBoundingBox:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"center_x": ("centerX", "float", None),
		"center_y": ("centerY", "float", None),
		"half_x": ("halfX", "float", None),
		"half_y": ("halfY", "float", None),
		"min_x": ("minX", "float", None),
		"max_x": ("maxX", "float", None),
		"min_y": ("minY", "float", None),
		"max_y": ("maxY", "float", None),
		"projection_urn": ("projectionUrn", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		center_x: "float",
		center_y: "float",
		half_x: "float",
		half_y: "float",
		min_x: "float",
		max_x: "float",
		min_y: "float",
		max_y: "float",
		projection_urn: Optional["str"] = None,
	) -> None:
		"""
		:param center_x:
		:type center_x: float
		:param center_y:
		:type center_y: float
		:param half_x:
		:type half_x: float
		:param half_y:
		:type half_y: float
		:param min_x:
		:type min_x: float
		:param max_x:
		:type max_x: float
		:param min_y:
		:type min_y: float
		:param max_y:
		:type max_y: float
		:param projection_urn:
		:type projection_urn: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._center_x = cast(float, kwargs.get("center_x"))
		self._center_y = cast(float, kwargs.get("center_y"))
		self._half_x = cast(float, kwargs.get("half_x"))
		self._half_y = cast(float, kwargs.get("half_y"))
		self._min_x = cast(float, kwargs.get("min_x"))
		self._max_x = cast(float, kwargs.get("max_x"))
		self._min_y = cast(float, kwargs.get("min_y"))
		self._max_y = cast(float, kwargs.get("max_y"))
		self._projection_urn = cast(Optional[str], kwargs.get("projection_urn"))
	@property
	def center_x(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._center_x
	@center_x.setter
	def center_x(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._center_x = value
	@property
	def center_y(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._center_y
	@center_y.setter
	def center_y(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._center_y = value
	@property
	def half_x(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._half_x
	@half_x.setter
	def half_x(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._half_x = value
	@property
	def half_y(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._half_y
	@half_y.setter
	def half_y(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._half_y = value
	@property
	def min_x(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._min_x
	@min_x.setter
	def min_x(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._min_x = value
	@property
	def max_x(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._max_x
	@max_x.setter
	def max_x(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._max_x = value
	@property
	def min_y(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._min_y
	@min_y.setter
	def min_y(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._min_y = value
	@property
	def max_y(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._max_y
	@max_y.setter
	def max_y(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._max_y = value
	@property
	def projection_urn(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._projection_urn
	@projection_urn.setter
	def projection_urn(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._projection_urn = value
class OgcColumnPair:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"map_large_column": ("mapLargeColumn", "str", None),
		"ogc_column": ("ogcColumn", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		map_large_column: Optional["str"] = None,
		ogc_column: Optional["str"] = None,
	) -> None:
		"""
		:param map_large_column:
		:type map_large_column: str or None
		:param ogc_column:
		:type ogc_column: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._map_large_column = cast(Optional[str], kwargs.get("map_large_column"))
		self._ogc_column = cast(Optional[str], kwargs.get("ogc_column"))
	@property
	def map_large_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._map_large_column
	@map_large_column.setter
	def map_large_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._map_large_column = value
	@property
	def ogc_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._ogc_column
	@ogc_column.setter
	def ogc_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._ogc_column = value
class OgcFeature:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"bounding_box": ("boundingBox", "OgcBoundingBox", None),
		"tag": ("tag", "OgcPublishTag", None),
		"crs": ("crs", "str", None),
		"dimensions": ("dimensions", "list", "DimensionalData"),
		"feature_attributes": ("featureAttributes", "list", "OgcAttribute"),
		"column_mapping": ("columnMapping", "list", "OgcColumnPair"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		bounding_box: "OgcBoundingBox",
		tag: "OgcPublishTag",
		dimensions: "List[DimensionalData]",
		feature_attributes: "List[OgcAttribute]",
		column_mapping: "List[OgcColumnPair]",
		crs: Optional["str"] = None,
	) -> None:
		"""
		:param bounding_box:
		:type bounding_box: OgcBoundingBox
		:param tag:
		:type tag: OgcPublishTag
		:param dimensions:
		:type dimensions: List[DimensionalData]
		:param feature_attributes:
		:type feature_attributes: List[OgcAttribute]
		:param column_mapping:
		:type column_mapping: List[OgcColumnPair]
		:param crs:
		:type crs: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._bounding_box = cast(OgcBoundingBox, kwargs.get("bounding_box"))
		self._tag = cast(OgcPublishTag, kwargs.get("tag"))
		self._crs = cast(Optional[str], kwargs.get("crs"))
		self._dimensions = cast(List[DimensionalData], kwargs.get("dimensions"))
		self._feature_attributes = cast(List[OgcAttribute], kwargs.get("feature_attributes"))
		self._column_mapping = cast(List[OgcColumnPair], kwargs.get("column_mapping"))
	@property
	def bounding_box(self) -> "OgcBoundingBox":
		# pylint: disable=missing-function-docstring
		return self._bounding_box
	@bounding_box.setter
	def bounding_box(self, value: "OgcBoundingBox") -> None:
		# pylint: disable=missing-function-docstring
		self._bounding_box = value
	@property
	def tag(self) -> "OgcPublishTag":
		# pylint: disable=missing-function-docstring
		return self._tag
	@tag.setter
	def tag(self, value: "OgcPublishTag") -> None:
		# pylint: disable=missing-function-docstring
		self._tag = value
	@property
	def crs(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._crs
	@crs.setter
	def crs(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._crs = value
	@property
	def dimensions(self) -> "List[DimensionalData]":
		# pylint: disable=missing-function-docstring
		return self._dimensions
	@dimensions.setter
	def dimensions(self, value: "List[DimensionalData]") -> None:
		# pylint: disable=missing-function-docstring
		self._dimensions = value
	@property
	def feature_attributes(self) -> "List[OgcAttribute]":
		# pylint: disable=missing-function-docstring
		return self._feature_attributes
	@feature_attributes.setter
	def feature_attributes(self, value: "List[OgcAttribute]") -> None:
		# pylint: disable=missing-function-docstring
		self._feature_attributes = value
	@property
	def column_mapping(self) -> "List[OgcColumnPair]":
		# pylint: disable=missing-function-docstring
		return self._column_mapping
	@column_mapping.setter
	def column_mapping(self, value: "List[OgcColumnPair]") -> None:
		# pylint: disable=missing-function-docstring
		self._column_mapping = value
class OgcPublishTag:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"type_": ("type", "str", None),
		"name": ("name", "str", None),
		"title": ("title", "str", None),
		"description": ("description", "str", None),
		"group": ("group", "str", None),
		"data_source": ("dataSource", "str", None),
		"strip_filters": ("stripFilters", "bool", None),
		"default_filters": ("defaultFilters", "list", "FilterNode"),
		"active": ("active", "bool", None),
		"time_column": ("timeColumn", "DimensionalData", None),
		"elevation_column": ("elevationColumn", "DimensionalData", None),
		"dimension_settings": ("dimensionSettings", "dict", "DimensionalData"),
		"auto_update": ("autoUpdate", "bool", None),
		"max_stat_age": ("maxStatAge", "str", None),
		"use_column_labels": ("useColumnLabels", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		strip_filters: "bool",
		default_filters: "List[FilterNode]",
		active: "bool",
		time_column: "DimensionalData",
		elevation_column: "DimensionalData",
		dimension_settings: "Dict[str, DimensionalData]",
		type_: Optional["str"] = None,
		name: Optional["str"] = None,
		title: Optional["str"] = None,
		description: Optional["str"] = None,
		group: Optional["str"] = None,
		data_source: Optional["str"] = None,
		auto_update: Optional["bool"] = None,
		max_stat_age: Optional["str"] = None,
		use_column_labels: Optional["bool"] = None,
	) -> None:
		"""
		:param strip_filters:
		:type strip_filters: bool
		:param default_filters:
		:type default_filters: List[FilterNode]
		:param active:
		:type active: bool
		:param time_column:
		:type time_column: DimensionalData
		:param elevation_column:
		:type elevation_column: DimensionalData
		:param dimension_settings:
		:type dimension_settings: Dict[str, DimensionalData]
		:param type_:
		:type type_: str or None
		:param name:
		:type name: str or None
		:param title:
		:type title: str or None
		:param description:
		:type description: str or None
		:param group:
		:type group: str or None
		:param data_source:
		:type data_source: str or None
		:param auto_update:
		:type auto_update: bool or None
		:param max_stat_age:
		:type max_stat_age: str or None
		:param use_column_labels:
		:type use_column_labels: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._title = cast(Optional[str], kwargs.get("title"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._group = cast(Optional[str], kwargs.get("group"))
		self._data_source = cast(Optional[str], kwargs.get("data_source"))
		self._strip_filters = cast(bool, kwargs.get("strip_filters"))
		self._default_filters = cast(List[FilterNode], kwargs.get("default_filters"))
		self._active = cast(bool, kwargs.get("active"))
		self._time_column = cast(DimensionalData, kwargs.get("time_column"))
		self._elevation_column = cast(DimensionalData, kwargs.get("elevation_column"))
		self._dimension_settings = cast(Dict[str, DimensionalData], kwargs.get("dimension_settings"))
		self._auto_update = cast(Optional[bool], kwargs.get("auto_update"))
		self._max_stat_age = cast(Optional[str], kwargs.get("max_stat_age"))
		self._use_column_labels = cast(Optional[bool], kwargs.get("use_column_labels"))
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def title(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._title
	@title.setter
	def title(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._title = value
	@property
	def description(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._description = value
	@property
	def group(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._group
	@group.setter
	def group(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._group = value
	@property
	def data_source(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._data_source
	@data_source.setter
	def data_source(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._data_source = value
	@property
	def strip_filters(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._strip_filters
	@strip_filters.setter
	def strip_filters(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._strip_filters = value
	@property
	def default_filters(self) -> "List[FilterNode]":
		# pylint: disable=missing-function-docstring
		return self._default_filters
	@default_filters.setter
	def default_filters(self, value: "List[FilterNode]") -> None:
		# pylint: disable=missing-function-docstring
		self._default_filters = value
	@property
	def active(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._active
	@active.setter
	def active(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._active = value
	@property
	def time_column(self) -> "DimensionalData":
		# pylint: disable=missing-function-docstring
		return self._time_column
	@time_column.setter
	def time_column(self, value: "DimensionalData") -> None:
		# pylint: disable=missing-function-docstring
		self._time_column = value
	@property
	def elevation_column(self) -> "DimensionalData":
		# pylint: disable=missing-function-docstring
		return self._elevation_column
	@elevation_column.setter
	def elevation_column(self, value: "DimensionalData") -> None:
		# pylint: disable=missing-function-docstring
		self._elevation_column = value
	@property
	def dimension_settings(self) -> "Dict[str, DimensionalData]":
		# pylint: disable=missing-function-docstring
		return self._dimension_settings
	@dimension_settings.setter
	def dimension_settings(self, value: "Dict[str, DimensionalData]") -> None:
		# pylint: disable=missing-function-docstring
		self._dimension_settings = value
	@property
	def auto_update(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._auto_update
	@auto_update.setter
	def auto_update(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._auto_update = value
	@property
	def max_stat_age(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._max_stat_age
	@max_stat_age.setter
	def max_stat_age(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_stat_age = value
	@property
	def use_column_labels(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._use_column_labels
	@use_column_labels.setter
	def use_column_labels(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._use_column_labels = value
class OllamaChatResponse:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"model": ("model", "str", None),
		"created_at": ("created_at", "str", None),
		"done": ("done", "bool", None),
		"message": ("message", "OllamaChatResponseMessage", None),
		"total_duration": ("total_duration", "int", None),
		"load_duration": ("load_duration", "int", None),
		"prompt_eval_count": ("prompt_eval_count", "int", None),
		"prompt_eval_duration": ("prompt_eval_duration", "int", None),
		"eval_count": ("eval_count", "int", None),
		"eval_duration": ("eval_duration", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		message: "OllamaChatResponseMessage",
		model: Optional["str"] = None,
		created_at: Optional["str"] = None,
		done: Optional["bool"] = None,
		total_duration: Optional["int"] = None,
		load_duration: Optional["int"] = None,
		prompt_eval_count: Optional["int"] = None,
		prompt_eval_duration: Optional["int"] = None,
		eval_count: Optional["int"] = None,
		eval_duration: Optional["int"] = None,
	) -> None:
		"""
		:param message:
		:type message: OllamaChatResponseMessage
		:param model:
		:type model: str or None
		:param created_at:
		:type created_at: str or None
		:param done:
		:type done: bool or None
		:param total_duration:
		:type total_duration: int or None
		:param load_duration:
		:type load_duration: int or None
		:param prompt_eval_count:
		:type prompt_eval_count: int or None
		:param prompt_eval_duration:
		:type prompt_eval_duration: int or None
		:param eval_count:
		:type eval_count: int or None
		:param eval_duration:
		:type eval_duration: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._model = cast(Optional[str], kwargs.get("model"))
		self._created_at = cast(Optional[str], kwargs.get("created_at"))
		self._done = cast(Optional[bool], kwargs.get("done"))
		self._message = cast(OllamaChatResponseMessage, kwargs.get("message"))
		self._total_duration = cast(Optional[int], kwargs.get("total_duration"))
		self._load_duration = cast(Optional[int], kwargs.get("load_duration"))
		self._prompt_eval_count = cast(Optional[int], kwargs.get("prompt_eval_count"))
		self._prompt_eval_duration = cast(Optional[int], kwargs.get("prompt_eval_duration"))
		self._eval_count = cast(Optional[int], kwargs.get("eval_count"))
		self._eval_duration = cast(Optional[int], kwargs.get("eval_duration"))
	@property
	def model(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._model
	@model.setter
	def model(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._model = value
	@property
	def created_at(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._created_at
	@created_at.setter
	def created_at(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._created_at = value
	@property
	def done(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._done
	@done.setter
	def done(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._done = value
	@property
	def message(self) -> "OllamaChatResponseMessage":
		# pylint: disable=missing-function-docstring
		return self._message
	@message.setter
	def message(self, value: "OllamaChatResponseMessage") -> None:
		# pylint: disable=missing-function-docstring
		self._message = value
	@property
	def total_duration(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._total_duration
	@total_duration.setter
	def total_duration(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._total_duration = value
	@property
	def load_duration(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._load_duration
	@load_duration.setter
	def load_duration(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._load_duration = value
	@property
	def prompt_eval_count(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._prompt_eval_count
	@prompt_eval_count.setter
	def prompt_eval_count(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._prompt_eval_count = value
	@property
	def prompt_eval_duration(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._prompt_eval_duration
	@prompt_eval_duration.setter
	def prompt_eval_duration(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._prompt_eval_duration = value
	@property
	def eval_count(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._eval_count
	@eval_count.setter
	def eval_count(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._eval_count = value
	@property
	def eval_duration(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._eval_duration
	@eval_duration.setter
	def eval_duration(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._eval_duration = value
class OllamaChatResponseMessage:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"role": ("role", "str", None),
		"content": ("content", "str", None),
		"images": ("images", "list", "str"),
		"tool_calls": ("tool_calls", "list", "OllamaChatResponseToolCall"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		images: "List[str]",
		tool_calls: "List[OllamaChatResponseToolCall]",
		role: Optional["str"] = None,
		content: Optional["str"] = None,
	) -> None:
		"""
		:param images:
		:type images: List[str]
		:param tool_calls:
		:type tool_calls: List[OllamaChatResponseToolCall]
		:param role:
		:type role: str or None
		:param content:
		:type content: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._role = cast(Optional[str], kwargs.get("role"))
		self._content = cast(Optional[str], kwargs.get("content"))
		self._images = cast(List[str], kwargs.get("images"))
		self._tool_calls = cast(List[OllamaChatResponseToolCall], kwargs.get("tool_calls"))
	@property
	def role(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._role
	@role.setter
	def role(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._role = value
	@property
	def content(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._content
	@content.setter
	def content(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._content = value
	@property
	def images(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._images
	@images.setter
	def images(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._images = value
	@property
	def tool_calls(self) -> "List[OllamaChatResponseToolCall]":
		# pylint: disable=missing-function-docstring
		return self._tool_calls
	@tool_calls.setter
	def tool_calls(self, value: "List[OllamaChatResponseToolCall]") -> None:
		# pylint: disable=missing-function-docstring
		self._tool_calls = value
class OllamaChatResponseToolCall:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"function": ("function", "OllamaChatResponseToolCallFunction", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		function: "OllamaChatResponseToolCallFunction",
	) -> None:
		"""
		:param function:
		:type function: OllamaChatResponseToolCallFunction
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._function = cast(OllamaChatResponseToolCallFunction, kwargs.get("function"))
	@property
	def function(self) -> "OllamaChatResponseToolCallFunction":
		# pylint: disable=missing-function-docstring
		return self._function
	@function.setter
	def function(self, value: "OllamaChatResponseToolCallFunction") -> None:
		# pylint: disable=missing-function-docstring
		self._function = value
class OllamaChatResponseToolCallFunction:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"arguments": ("arguments", "dict", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		arguments: "Dict[str, str]",
		name: Optional["str"] = None,
	) -> None:
		"""
		:param arguments:
		:type arguments: Dict[str, str]
		:param name:
		:type name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._arguments = cast(Dict[str, str], kwargs.get("arguments"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def arguments(self) -> "Dict[str, str]":
		# pylint: disable=missing-function-docstring
		return self._arguments
	@arguments.setter
	def arguments(self, value: "Dict[str, str]") -> None:
		# pylint: disable=missing-function-docstring
		self._arguments = value
class OnboardingLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"result": ("result", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
		result: Optional["Link"] = None,
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		:param result: When the onboarding is complete, the results (either a list of tables, or an error) will be available at this link.
		:type result: Link or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._result = cast(Optional[Link], kwargs.get("result"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def result(self) -> Optional["Link"]:
		"""When the onboarding is complete, the results (either a list of tables, or an error) will be available at this link."""
		return self._result
	@result.setter
	def result(self, value: Optional["Link"]) -> None:
		"""When the onboarding is complete, the results (either a list of tables, or an error) will be available at this link."""
		self._result = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value


class OnboardingMode(str, Enum):
	# pylint: disable=missing-class-docstring
	FILESYSTEM = 'Filesystem'
	INTERCLUSTER = 'Intercluster'
	LOCAL_DB = 'LocalDB'

class OnboardingRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"mode": ("mode", "OnboardingMode", None),
		"parallel_factor": ("parallelFactor", "int", None),
		"source_db_path": ("sourceDBPath", "str", None),
		"source_map_large_uri": ("sourceMapLargeURI", "str", None),
		"user_name": ("userName", "str", None),
		"password": ("password", "str", None),
		"rules": ("rules", "list", "OnboardingRule"),
		"latest_table_version_only": ("latestTableVersionOnly", "bool", None),
		"links": ("links", "OnboardingLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		mode: "OnboardingMode",
		parallel_factor: "int",
		rules: "List[OnboardingRule]",
		latest_table_version_only: "bool",
		links: "OnboardingLinks",
		source_db_path: Optional["str"] = None,
		source_map_large_uri: Optional["str"] = None,
		user_name: Optional["str"] = None,
		password: Optional["str"] = None,
	) -> None:
		"""
		:param mode: The physical transport to be used for the migration. Supported modes are currently "Filesystem" and "Intercluster".
		:type mode: OnboardingMode
		:param parallel_factor: If set to a value larger than 1, determines how many tables are migrated in parallel.
		:type parallel_factor: int
		:param rules: The list of rules for including and excluding tables and their relevant tags for the onboarding process.
		:type rules: List[OnboardingRule]
		:param latest_table_version_only: If true (the default), only the latest version of each selected table will be enqueued for onboarding.
		:type latest_table_version_only: bool
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: OnboardingLinks
		:param source_db_path: The filesystem path which contains the source Database directory. Relevant to the "Filesystem" transfer mode.
		:type source_db_path: str or None
		:param source_map_large_uri: The HTTP(S) URI used to connect to the running remote maplarge cluster. Relevant to the "Intercluster" transfer mode.
		:type source_map_large_uri: str or None
		:param user_name: The MapLarge user name to authenticate the onboarding process. Relevant to the "Intercluster" transfer mode.
		:type user_name: str or None
		:param password: The MapLarge password used to authenticate the onboarding process. Relevant to the "Intercluster" transfer mode.
		:type password: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._mode = cast(OnboardingMode, kwargs.get("mode"))
		self._parallel_factor = cast(int, kwargs.get("parallel_factor"))
		self._source_db_path = cast(Optional[str], kwargs.get("source_db_path"))
		self._source_map_large_uri = cast(Optional[str], kwargs.get("source_map_large_uri"))
		self._user_name = cast(Optional[str], kwargs.get("user_name"))
		self._password = cast(Optional[str], kwargs.get("password"))
		self._rules = cast(List[OnboardingRule], kwargs.get("rules"))
		self._latest_table_version_only = cast(bool, kwargs.get("latest_table_version_only"))
		self._links = cast(OnboardingLinks, kwargs.get("links"))
	@property
	def mode(self) -> "OnboardingMode":
		"""The physical transport to be used for the migration. Supported modes are currently "Filesystem" and "Intercluster"."""
		return self._mode
	@mode.setter
	def mode(self, value: "OnboardingMode") -> None:
		"""The physical transport to be used for the migration. Supported modes are currently "Filesystem" and "Intercluster"."""
		self._mode = value
	@property
	def parallel_factor(self) -> "int":
		"""If set to a value larger than 1, determines how many tables are migrated in parallel."""
		return self._parallel_factor
	@parallel_factor.setter
	def parallel_factor(self, value: "int") -> None:
		"""If set to a value larger than 1, determines how many tables are migrated in parallel."""
		self._parallel_factor = value
	@property
	def source_db_path(self) -> Optional["str"]:
		"""The filesystem path which contains the source Database directory. Relevant to the "Filesystem" transfer mode."""
		return self._source_db_path
	@source_db_path.setter
	def source_db_path(self, value: Optional["str"]) -> None:
		"""The filesystem path which contains the source Database directory. Relevant to the "Filesystem" transfer mode."""
		self._source_db_path = value
	@property
	def source_map_large_uri(self) -> Optional["str"]:
		"""The HTTP(S) URI used to connect to the running remote maplarge cluster. Relevant to the "Intercluster" transfer mode."""
		return self._source_map_large_uri
	@source_map_large_uri.setter
	def source_map_large_uri(self, value: Optional["str"]) -> None:
		"""The HTTP(S) URI used to connect to the running remote maplarge cluster. Relevant to the "Intercluster" transfer mode."""
		self._source_map_large_uri = value
	@property
	def user_name(self) -> Optional["str"]:
		"""The MapLarge user name to authenticate the onboarding process. Relevant to the "Intercluster" transfer mode."""
		return self._user_name
	@user_name.setter
	def user_name(self, value: Optional["str"]) -> None:
		"""The MapLarge user name to authenticate the onboarding process. Relevant to the "Intercluster" transfer mode."""
		self._user_name = value
	@property
	def password(self) -> Optional["str"]:
		"""The MapLarge password used to authenticate the onboarding process. Relevant to the "Intercluster" transfer mode."""
		return self._password
	@password.setter
	def password(self, value: Optional["str"]) -> None:
		"""The MapLarge password used to authenticate the onboarding process. Relevant to the "Intercluster" transfer mode."""
		self._password = value
	@property
	def rules(self) -> "List[OnboardingRule]":
		"""The list of rules for including and excluding tables and their relevant tags for the onboarding process."""
		return self._rules
	@rules.setter
	def rules(self, value: "List[OnboardingRule]") -> None:
		"""The list of rules for including and excluding tables and their relevant tags for the onboarding process."""
		self._rules = value
	@property
	def latest_table_version_only(self) -> "bool":
		"""If true (the default), only the latest version of each selected table will be enqueued for onboarding."""
		return self._latest_table_version_only
	@latest_table_version_only.setter
	def latest_table_version_only(self, value: "bool") -> None:
		"""If true (the default), only the latest version of each selected table will be enqueued for onboarding."""
		self._latest_table_version_only = value
	@property
	def links(self) -> "OnboardingLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "OnboardingLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class OnboardingResponse:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"is_running": ("isRunning", "bool", None),
		"tables_completed": ("tablesCompleted", "list", "TableResult"),
		"table_errors": ("tableErrors", "list", "TableError"),
		"tables_in_progress": ("tablesInProgress", "list", "str"),
		"percent_complete": ("percentComplete", "int", None),
		"global_error": ("globalError", "str", None),
		"status": ("status", "OnboardingStatus", None),
		"links": ("links", "OnboardingLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		is_running: "bool",
		tables_completed: "List[TableResult]",
		table_errors: "List[TableError]",
		tables_in_progress: "List[str]",
		percent_complete: "int",
		status: "OnboardingStatus",
		links: "OnboardingLinks",
		id_: Optional["str"] = None,
		global_error: Optional["str"] = None,
	) -> None:
		"""
		:param is_running: True if the onboarding process is current running.
		:type is_running: bool
		:param tables_completed: A list of tables which have finished onboarding successfully.
		:type tables_completed: List[TableResult]
		:param table_errors: A list of tables which have failed to onboard, with reasons.
		:type table_errors: List[TableError]
		:param tables_in_progress: A list of tables which are currently being onboarded.
		:type tables_in_progress: List[str]
		:param percent_complete: Percentage of tables and preliminary work items (such as tag migration) which have finished.
		:type percent_complete: int
		:param status: Current status of the onboarding request.
		:type status: OnboardingStatus
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: OnboardingLinks
		:param id_: Unique identifier of the onboarding process.
		:type id_: str or None
		:param global_error: If the overall onboarding process has failed, this property will be populated with the relevant error message.
		:type global_error: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._is_running = cast(bool, kwargs.get("is_running"))
		self._tables_completed = cast(List[TableResult], kwargs.get("tables_completed"))
		self._table_errors = cast(List[TableError], kwargs.get("table_errors"))
		self._tables_in_progress = cast(List[str], kwargs.get("tables_in_progress"))
		self._percent_complete = cast(int, kwargs.get("percent_complete"))
		self._global_error = cast(Optional[str], kwargs.get("global_error"))
		self._status = cast(OnboardingStatus, kwargs.get("status"))
		self._links = cast(OnboardingLinks, kwargs.get("links"))
	@property
	def id_(self) -> Optional["str"]:
		"""Unique identifier of the onboarding process."""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		"""Unique identifier of the onboarding process."""
		self._id_ = value
	@property
	def is_running(self) -> "bool":
		"""True if the onboarding process is current running."""
		return self._is_running
	@is_running.setter
	def is_running(self, value: "bool") -> None:
		"""True if the onboarding process is current running."""
		self._is_running = value
	@property
	def tables_completed(self) -> "List[TableResult]":
		"""A list of tables which have finished onboarding successfully."""
		return self._tables_completed
	@tables_completed.setter
	def tables_completed(self, value: "List[TableResult]") -> None:
		"""A list of tables which have finished onboarding successfully."""
		self._tables_completed = value
	@property
	def table_errors(self) -> "List[TableError]":
		"""A list of tables which have failed to onboard, with reasons."""
		return self._table_errors
	@table_errors.setter
	def table_errors(self, value: "List[TableError]") -> None:
		"""A list of tables which have failed to onboard, with reasons."""
		self._table_errors = value
	@property
	def tables_in_progress(self) -> "List[str]":
		"""A list of tables which are currently being onboarded."""
		return self._tables_in_progress
	@tables_in_progress.setter
	def tables_in_progress(self, value: "List[str]") -> None:
		"""A list of tables which are currently being onboarded."""
		self._tables_in_progress = value
	@property
	def percent_complete(self) -> "int":
		"""Percentage of tables and preliminary work items (such as tag migration) which have finished."""
		return self._percent_complete
	@percent_complete.setter
	def percent_complete(self, value: "int") -> None:
		"""Percentage of tables and preliminary work items (such as tag migration) which have finished."""
		self._percent_complete = value
	@property
	def global_error(self) -> Optional["str"]:
		"""If the overall onboarding process has failed, this property will be populated with the relevant error message."""
		return self._global_error
	@global_error.setter
	def global_error(self, value: Optional["str"]) -> None:
		"""If the overall onboarding process has failed, this property will be populated with the relevant error message."""
		self._global_error = value
	@property
	def status(self) -> "OnboardingStatus":
		"""Current status of the onboarding request."""
		return self._status
	@status.setter
	def status(self, value: "OnboardingStatus") -> None:
		"""Current status of the onboarding request."""
		self._status = value
	@property
	def links(self) -> "OnboardingLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "OnboardingLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class OnboardingRule:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("Account", "str", None),
		"table": ("Table", "str", None),
		"target_account": ("TargetAccount", "str", None),
		"target_table": ("TargetTable", "str", None),
		"should_onboard": ("ShouldOnboard", "bool", None),
		"include_tags": ("IncludeTags", "list", "str"),
		"exclude_tags": ("ExcludeTags", "list", "str"),
		"filter_expression": ("FilterExpression", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		should_onboard: "bool",
		include_tags: "List[str]",
		exclude_tags: "List[str]",
		account: Optional["str"] = None,
		table: Optional["str"] = None,
		target_account: Optional["str"] = None,
		target_table: Optional["str"] = None,
		filter_expression: Optional["str"] = None,
	) -> None:
		"""
		:param should_onboard: True if the table should be included in onboarding, false otherwise.  Defaults to true.
		:type should_onboard: bool
		:param include_tags: List of tags to onboard for this table.  Can include wildcards (*).
		:type include_tags: List[str]
		:param exclude_tags: List of tags to exclude from onboarding for this table.  Can include wildcards (*).
		:type exclude_tags: List[str]
		:param account: The original account code of the table to be onboarded. Can include wildcards (*).
		:type account: str or None
		:param table: The original table name for the table to be onboarded. Can include wildcards (*).
		:type table: str or None
		:param target_account: The final account code of the table to be onboarded.  Can include substitutions {1}..{n} corresponding to wildcards in Account.
		:type target_account: str or None
		:param target_table: The final name of the table to be onboarded.  Can include substitutions {1}..{n} corresponding to wildcards in Table.
		:type target_table: str or None
		:param filter_expression: A filter query expression determining which records are transferred to the target table.
		:type filter_expression: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._account = cast(Optional[str], kwargs.get("account"))
		self._table = cast(Optional[str], kwargs.get("table"))
		self._target_account = cast(Optional[str], kwargs.get("target_account"))
		self._target_table = cast(Optional[str], kwargs.get("target_table"))
		self._should_onboard = cast(bool, kwargs.get("should_onboard"))
		self._include_tags = cast(List[str], kwargs.get("include_tags"))
		self._exclude_tags = cast(List[str], kwargs.get("exclude_tags"))
		self._filter_expression = cast(Optional[str], kwargs.get("filter_expression"))
	@property
	def account(self) -> Optional["str"]:
		"""The original account code of the table to be onboarded. Can include wildcards (*)."""
		return self._account
	@account.setter
	def account(self, value: Optional["str"]) -> None:
		"""The original account code of the table to be onboarded. Can include wildcards (*)."""
		self._account = value
	@property
	def table(self) -> Optional["str"]:
		"""The original table name for the table to be onboarded. Can include wildcards (*)."""
		return self._table
	@table.setter
	def table(self, value: Optional["str"]) -> None:
		"""The original table name for the table to be onboarded. Can include wildcards (*)."""
		self._table = value
	@property
	def target_account(self) -> Optional["str"]:
		"""The final account code of the table to be onboarded.  Can include substitutions {1}..{n} corresponding to wildcards in Account."""
		return self._target_account
	@target_account.setter
	def target_account(self, value: Optional["str"]) -> None:
		"""The final account code of the table to be onboarded.  Can include substitutions {1}..{n} corresponding to wildcards in Account."""
		self._target_account = value
	@property
	def target_table(self) -> Optional["str"]:
		"""The final name of the table to be onboarded.  Can include substitutions {1}..{n} corresponding to wildcards in Table."""
		return self._target_table
	@target_table.setter
	def target_table(self, value: Optional["str"]) -> None:
		"""The final name of the table to be onboarded.  Can include substitutions {1}..{n} corresponding to wildcards in Table."""
		self._target_table = value
	@property
	def should_onboard(self) -> "bool":
		"""True if the table should be included in onboarding, false otherwise.  Defaults to true."""
		return self._should_onboard
	@should_onboard.setter
	def should_onboard(self, value: "bool") -> None:
		"""True if the table should be included in onboarding, false otherwise.  Defaults to true."""
		self._should_onboard = value
	@property
	def include_tags(self) -> "List[str]":
		"""List of tags to onboard for this table.  Can include wildcards (*)."""
		return self._include_tags
	@include_tags.setter
	def include_tags(self, value: "List[str]") -> None:
		"""List of tags to onboard for this table.  Can include wildcards (*)."""
		self._include_tags = value
	@property
	def exclude_tags(self) -> "List[str]":
		"""List of tags to exclude from onboarding for this table.  Can include wildcards (*)."""
		return self._exclude_tags
	@exclude_tags.setter
	def exclude_tags(self, value: "List[str]") -> None:
		"""List of tags to exclude from onboarding for this table.  Can include wildcards (*)."""
		self._exclude_tags = value
	@property
	def filter_expression(self) -> Optional["str"]:
		"""A filter query expression determining which records are transferred to the target table."""
		return self._filter_expression
	@filter_expression.setter
	def filter_expression(self, value: Optional["str"]) -> None:
		"""A filter query expression determining which records are transferred to the target table."""
		self._filter_expression = value


class OnboardingStatus(str, Enum):
	# pylint: disable=missing-class-docstring
	INITIAL = 'Initial'
	IN_PROGRESS = 'InProgress'
	CANCELLING = 'Cancelling'
	CANCELLED = 'Cancelled'
	DONE = 'Done'
	FAULTED = 'Faulted'



class OperationCrsExtentUse(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	BOTH = 'Both'
	INTERSECTION = 'Intersection'
	SMALLEST = 'Smallest'



class OperationStrictMode(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	AUTOMATIC = 'Automatic'
	ON_THE_FLY = 'OnTheFly'
	REQUIRED = 'Required'
	FORCED = 'Forced'
	STRICT = 'Strict'
	PREDEFINED_ONLY = 'PredefinedOnly'
	PREDEFINED = 'Predefined'



class OverlayEngineType(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	BITMAP = 'Bitmap'
	SURFACE = 'Surface'
	GPU = 'GPU'

class PackageDashboardToExport:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"type_": ("type", "PackageResourcesTypes", None),
		"version": ("version", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		type_: "PackageResourcesTypes",
		id_: Optional["str"] = None,
		version: Optional["str"] = None,
	) -> None:
		"""
		:param type_: Resource type
		:type type_: PackageResourcesTypes
		:param id_: Dashboard ID
		:type id_: str or None
		:param version: Specific version number of the dashboard
		:type version: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._type_ = cast(PackageResourcesTypes, kwargs.get("type_"))
		self._version = cast(Optional[str], kwargs.get("version"))
	@property
	def id_(self) -> Optional["str"]:
		"""Dashboard ID"""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		"""Dashboard ID"""
		self._id_ = value
	@property
	def type_(self) -> "PackageResourcesTypes":
		"""Resource type"""
		return self._type_
	@type_.setter
	def type_(self, value: "PackageResourcesTypes") -> None:
		"""Resource type"""
		self._type_ = value
	@property
	def version(self) -> Optional["str"]:
		"""Specific version number of the dashboard"""
		return self._version
	@version.setter
	def version(self, value: Optional["str"]) -> None:
		"""Specific version number of the dashboard"""
		self._version = value
class PackageExportTableInterClusterConfig:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"source_account": ("sourceAccount", "str", None),
		"source_table": ("sourceTable", "str", None),
		"sync_modes": ("syncModes", "str", None),
		"source_server": ("sourceServer", "str", None),
		"source_server_username": ("sourceServerUsername", "str", None),
		"source_server_password": ("sourceServerPassword", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		source_account: Optional["str"] = None,
		source_table: Optional["str"] = None,
		sync_modes: Optional["str"] = None,
		source_server: Optional["str"] = None,
		source_server_username: Optional["str"] = None,
		source_server_password: Optional["str"] = None,
	) -> None:
		"""
		:param source_account:
		:type source_account: str or None
		:param source_table:
		:type source_table: str or None
		:param sync_modes:
		:type sync_modes: str or None
		:param source_server:
		:type source_server: str or None
		:param source_server_username:
		:type source_server_username: str or None
		:param source_server_password:
		:type source_server_password: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._source_account = cast(Optional[str], kwargs.get("source_account"))
		self._source_table = cast(Optional[str], kwargs.get("source_table"))
		self._sync_modes = cast(Optional[str], kwargs.get("sync_modes"))
		self._source_server = cast(Optional[str], kwargs.get("source_server"))
		self._source_server_username = cast(Optional[str], kwargs.get("source_server_username"))
		self._source_server_password = cast(Optional[str], kwargs.get("source_server_password"))
	@property
	def source_account(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._source_account
	@source_account.setter
	def source_account(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._source_account = value
	@property
	def source_table(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._source_table
	@source_table.setter
	def source_table(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._source_table = value
	@property
	def sync_modes(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._sync_modes
	@sync_modes.setter
	def sync_modes(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._sync_modes = value
	@property
	def source_server(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._source_server
	@source_server.setter
	def source_server(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._source_server = value
	@property
	def source_server_username(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._source_server_username
	@source_server_username.setter
	def source_server_username(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._source_server_username = value
	@property
	def source_server_password(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._source_server_password
	@source_server_password.setter
	def source_server_password(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._source_server_password = value
class PackageResourcesToExport:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"dashboards": ("dashboards", "list", "PackageDashboardToExport"),
		"tables": ("tables", "list", "PackageTableToExport"),
		"summary": ("Summary", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		dashboards: "List[PackageDashboardToExport]",
		tables: "List[PackageTableToExport]",
		summary: Optional["str"] = None,
	) -> None:
		"""
		:param dashboards: Collection of dashboards to export
		:type dashboards: List[PackageDashboardToExport]
		:param tables: Collection of tables to export
		:type tables: List[PackageTableToExport]
		:param summary:
		:type summary: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._dashboards = cast(List[PackageDashboardToExport], kwargs.get("dashboards"))
		self._tables = cast(List[PackageTableToExport], kwargs.get("tables"))
		self._summary = cast(Optional[str], kwargs.get("summary"))
	@property
	def dashboards(self) -> "List[PackageDashboardToExport]":
		"""Collection of dashboards to export"""
		return self._dashboards
	@dashboards.setter
	def dashboards(self, value: "List[PackageDashboardToExport]") -> None:
		"""Collection of dashboards to export"""
		self._dashboards = value
	@property
	def tables(self) -> "List[PackageTableToExport]":
		"""Collection of tables to export"""
		return self._tables
	@tables.setter
	def tables(self, value: "List[PackageTableToExport]") -> None:
		"""Collection of tables to export"""
		self._tables = value
	@property
	def summary(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._summary
	@summary.setter
	def summary(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._summary = value


class PackageResourcesTypes(str, Enum):
	# pylint: disable=missing-class-docstring
	DASHBOARD = 'Dashboard'
	TABLE = 'Table'



class PackageSources(str, Enum):
	# pylint: disable=missing-class-docstring
	REMOTE_URL = 'RemoteURL'
	HTTP_POST = 'HttpPost'
	VFS = 'VFS'
	LOCAL_PATH = 'LocalPath'



class PackageTableImportIntents(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	REPLACE = 'Replace'
	APPEND = 'Append'

PackageTableImportIntents.NONE.__doc__ = """None"""
PackageTableImportIntents.REPLACE.__doc__ = """Replace"""
PackageTableImportIntents.APPEND.__doc__ = """Append"""


class PackageTableImportTransportMethods(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	FILE = 'File'
	REMOTE_URL = 'RemoteURL'
	INTERCLUSTER = 'Intercluster'

PackageTableImportTransportMethods.NONE.__doc__ = """None"""
PackageTableImportTransportMethods.FILE.__doc__ = """File"""
PackageTableImportTransportMethods.REMOTE_URL.__doc__ = """RemoteURL"""
PackageTableImportTransportMethods.INTERCLUSTER.__doc__ = """Intercluster"""
class PackageTableToExport:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"type_": ("type", "PackageResourcesTypes", None),
		"version": ("version", "str", None),
		"account": ("account", "str", None),
		"table": ("table", "str", None),
		"remote_url": ("remoteUrl", "str", None),
		"transport_method": ("transportMethod", "PackageTableImportTransportMethods", None),
		"import_intent": ("importIntent", "PackageTableImportIntents", None),
		"inter_cluster_config": ("interClusterConfig", "PackageExportTableInterClusterConfig", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		type_: "PackageResourcesTypes",
		account: "str",
		table: "str",
		transport_method: "PackageTableImportTransportMethods",
		import_intent: "PackageTableImportIntents",
		inter_cluster_config: "PackageExportTableInterClusterConfig",
		version: Optional["str"] = None,
		remote_url: Optional["str"] = None,
	) -> None:
		"""
		:param type_: Resource type
		:type type_: PackageResourcesTypes
		:param account: Account
		:type account: str
		:param table: Table name
		:type table: str
		:param transport_method: Transport method
		:type transport_method: PackageTableImportTransportMethods
		:param import_intent: Import intent
		:type import_intent: PackageTableImportIntents
		:param inter_cluster_config: Intercluster configuration
		:type inter_cluster_config: PackageExportTableInterClusterConfig
		:param version: Specific version number of the table
		:type version: str or None
		:param remote_url: Remote URL
		:type remote_url: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._type_ = cast(PackageResourcesTypes, kwargs.get("type_"))
		self._version = cast(Optional[str], kwargs.get("version"))
		self._account = cast(str, kwargs.get("account"))
		self._table = cast(str, kwargs.get("table"))
		self._remote_url = cast(Optional[str], kwargs.get("remote_url"))
		self._transport_method = cast(PackageTableImportTransportMethods, kwargs.get("transport_method"))
		self._import_intent = cast(PackageTableImportIntents, kwargs.get("import_intent"))
		self._inter_cluster_config = cast(PackageExportTableInterClusterConfig, kwargs.get("inter_cluster_config"))
	@property
	def type_(self) -> "PackageResourcesTypes":
		"""Resource type"""
		return self._type_
	@type_.setter
	def type_(self, value: "PackageResourcesTypes") -> None:
		"""Resource type"""
		self._type_ = value
	@property
	def version(self) -> Optional["str"]:
		"""Specific version number of the table"""
		return self._version
	@version.setter
	def version(self, value: Optional["str"]) -> None:
		"""Specific version number of the table"""
		self._version = value
	@property
	def account(self) -> "str":
		"""Account"""
		return self._account
	@account.setter
	def account(self, value: "str") -> None:
		"""Account"""
		self._account = value
	@property
	def table(self) -> "str":
		"""Table name"""
		return self._table
	@table.setter
	def table(self, value: "str") -> None:
		"""Table name"""
		self._table = value
	@property
	def remote_url(self) -> Optional["str"]:
		"""Remote URL"""
		return self._remote_url
	@remote_url.setter
	def remote_url(self, value: Optional["str"]) -> None:
		"""Remote URL"""
		self._remote_url = value
	@property
	def transport_method(self) -> "PackageTableImportTransportMethods":
		"""Transport method"""
		return self._transport_method
	@transport_method.setter
	def transport_method(self, value: "PackageTableImportTransportMethods") -> None:
		"""Transport method"""
		self._transport_method = value
	@property
	def import_intent(self) -> "PackageTableImportIntents":
		"""Import intent"""
		return self._import_intent
	@import_intent.setter
	def import_intent(self, value: "PackageTableImportIntents") -> None:
		"""Import intent"""
		self._import_intent = value
	@property
	def inter_cluster_config(self) -> "PackageExportTableInterClusterConfig":
		"""Intercluster configuration"""
		return self._inter_cluster_config
	@inter_cluster_config.setter
	def inter_cluster_config(self, value: "PackageExportTableInterClusterConfig") -> None:
		"""Intercluster configuration"""
		self._inter_cluster_config = value
class PackageToExport:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"account": ("account", "str", None),
		"resources_to_export": ("resourcesToExport", "PackageResourcesToExport", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		account: "str",
		resources_to_export: "PackageResourcesToExport",
	) -> None:
		"""
		:param name: Name of the package to be exported
		:type name: str
		:param account: Account under which the package export job will run
		:type account: str
		:param resources_to_export: Collection of resource IDs and metadata to be included in the exported package
		:type resources_to_export: PackageResourcesToExport
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._account = cast(str, kwargs.get("account"))
		self._resources_to_export = cast(PackageResourcesToExport, kwargs.get("resources_to_export"))
	@property
	def name(self) -> "str":
		"""Name of the package to be exported"""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""Name of the package to be exported"""
		self._name = value
	@property
	def account(self) -> "str":
		"""Account under which the package export job will run"""
		return self._account
	@account.setter
	def account(self, value: "str") -> None:
		"""Account under which the package export job will run"""
		self._account = value
	@property
	def resources_to_export(self) -> "PackageResourcesToExport":
		"""Collection of resource IDs and metadata to be included in the exported package"""
		return self._resources_to_export
	@resources_to_export.setter
	def resources_to_export(self, value: "PackageResourcesToExport") -> None:
		"""Collection of resource IDs and metadata to be included in the exported package"""
		self._resources_to_export = value
class PackageToInstall:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "str", None),
		"packagesource": ("packagesource", "PackageSources", None),
		"path": ("path", "str", None),
		"overrides": ("overrides", "dict", "dict"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "str",
		packagesource: "PackageSources",
		path: "str",
		overrides: "Dict[str, Dict[str, Any]]",
	) -> None:
		"""
		:param account: Account under which the package install job will run and under which resources will be installed, if they are not specified in the package manifest
		:type account: str
		:param packagesource: Type of location where the package archive resides
		:type packagesource: PackageSources
		:param path: Location of the package archive file.
		:type path: str
		:param overrides: Collection of JSON override configurations for specific resource IDs
		:type overrides: Dict[str, Dict[str, Any]]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._account = cast(str, kwargs.get("account"))
		self._packagesource = cast(PackageSources, kwargs.get("packagesource"))
		self._path = cast(str, kwargs.get("path"))
		self._overrides = cast(Dict[str, Dict[str, Any]], kwargs.get("overrides"))
	@property
	def account(self) -> "str":
		"""Account under which the package install job will run and under which resources will be installed, if they are not specified in the package manifest"""
		return self._account
	@account.setter
	def account(self, value: "str") -> None:
		"""Account under which the package install job will run and under which resources will be installed, if they are not specified in the package manifest"""
		self._account = value
	@property
	def packagesource(self) -> "PackageSources":
		"""Type of location where the package archive resides"""
		return self._packagesource
	@packagesource.setter
	def packagesource(self, value: "PackageSources") -> None:
		"""Type of location where the package archive resides"""
		self._packagesource = value
	@property
	def path(self) -> "str":
		"""Location of the package archive file."""
		return self._path
	@path.setter
	def path(self, value: "str") -> None:
		"""Location of the package archive file."""
		self._path = value
	@property
	def overrides(self) -> "Dict[str, Dict[str, Any]]":
		"""Collection of JSON override configurations for specific resource IDs"""
		return self._overrides
	@overrides.setter
	def overrides(self, value: "Dict[str, Dict[str, Any]]") -> None:
		"""Collection of JSON override configurations for specific resource IDs"""
		self._overrides = value
class RestList(Generic[T]):
	"""A JSON HAL wrapper for a list of records."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"links": ("_links", "RestListLinks", None),
		"embedded": ("_embedded", "RestListItems", None),
		"count": ("count", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		links: "RestListLinks[T]",
		embedded: "RestListItems[T]",
		count: "int",
	) -> None:
		"""
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: RestListLinks[T]
		:param embedded:
		:type embedded: RestListItems[T]
		:param count: The number of items returned in this list.
		:type count: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._links = cast(RestListLinks[T], kwargs.get("links"))
		self._embedded = cast(RestListItems[T], kwargs.get("embedded"))
		self._count = cast(int, kwargs.get("count"))
	@property
	def links(self) -> "RestListLinks[T]":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "RestListLinks[T]") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
	@property
	def embedded(self) -> "RestListItems[T]":
		# pylint: disable=missing-function-docstring
		return self._embedded
	@embedded.setter
	def embedded(self, value: "RestListItems[T]") -> None:
		# pylint: disable=missing-function-docstring
		self._embedded = value
	@property
	def count(self) -> "int":
		"""The number of items returned in this list."""
		return self._count
	@count.setter
	def count(self, value: "int") -> None:
		"""The number of items returned in this list."""
		self._count = value
class Page(RestList[T]):
	"""A JSON HAL wrapper for a list of records."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"size": ("size", "int", None),
		"next_": ("next", "str", None),
		"prev": ("prev", "str", None),
		"links": ("_links", "PageLinks", None),
		"embedded": ("_embedded", "RestListItems", None),
		"count": ("count", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		size: "int",
		links: "PageLinks[T]",
		embedded: "RestListItems[T]",
		count: "int",
		next_: Optional["str"] = None,
		prev: Optional["str"] = None,
	) -> None:
		"""
		:param size: The number of items to include on a single page.
		:type size: int
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: PageLinks[T]
		:param embedded:
		:type embedded: RestListItems[T]
		:param count: The number of items returned in this list.
		:type count: int
		:param next_: The token to fetch the next page.
		:type next_: str or None
		:param prev: The token to fetch the previous page.
		:type prev: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		RestList.__init__(self,
			links=kwargs.get("links"),
			embedded=kwargs.get("embedded"),
			count=kwargs.get("count"),
		)
		self._size = cast(int, kwargs.get("size"))
		self._next_ = cast(Optional[str], kwargs.get("next_"))
		self._prev = cast(Optional[str], kwargs.get("prev"))
		self._links = cast(PageLinks[T], kwargs.get("links"))
	@property
	def size(self) -> "int":
		"""The number of items to include on a single page."""
		return self._size
	@size.setter
	def size(self, value: "int") -> None:
		"""The number of items to include on a single page."""
		self._size = value
	@property
	def next_(self) -> Optional["str"]:
		"""The token to fetch the next page."""
		return self._next_
	@next_.setter
	def next_(self, value: Optional["str"]) -> None:
		"""The token to fetch the next page."""
		self._next_ = value
	@property
	def prev(self) -> Optional["str"]:
		"""The token to fetch the previous page."""
		return self._prev
	@prev.setter
	def prev(self, value: Optional["str"]) -> None:
		"""The token to fetch the previous page."""
		self._prev = value
	@property
	def links(self) -> "PageLinks[T]":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return cast(PageLinks[T], self._links)
	@links.setter
	def links(self, value: "PageLinks[T]") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class RestListLinks(Generic[T], Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class PageLinks(RestListLinks[T]):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"prev": ("prev", "Link", None),
		"next_": ("next", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
		prev: Optional["Link"] = None,
		next_: Optional["Link"] = None,
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		:param prev: A link to the previous page of results.
		:type prev: Link or None
		:param next_: A link to the next page of results.
		:type next_: Link or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		RestListLinks.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._prev = cast(Optional[Link], kwargs.get("prev"))
		self._next_ = cast(Optional[Link], kwargs.get("next_"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def prev(self) -> Optional["Link"]:
		"""A link to the previous page of results."""
		return self._prev
	@prev.setter
	def prev(self, value: Optional["Link"]) -> None:
		"""A link to the previous page of results."""
		self._prev = value
	@property
	def next_(self) -> Optional["Link"]:
		"""A link to the next page of results."""
		return self._next_
	@next_.setter
	def next_(self, value: Optional["Link"]) -> None:
		"""A link to the next page of results."""
		self._next_ = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class PageOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"size": ("size", "int", None),
		"next_": ("next", "str", None),
		"prev": ("prev", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		size: "int",
		next_: Optional["str"] = None,
		prev: Optional["str"] = None,
	) -> None:
		"""
		:param size: The number of items to include on a single page.
		:type size: int
		:param next_: The token to fetch the next page.
		:type next_: str or None
		:param prev: The token to fetch the previous page.
		:type prev: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._size = cast(int, kwargs.get("size"))
		self._next_ = cast(Optional[str], kwargs.get("next_"))
		self._prev = cast(Optional[str], kwargs.get("prev"))
	@property
	def size(self) -> "int":
		"""The number of items to include on a single page."""
		return self._size
	@size.setter
	def size(self, value: "int") -> None:
		"""The number of items to include on a single page."""
		self._size = value
	@property
	def next_(self) -> Optional["str"]:
		"""The token to fetch the next page."""
		return self._next_
	@next_.setter
	def next_(self, value: Optional["str"]) -> None:
		"""The token to fetch the next page."""
		self._next_ = value
	@property
	def prev(self) -> Optional["str"]:
		"""The token to fetch the previous page."""
		return self._prev
	@prev.setter
	def prev(self, value: Optional["str"]) -> None:
		"""The token to fetch the previous page."""
		self._prev = value
class ParallelOpts:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"max_degree_of_parallelism": ("maxDegreeOfParallelism", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		max_degree_of_parallelism: "int",
	) -> None:
		"""
		:param max_degree_of_parallelism:
		:type max_degree_of_parallelism: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._max_degree_of_parallelism = cast(int, kwargs.get("max_degree_of_parallelism"))
	@property
	def max_degree_of_parallelism(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._max_degree_of_parallelism
	@max_degree_of_parallelism.setter
	def max_degree_of_parallelism(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._max_degree_of_parallelism = value
class PBFImportOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"include_amenities": ("includeAmenities", "bool", None),
		"ingest_as_binary": ("ingestAsBinary", "bool", None),
		"include_roads": ("includeRoads", "bool", None),
		"ingest_buildings_as_binary": ("ingestBuildingsAsBinary", "bool", None),
		"ingest_water_as_binary": ("ingestWaterAsBinary", "bool", None),
		"ingest_boundaries_as_binary": ("ingestBoundariesAsBinary", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		include_amenities: "bool",
		ingest_as_binary: "bool",
		include_roads: "bool",
		ingest_buildings_as_binary: "bool",
		ingest_water_as_binary: "bool",
		ingest_boundaries_as_binary: "bool",
	) -> None:
		"""
		:param include_amenities:
		:type include_amenities: bool
		:param ingest_as_binary:
		:type ingest_as_binary: bool
		:param include_roads:
		:type include_roads: bool
		:param ingest_buildings_as_binary:
		:type ingest_buildings_as_binary: bool
		:param ingest_water_as_binary:
		:type ingest_water_as_binary: bool
		:param ingest_boundaries_as_binary:
		:type ingest_boundaries_as_binary: bool
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._include_amenities = cast(bool, kwargs.get("include_amenities"))
		self._ingest_as_binary = cast(bool, kwargs.get("ingest_as_binary"))
		self._include_roads = cast(bool, kwargs.get("include_roads"))
		self._ingest_buildings_as_binary = cast(bool, kwargs.get("ingest_buildings_as_binary"))
		self._ingest_water_as_binary = cast(bool, kwargs.get("ingest_water_as_binary"))
		self._ingest_boundaries_as_binary = cast(bool, kwargs.get("ingest_boundaries_as_binary"))
	@property
	def include_amenities(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._include_amenities
	@include_amenities.setter
	def include_amenities(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._include_amenities = value
	@property
	def ingest_as_binary(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._ingest_as_binary
	@ingest_as_binary.setter
	def ingest_as_binary(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._ingest_as_binary = value
	@property
	def include_roads(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._include_roads
	@include_roads.setter
	def include_roads(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._include_roads = value
	@property
	def ingest_buildings_as_binary(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._ingest_buildings_as_binary
	@ingest_buildings_as_binary.setter
	def ingest_buildings_as_binary(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._ingest_buildings_as_binary = value
	@property
	def ingest_water_as_binary(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._ingest_water_as_binary
	@ingest_water_as_binary.setter
	def ingest_water_as_binary(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._ingest_water_as_binary = value
	@property
	def ingest_boundaries_as_binary(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._ingest_boundaries_as_binary
	@ingest_boundaries_as_binary.setter
	def ingest_boundaries_as_binary(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._ingest_boundaries_as_binary = value
class Pipeline:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"links": ("links", "PipelineLinks", None),
		"id_": ("id", "str", None),
		"name": ("name", "str", None),
		"last_edit_user": ("lastEditUser", "str", None),
		"pipeline_definition": ("pipelineDefinition", None, None),
		"last_edited": ("lastEdited", "datetime", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		links: "PipelineLinks",
		last_edited: "datetime",
		id_: Optional["str"] = None,
		name: Optional["str"] = None,
		last_edit_user: Optional["str"] = None,
		pipeline_definition: Optional["Any"] = None,
	) -> None:
		"""
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: PipelineLinks
		:param last_edited:
		:type last_edited: datetime
		:param id_: The ramp's unique id
		:type id_: str or None
		:param name:
		:type name: str or None
		:param last_edit_user:
		:type last_edit_user: str or None
		:param pipeline_definition:
		:type pipeline_definition: Any or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._links = cast(PipelineLinks, kwargs.get("links"))
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._last_edit_user = cast(Optional[str], kwargs.get("last_edit_user"))
		self._pipeline_definition = kwargs.get("pipeline_definition")
		self._last_edited = cast(datetime, kwargs.get("last_edited"))
	@property
	def links(self) -> "PipelineLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "PipelineLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
	@property
	def id_(self) -> Optional["str"]:
		"""The ramp's unique id"""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		"""The ramp's unique id"""
		self._id_ = value
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def last_edit_user(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._last_edit_user
	@last_edit_user.setter
	def last_edit_user(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._last_edit_user = value
	@property
	def pipeline_definition(self) -> Optional["Any"]:
		# pylint: disable=missing-function-docstring
		return self._pipeline_definition
	@pipeline_definition.setter
	def pipeline_definition(self, value: Optional["Any"]) -> None:
		# pylint: disable=missing-function-docstring
		self._pipeline_definition = value
	@property
	def last_edited(self) -> "datetime":
		# pylint: disable=missing-function-docstring
		return self._last_edited
	@last_edited.setter
	def last_edited(self, value: "datetime") -> None:
		# pylint: disable=missing-function-docstring
		self._last_edited = value
class PipelineDefinition:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"number_of_workers": ("NumberOfWorkers", "int", None),
		"steps": ("Steps", "list", "PipelineDefinitionStep"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		number_of_workers: "int",
		steps: "List[PipelineDefinitionStep]",
	) -> None:
		"""
		:param number_of_workers:
		:type number_of_workers: int
		:param steps:
		:type steps: List[PipelineDefinitionStep]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._number_of_workers = cast(int, kwargs.get("number_of_workers"))
		self._steps = cast(List[PipelineDefinitionStep], kwargs.get("steps"))
	@property
	def number_of_workers(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._number_of_workers
	@number_of_workers.setter
	def number_of_workers(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._number_of_workers = value
	@property
	def steps(self) -> "List[PipelineDefinitionStep]":
		# pylint: disable=missing-function-docstring
		return self._steps
	@steps.setter
	def steps(self, value: "List[PipelineDefinitionStep]") -> None:
		# pylint: disable=missing-function-docstring
		self._steps = value


class PipelineDefinitionPipelineStepType(str, Enum):
	# pylint: disable=missing-class-docstring
	STREAM_TRANSFORM = 'StreamTransform'
	PARSER = 'Parser'
	RECORD_TRANSFORM = 'RecordTransform'
	COMMITTER = 'Committer'
	INTERCHANGE_TRANSFORM = 'InterchangeTransform'
	STREAM_COMMITTER = 'StreamCommitter'
	RECORD_ACCUMULATOR = 'RecordAccumulator'
	SERIALIZER = 'Serializer'
	EXPORT_CONNECTOR = 'ExportConnector'
	RECORD_OBSERVER = 'RecordObserver'

class PipelineDefinitionStep:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"step_name": ("StepName", "str", None),
		"type_": ("Type", "PipelineDefinitionPipelineStepType", None),
		"application": ("Application", "str", None),
		"plugin_name": ("PluginName", "str", None),
		"options": ("Options", "dict", None),
		"transitions": ("Transitions", "list", "PipelineDefinitionTransition"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		type_: "PipelineDefinitionPipelineStepType",
		options: "Dict[str, Any]",
		transitions: "List[PipelineDefinitionTransition]",
		step_name: Optional["str"] = None,
		application: Optional["str"] = None,
		plugin_name: Optional["str"] = None,
	) -> None:
		"""
		:param type_:
		:type type_: PipelineDefinitionPipelineStepType
		:param options:
		:type options: Dict[str, Any]
		:param transitions:
		:type transitions: List[PipelineDefinitionTransition]
		:param step_name:
		:type step_name: str or None
		:param application:
		:type application: str or None
		:param plugin_name:
		:type plugin_name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._step_name = cast(Optional[str], kwargs.get("step_name"))
		self._type_ = cast(PipelineDefinitionPipelineStepType, kwargs.get("type_"))
		self._application = cast(Optional[str], kwargs.get("application"))
		self._plugin_name = cast(Optional[str], kwargs.get("plugin_name"))
		self._options = cast(Dict[str, Any], kwargs.get("options"))
		self._transitions = cast(List[PipelineDefinitionTransition], kwargs.get("transitions"))
	@property
	def step_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._step_name
	@step_name.setter
	def step_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._step_name = value
	@property
	def type_(self) -> "PipelineDefinitionPipelineStepType":
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: "PipelineDefinitionPipelineStepType") -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def application(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._application
	@application.setter
	def application(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._application = value
	@property
	def plugin_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._plugin_name
	@plugin_name.setter
	def plugin_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._plugin_name = value
	@property
	def options(self) -> "Dict[str, Any]":
		# pylint: disable=missing-function-docstring
		return self._options
	@options.setter
	def options(self, value: "Dict[str, Any]") -> None:
		# pylint: disable=missing-function-docstring
		self._options = value
	@property
	def transitions(self) -> "List[PipelineDefinitionTransition]":
		# pylint: disable=missing-function-docstring
		return self._transitions
	@transitions.setter
	def transitions(self, value: "List[PipelineDefinitionTransition]") -> None:
		# pylint: disable=missing-function-docstring
		self._transitions = value
class PipelineDefinitionTransition:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"target_input_key": ("TargetInputKey", "str", None),
		"source_output_key": ("SourceOutputKey", "str", None),
		"to_step": ("ToStep", "str", None),
		"transition_guard": ("TransitionGuard", "PipelineDefinitionTransitionGuard", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		transition_guard: "PipelineDefinitionTransitionGuard",
		target_input_key: Optional["str"] = None,
		source_output_key: Optional["str"] = None,
		to_step: Optional["str"] = None,
	) -> None:
		"""
		:param transition_guard:
		:type transition_guard: PipelineDefinitionTransitionGuard
		:param target_input_key:
		:type target_input_key: str or None
		:param source_output_key:
		:type source_output_key: str or None
		:param to_step:
		:type to_step: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._target_input_key = cast(Optional[str], kwargs.get("target_input_key"))
		self._source_output_key = cast(Optional[str], kwargs.get("source_output_key"))
		self._to_step = cast(Optional[str], kwargs.get("to_step"))
		self._transition_guard = cast(PipelineDefinitionTransitionGuard, kwargs.get("transition_guard"))
	@property
	def target_input_key(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._target_input_key
	@target_input_key.setter
	def target_input_key(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._target_input_key = value
	@property
	def source_output_key(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._source_output_key
	@source_output_key.setter
	def source_output_key(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._source_output_key = value
	@property
	def to_step(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._to_step
	@to_step.setter
	def to_step(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._to_step = value
	@property
	def transition_guard(self) -> "PipelineDefinitionTransitionGuard":
		# pylint: disable=missing-function-docstring
		return self._transition_guard
	@transition_guard.setter
	def transition_guard(self, value: "PipelineDefinitionTransitionGuard") -> None:
		# pylint: disable=missing-function-docstring
		self._transition_guard = value
class PipelineDefinitionTransitionGuard:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"context_scope": ("ContextScope", "str", None),
		"context_property": ("ContextProperty", "str", None),
		"compare_to": ("CompareTo", "str", None),
		"not_equal_to": ("NotEqualTo", "str", None),
		"contains": ("Contains", "str", None),
		"context_mask": ("ContextMask", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		context_scope: Optional["str"] = None,
		context_property: Optional["str"] = None,
		compare_to: Optional["str"] = None,
		not_equal_to: Optional["str"] = None,
		contains: Optional["str"] = None,
		context_mask: Optional["str"] = None,
	) -> None:
		"""
		:param context_scope:
		:type context_scope: str or None
		:param context_property:
		:type context_property: str or None
		:param compare_to:
		:type compare_to: str or None
		:param not_equal_to:
		:type not_equal_to: str or None
		:param contains:
		:type contains: str or None
		:param context_mask:
		:type context_mask: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._context_scope = cast(Optional[str], kwargs.get("context_scope"))
		self._context_property = cast(Optional[str], kwargs.get("context_property"))
		self._compare_to = cast(Optional[str], kwargs.get("compare_to"))
		self._not_equal_to = cast(Optional[str], kwargs.get("not_equal_to"))
		self._contains = cast(Optional[str], kwargs.get("contains"))
		self._context_mask = cast(Optional[str], kwargs.get("context_mask"))
	@property
	def context_scope(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._context_scope
	@context_scope.setter
	def context_scope(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._context_scope = value
	@property
	def context_property(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._context_property
	@context_property.setter
	def context_property(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._context_property = value
	@property
	def compare_to(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._compare_to
	@compare_to.setter
	def compare_to(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._compare_to = value
	@property
	def not_equal_to(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._not_equal_to
	@not_equal_to.setter
	def not_equal_to(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._not_equal_to = value
	@property
	def contains(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._contains
	@contains.setter
	def contains(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._contains = value
	@property
	def context_mask(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._context_mask
	@context_mask.setter
	def context_mask(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._context_mask = value
class PipelineExport:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"pipelines": ("Pipelines", "list", "Pipeline"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		pipelines: "List[Pipeline]",
	) -> None:
		"""
		:param pipelines:
		:type pipelines: List[Pipeline]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._pipelines = cast(List[Pipeline], kwargs.get("pipelines"))
	@property
	def pipelines(self) -> "List[Pipeline]":
		# pylint: disable=missing-function-docstring
		return self._pipelines
	@pipelines.setter
	def pipelines(self, value: "List[Pipeline]") -> None:
		# pylint: disable=missing-function-docstring
		self._pipelines = value
class PipelineLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class PlacenameBaseMapTheme:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"dot_fill": ("dotFill", "str", None),
		"dot_border": ("dotBorder", "str", None),
		"text_color": ("textColor", "str", None),
		"country_label_color": ("countryLabelColor", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		dot_fill: Optional["str"] = None,
		dot_border: Optional["str"] = None,
		text_color: Optional["str"] = None,
		country_label_color: Optional["str"] = None,
	) -> None:
		"""
		:param dot_fill:
		:type dot_fill: str or None
		:param dot_border:
		:type dot_border: str or None
		:param text_color:
		:type text_color: str or None
		:param country_label_color:
		:type country_label_color: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._dot_fill = cast(Optional[str], kwargs.get("dot_fill"))
		self._dot_border = cast(Optional[str], kwargs.get("dot_border"))
		self._text_color = cast(Optional[str], kwargs.get("text_color"))
		self._country_label_color = cast(Optional[str], kwargs.get("country_label_color"))
	@property
	def dot_fill(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._dot_fill
	@dot_fill.setter
	def dot_fill(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._dot_fill = value
	@property
	def dot_border(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._dot_border
	@dot_border.setter
	def dot_border(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._dot_border = value
	@property
	def text_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._text_color
	@text_color.setter
	def text_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._text_color = value
	@property
	def country_label_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._country_label_color
	@country_label_color.setter
	def country_label_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._country_label_color = value


class PolyGradientStyle(str, Enum):
	"""Polygon property"""
	LINEAR = 'Linear'
	RADIAL = 'Radial'
	VERTICIES = 'Verticies'



class PolyPathFillType(str, Enum):
	"""Polygon property"""
	DEFAULT = 'Default'
	WINDING = 'Winding'
	EVEN_ODD = 'EvenOdd'
	INVERSE_WINDING = 'InverseWinding'
	INVERSE_EVEN_ODD = 'InverseEvenOdd'



class PolyVertexColorStyle(str, Enum):
	"""Polygon property"""
	REPEAT = 'Repeat'
	REPEAT_LAST = 'RepeatLast'
	WIREFRAME = 'Wireframe'



class PolyVertexMode(str, Enum):
	"""Polygon property"""
	TRIANGLES = 'Triangles'
	TRIANGLE_FAN = 'TriangleFan'
	TRIANGLE_STRIP = 'TriangleStrip'



class Position(str, Enum):
	# pylint: disable=missing-class-docstring
	TOP_RIGHT = 'TopRight'
	TOP_LEFT = 'TopLeft'
	BOTTOM_RIGHT = 'BottomRight'
	BOTTOM_LEFT = 'BottomLeft'
	CENTER = 'Center'
	OVERLAY = 'Overlay'
	ABSOLUTE = 'Absolute'
	OFF_CENTER = 'OffCenter'

class ProblemDetails:
	"""[RFC 7808](https://tools.ietf.org/html/rfc7807) compliant error information."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"detail": ("detail", "str", None),
		"instance": ("instance", "str", None),
		"status": ("status", "int", None),
		"title": ("title", "str", None),
		"type_": ("type", "str", None),
		"messages": ("messages", "list", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		messages: "List[str]",
		detail: Optional["str"] = None,
		instance: Optional["str"] = None,
		status: Optional["int"] = None,
		title: Optional["str"] = None,
		type_: Optional["str"] = None,
	) -> None:
		"""
		:param messages:
		:type messages: List[str]
		:param detail: A human-readable explanation specific to this occurrence of the problem.
		:type detail: str or None
		:param instance: A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
		:type instance: str or None
		:param status: The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
		:type status: int or None
		:param title: A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization(e.g., using proactive content negotiation; see[RFC7231], Section 3.4).
		:type title: str or None
		:param type_: A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank".
		:type type_: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._detail = cast(Optional[str], kwargs.get("detail"))
		self._instance = cast(Optional[str], kwargs.get("instance"))
		self._status = cast(Optional[int], kwargs.get("status"))
		self._title = cast(Optional[str], kwargs.get("title"))
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._messages = cast(List[str], kwargs.get("messages"))
	@property
	def detail(self) -> Optional["str"]:
		"""A human-readable explanation specific to this occurrence of the problem."""
		return self._detail
	@detail.setter
	def detail(self, value: Optional["str"]) -> None:
		"""A human-readable explanation specific to this occurrence of the problem."""
		self._detail = value
	@property
	def instance(self) -> Optional["str"]:
		"""A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced."""
		return self._instance
	@instance.setter
	def instance(self, value: Optional["str"]) -> None:
		"""A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced."""
		self._instance = value
	@property
	def status(self) -> Optional["int"]:
		"""The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem."""
		return self._status
	@status.setter
	def status(self, value: Optional["int"]) -> None:
		"""The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem."""
		self._status = value
	@property
	def title(self) -> Optional["str"]:
		"""A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization(e.g., using proactive content negotiation; see[RFC7231], Section 3.4)."""
		return self._title
	@title.setter
	def title(self, value: Optional["str"]) -> None:
		"""A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization(e.g., using proactive content negotiation; see[RFC7231], Section 3.4)."""
		self._title = value
	@property
	def type_(self) -> Optional["str"]:
		"""A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank"."""
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		"""A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank"."""
		self._type_ = value
	@property
	def messages(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._messages
	@messages.setter
	def messages(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._messages = value


class ProjectionMode(str, Enum):
	"""The map projection."""
	MERCATOR = 'mercator'
	WGS_84 = 'wgs84'

ProjectionMode.MERCATOR.__doc__ = """EPSG:3857"""
ProjectionMode.WGS_84.__doc__ = """EPSG:4326"""
class ProxyRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"domain": ("domain", "str", None),
		"cluster_key": ("clusterKey", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		domain: Optional["str"] = None,
		cluster_key: Optional["str"] = None,
	) -> None:
		"""
		:param domain: The URL of the remote MapLarge cluster that the query should be executed on.
		:type domain: str or None
		:param cluster_key: A string identifier indicating the remote MapLarge cluster that the query should be executed on.
		:type cluster_key: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._domain = cast(Optional[str], kwargs.get("domain"))
		self._cluster_key = cast(Optional[str], kwargs.get("cluster_key"))
	@property
	def domain(self) -> Optional["str"]:
		"""The URL of the remote MapLarge cluster that the query should be executed on."""
		return self._domain
	@domain.setter
	def domain(self, value: Optional["str"]) -> None:
		"""The URL of the remote MapLarge cluster that the query should be executed on."""
		self._domain = value
	@property
	def cluster_key(self) -> Optional["str"]:
		"""A string identifier indicating the remote MapLarge cluster that the query should be executed on."""
		return self._cluster_key
	@cluster_key.setter
	def cluster_key(self, value: Optional["str"]) -> None:
		"""A string identifier indicating the remote MapLarge cluster that the query should be executed on."""
		self._cluster_key = value
class PxImport:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"format_": ("format", "PxImportFormat", None),
		"path_or_delimiter": ("pathOrDelimiter", "str", None),
		"download_url_format": ("downloadURLFormat", "str", None),
		"continuation_path": ("continuationPath", "str", None),
		"px_factor_per_node": ("pxFactorPerNode", "int", None),
		"use_all_nodes": ("useAllNodes", "bool", None),
		"import_items": ("importItems", "list", "PxImportItem"),
		"files_per_batch": ("filesPerBatch", "int", None),
		"retries": ("retries", "int", None),
		"worker_timeout": ("workerTimeout", "str", None),
		"file_filter_plugin_name": ("fileFilterPluginName", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		format_: "PxImportFormat",
		px_factor_per_node: "int",
		use_all_nodes: "bool",
		import_items: "List[PxImportItem]",
		files_per_batch: "int",
		retries: "int",
		path_or_delimiter: Optional["str"] = None,
		download_url_format: Optional["str"] = None,
		continuation_path: Optional["str"] = None,
		worker_timeout: Optional["str"] = None,
		file_filter_plugin_name: Optional["str"] = None,
	) -> None:
		"""
		:param format_:
		:type format_: PxImportFormat
		:param px_factor_per_node:
		:type px_factor_per_node: int
		:param use_all_nodes:
		:type use_all_nodes: bool
		:param import_items:
		:type import_items: List[PxImportItem]
		:param files_per_batch:
		:type files_per_batch: int
		:param retries:
		:type retries: int
		:param path_or_delimiter:
		:type path_or_delimiter: str or None
		:param download_url_format:
		:type download_url_format: str or None
		:param continuation_path:
		:type continuation_path: str or None
		:param worker_timeout:
		:type worker_timeout: str or None
		:param file_filter_plugin_name:
		:type file_filter_plugin_name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._format_ = cast(PxImportFormat, kwargs.get("format_"))
		self._path_or_delimiter = cast(Optional[str], kwargs.get("path_or_delimiter"))
		self._download_url_format = cast(Optional[str], kwargs.get("download_url_format"))
		self._continuation_path = cast(Optional[str], kwargs.get("continuation_path"))
		self._px_factor_per_node = cast(int, kwargs.get("px_factor_per_node"))
		self._use_all_nodes = cast(bool, kwargs.get("use_all_nodes"))
		self._import_items = cast(List[PxImportItem], kwargs.get("import_items"))
		self._files_per_batch = cast(int, kwargs.get("files_per_batch"))
		self._retries = cast(int, kwargs.get("retries"))
		self._worker_timeout = cast(Optional[str], kwargs.get("worker_timeout"))
		self._file_filter_plugin_name = cast(Optional[str], kwargs.get("file_filter_plugin_name"))
	@property
	def format_(self) -> "PxImportFormat":
		# pylint: disable=missing-function-docstring
		return self._format_
	@format_.setter
	def format_(self, value: "PxImportFormat") -> None:
		# pylint: disable=missing-function-docstring
		self._format_ = value
	@property
	def path_or_delimiter(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._path_or_delimiter
	@path_or_delimiter.setter
	def path_or_delimiter(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path_or_delimiter = value
	@property
	def download_url_format(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._download_url_format
	@download_url_format.setter
	def download_url_format(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._download_url_format = value
	@property
	def continuation_path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._continuation_path
	@continuation_path.setter
	def continuation_path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._continuation_path = value
	@property
	def px_factor_per_node(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._px_factor_per_node
	@px_factor_per_node.setter
	def px_factor_per_node(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._px_factor_per_node = value
	@property
	def use_all_nodes(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._use_all_nodes
	@use_all_nodes.setter
	def use_all_nodes(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._use_all_nodes = value
	@property
	def import_items(self) -> "List[PxImportItem]":
		# pylint: disable=missing-function-docstring
		return self._import_items
	@import_items.setter
	def import_items(self, value: "List[PxImportItem]") -> None:
		# pylint: disable=missing-function-docstring
		self._import_items = value
	@property
	def files_per_batch(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._files_per_batch
	@files_per_batch.setter
	def files_per_batch(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._files_per_batch = value
	@property
	def retries(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._retries
	@retries.setter
	def retries(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._retries = value
	@property
	def worker_timeout(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._worker_timeout
	@worker_timeout.setter
	def worker_timeout(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._worker_timeout = value
	@property
	def file_filter_plugin_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._file_filter_plugin_name
	@file_filter_plugin_name.setter
	def file_filter_plugin_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._file_filter_plugin_name = value


class PxImportFormat(str, Enum):
	# pylint: disable=missing-class-docstring
	XML = 'XML'
	JSON = 'JSON'
	DELIMITED = 'Delimited'

class PxImportItem:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"match_regex": ("matchRegex", "str", None),
		"split": ("split", "bool", None),
		"split_bytes": ("splitBytes", "int", None),
		"has_header": ("hasHeader", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		split: "bool",
		split_bytes: "int",
		has_header: "bool",
		match_regex: Optional["str"] = None,
	) -> None:
		"""
		:param split:
		:type split: bool
		:param split_bytes:
		:type split_bytes: int
		:param has_header:
		:type has_header: bool
		:param match_regex:
		:type match_regex: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._match_regex = cast(Optional[str], kwargs.get("match_regex"))
		self._split = cast(bool, kwargs.get("split"))
		self._split_bytes = cast(int, kwargs.get("split_bytes"))
		self._has_header = cast(bool, kwargs.get("has_header"))
	@property
	def match_regex(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._match_regex
	@match_regex.setter
	def match_regex(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._match_regex = value
	@property
	def split(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._split
	@split.setter
	def split(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._split = value
	@property
	def split_bytes(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._split_bytes
	@split_bytes.setter
	def split_bytes(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._split_bytes = value
	@property
	def has_header(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._has_header
	@has_header.setter
	def has_header(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._has_header = value


class QueriesExportAcceptType(str, Enum):
	"""The content types that `queries_export` is able to return."""
	TEXT_CSV = 'text/csv'
	APPLICATION_VND_GOOGLE_EARTH_KML_XML = 'application/vnd.google-earth.kml+xml'
	APPLICATION_GEO_JSON = 'application/geo+json'
	APPLICATION_VND_SHP = 'application/vnd.shp'
	APPLICATION_GML_XML = 'application/gml+xml'
	APPLICATION_X_FLT_ZIP = 'application/x-flt+zip'
	APPLICATION_X_NETCDF = 'application/x-netcdf'
	APPLICATION_GRAPHML_XML = 'application/graphml+xml'
	APPLICATION_LD_JSON = 'application/ld+json'
	APPLICATION_X_GEOTIFF = 'application/x-geotiff'
	APPLICATION_VND_APACHE_PARQUET = 'application/vnd.apache.parquet'
	APPLICATION_VND_SQLITE_3 = 'application/vnd.sqlite3'



class QueriesExportDirectAcceptType(str, Enum):
	"""The content types that `queries_exportDirect` is able to return."""
	TEXT_CSV = 'text/csv'
	APPLICATION_VND_GOOGLE_EARTH_KML_XML = 'application/vnd.google-earth.kml+xml'
	APPLICATION_GEO_JSON = 'application/geo+json'
	APPLICATION_VND_SHP = 'application/vnd.shp'
	APPLICATION_GML_XML = 'application/gml+xml'
	APPLICATION_X_FLT_ZIP = 'application/x-flt+zip'
	APPLICATION_X_NETCDF = 'application/x-netcdf'
	APPLICATION_GRAPHML_XML = 'application/graphml+xml'
	APPLICATION_LD_JSON = 'application/ld+json'
	APPLICATION_X_GEOTIFF = 'application/x-geotiff'
	APPLICATION_VND_APACHE_PARQUET = 'application/vnd.apache.parquet'
	APPLICATION_VND_SQLITE_3 = 'application/vnd.sqlite3'

class Query:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"start": ("start", "int", None),
		"take": ("take", "int", None),
		"where_first": ("whereFirst", "bool", None),
		"with_geo": ("withGeo", "bool", None),
		"use_null_values": ("useNullValues", "bool", None),
		"attempt_flattening": ("attemptFlattening", "bool", None),
		"with_stats": ("withStats", "bool", None),
		"materialize_table": ("materializeTable", "str", None),
		"materialize_origin": ("materializeOrigin", "QueryRequestQueryMaterializeOrigin", None),
		"materialize_operation": ("materializeOperation", "QueryMaterializeOperations", None),
		"materialize_primary_key": ("materializePrimaryKey", "str", None),
		"materialize_s2_index": ("materializeS2Index", "bool", None),
		"create_resource_on_materialize": ("createResourceOnMaterialize", "bool", None),
		"materialize_classification": ("materializeClassification", "str", None),
		"with_bounding_box": ("withBoundingBox", "bool", None),
		"with_geo_json": ("withGeoJson", "bool", None),
		"select": ("select", "QuerySelect", None),
		"table": ("table", "QueryTable", None),
		"where": ("where", "QueryWhere", None),
		"having": ("having", "QueryWhere", None),
		"order_by": ("orderBy", "list", "str"),
		"group_by": ("groupBy", "list", "str"),
		"join": ("join", "QueryJoin", None),
		"sql_select": ("sqlSelect", "list", "str"),
		"projection": ("projection", "ProjectionMode", None),
		"remove_empty_columns": ("removeEmptyColumns", "bool", None),
		"remove_zeroed_columns": ("removeZeroedColumns", "bool", None),
		"truncate_string_length": ("truncateStringLength", "int", None),
		"truncate_string_ellipsis": ("truncateStringEllipsis", "str", None),
		"raster": ("raster", "RasterRequest", None),
		"image": ("image", "ImageRequest", None),
		"union_all": ("unionAll", "list", "Query"),
		"engine_version": ("engineVersion", "int", None),
		"query_name": ("queryName", "str", None),
		"query_tag": ("queryTag", "str", None),
		"dual_query_mode_testing": ("dualQueryModeTesting", "bool", None),
		"binary_result_column": ("binaryResultColumn", "str", None),
		"domain": ("domain", "str", None),
		"cluster_key": ("clusterKey", "str", None),
		"export_column_order": ("exportColumnOrder", "list", "str"),
		"parallel": ("parallel", "int", None),
		"parallel_debug": ("parallelDebug", "bool", None),
		"bypass_caching": ("bypassCaching", "bool", None),
		"parallel_table": ("parallelTable", "str", None),
		"materialize_partition_columns": ("materializePartitionColumns", "list", "str"),
		"remote": ("remote", "RemoteQueryOptions", None),
		"column_stats": ("columnStats", "ColumnStatOptions", None),
		"live": ("live", "LiveGroupingOptions", None),
		"query_source": ("querySource", "str", None),
		"performance_counter_instance_name": ("performanceCounterInstanceName", "str", None),
		"prune": ("prune", "bool", None),
		"return_geo_by_reference": ("returnGeoByReference", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		table: "QueryTable",
		start: Optional["int"] = None,
		take: Optional["int"] = None,
		where_first: Optional["bool"] = None,
		with_geo: Optional["bool"] = None,
		use_null_values: Optional["bool"] = None,
		attempt_flattening: Optional["bool"] = None,
		with_stats: Optional["bool"] = None,
		materialize_table: Optional["str"] = None,
		materialize_origin: Optional["QueryRequestQueryMaterializeOrigin"] = None,
		materialize_operation: Optional["QueryMaterializeOperations"] = None,
		materialize_primary_key: Optional["str"] = None,
		materialize_s2_index: Optional["bool"] = None,
		create_resource_on_materialize: Optional["bool"] = None,
		materialize_classification: Optional["str"] = None,
		with_bounding_box: Optional["bool"] = None,
		with_geo_json: Optional["bool"] = None,
		select: Optional["QuerySelect"] = None,
		where: Optional["QueryWhere"] = None,
		having: Optional["QueryWhere"] = None,
		order_by: Optional["List[str]"] = None,
		group_by: Optional["List[str]"] = None,
		join: Optional["QueryJoin"] = None,
		sql_select: Optional["List[str]"] = None,
		projection: Optional["ProjectionMode"] = None,
		remove_empty_columns: Optional["bool"] = None,
		remove_zeroed_columns: Optional["bool"] = None,
		truncate_string_length: Optional["int"] = None,
		truncate_string_ellipsis: Optional["str"] = None,
		raster: Optional["RasterRequest"] = None,
		image: Optional["ImageRequest"] = None,
		union_all: Optional["List[Query]"] = None,
		engine_version: Optional["int"] = None,
		query_name: Optional["str"] = None,
		query_tag: Optional["str"] = None,
		dual_query_mode_testing: Optional["bool"] = None,
		binary_result_column: Optional["str"] = None,
		domain: Optional["str"] = None,
		cluster_key: Optional["str"] = None,
		export_column_order: Optional["List[str]"] = None,
		parallel: Optional["int"] = None,
		parallel_debug: Optional["bool"] = None,
		bypass_caching: Optional["bool"] = None,
		parallel_table: Optional["str"] = None,
		materialize_partition_columns: Optional["List[str]"] = None,
		remote: Optional["RemoteQueryOptions"] = None,
		column_stats: Optional["ColumnStatOptions"] = None,
		live: Optional["LiveGroupingOptions"] = None,
		query_source: Optional["str"] = None,
		performance_counter_instance_name: Optional["str"] = None,
		prune: Optional["bool"] = None,
		return_geo_by_reference: Optional["bool"] = None,
	) -> None:
		"""
		:param table: Specifies the data source of the query: a table, a sub-query, or a table-valued-function.
		:type table: QueryTable
		:param start: How many rows to skip from the beginning of the results. Use this with `take` to page results.
		:type start: int or None
		:param take: How many results to return. Use this with `start` to page results. Defaults to 100.
		:type take: int or None
		:param where_first: Flag to apply the `where` clause before `groupBy`. By default, `where` is applied after `groupBy`.
		:type where_first: bool or None
		:param with_geo: Flag to return geospatial columns in the result set. By default they are not returned.
		:type with_geo: bool or None
		:param use_null_values: Flag to return null values as-is. By default they are converted to default non-null values, such as 0.
		:type use_null_values: bool or None
		:param attempt_flattening: Flag to enable or disable a query optimization: promotes any unnecessary sub-queries to joins, etc. Default value is configured by `core.Config.options.attemptQueryOptimization`.
		:type attempt_flattening: bool or None
		:param with_stats: Flag to return performance statistics. Default value is configured by `core.Config.options.outputQueryStats`.
		:type with_stats: bool or None
		:param materialize_table: Optional name of a table to write the query results to. Similar to SQL's `SELECT INTO`.
		:type materialize_table: str or None
		:param materialize_origin: Identifies the origination of the requested materialize operation.
		:type materialize_origin: QueryRequestQueryMaterializeOrigin or None
		:param materialize_operation: Flag to append/create/delete the results to/from the table named in `materializeTable`. By default the contents of `materializeTable` will be completely replaced with the results of this query.
		:type materialize_operation: QueryMaterializeOperations or None
		:param materialize_primary_key: When appending results to a materialized table, you can optionally specify a primary key to use to eliminate duplicate records.
		:type materialize_primary_key: str or None
		:param materialize_s2_index: When appending results to a materialized table, you can optionally specify whether the table will enable its S2 index.
		:type materialize_s2_index: bool or None
		:param create_resource_on_materialize: Flag to create a resource for managing the permissions of the new materialized table. Defaults to true.
		:type create_resource_on_materialize: bool or None
		:param materialize_classification: Value for the `classification` tag of the new materialized table.
		:type materialize_classification: str or None
		:param with_bounding_box: Flag to return a bounding box in the `BBWKT` column for each row of the selected geospatial polygon data.
		:type with_bounding_box: bool or None
		:param with_geo_json: If `false`, contents of the `WKT` column will be WKT strings. If `true`, the `WKT` column will contain GeoJSON features.
		:type with_geo_json: bool or None
		:param select: Specifies which geospatial column should be selected from `table`.
		:type select: QuerySelect or None
		:param where:
		:type where: QueryWhere or None
		:param having: Warning: `having` is not fully implemented. Instead use `where` with `wherefirst = false` (the default).
		:type having: QueryWhere or None
		:param order_by: Specifies how the query results should be sorted.
		:type order_by: List[str] or None
		:param group_by:
		:type group_by: List[str] or None
		:param join:
		:type join: QueryJoin or None
		:param sql_select: Specify the fields/columns that will be returned in the results when the query is run.
		:type sql_select: List[str] or None
		:param projection: The map projection.
* `mercator` - EPSG:3857
* `wgs84` - EPSG:4326
		:type projection: ProjectionMode or None
		:param remove_empty_columns: Flag to remove result columns whose values are all null or whitespace. Useful with sparse data sets.
		:type remove_empty_columns: bool or None
		:param remove_zeroed_columns: Flag to remove result columns whose values are all null, whitespace, 0, "0", EMPTY_DATE (1000-01-01), or the string version of EMPTY_DATE. Useful with sparse data sets.
		:type remove_zeroed_columns: bool or None
		:param truncate_string_length: Truncate strings that are longer than this value. Specify 0 to disable truncation. If the string is truncated, `truncateStringEllipsis` will be appended to the end.
		:type truncate_string_length: int or None
		:param truncate_string_ellipsis: The value to append to the end of truncated strings.
		:type truncate_string_ellipsis: str or None
		:param raster:
		:type raster: RasterRequest or None
		:param image:
		:type image: ImageRequest or None
		:param union_all: Combine the results of this query with other queries.
		:type union_all: List[Query] or None
		:param engine_version:
		:type engine_version: int or None
		:param query_name:
		:type query_name: str or None
		:param query_tag:
		:type query_tag: str or None
		:param dual_query_mode_testing:
		:type dual_query_mode_testing: bool or None
		:param binary_result_column:
		:type binary_result_column: str or None
		:param domain:
		:type domain: str or None
		:param cluster_key:
		:type cluster_key: str or None
		:param export_column_order:
		:type export_column_order: List[str] or None
		:param parallel:
		:type parallel: int or None
		:param parallel_debug:
		:type parallel_debug: bool or None
		:param bypass_caching:
		:type bypass_caching: bool or None
		:param parallel_table:
		:type parallel_table: str or None
		:param materialize_partition_columns:
		:type materialize_partition_columns: List[str] or None
		:param remote:
		:type remote: RemoteQueryOptions or None
		:param column_stats:
		:type column_stats: ColumnStatOptions or None
		:param live:
		:type live: LiveGroupingOptions or None
		:param query_source:
		:type query_source: str or None
		:param performance_counter_instance_name:
		:type performance_counter_instance_name: str or None
		:param prune:
		:type prune: bool or None
		:param return_geo_by_reference:
		:type return_geo_by_reference: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._start = cast(Optional[int], kwargs.get("start"))
		self._take = cast(Optional[int], kwargs.get("take"))
		self._where_first = cast(Optional[bool], kwargs.get("where_first"))
		self._with_geo = cast(Optional[bool], kwargs.get("with_geo"))
		self._use_null_values = cast(Optional[bool], kwargs.get("use_null_values"))
		self._attempt_flattening = cast(Optional[bool], kwargs.get("attempt_flattening"))
		self._with_stats = cast(Optional[bool], kwargs.get("with_stats"))
		self._materialize_table = cast(Optional[str], kwargs.get("materialize_table"))
		self._materialize_origin = cast(Optional[QueryRequestQueryMaterializeOrigin], kwargs.get("materialize_origin"))
		self._materialize_operation = cast(Optional[QueryMaterializeOperations], kwargs.get("materialize_operation"))
		self._materialize_primary_key = cast(Optional[str], kwargs.get("materialize_primary_key"))
		self._materialize_s2_index = cast(Optional[bool], kwargs.get("materialize_s2_index"))
		self._create_resource_on_materialize = cast(Optional[bool], kwargs.get("create_resource_on_materialize"))
		self._materialize_classification = cast(Optional[str], kwargs.get("materialize_classification"))
		self._with_bounding_box = cast(Optional[bool], kwargs.get("with_bounding_box"))
		self._with_geo_json = cast(Optional[bool], kwargs.get("with_geo_json"))
		self._select = cast(Optional[QuerySelect], kwargs.get("select"))
		self._table = cast(QueryTable, kwargs.get("table"))
		self._where = cast(Optional[QueryWhere], kwargs.get("where"))
		self._having = cast(Optional[QueryWhere], kwargs.get("having"))
		self._order_by = cast(Optional[List[str]], kwargs.get("order_by"))
		self._group_by = cast(Optional[List[str]], kwargs.get("group_by"))
		self._join = cast(Optional[QueryJoin], kwargs.get("join"))
		self._sql_select = cast(Optional[List[str]], kwargs.get("sql_select"))
		self._projection = cast(Optional[ProjectionMode], kwargs.get("projection"))
		self._remove_empty_columns = cast(Optional[bool], kwargs.get("remove_empty_columns"))
		self._remove_zeroed_columns = cast(Optional[bool], kwargs.get("remove_zeroed_columns"))
		self._truncate_string_length = cast(Optional[int], kwargs.get("truncate_string_length"))
		self._truncate_string_ellipsis = cast(Optional[str], kwargs.get("truncate_string_ellipsis"))
		self._raster = cast(Optional[RasterRequest], kwargs.get("raster"))
		self._image = cast(Optional[ImageRequest], kwargs.get("image"))
		self._union_all = cast(Optional[List[Query]], kwargs.get("union_all"))
		self._engine_version = cast(Optional[int], kwargs.get("engine_version"))
		self._query_name = cast(Optional[str], kwargs.get("query_name"))
		self._query_tag = cast(Optional[str], kwargs.get("query_tag"))
		self._dual_query_mode_testing = cast(Optional[bool], kwargs.get("dual_query_mode_testing"))
		self._binary_result_column = cast(Optional[str], kwargs.get("binary_result_column"))
		self._domain = cast(Optional[str], kwargs.get("domain"))
		self._cluster_key = cast(Optional[str], kwargs.get("cluster_key"))
		self._export_column_order = cast(Optional[List[str]], kwargs.get("export_column_order"))
		self._parallel = cast(Optional[int], kwargs.get("parallel"))
		self._parallel_debug = cast(Optional[bool], kwargs.get("parallel_debug"))
		self._bypass_caching = cast(Optional[bool], kwargs.get("bypass_caching"))
		self._parallel_table = cast(Optional[str], kwargs.get("parallel_table"))
		self._materialize_partition_columns = cast(Optional[List[str]], kwargs.get("materialize_partition_columns"))
		self._remote = cast(Optional[RemoteQueryOptions], kwargs.get("remote"))
		self._column_stats = cast(Optional[ColumnStatOptions], kwargs.get("column_stats"))
		self._live = cast(Optional[LiveGroupingOptions], kwargs.get("live"))
		self._query_source = cast(Optional[str], kwargs.get("query_source"))
		self._performance_counter_instance_name = cast(Optional[str], kwargs.get("performance_counter_instance_name"))
		self._prune = cast(Optional[bool], kwargs.get("prune"))
		self._return_geo_by_reference = cast(Optional[bool], kwargs.get("return_geo_by_reference"))
	@property
	def start(self) -> Optional["int"]:
		"""How many rows to skip from the beginning of the results. Use this with `take` to page results."""
		return self._start
	@start.setter
	def start(self, value: Optional["int"]) -> None:
		"""How many rows to skip from the beginning of the results. Use this with `take` to page results."""
		self._start = value
	@property
	def take(self) -> Optional["int"]:
		"""How many results to return. Use this with `start` to page results. Defaults to 100."""
		return self._take
	@take.setter
	def take(self, value: Optional["int"]) -> None:
		"""How many results to return. Use this with `start` to page results. Defaults to 100."""
		self._take = value
	@property
	def where_first(self) -> Optional["bool"]:
		"""Flag to apply the `where` clause before `groupBy`. By default, `where` is applied after `groupBy`."""
		return self._where_first
	@where_first.setter
	def where_first(self, value: Optional["bool"]) -> None:
		"""Flag to apply the `where` clause before `groupBy`. By default, `where` is applied after `groupBy`."""
		self._where_first = value
	@property
	def with_geo(self) -> Optional["bool"]:
		"""Flag to return geospatial columns in the result set. By default they are not returned."""
		return self._with_geo
	@with_geo.setter
	def with_geo(self, value: Optional["bool"]) -> None:
		"""Flag to return geospatial columns in the result set. By default they are not returned."""
		self._with_geo = value
	@property
	def use_null_values(self) -> Optional["bool"]:
		"""Flag to return null values as-is. By default they are converted to default non-null values, such as 0."""
		return self._use_null_values
	@use_null_values.setter
	def use_null_values(self, value: Optional["bool"]) -> None:
		"""Flag to return null values as-is. By default they are converted to default non-null values, such as 0."""
		self._use_null_values = value
	@property
	def attempt_flattening(self) -> Optional["bool"]:
		"""Flag to enable or disable a query optimization: promotes any unnecessary sub-queries to joins, etc. Default value is configured by `core.Config.options.attemptQueryOptimization`."""
		return self._attempt_flattening
	@attempt_flattening.setter
	def attempt_flattening(self, value: Optional["bool"]) -> None:
		"""Flag to enable or disable a query optimization: promotes any unnecessary sub-queries to joins, etc. Default value is configured by `core.Config.options.attemptQueryOptimization`."""
		self._attempt_flattening = value
	@property
	def with_stats(self) -> Optional["bool"]:
		"""Flag to return performance statistics. Default value is configured by `core.Config.options.outputQueryStats`."""
		return self._with_stats
	@with_stats.setter
	def with_stats(self, value: Optional["bool"]) -> None:
		"""Flag to return performance statistics. Default value is configured by `core.Config.options.outputQueryStats`."""
		self._with_stats = value
	@property
	def materialize_table(self) -> Optional["str"]:
		"""Optional name of a table to write the query results to. Similar to SQL's `SELECT INTO`."""
		return self._materialize_table
	@materialize_table.setter
	def materialize_table(self, value: Optional["str"]) -> None:
		"""Optional name of a table to write the query results to. Similar to SQL's `SELECT INTO`."""
		self._materialize_table = value
	@property
	def materialize_origin(self) -> Optional["QueryRequestQueryMaterializeOrigin"]:
		"""Identifies the origination of the requested materialize operation."""
		return self._materialize_origin
	@materialize_origin.setter
	def materialize_origin(self, value: Optional["QueryRequestQueryMaterializeOrigin"]) -> None:
		"""Identifies the origination of the requested materialize operation."""
		self._materialize_origin = value
	@property
	def materialize_operation(self) -> Optional["QueryMaterializeOperations"]:
		"""Flag to append/create/delete the results to/from the table named in `materializeTable`. By default the contents of `materializeTable` will be completely replaced with the results of this query."""
		return self._materialize_operation
	@materialize_operation.setter
	def materialize_operation(self, value: Optional["QueryMaterializeOperations"]) -> None:
		"""Flag to append/create/delete the results to/from the table named in `materializeTable`. By default the contents of `materializeTable` will be completely replaced with the results of this query."""
		self._materialize_operation = value
	@property
	def materialize_primary_key(self) -> Optional["str"]:
		"""When appending results to a materialized table, you can optionally specify a primary key to use to eliminate duplicate records."""
		return self._materialize_primary_key
	@materialize_primary_key.setter
	def materialize_primary_key(self, value: Optional["str"]) -> None:
		"""When appending results to a materialized table, you can optionally specify a primary key to use to eliminate duplicate records."""
		self._materialize_primary_key = value
	@property
	def materialize_s2_index(self) -> Optional["bool"]:
		"""When appending results to a materialized table, you can optionally specify whether the table will enable its S2 index."""
		return self._materialize_s2_index
	@materialize_s2_index.setter
	def materialize_s2_index(self, value: Optional["bool"]) -> None:
		"""When appending results to a materialized table, you can optionally specify whether the table will enable its S2 index."""
		self._materialize_s2_index = value
	@property
	def create_resource_on_materialize(self) -> Optional["bool"]:
		"""Flag to create a resource for managing the permissions of the new materialized table. Defaults to true."""
		return self._create_resource_on_materialize
	@create_resource_on_materialize.setter
	def create_resource_on_materialize(self, value: Optional["bool"]) -> None:
		"""Flag to create a resource for managing the permissions of the new materialized table. Defaults to true."""
		self._create_resource_on_materialize = value
	@property
	def materialize_classification(self) -> Optional["str"]:
		"""Value for the `classification` tag of the new materialized table."""
		return self._materialize_classification
	@materialize_classification.setter
	def materialize_classification(self, value: Optional["str"]) -> None:
		"""Value for the `classification` tag of the new materialized table."""
		self._materialize_classification = value
	@property
	def with_bounding_box(self) -> Optional["bool"]:
		"""Flag to return a bounding box in the `BBWKT` column for each row of the selected geospatial polygon data."""
		return self._with_bounding_box
	@with_bounding_box.setter
	def with_bounding_box(self, value: Optional["bool"]) -> None:
		"""Flag to return a bounding box in the `BBWKT` column for each row of the selected geospatial polygon data."""
		self._with_bounding_box = value
	@property
	def with_geo_json(self) -> Optional["bool"]:
		"""If `false`, contents of the `WKT` column will be WKT strings. If `true`, the `WKT` column will contain GeoJSON features."""
		return self._with_geo_json
	@with_geo_json.setter
	def with_geo_json(self, value: Optional["bool"]) -> None:
		"""If `false`, contents of the `WKT` column will be WKT strings. If `true`, the `WKT` column will contain GeoJSON features."""
		self._with_geo_json = value
	@property
	def select(self) -> Optional["QuerySelect"]:
		"""Specifies which geospatial column should be selected from `table`."""
		return self._select
	@select.setter
	def select(self, value: Optional["QuerySelect"]) -> None:
		"""Specifies which geospatial column should be selected from `table`."""
		self._select = value
	@property
	def table(self) -> "QueryTable":
		"""Specifies the data source of the query: a table, a sub-query, or a table-valued-function."""
		return self._table
	@table.setter
	def table(self, value: "QueryTable") -> None:
		"""Specifies the data source of the query: a table, a sub-query, or a table-valued-function."""
		self._table = value
	@property
	def where(self) -> Optional["QueryWhere"]:
		# pylint: disable=missing-function-docstring
		return self._where
	@where.setter
	def where(self, value: Optional["QueryWhere"]) -> None:
		# pylint: disable=missing-function-docstring
		self._where = value
	@property
	def having(self) -> Optional["QueryWhere"]:
		"""Warning: `having` is not fully implemented. Instead use `where` with `wherefirst = false` (the default)."""
		return self._having
	@having.setter
	def having(self, value: Optional["QueryWhere"]) -> None:
		"""Warning: `having` is not fully implemented. Instead use `where` with `wherefirst = false` (the default)."""
		self._having = value
	@property
	def order_by(self) -> Optional["List[str]"]:
		"""Specifies how the query results should be sorted."""
		return self._order_by
	@order_by.setter
	def order_by(self, value: Optional["List[str]"]) -> None:
		"""Specifies how the query results should be sorted."""
		self._order_by = value
	@property
	def group_by(self) -> Optional["List[str]"]:
		# pylint: disable=missing-function-docstring
		return self._group_by
	@group_by.setter
	def group_by(self, value: Optional["List[str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._group_by = value
	@property
	def join(self) -> Optional["QueryJoin"]:
		# pylint: disable=missing-function-docstring
		return self._join
	@join.setter
	def join(self, value: Optional["QueryJoin"]) -> None:
		# pylint: disable=missing-function-docstring
		self._join = value
	@property
	def sql_select(self) -> Optional["List[str]"]:
		"""Specify the fields/columns that will be returned in the results when the query is run."""
		return self._sql_select
	@sql_select.setter
	def sql_select(self, value: Optional["List[str]"]) -> None:
		"""Specify the fields/columns that will be returned in the results when the query is run."""
		self._sql_select = value
	@property
	def projection(self) -> Optional["ProjectionMode"]:
		"""The map projection.
* `mercator` - EPSG:3857
* `wgs84` - EPSG:4326"""
		return self._projection
	@projection.setter
	def projection(self, value: Optional["ProjectionMode"]) -> None:
		"""The map projection.
* `mercator` - EPSG:3857
* `wgs84` - EPSG:4326"""
		self._projection = value
	@property
	def remove_empty_columns(self) -> Optional["bool"]:
		"""Flag to remove result columns whose values are all null or whitespace. Useful with sparse data sets."""
		return self._remove_empty_columns
	@remove_empty_columns.setter
	def remove_empty_columns(self, value: Optional["bool"]) -> None:
		"""Flag to remove result columns whose values are all null or whitespace. Useful with sparse data sets."""
		self._remove_empty_columns = value
	@property
	def remove_zeroed_columns(self) -> Optional["bool"]:
		"""Flag to remove result columns whose values are all null, whitespace, 0, "0", EMPTY_DATE (1000-01-01), or the string version of EMPTY_DATE. Useful with sparse data sets."""
		return self._remove_zeroed_columns
	@remove_zeroed_columns.setter
	def remove_zeroed_columns(self, value: Optional["bool"]) -> None:
		"""Flag to remove result columns whose values are all null, whitespace, 0, "0", EMPTY_DATE (1000-01-01), or the string version of EMPTY_DATE. Useful with sparse data sets."""
		self._remove_zeroed_columns = value
	@property
	def truncate_string_length(self) -> Optional["int"]:
		"""Truncate strings that are longer than this value. Specify 0 to disable truncation. If the string is truncated, `truncateStringEllipsis` will be appended to the end."""
		return self._truncate_string_length
	@truncate_string_length.setter
	def truncate_string_length(self, value: Optional["int"]) -> None:
		"""Truncate strings that are longer than this value. Specify 0 to disable truncation. If the string is truncated, `truncateStringEllipsis` will be appended to the end."""
		self._truncate_string_length = value
	@property
	def truncate_string_ellipsis(self) -> Optional["str"]:
		"""The value to append to the end of truncated strings."""
		return self._truncate_string_ellipsis
	@truncate_string_ellipsis.setter
	def truncate_string_ellipsis(self, value: Optional["str"]) -> None:
		"""The value to append to the end of truncated strings."""
		self._truncate_string_ellipsis = value
	@property
	def raster(self) -> Optional["RasterRequest"]:
		# pylint: disable=missing-function-docstring
		return self._raster
	@raster.setter
	def raster(self, value: Optional["RasterRequest"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster = value
	@property
	def image(self) -> Optional["ImageRequest"]:
		# pylint: disable=missing-function-docstring
		return self._image
	@image.setter
	def image(self, value: Optional["ImageRequest"]) -> None:
		# pylint: disable=missing-function-docstring
		self._image = value
	@property
	def union_all(self) -> Optional["List[Query]"]:
		"""Combine the results of this query with other queries."""
		return self._union_all
	@union_all.setter
	def union_all(self, value: Optional["List[Query]"]) -> None:
		"""Combine the results of this query with other queries."""
		self._union_all = value
	@property
	def engine_version(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._engine_version
	@engine_version.setter
	def engine_version(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._engine_version = value
	@property
	def query_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._query_name
	@query_name.setter
	def query_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._query_name = value
	@property
	def query_tag(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._query_tag
	@query_tag.setter
	def query_tag(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._query_tag = value
	@property
	def dual_query_mode_testing(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._dual_query_mode_testing
	@dual_query_mode_testing.setter
	def dual_query_mode_testing(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._dual_query_mode_testing = value
	@property
	def binary_result_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._binary_result_column
	@binary_result_column.setter
	def binary_result_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._binary_result_column = value
	@property
	def domain(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._domain
	@domain.setter
	def domain(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._domain = value
	@property
	def cluster_key(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._cluster_key
	@cluster_key.setter
	def cluster_key(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._cluster_key = value
	@property
	def export_column_order(self) -> Optional["List[str]"]:
		# pylint: disable=missing-function-docstring
		return self._export_column_order
	@export_column_order.setter
	def export_column_order(self, value: Optional["List[str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._export_column_order = value
	@property
	def parallel(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._parallel
	@parallel.setter
	def parallel(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._parallel = value
	@property
	def parallel_debug(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._parallel_debug
	@parallel_debug.setter
	def parallel_debug(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._parallel_debug = value
	@property
	def bypass_caching(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._bypass_caching
	@bypass_caching.setter
	def bypass_caching(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._bypass_caching = value
	@property
	def parallel_table(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._parallel_table
	@parallel_table.setter
	def parallel_table(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._parallel_table = value
	@property
	def materialize_partition_columns(self) -> Optional["List[str]"]:
		# pylint: disable=missing-function-docstring
		return self._materialize_partition_columns
	@materialize_partition_columns.setter
	def materialize_partition_columns(self, value: Optional["List[str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._materialize_partition_columns = value
	@property
	def remote(self) -> Optional["RemoteQueryOptions"]:
		# pylint: disable=missing-function-docstring
		return self._remote
	@remote.setter
	def remote(self, value: Optional["RemoteQueryOptions"]) -> None:
		# pylint: disable=missing-function-docstring
		self._remote = value
	@property
	def column_stats(self) -> Optional["ColumnStatOptions"]:
		# pylint: disable=missing-function-docstring
		return self._column_stats
	@column_stats.setter
	def column_stats(self, value: Optional["ColumnStatOptions"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column_stats = value
	@property
	def live(self) -> Optional["LiveGroupingOptions"]:
		# pylint: disable=missing-function-docstring
		return self._live
	@live.setter
	def live(self, value: Optional["LiveGroupingOptions"]) -> None:
		# pylint: disable=missing-function-docstring
		self._live = value
	@property
	def query_source(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._query_source
	@query_source.setter
	def query_source(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._query_source = value
	@property
	def performance_counter_instance_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._performance_counter_instance_name
	@performance_counter_instance_name.setter
	def performance_counter_instance_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._performance_counter_instance_name = value
	@property
	def prune(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._prune
	@prune.setter
	def prune(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._prune = value
	@property
	def return_geo_by_reference(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._return_geo_by_reference
	@return_geo_by_reference.setter
	def return_geo_by_reference(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._return_geo_by_reference = value
class QueryColumn:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"type_": ("type", "ColumnType", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		type_: "ColumnType",
	) -> None:
		"""
		:param name:
		:type name: str
		:param type_: The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data.
		:type type_: ColumnType
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._type_ = cast(ColumnType, kwargs.get("type_"))
	@property
	def name(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def type_(self) -> "ColumnType":
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		return self._type_
	@type_.setter
	def type_(self, value: "ColumnType") -> None:
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		self._type_ = value
class QueryDatasource:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"type_": ("type", "QueryDatasourceTypes", None),
		"host": ("host", "str", None),
		"database": ("database", "str", None),
		"user": ("user", "str", None),
		"password": ("password", "str", None),
		"sql": ("sql", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		type_: Optional["QueryDatasourceTypes"] = None,
		host: Optional["str"] = None,
		database: Optional["str"] = None,
		user: Optional["str"] = None,
		password: Optional["str"] = None,
		sql: Optional["str"] = None,
	) -> None:
		"""
		:param type_: 
* `sqlserver` - Populate the table with data from a MS SQL Server database.
		:type type_: QueryDatasourceTypes or None
		:param host:
		:type host: str or None
		:param database:
		:type database: str or None
		:param user:
		:type user: str or None
		:param password:
		:type password: str or None
		:param sql:
		:type sql: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._type_ = cast(Optional[QueryDatasourceTypes], kwargs.get("type_"))
		self._host = cast(Optional[str], kwargs.get("host"))
		self._database = cast(Optional[str], kwargs.get("database"))
		self._user = cast(Optional[str], kwargs.get("user"))
		self._password = cast(Optional[str], kwargs.get("password"))
		self._sql = cast(Optional[str], kwargs.get("sql"))
	@property
	def type_(self) -> Optional["QueryDatasourceTypes"]:
		"""
* `sqlserver` - Populate the table with data from a MS SQL Server database."""
		return self._type_
	@type_.setter
	def type_(self, value: Optional["QueryDatasourceTypes"]) -> None:
		"""
* `sqlserver` - Populate the table with data from a MS SQL Server database."""
		self._type_ = value
	@property
	def host(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._host
	@host.setter
	def host(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._host = value
	@property
	def database(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._database
	@database.setter
	def database(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._database = value
	@property
	def user(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._user
	@user.setter
	def user(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._user = value
	@property
	def password(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._password
	@password.setter
	def password(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._password = value
	@property
	def sql(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._sql
	@sql.setter
	def sql(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._sql = value


class QueryDatasourceTypes(str, Enum):
	# pylint: disable=missing-class-docstring
	SQLSERVER = 'sqlserver'

QueryDatasourceTypes.SQLSERVER.__doc__ = """Populate the table with data from a MS SQL Server database."""
class QueryExportSettings(ExportSettings):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"kml_timestamp_column": ("kmlTimestampColumn", "str", None),
		"geo_format": ("geoFormat", "GeoFormat", None),
		"include_policies": ("includePolicies", "bool", None),
		"message_identifier": ("messageIdentifier", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		kml_timestamp_column: Optional["str"] = None,
		geo_format: Optional["GeoFormat"] = None,
		include_policies: Optional["bool"] = None,
		message_identifier: Optional["str"] = None,
	) -> None:
		"""
		:param kml_timestamp_column:
		:type kml_timestamp_column: str or None
		:param geo_format: If the Accept header is text/csv, specify the desired format for the geospatial data. Defaults to WKT.
		:type geo_format: GeoFormat or None
		:param include_policies:
		:type include_policies: bool or None
		:param message_identifier:
		:type message_identifier: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		ExportSettings.__init__(self,
			geo_format=kwargs.get("geo_format"),
			include_policies=kwargs.get("include_policies"),
			message_identifier=kwargs.get("message_identifier"),
		)
		self._kml_timestamp_column = cast(Optional[str], kwargs.get("kml_timestamp_column"))
	@property
	def kml_timestamp_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._kml_timestamp_column
	@kml_timestamp_column.setter
	def kml_timestamp_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._kml_timestamp_column = value
class QueryGeometry3D:
	"""Auto conversion settings for 3D outputs, such as KML and CZML"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name_column_or_val": ("nameColumnOrVal", "str", None),
		"altitude_column": ("altitudeColumn", "str", None),
		"altitude_units": ("altitudeUnits", "str", None),
		"altitude_multiplier": ("altitudeMultiplier", "float", None),
		"altitude_coordinate": ("altitudeCoordinate", "list", "WktDimsEnum"),
		"altitude_multiplier_specified": ("altitudeMultiplierSpecified", "bool", None),
		"geometry_column": ("geometryColumn", "str", None),
		"geometries": ("geometries", "list", "str"),
		"altitude_reference": ("altitudeReference", "AltitudeBase", None),
		"altitude_mode": ("altitudeMode", "LiftMode", None),
		"max_level": ("maxLevel", "int", None),
		"unique_id": ("UniqueId", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		altitude_multiplier: "float",
		altitude_coordinate: "WktDims",
		altitude_multiplier_specified: "bool",
		geometries: "List[str]",
		altitude_reference: "AltitudeBase",
		altitude_mode: "LiftMode",
		max_level: "int",
		unique_id: "str",
		name_column_or_val: Optional["str"] = None,
		altitude_column: Optional["str"] = None,
		altitude_units: Optional["str"] = None,
		geometry_column: Optional["str"] = None,
	) -> None:
		"""
		:param altitude_multiplier:
		:type altitude_multiplier: float
		:param altitude_coordinate:
		:type altitude_coordinate: WktDims
		:param altitude_multiplier_specified:
		:type altitude_multiplier_specified: bool
		:param geometries:
		:type geometries: List[str]
		:param altitude_reference:
		:type altitude_reference: AltitudeBase
		:param altitude_mode:
		:type altitude_mode: LiftMode
		:param max_level:
		:type max_level: int
		:param unique_id:
		:type unique_id: str
		:param name_column_or_val:
		:type name_column_or_val: str or None
		:param altitude_column:
		:type altitude_column: str or None
		:param altitude_units:
		:type altitude_units: str or None
		:param geometry_column:
		:type geometry_column: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name_column_or_val = cast(Optional[str], kwargs.get("name_column_or_val"))
		self._altitude_column = cast(Optional[str], kwargs.get("altitude_column"))
		self._altitude_units = cast(Optional[str], kwargs.get("altitude_units"))
		self._altitude_multiplier = cast(float, kwargs.get("altitude_multiplier"))
		self._altitude_coordinate = cast(WktDims, kwargs.get("altitude_coordinate"))
		self._altitude_multiplier_specified = cast(bool, kwargs.get("altitude_multiplier_specified"))
		self._geometry_column = cast(Optional[str], kwargs.get("geometry_column"))
		self._geometries = cast(List[str], kwargs.get("geometries"))
		self._altitude_reference = cast(AltitudeBase, kwargs.get("altitude_reference"))
		self._altitude_mode = cast(LiftMode, kwargs.get("altitude_mode"))
		self._max_level = cast(int, kwargs.get("max_level"))
		self._unique_id = cast(str, kwargs.get("unique_id"))
	@property
	def name_column_or_val(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name_column_or_val
	@name_column_or_val.setter
	def name_column_or_val(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name_column_or_val = value
	@property
	def altitude_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._altitude_column
	@altitude_column.setter
	def altitude_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._altitude_column = value
	@property
	def altitude_units(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._altitude_units
	@altitude_units.setter
	def altitude_units(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._altitude_units = value
	@property
	def altitude_multiplier(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._altitude_multiplier
	@altitude_multiplier.setter
	def altitude_multiplier(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._altitude_multiplier = value
	@property
	def altitude_coordinate(self) -> "WktDims":
		# pylint: disable=missing-function-docstring
		return self._altitude_coordinate
	@altitude_coordinate.setter
	def altitude_coordinate(self, value: "WktDims") -> None:
		# pylint: disable=missing-function-docstring
		self._altitude_coordinate = value
	@property
	def altitude_multiplier_specified(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._altitude_multiplier_specified
	@altitude_multiplier_specified.setter
	def altitude_multiplier_specified(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._altitude_multiplier_specified = value
	@property
	def geometry_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._geometry_column
	@geometry_column.setter
	def geometry_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._geometry_column = value
	@property
	def geometries(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._geometries
	@geometries.setter
	def geometries(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._geometries = value
	@property
	def altitude_reference(self) -> "AltitudeBase":
		# pylint: disable=missing-function-docstring
		return self._altitude_reference
	@altitude_reference.setter
	def altitude_reference(self, value: "AltitudeBase") -> None:
		# pylint: disable=missing-function-docstring
		self._altitude_reference = value
	@property
	def altitude_mode(self) -> "LiftMode":
		# pylint: disable=missing-function-docstring
		return self._altitude_mode
	@altitude_mode.setter
	def altitude_mode(self, value: "LiftMode") -> None:
		# pylint: disable=missing-function-docstring
		self._altitude_mode = value
	@property
	def max_level(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._max_level
	@max_level.setter
	def max_level(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._max_level = value
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
class QueryJoin:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"method": ("method", "str", None),
		"table": ("table", "QueryTable", None),
		"where": ("where", "QueryWhere", None),
		"having": ("having", "QueryWhere", None),
		"column_pairs": ("columnPairs", "list", "list"),
		"leftcolumn": ("leftcolumn", "str", None),
		"rightcolumn": ("rightcolumn", "str", None),
		"expression": ("expression", "str", None),
		"outer": ("outer", "bool", None),
		"cartesian": ("cartesian", "bool", None),
		"jointake": ("jointake", "int", None),
		"anti": ("anti", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		table: "QueryTable",
		anti: "bool",
		method: Optional["str"] = None,
		where: Optional["QueryWhere"] = None,
		having: Optional["QueryWhere"] = None,
		column_pairs: Optional["List[List[HashJoinDataLR]]"] = None,
		leftcolumn: Optional["str"] = None,
		rightcolumn: Optional["str"] = None,
		expression: Optional["str"] = None,
		outer: Optional["bool"] = None,
		cartesian: Optional["bool"] = None,
		jointake: Optional["int"] = None,
	) -> None:
		"""
		:param table: The "right" table of the join.
		:type table: QueryTable
		:param anti: Take all rows from the left side that don't match any rows from the right side.
		:type anti: bool
		:param method:
		:type method: str or None
		:param where:
		:type where: QueryWhere or None
		:param having: Warning: `having` is not fully implemented.
		:type having: QueryWhere or None
		:param column_pairs:
		:type column_pairs: List[List[HashJoinDataLR]] or None
		:param leftcolumn:
		:type leftcolumn: str or None
		:param rightcolumn:
		:type rightcolumn: str or None
		:param expression:
		:type expression: str or None
		:param outer:
		:type outer: bool or None
		:param cartesian:
		:type cartesian: bool or None
		:param jointake: Limits the number of rows from the right side matching the row from the left.
		:type jointake: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._method = cast(Optional[str], kwargs.get("method"))
		self._table = cast(QueryTable, kwargs.get("table"))
		self._where = cast(Optional[QueryWhere], kwargs.get("where"))
		self._having = cast(Optional[QueryWhere], kwargs.get("having"))
		self._column_pairs = cast(Optional[List[List[HashJoinDataLR]]], kwargs.get("column_pairs"))
		self._leftcolumn = cast(Optional[str], kwargs.get("leftcolumn"))
		self._rightcolumn = cast(Optional[str], kwargs.get("rightcolumn"))
		self._expression = cast(Optional[str], kwargs.get("expression"))
		self._outer = cast(Optional[bool], kwargs.get("outer"))
		self._cartesian = cast(Optional[bool], kwargs.get("cartesian"))
		self._jointake = cast(Optional[int], kwargs.get("jointake"))
		self._anti = cast(bool, kwargs.get("anti"))
	@property
	def method(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._method
	@method.setter
	def method(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._method = value
	@property
	def table(self) -> "QueryTable":
		"""The "right" table of the join."""
		return self._table
	@table.setter
	def table(self, value: "QueryTable") -> None:
		"""The "right" table of the join."""
		self._table = value
	@property
	def where(self) -> Optional["QueryWhere"]:
		# pylint: disable=missing-function-docstring
		return self._where
	@where.setter
	def where(self, value: Optional["QueryWhere"]) -> None:
		# pylint: disable=missing-function-docstring
		self._where = value
	@property
	def having(self) -> Optional["QueryWhere"]:
		"""Warning: `having` is not fully implemented."""
		return self._having
	@having.setter
	def having(self, value: Optional["QueryWhere"]) -> None:
		"""Warning: `having` is not fully implemented."""
		self._having = value
	@property
	def column_pairs(self) -> Optional["List[List[HashJoinDataLR]]"]:
		# pylint: disable=missing-function-docstring
		return self._column_pairs
	@column_pairs.setter
	def column_pairs(self, value: Optional["List[List[HashJoinDataLR]]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column_pairs = value
	@property
	def leftcolumn(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._leftcolumn
	@leftcolumn.setter
	def leftcolumn(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._leftcolumn = value
	@property
	def rightcolumn(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._rightcolumn
	@rightcolumn.setter
	def rightcolumn(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rightcolumn = value
	@property
	def expression(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._expression
	@expression.setter
	def expression(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._expression = value
	@property
	def outer(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._outer
	@outer.setter
	def outer(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._outer = value
	@property
	def cartesian(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._cartesian
	@cartesian.setter
	def cartesian(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._cartesian = value
	@property
	def jointake(self) -> Optional["int"]:
		"""Limits the number of rows from the right side matching the row from the left."""
		return self._jointake
	@jointake.setter
	def jointake(self, value: Optional["int"]) -> None:
		"""Limits the number of rows from the right side matching the row from the left."""
		self._jointake = value
	@property
	def anti(self) -> "bool":
		"""Take all rows from the left side that don't match any rows from the right side."""
		return self._anti
	@anti.setter
	def anti(self, value: "bool") -> None:
		"""Take all rows from the left side that don't match any rows from the right side."""
		self._anti = value
class QueryLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"result": ("result", "Link", None),
		"export": ("export", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		result: "Link",
		export: "Link",
		self_: "Link",
	) -> None:
		"""
		:param result: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type result: Link
		:param export: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type export: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._result = cast(Link, kwargs.get("result"))
		self._export = cast(Link, kwargs.get("export"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def result(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._result
	@result.setter
	def result(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._result = value
	@property
	def export(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._export
	@export.setter
	def export(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._export = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value


class QueryMaterializeOperations(str, Enum):
	# pylint: disable=missing-class-docstring
	APPEND = 'Append'
	CREATE = 'Create'
	PK_DELETE = 'PKDelete'

class QueryProjectionCrsEntry:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"definition": ("definition", "str", None),
		"promote_to_3_d": ("promoteTo3d", "bool", None),
		"absolute_area": ("absoluteArea", "list", "list"),
		"absolute_area_clip_step": ("absoluteAreaClipStep", "float", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		absolute_area: "List[List[float]]",
		definition: Optional["str"] = None,
		promote_to_3_d: Optional["bool"] = None,
		absolute_area_clip_step: Optional["float"] = None,
	) -> None:
		"""
		:param absolute_area: If specified, override the default clipping area for the projection with these array values. An empty array means the whole world. These values must be mutually exclusive and are lat/long coordinates of the form: [[minX, minY, maxX, maxY],...,[minX, minY, maxX, maxY]].
		:type absolute_area: List[List[float]]
		:param definition: CRS definition value. Must be provided.
		:type definition: str or None
		:param promote_to_3_d: If true, promote the CRS to a 3D CRS when encountered.
		:type promote_to_3_d: bool or None
		:param absolute_area_clip_step: If shapes are clipped for the projection, this parameter controls the spacing of points along the new clipping line segment. 0 falls back to the default value, and -1 disables adding extra points.
		:type absolute_area_clip_step: float or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._definition = cast(Optional[str], kwargs.get("definition"))
		self._promote_to_3_d = cast(Optional[bool], kwargs.get("promote_to_3_d"))
		self._absolute_area = cast(List[List[float]], kwargs.get("absolute_area"))
		self._absolute_area_clip_step = cast(Optional[float], kwargs.get("absolute_area_clip_step"))
	@property
	def definition(self) -> Optional["str"]:
		"""CRS definition value. Must be provided."""
		return self._definition
	@definition.setter
	def definition(self, value: Optional["str"]) -> None:
		"""CRS definition value. Must be provided."""
		self._definition = value
	@property
	def promote_to_3_d(self) -> Optional["bool"]:
		"""If true, promote the CRS to a 3D CRS when encountered."""
		return self._promote_to_3_d
	@promote_to_3_d.setter
	def promote_to_3_d(self, value: Optional["bool"]) -> None:
		"""If true, promote the CRS to a 3D CRS when encountered."""
		self._promote_to_3_d = value
	@property
	def absolute_area(self) -> "List[List[float]]":
		"""If specified, override the default clipping area for the projection with these array values. An empty array means the whole world. These values must be mutually exclusive and are lat/long coordinates of the form: [[minX, minY, maxX, maxY],...,[minX, minY, maxX, maxY]]."""
		return self._absolute_area
	@absolute_area.setter
	def absolute_area(self, value: "List[List[float]]") -> None:
		"""If specified, override the default clipping area for the projection with these array values. An empty array means the whole world. These values must be mutually exclusive and are lat/long coordinates of the form: [[minX, minY, maxX, maxY],...,[minX, minY, maxX, maxY]]."""
		self._absolute_area = value
	@property
	def absolute_area_clip_step(self) -> Optional["float"]:
		"""If shapes are clipped for the projection, this parameter controls the spacing of points along the new clipping line segment. 0 falls back to the default value, and -1 disables adding extra points."""
		return self._absolute_area_clip_step
	@absolute_area_clip_step.setter
	def absolute_area_clip_step(self, value: Optional["float"]) -> None:
		"""If shapes are clipped for the projection, this parameter controls the spacing of points along the new clipping line segment. 0 falls back to the default value, and -1 disables adding extra points."""
		self._absolute_area_clip_step = value
class QueryProjectionOperation:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"strict": ("strict", "OperationStrictMode", None),
		"crs_options": ("crsOptions", None, None),
		"items": ("items", None, None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		strict: Optional["OperationStrictMode"] = None,
		crs_options: Optional["Union[QueryProjectionCrsEntry, List[QueryProjectionCrsEntry]]"] = None,
		items: Optional["Union[QueryProjectionOperationEntry, List[QueryProjectionOperationEntry]]"] = None,
	) -> None:
		"""
		:param strict: Set strict mode. Strictness could mean throwing an error if an explicit transform operation is requested but not supplied.
		:type strict: OperationStrictMode or None
		:param crs_options:
		:type crs_options: Union[QueryProjectionCrsEntry, List[QueryProjectionCrsEntry]] or None
		:param items:
		:type items: Union[QueryProjectionOperationEntry, List[QueryProjectionOperationEntry]] or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._strict = cast(Optional[OperationStrictMode], kwargs.get("strict"))
		self._crs_options = cast(Optional[Union[QueryProjectionCrsEntry, List[QueryProjectionCrsEntry]]], kwargs.get("crs_options"))
		self._items = cast(Optional[Union[QueryProjectionOperationEntry, List[QueryProjectionOperationEntry]]], kwargs.get("items"))
	@property
	def strict(self) -> Optional["OperationStrictMode"]:
		"""Set strict mode. Strictness could mean throwing an error if an explicit transform operation is requested but not supplied."""
		return self._strict
	@strict.setter
	def strict(self, value: Optional["OperationStrictMode"]) -> None:
		"""Set strict mode. Strictness could mean throwing an error if an explicit transform operation is requested but not supplied."""
		self._strict = value
	@property
	def crs_options(self) -> Optional["Union[QueryProjectionCrsEntry, List[QueryProjectionCrsEntry]]"]:
		# pylint: disable=missing-function-docstring
		return self._crs_options
	@crs_options.setter
	def crs_options(self, value: Optional["Union[QueryProjectionCrsEntry, List[QueryProjectionCrsEntry]]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._crs_options = value
	@property
	def items(self) -> Optional["Union[QueryProjectionOperationEntry, List[QueryProjectionOperationEntry]]"]:
		# pylint: disable=missing-function-docstring
		return self._items
	@items.setter
	def items(self, value: Optional["Union[QueryProjectionOperationEntry, List[QueryProjectionOperationEntry]]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._items = value
class QueryProjectionOperationEntry:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"source": ("source", "str", None),
		"target": ("target", "str", None),
		"definition": ("definition", "str", None),
		"authority": ("authority", "str", None),
		"include_missing_grids": ("includeMissingGrids", "bool", None),
		"partial_intersection": ("partialIntersection", "bool", None),
		"allow_ballpark": ("allowBallpark", "bool", None),
		"desired_accuracy": ("desiredAccuracy", "float", None),
		"crs_extent_use": ("crsExtentUse", "OperationCrsExtentUse", None),
		"area": ("area", "list", "float"),
		"bounds": ("bounds", "list", "list"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		source: "str",
		target: "str",
		area: "List[float]",
		bounds: "List[List[float]]",
		definition: Optional["str"] = None,
		authority: Optional["str"] = None,
		include_missing_grids: Optional["bool"] = None,
		partial_intersection: Optional["bool"] = None,
		allow_ballpark: Optional["bool"] = None,
		desired_accuracy: Optional["float"] = None,
		crs_extent_use: Optional["OperationCrsExtentUse"] = None,
	) -> None:
		"""
		:param source: Source crs name. Required.
		:type source: str
		:param target: Target crs name. Required.
		:type target: str
		:param area: Area expressed as an array of doubles. [west, south, east, west]
		:type area: List[float]
		:param bounds: Area expressed as a nested array of doubles. [[west, south],[east,north]]
		:type bounds: List[List[float]]
		:param definition: Definition string. Used to look up the operation by its name, id, or code. Alternatively, a normalized coordinate operation or concatenated operation PROJ string definition can be provided to be used for the transform operation.
		:type definition: str or None
		:param authority: Authority hint. Helpful if not dealing with the EPSG authority.
		:type authority: str or None
		:param include_missing_grids: If true, include results for operations with grids that are not found on the server.
		:type include_missing_grids: bool or None
		:param partial_intersection: If true, include results for operations whose areas partially intersect the area of interest.
		:type partial_intersection: bool or None
		:param allow_ballpark: If true, include the ballpark operation if available.
		:type allow_ballpark: bool or None
		:param desired_accuracy: If provided, only return operations whose accuracy value meet this desired accuracy value.
		:type desired_accuracy: float or None
		:param crs_extent_use: Include results for operations whose area of use meets this usage criteria.
		:type crs_extent_use: OperationCrsExtentUse or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._source = cast(str, kwargs.get("source"))
		self._target = cast(str, kwargs.get("target"))
		self._definition = cast(Optional[str], kwargs.get("definition"))
		self._authority = cast(Optional[str], kwargs.get("authority"))
		self._include_missing_grids = cast(Optional[bool], kwargs.get("include_missing_grids"))
		self._partial_intersection = cast(Optional[bool], kwargs.get("partial_intersection"))
		self._allow_ballpark = cast(Optional[bool], kwargs.get("allow_ballpark"))
		self._desired_accuracy = cast(Optional[float], kwargs.get("desired_accuracy"))
		self._crs_extent_use = cast(Optional[OperationCrsExtentUse], kwargs.get("crs_extent_use"))
		self._area = cast(List[float], kwargs.get("area"))
		self._bounds = cast(List[List[float]], kwargs.get("bounds"))
	@property
	def source(self) -> "str":
		"""Source crs name. Required."""
		return self._source
	@source.setter
	def source(self, value: "str") -> None:
		"""Source crs name. Required."""
		self._source = value
	@property
	def target(self) -> "str":
		"""Target crs name. Required."""
		return self._target
	@target.setter
	def target(self, value: "str") -> None:
		"""Target crs name. Required."""
		self._target = value
	@property
	def definition(self) -> Optional["str"]:
		"""Definition string. Used to look up the operation by its name, id, or code. Alternatively, a normalized coordinate operation or concatenated operation PROJ string definition can be provided to be used for the transform operation."""
		return self._definition
	@definition.setter
	def definition(self, value: Optional["str"]) -> None:
		"""Definition string. Used to look up the operation by its name, id, or code. Alternatively, a normalized coordinate operation or concatenated operation PROJ string definition can be provided to be used for the transform operation."""
		self._definition = value
	@property
	def authority(self) -> Optional["str"]:
		"""Authority hint. Helpful if not dealing with the EPSG authority."""
		return self._authority
	@authority.setter
	def authority(self, value: Optional["str"]) -> None:
		"""Authority hint. Helpful if not dealing with the EPSG authority."""
		self._authority = value
	@property
	def include_missing_grids(self) -> Optional["bool"]:
		"""If true, include results for operations with grids that are not found on the server."""
		return self._include_missing_grids
	@include_missing_grids.setter
	def include_missing_grids(self, value: Optional["bool"]) -> None:
		"""If true, include results for operations with grids that are not found on the server."""
		self._include_missing_grids = value
	@property
	def partial_intersection(self) -> Optional["bool"]:
		"""If true, include results for operations whose areas partially intersect the area of interest."""
		return self._partial_intersection
	@partial_intersection.setter
	def partial_intersection(self, value: Optional["bool"]) -> None:
		"""If true, include results for operations whose areas partially intersect the area of interest."""
		self._partial_intersection = value
	@property
	def allow_ballpark(self) -> Optional["bool"]:
		"""If true, include the ballpark operation if available."""
		return self._allow_ballpark
	@allow_ballpark.setter
	def allow_ballpark(self, value: Optional["bool"]) -> None:
		"""If true, include the ballpark operation if available."""
		self._allow_ballpark = value
	@property
	def desired_accuracy(self) -> Optional["float"]:
		"""If provided, only return operations whose accuracy value meet this desired accuracy value."""
		return self._desired_accuracy
	@desired_accuracy.setter
	def desired_accuracy(self, value: Optional["float"]) -> None:
		"""If provided, only return operations whose accuracy value meet this desired accuracy value."""
		self._desired_accuracy = value
	@property
	def crs_extent_use(self) -> Optional["OperationCrsExtentUse"]:
		"""Include results for operations whose area of use meets this usage criteria."""
		return self._crs_extent_use
	@crs_extent_use.setter
	def crs_extent_use(self, value: Optional["OperationCrsExtentUse"]) -> None:
		"""Include results for operations whose area of use meets this usage criteria."""
		self._crs_extent_use = value
	@property
	def area(self) -> "List[float]":
		"""Area expressed as an array of doubles. [west, south, east, west]"""
		return self._area
	@area.setter
	def area(self, value: "List[float]") -> None:
		"""Area expressed as an array of doubles. [west, south, east, west]"""
		self._area = value
	@property
	def bounds(self) -> "List[List[float]]":
		"""Area expressed as a nested array of doubles. [[west, south],[east,north]]"""
		return self._bounds
	@bounds.setter
	def bounds(self, value: "List[List[float]]") -> None:
		"""Area expressed as a nested array of doubles. [[west, south],[east,north]]"""
		self._bounds = value


class QueryRequestQueryMaterializeOrigin(str, Enum):
	# pylint: disable=missing-class-docstring
	UNKNOWN = 'Unknown'
	COPY = 'Copy'
	RENAME = 'Rename'

class QueryResponse:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"hash_": ("hash", "str", None),
		"links": ("_links", "QueryLinks", None),
		"columns": ("columns", "list", "QueryColumn"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		hash_: "str",
		links: "QueryLinks",
		columns: "List[QueryColumn]",
	) -> None:
		"""
		:param hash_: The query hash. An MD5 hash of a JSON object containing a single 'query' property containing the Query object.
		:type hash_: str
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: QueryLinks
		:param columns:
		:type columns: List[QueryColumn]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._hash_ = cast(str, kwargs.get("hash_"))
		self._links = cast(QueryLinks, kwargs.get("links"))
		self._columns = cast(List[QueryColumn], kwargs.get("columns"))
	@property
	def hash_(self) -> "str":
		"""The query hash. An MD5 hash of a JSON object containing a single 'query' property containing the Query object."""
		return self._hash_
	@hash_.setter
	def hash_(self, value: "str") -> None:
		"""The query hash. An MD5 hash of a JSON object containing a single 'query' property containing the Query object."""
		self._hash_ = value
	@property
	def links(self) -> "QueryLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "QueryLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
	@property
	def columns(self) -> "List[QueryColumn]":
		# pylint: disable=missing-function-docstring
		return self._columns
	@columns.setter
	def columns(self, value: "List[QueryColumn]") -> None:
		# pylint: disable=missing-function-docstring
		self._columns = value
class QuerySection:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"sub_sections": ("SubSections", "dict", "QuerySection"),
		"total_milliseconds": ("TotalMilliseconds", "int", None),
		"memory_used": ("MemoryUsed", "int", None),
		"row_count": ("RowCount", "int", None),
		"column_count": ("ColumnCount", "int", None),
		"sorted_": ("Sorted", "bool", None),
		"cached": ("Cached", "bool", None),
		"index_width": ("IndexWidth", "int", None),
		"item_name": ("ItemName", "str", None),
		"row_level_cache_hit_count": ("RowLevelCacheHitCount", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		sub_sections: "Dict[str, QuerySection]",
		total_milliseconds: Optional["int"] = None,
		memory_used: Optional["int"] = None,
		row_count: Optional["int"] = None,
		column_count: Optional["int"] = None,
		sorted_: Optional["bool"] = None,
		cached: Optional["bool"] = None,
		index_width: Optional["int"] = None,
		item_name: Optional["str"] = None,
		row_level_cache_hit_count: Optional["int"] = None,
	) -> None:
		"""
		:param sub_sections:
		:type sub_sections: Dict[str, QuerySection]
		:param total_milliseconds:
		:type total_milliseconds: int or None
		:param memory_used:
		:type memory_used: int or None
		:param row_count:
		:type row_count: int or None
		:param column_count:
		:type column_count: int or None
		:param sorted_:
		:type sorted_: bool or None
		:param cached:
		:type cached: bool or None
		:param index_width:
		:type index_width: int or None
		:param item_name:
		:type item_name: str or None
		:param row_level_cache_hit_count:
		:type row_level_cache_hit_count: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._sub_sections = cast(Dict[str, QuerySection], kwargs.get("sub_sections"))
		self._total_milliseconds = cast(Optional[int], kwargs.get("total_milliseconds"))
		self._memory_used = cast(Optional[int], kwargs.get("memory_used"))
		self._row_count = cast(Optional[int], kwargs.get("row_count"))
		self._column_count = cast(Optional[int], kwargs.get("column_count"))
		self._sorted_ = cast(Optional[bool], kwargs.get("sorted_"))
		self._cached = cast(Optional[bool], kwargs.get("cached"))
		self._index_width = cast(Optional[int], kwargs.get("index_width"))
		self._item_name = cast(Optional[str], kwargs.get("item_name"))
		self._row_level_cache_hit_count = cast(Optional[int], kwargs.get("row_level_cache_hit_count"))
	@property
	def sub_sections(self) -> "Dict[str, QuerySection]":
		# pylint: disable=missing-function-docstring
		return self._sub_sections
	@sub_sections.setter
	def sub_sections(self, value: "Dict[str, QuerySection]") -> None:
		# pylint: disable=missing-function-docstring
		self._sub_sections = value
	@property
	def total_milliseconds(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._total_milliseconds
	@total_milliseconds.setter
	def total_milliseconds(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._total_milliseconds = value
	@property
	def memory_used(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._memory_used
	@memory_used.setter
	def memory_used(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._memory_used = value
	@property
	def row_count(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._row_count
	@row_count.setter
	def row_count(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._row_count = value
	@property
	def column_count(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._column_count
	@column_count.setter
	def column_count(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column_count = value
	@property
	def sorted_(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._sorted_
	@sorted_.setter
	def sorted_(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._sorted_ = value
	@property
	def cached(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._cached
	@cached.setter
	def cached(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._cached = value
	@property
	def index_width(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._index_width
	@index_width.setter
	def index_width(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._index_width = value
	@property
	def item_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._item_name
	@item_name.setter
	def item_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._item_name = value
	@property
	def row_level_cache_hit_count(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._row_level_cache_hit_count
	@row_level_cache_hit_count.setter
	def row_level_cache_hit_count(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._row_level_cache_hit_count = value
class QuerySelect:
	"""Specifies which geospatial column should be selected from `table`."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"three_dgeometry": ("threeDGeometry", "QueryGeometry3D", None),
		"type_": ("type", None, None),
		"column": ("column", "str", None),
		"projection": ("projection", "str", None),
		"terrain": ("terrain", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		three_dgeometry: "QueryGeometry3D",
		type_: "Union[LayerType, str]",
		terrain: "bool",
		column: Optional["str"] = None,
		projection: Optional["str"] = None,
	) -> None:
		"""
		:param three_dgeometry: When specified, directs the generation of 3D geometry in detail, such as CZML and KML
		:type three_dgeometry: QueryGeometry3D
		:param type_: The type of geospatial data to select. One of: 'geo.dot', 'geo.poly', 'geo.line', 'geo.dotcluster', 'geo.markercluster', 'geo.pointcluster', 'geo.heat', 'geo.heat2', 'geo.heat2poly', 'geo.heat2line', 'geo.heat2multipoint', 'geo.raster', 'geo.trace', 'geo.image', or 'geo.graph'. A cluster size (16, 32, 64, 128, or 256) may be appended to 'geo.dotcluster' or 'geo.markercluster'. Cluster size defaults to 64.
		:type type_: Union[LayerType, str]
		:param terrain:
		:type terrain: bool
		:param column: The column that contains the desired geospatial data.
		:type column: str or None
		:param projection: Source projection to use for query geometry.
		:type projection: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._three_dgeometry = cast(QueryGeometry3D, kwargs.get("three_dgeometry"))
		self._type_ = cast(Union[LayerType, str], kwargs.get("type_"))
		self._column = cast(Optional[str], kwargs.get("column"))
		self._projection = cast(Optional[str], kwargs.get("projection"))
		self._terrain = cast(bool, kwargs.get("terrain"))
	@property
	def three_dgeometry(self) -> "QueryGeometry3D":
		"""When specified, directs the generation of 3D geometry in detail, such as CZML and KML"""
		return self._three_dgeometry
	@three_dgeometry.setter
	def three_dgeometry(self, value: "QueryGeometry3D") -> None:
		"""When specified, directs the generation of 3D geometry in detail, such as CZML and KML"""
		self._three_dgeometry = value
	@property
	def type_(self) -> "Union[LayerType, str]":
		"""The type of geospatial data to select. One of: 'geo.dot', 'geo.poly', 'geo.line', 'geo.dotcluster', 'geo.markercluster', 'geo.pointcluster', 'geo.heat', 'geo.heat2', 'geo.heat2poly', 'geo.heat2line', 'geo.heat2multipoint', 'geo.raster', 'geo.trace', 'geo.image', or 'geo.graph'. A cluster size (16, 32, 64, 128, or 256) may be appended to 'geo.dotcluster' or 'geo.markercluster'. Cluster size defaults to 64."""
		return self._type_
	@type_.setter
	def type_(self, value: "Union[LayerType, str]") -> None:
		"""The type of geospatial data to select. One of: 'geo.dot', 'geo.poly', 'geo.line', 'geo.dotcluster', 'geo.markercluster', 'geo.pointcluster', 'geo.heat', 'geo.heat2', 'geo.heat2poly', 'geo.heat2line', 'geo.heat2multipoint', 'geo.raster', 'geo.trace', 'geo.image', or 'geo.graph'. A cluster size (16, 32, 64, 128, or 256) may be appended to 'geo.dotcluster' or 'geo.markercluster'. Cluster size defaults to 64."""
		self._type_ = value
	@property
	def column(self) -> Optional["str"]:
		"""The column that contains the desired geospatial data."""
		return self._column
	@column.setter
	def column(self, value: Optional["str"]) -> None:
		"""The column that contains the desired geospatial data."""
		self._column = value
	@property
	def projection(self) -> Optional["str"]:
		"""Source projection to use for query geometry."""
		return self._projection
	@projection.setter
	def projection(self, value: Optional["str"]) -> None:
		"""Source projection to use for query geometry."""
		self._projection = value
	@property
	def terrain(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._terrain
	@terrain.setter
	def terrain(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._terrain = value
class QueryStats:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"tree": ("tree", "QuerySection", None),
		"engine_version": ("EngineVersion", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		tree: "QuerySection",
		engine_version: "int",
	) -> None:
		"""
		:param tree:
		:type tree: QuerySection
		:param engine_version:
		:type engine_version: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._tree = cast(QuerySection, kwargs.get("tree"))
		self._engine_version = cast(int, kwargs.get("engine_version"))
	@property
	def tree(self) -> "QuerySection":
		# pylint: disable=missing-function-docstring
		return self._tree
	@tree.setter
	def tree(self, value: "QuerySection") -> None:
		# pylint: disable=missing-function-docstring
		self._tree = value
	@property
	def engine_version(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._engine_version
	@engine_version.setter
	def engine_version(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._engine_version = value
class QueryTable:
	"""Specifies the data source of the query: a table, a sub-query, or a table-valued-function."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"alias": ("alias", "str", None),
		"query": ("query", "Query", None),
		"function": ("function", "QueryTableFunction", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: Optional["str"] = None,
		alias: Optional["str"] = None,
		query: Optional["Query"] = None,
		function: Optional["QueryTableFunction"] = None,
	) -> None:
		"""
		:param name: The name of the table to select from.
		:type name: str or None
		:param alias: Table alias.
		:type alias: str or None
		:param query: A sub-query to select from instead of a table.
		:type query: Query or None
		:param function: A table-valued-function to select from instead of a table.
		:type function: QueryTableFunction or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._alias = cast(Optional[str], kwargs.get("alias"))
		self._query = cast(Optional[Query], kwargs.get("query"))
		self._function = cast(Optional[QueryTableFunction], kwargs.get("function"))
	@property
	def name(self) -> Optional["str"]:
		"""The name of the table to select from."""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""The name of the table to select from."""
		self._name = value
	@property
	def alias(self) -> Optional["str"]:
		"""Table alias."""
		return self._alias
	@alias.setter
	def alias(self, value: Optional["str"]) -> None:
		"""Table alias."""
		self._alias = value
	@property
	def query(self) -> Optional["Query"]:
		"""A sub-query to select from instead of a table."""
		return self._query
	@query.setter
	def query(self, value: Optional["Query"]) -> None:
		"""A sub-query to select from instead of a table."""
		self._query = value
	@property
	def function(self) -> Optional["QueryTableFunction"]:
		"""A table-valued-function to select from instead of a table."""
		return self._function
	@function.setter
	def function(self, value: Optional["QueryTableFunction"]) -> None:
		"""A table-valued-function to select from instead of a table."""
		self._function = value
class QueryTableFunction:
	"""A table-valued-function to select from instead of a table."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"input_tables": ("InputTables", "dict", "FilteredTable"),
		"param": ("Param", "dict", None),
		"name": ("name", "str", None),
		"account": ("account", "str", None),
		"materialize_table_name": ("materializeTableName", "str", None),
		"params": ("params", "dict", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		input_tables: "Dict[str, FilteredTable]",
		param: "Dict[str, Any]",
		name: "str",
		params: "Dict[str, Any]",
		account: Optional["str"] = None,
		materialize_table_name: Optional["str"] = None,
	) -> None:
		"""
		:param input_tables:
		:type input_tables: Dict[str, FilteredTable]
		:param param:
		:type param: Dict[str, Any]
		:param name:
		:type name: str
		:param params:
		:type params: Dict[str, Any]
		:param account:
		:type account: str or None
		:param materialize_table_name:
		:type materialize_table_name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._input_tables = cast(Dict[str, FilteredTable], kwargs.get("input_tables"))
		self._param = cast(Dict[str, Any], kwargs.get("param"))
		self._name = cast(str, kwargs.get("name"))
		self._account = cast(Optional[str], kwargs.get("account"))
		self._materialize_table_name = cast(Optional[str], kwargs.get("materialize_table_name"))
		self._params = cast(Dict[str, Any], kwargs.get("params"))
	@property
	def input_tables(self) -> "Dict[str, FilteredTable]":
		# pylint: disable=missing-function-docstring
		return self._input_tables
	@input_tables.setter
	def input_tables(self, value: "Dict[str, FilteredTable]") -> None:
		# pylint: disable=missing-function-docstring
		self._input_tables = value
	@property
	def param(self) -> "Dict[str, Any]":
		# pylint: disable=missing-function-docstring
		return self._param
	@param.setter
	def param(self, value: "Dict[str, Any]") -> None:
		# pylint: disable=missing-function-docstring
		self._param = value
	@property
	def name(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def account(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._account
	@account.setter
	def account(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._account = value
	@property
	def materialize_table_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._materialize_table_name
	@materialize_table_name.setter
	def materialize_table_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._materialize_table_name = value
	@property
	def params(self) -> "Dict[str, Any]":
		# pylint: disable=missing-function-docstring
		return self._params
	@params.setter
	def params(self, value: "Dict[str, Any]") -> None:
		# pylint: disable=missing-function-docstring
		self._params = value



QueryWhere = Union["List[List[QueryWhereAndElement]]", "QueryWhereTest", "QueryWhereExpression"]



QueryWhereAndElement = Union["QueryWhereTest", "QueryWhereExpression"]
class QueryWhereExpression:
	"""A single constraint for a where clause, written as a string expression using C#-like syntax."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"expression": ("expression", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		expression: "str",
	) -> None:
		"""
		:param expression: An expression to evaluate, using C#-like syntax.
		:type expression: str
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._expression = cast(str, kwargs.get("expression"))
	@property
	def expression(self) -> "str":
		"""An expression to evaluate, using C#-like syntax."""
		return self._expression
	@expression.setter
	def expression(self, value: "str") -> None:
		"""An expression to evaluate, using C#-like syntax."""
		self._expression = value



QueryWhereLiteral = Union["int", "str", "float", "datetime"]
class QueryWhereTest:
	"""A single constraint for a where clause. Compares a column against a value using the specified `test`, or comparison operator."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"column": ("column", "str", None),
		"test": ("test", None, None),
		"value": ("value", "QueryWhereValue", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		column: Optional["str"] = None,
		test: Optional["Union[TestSymbol, str]"] = None,
		value: Optional["QueryWhereValue"] = None,
	) -> None:
		"""
		:param column: The data to test. Either 'column', 'column.aggregate', 'account/table.column', or 'account/table.column.aggregate'.
		:type column: str or None
		:param test: The comparison operator. Compares `column` against `value`.
		:type test: Union[TestSymbol, str] or None
		:param value: The value to test against.
		:type value: QueryWhereValue or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._column = cast(Optional[str], kwargs.get("column"))
		self._test = cast(Optional[Union[TestSymbol, str]], kwargs.get("test"))
		self._value = cast(Optional[QueryWhereValue], kwargs.get("value"))
	@property
	def column(self) -> Optional["str"]:
		"""The data to test. Either 'column', 'column.aggregate', 'account/table.column', or 'account/table.column.aggregate'."""
		return self._column
	@column.setter
	def column(self, value: Optional["str"]) -> None:
		"""The data to test. Either 'column', 'column.aggregate', 'account/table.column', or 'account/table.column.aggregate'."""
		self._column = value
	@property
	def test(self) -> Optional["Union[TestSymbol, str]"]:
		"""The comparison operator. Compares `column` against `value`."""
		return self._test
	@test.setter
	def test(self, value: Optional["Union[TestSymbol, str]"]) -> None:
		"""The comparison operator. Compares `column` against `value`."""
		self._test = value
	@property
	def value(self) -> Optional["QueryWhereValue"]:
		"""The value to test against."""
		return self._value
	@value.setter
	def value(self, value: Optional["QueryWhereValue"]) -> None:
		"""The value to test against."""
		self._value = value



QueryWhereValue = Union["List[QueryWhereValueArrayElement]", "QueryWhereLiteral", "QueryWhereValueQuery", "QueryWhereValueMinMax"]



QueryWhereValueArrayElement = Union["QueryWhereValueMinMax", "QueryWhereLiteral"]
class QueryWhereValueMinMax:
	"""Specifies a range of values to compare against the column. For use with comparison operators such as 'Between'."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"min_": ("min", "QueryWhereLiteral", None),
		"max_": ("max", "QueryWhereLiteral", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		min_: Optional["QueryWhereLiteral"] = None,
		max_: Optional["QueryWhereLiteral"] = None,
	) -> None:
		"""
		:param min_:
		:type min_: QueryWhereLiteral or None
		:param max_:
		:type max_: QueryWhereLiteral or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._min_ = cast(Optional[QueryWhereLiteral], kwargs.get("min_"))
		self._max_ = cast(Optional[QueryWhereLiteral], kwargs.get("max_"))
	@property
	def min_(self) -> Optional["QueryWhereLiteral"]:
		# pylint: disable=missing-function-docstring
		return self._min_
	@min_.setter
	def min_(self, value: Optional["QueryWhereLiteral"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_ = value
	@property
	def max_(self) -> Optional["QueryWhereLiteral"]:
		# pylint: disable=missing-function-docstring
		return self._max_
	@max_.setter
	def max_(self, value: Optional["QueryWhereLiteral"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_ = value
class QueryWhereValueQuery:
	"""Specifies a sub-query to provide the values to compare against the column."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"query": ("query", "Query", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		query: "Query",
	) -> None:
		"""
		:param query: A sub-query to get values to compare against.
		:type query: Query
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._query = cast(Query, kwargs.get("query"))
	@property
	def query(self) -> "Query":
		"""A sub-query to get values to compare against."""
		return self._query
	@query.setter
	def query(self, value: "Query") -> None:
		"""A sub-query to get values to compare against."""
		self._query = value
class QueueDepths:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"work": ("work", "int", None),
		"schedule": ("schedule", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		work: "int",
		schedule: "int",
	) -> None:
		"""
		:param work: The number of state machine requests awaiting start
		:type work: int
		:param schedule: The number of pending transactions with dependencies ready to apply once dependencies are resolved
		:type schedule: int
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._work = cast(int, kwargs.get("work"))
		self._schedule = cast(int, kwargs.get("schedule"))
	@property
	def work(self) -> "int":
		"""The number of state machine requests awaiting start"""
		return self._work
	@work.setter
	def work(self, value: "int") -> None:
		"""The number of state machine requests awaiting start"""
		self._work = value
	@property
	def schedule(self) -> "int":
		"""The number of pending transactions with dependencies ready to apply once dependencies are resolved"""
		return self._schedule
	@schedule.setter
	def schedule(self, value: "int") -> None:
		"""The number of pending transactions with dependencies ready to apply once dependencies are resolved"""
		self._schedule = value
class Ramp:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"links": ("links", "RampLinks", None),
		"well_known_pipeline_id": ("wellKnownPipelineId", "str", None),
		"id_": ("id", "str", None),
		"name": ("name", "str", None),
		"requested_status": ("requestedStatus", "str", None),
		"actual_status": ("actualStatus", "str", None),
		"connector_app_name": ("connectorAppName", "str", None),
		"connector_plugin_name": ("connectorPluginName", "str", None),
		"connector_options": ("connectorOptions", None, None),
		"pipeline_definition": ("pipelineDefinition", None, None),
		"effective_user_name": ("effectiveUserName", "str", None),
		"required_cluster_role": ("requiredClusterRole", "str", None),
		"performance_counter_instance_name": ("performanceCounterInstanceName", "str", None),
		"running_on_servers": ("runningOnServers", "int", None),
		"faulted_on_servers": ("faultedOnServers", "int", None),
		"non_fatal_on_servers": ("nonFatalOnServers", "int", None),
		"support_incremental_update": ("supportIncrementalUpdate", "bool", None),
		"pipeline_parameters": ("pipelineParameters", "dict", "str"),
		"verbose_logging": ("verboseLogging", "bool", None),
		"table_logging": ("tableLogging", "bool", None),
		"is_export_ramp": ("isExportRamp", "bool", None),
		"faulted_retry_attempts": ("faultedRetryAttempts", "int", None),
		"faulted_retry_delay": ("faultedRetryDelay", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		links: "RampLinks",
		running_on_servers: "int",
		faulted_on_servers: "int",
		non_fatal_on_servers: "int",
		support_incremental_update: "bool",
		pipeline_parameters: "Dict[str, str]",
		verbose_logging: "bool",
		table_logging: "bool",
		is_export_ramp: "bool",
		well_known_pipeline_id: Optional["str"] = None,
		id_: Optional["str"] = None,
		name: Optional["str"] = None,
		requested_status: Optional["str"] = None,
		actual_status: Optional["str"] = None,
		connector_app_name: Optional["str"] = None,
		connector_plugin_name: Optional["str"] = None,
		connector_options: Optional["Any"] = None,
		pipeline_definition: Optional["Any"] = None,
		effective_user_name: Optional["str"] = None,
		required_cluster_role: Optional["str"] = None,
		performance_counter_instance_name: Optional["str"] = None,
		faulted_retry_attempts: Optional["int"] = None,
		faulted_retry_delay: Optional["int"] = None,
	) -> None:
		"""
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: RampLinks
		:param running_on_servers: The number of nodes that the ramp is executing on
		:type running_on_servers: int
		:param faulted_on_servers: The number of nodes that the ramp has failed
		:type faulted_on_servers: int
		:param non_fatal_on_servers: The number of nodes where the ramp has a non-fatal warning
		:type non_fatal_on_servers: int
		:param support_incremental_update: Indicates that the connector supports incremental updates in the code
		:type support_incremental_update: bool
		:param pipeline_parameters: A collection of key value pairs containing specific pipeline run options and their values
		:type pipeline_parameters: Dict[str, str]
		:param verbose_logging: If true, detailed pipeline execution results are added to the server log if Information level logging is enabled.
		:type verbose_logging: bool
		:param table_logging: If true, detailed pipeline execution results are logged to a table.
		:type table_logging: bool
		:param is_export_ramp: If true, denotes an Off Ramp.
		:type is_export_ramp: bool
		:param well_known_pipeline_id: The id of an existing pipeline. Either this or PipelineDefinition must be specified.
		:type well_known_pipeline_id: str or None
		:param id_: The ramp's unique id
		:type id_: str or None
		:param name: The ramp's unique human friendly identifier
		:type name: str or None
		:param requested_status: The ramp's desired execution state. Either 'Started' or 'Stopped'
		:type requested_status: str or None
		:param actual_status: The ramp's present execution state. Possible values are 'Stopped', 'Running', 'Faulted' or 'PartiallyFaulted'
		:type actual_status: str or None
		:param connector_app_name: The name of the Maplarge application that contains the connector or observer plugin. Either 'MapLargeCore' or the name of a custom application build with the Maplarge Development Kit (ADK).'
		:type connector_app_name: str or None
		:param connector_plugin_name: The name of the connector or observer plugin.
		:type connector_plugin_name: str or None
		:param connector_options: A JSON object containing parameters for the specified connector or observer.
		:type connector_options: Any or None
		:param pipeline_definition: A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified.
		:type pipeline_definition: Any or None
		:param effective_user_name: The permissions that the ramp will use to execute.
		:type effective_user_name: str or None
		:param required_cluster_role: The required role of node within a cluster required to execute the ramp, if any. May be required if duplicates are possible in the pipeline input.
		:type required_cluster_role: str or None
		:param performance_counter_instance_name: The name of the performance counter instance for this ramp.
		:type performance_counter_instance_name: str or None
		:param faulted_retry_attempts: The number of times that MapLarge will automatically retry when the ramp encounters an error.
		:type faulted_retry_attempts: int or None
		:param faulted_retry_delay: The minimum delay (in seconds) before the ramp will automatically retry when the ramp encounters an error.
		:type faulted_retry_delay: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._links = cast(RampLinks, kwargs.get("links"))
		self._well_known_pipeline_id = cast(Optional[str], kwargs.get("well_known_pipeline_id"))
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._requested_status = cast(Optional[str], kwargs.get("requested_status"))
		self._actual_status = cast(Optional[str], kwargs.get("actual_status"))
		self._connector_app_name = cast(Optional[str], kwargs.get("connector_app_name"))
		self._connector_plugin_name = cast(Optional[str], kwargs.get("connector_plugin_name"))
		self._connector_options = kwargs.get("connector_options")
		self._pipeline_definition = kwargs.get("pipeline_definition")
		self._effective_user_name = cast(Optional[str], kwargs.get("effective_user_name"))
		self._required_cluster_role = cast(Optional[str], kwargs.get("required_cluster_role"))
		self._performance_counter_instance_name = cast(Optional[str], kwargs.get("performance_counter_instance_name"))
		self._running_on_servers = cast(int, kwargs.get("running_on_servers"))
		self._faulted_on_servers = cast(int, kwargs.get("faulted_on_servers"))
		self._non_fatal_on_servers = cast(int, kwargs.get("non_fatal_on_servers"))
		self._support_incremental_update = cast(bool, kwargs.get("support_incremental_update"))
		self._pipeline_parameters = cast(Dict[str, str], kwargs.get("pipeline_parameters"))
		self._verbose_logging = cast(bool, kwargs.get("verbose_logging"))
		self._table_logging = cast(bool, kwargs.get("table_logging"))
		self._is_export_ramp = cast(bool, kwargs.get("is_export_ramp"))
		self._faulted_retry_attempts = cast(Optional[int], kwargs.get("faulted_retry_attempts"))
		self._faulted_retry_delay = cast(Optional[int], kwargs.get("faulted_retry_delay"))
	@property
	def links(self) -> "RampLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "RampLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
	@property
	def well_known_pipeline_id(self) -> Optional["str"]:
		"""The id of an existing pipeline. Either this or PipelineDefinition must be specified."""
		return self._well_known_pipeline_id
	@well_known_pipeline_id.setter
	def well_known_pipeline_id(self, value: Optional["str"]) -> None:
		"""The id of an existing pipeline. Either this or PipelineDefinition must be specified."""
		self._well_known_pipeline_id = value
	@property
	def id_(self) -> Optional["str"]:
		"""The ramp's unique id"""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		"""The ramp's unique id"""
		self._id_ = value
	@property
	def name(self) -> Optional["str"]:
		"""The ramp's unique human friendly identifier"""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""The ramp's unique human friendly identifier"""
		self._name = value
	@property
	def requested_status(self) -> Optional["str"]:
		"""The ramp's desired execution state. Either 'Started' or 'Stopped'"""
		return self._requested_status
	@requested_status.setter
	def requested_status(self, value: Optional["str"]) -> None:
		"""The ramp's desired execution state. Either 'Started' or 'Stopped'"""
		self._requested_status = value
	@property
	def actual_status(self) -> Optional["str"]:
		"""The ramp's present execution state. Possible values are 'Stopped', 'Running', 'Faulted' or 'PartiallyFaulted'"""
		return self._actual_status
	@actual_status.setter
	def actual_status(self, value: Optional["str"]) -> None:
		"""The ramp's present execution state. Possible values are 'Stopped', 'Running', 'Faulted' or 'PartiallyFaulted'"""
		self._actual_status = value
	@property
	def connector_app_name(self) -> Optional["str"]:
		"""The name of the Maplarge application that contains the connector or observer plugin. Either 'MapLargeCore' or the name of a custom application build with the Maplarge Development Kit (ADK).'"""
		return self._connector_app_name
	@connector_app_name.setter
	def connector_app_name(self, value: Optional["str"]) -> None:
		"""The name of the Maplarge application that contains the connector or observer plugin. Either 'MapLargeCore' or the name of a custom application build with the Maplarge Development Kit (ADK).'"""
		self._connector_app_name = value
	@property
	def connector_plugin_name(self) -> Optional["str"]:
		"""The name of the connector or observer plugin."""
		return self._connector_plugin_name
	@connector_plugin_name.setter
	def connector_plugin_name(self, value: Optional["str"]) -> None:
		"""The name of the connector or observer plugin."""
		self._connector_plugin_name = value
	@property
	def connector_options(self) -> Optional["Any"]:
		"""A JSON object containing parameters for the specified connector or observer."""
		return self._connector_options
	@connector_options.setter
	def connector_options(self, value: Optional["Any"]) -> None:
		"""A JSON object containing parameters for the specified connector or observer."""
		self._connector_options = value
	@property
	def pipeline_definition(self) -> Optional["Any"]:
		"""A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified."""
		return self._pipeline_definition
	@pipeline_definition.setter
	def pipeline_definition(self, value: Optional["Any"]) -> None:
		"""A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified."""
		self._pipeline_definition = value
	@property
	def effective_user_name(self) -> Optional["str"]:
		"""The permissions that the ramp will use to execute."""
		return self._effective_user_name
	@effective_user_name.setter
	def effective_user_name(self, value: Optional["str"]) -> None:
		"""The permissions that the ramp will use to execute."""
		self._effective_user_name = value
	@property
	def required_cluster_role(self) -> Optional["str"]:
		"""The required role of node within a cluster required to execute the ramp, if any. May be required if duplicates are possible in the pipeline input."""
		return self._required_cluster_role
	@required_cluster_role.setter
	def required_cluster_role(self, value: Optional["str"]) -> None:
		"""The required role of node within a cluster required to execute the ramp, if any. May be required if duplicates are possible in the pipeline input."""
		self._required_cluster_role = value
	@property
	def performance_counter_instance_name(self) -> Optional["str"]:
		"""The name of the performance counter instance for this ramp."""
		return self._performance_counter_instance_name
	@performance_counter_instance_name.setter
	def performance_counter_instance_name(self, value: Optional["str"]) -> None:
		"""The name of the performance counter instance for this ramp."""
		self._performance_counter_instance_name = value
	@property
	def running_on_servers(self) -> "int":
		"""The number of nodes that the ramp is executing on"""
		return self._running_on_servers
	@running_on_servers.setter
	def running_on_servers(self, value: "int") -> None:
		"""The number of nodes that the ramp is executing on"""
		self._running_on_servers = value
	@property
	def faulted_on_servers(self) -> "int":
		"""The number of nodes that the ramp has failed"""
		return self._faulted_on_servers
	@faulted_on_servers.setter
	def faulted_on_servers(self, value: "int") -> None:
		"""The number of nodes that the ramp has failed"""
		self._faulted_on_servers = value
	@property
	def non_fatal_on_servers(self) -> "int":
		"""The number of nodes where the ramp has a non-fatal warning"""
		return self._non_fatal_on_servers
	@non_fatal_on_servers.setter
	def non_fatal_on_servers(self, value: "int") -> None:
		"""The number of nodes where the ramp has a non-fatal warning"""
		self._non_fatal_on_servers = value
	@property
	def support_incremental_update(self) -> "bool":
		"""Indicates that the connector supports incremental updates in the code"""
		return self._support_incremental_update
	@support_incremental_update.setter
	def support_incremental_update(self, value: "bool") -> None:
		"""Indicates that the connector supports incremental updates in the code"""
		self._support_incremental_update = value
	@property
	def pipeline_parameters(self) -> "Dict[str, str]":
		"""A collection of key value pairs containing specific pipeline run options and their values"""
		return self._pipeline_parameters
	@pipeline_parameters.setter
	def pipeline_parameters(self, value: "Dict[str, str]") -> None:
		"""A collection of key value pairs containing specific pipeline run options and their values"""
		self._pipeline_parameters = value
	@property
	def verbose_logging(self) -> "bool":
		"""If true, detailed pipeline execution results are added to the server log if Information level logging is enabled."""
		return self._verbose_logging
	@verbose_logging.setter
	def verbose_logging(self, value: "bool") -> None:
		"""If true, detailed pipeline execution results are added to the server log if Information level logging is enabled."""
		self._verbose_logging = value
	@property
	def table_logging(self) -> "bool":
		"""If true, detailed pipeline execution results are logged to a table."""
		return self._table_logging
	@table_logging.setter
	def table_logging(self, value: "bool") -> None:
		"""If true, detailed pipeline execution results are logged to a table."""
		self._table_logging = value
	@property
	def is_export_ramp(self) -> "bool":
		"""If true, denotes an Off Ramp."""
		return self._is_export_ramp
	@is_export_ramp.setter
	def is_export_ramp(self, value: "bool") -> None:
		"""If true, denotes an Off Ramp."""
		self._is_export_ramp = value
	@property
	def faulted_retry_attempts(self) -> Optional["int"]:
		"""The number of times that MapLarge will automatically retry when the ramp encounters an error."""
		return self._faulted_retry_attempts
	@faulted_retry_attempts.setter
	def faulted_retry_attempts(self, value: Optional["int"]) -> None:
		"""The number of times that MapLarge will automatically retry when the ramp encounters an error."""
		self._faulted_retry_attempts = value
	@property
	def faulted_retry_delay(self) -> Optional["int"]:
		"""The minimum delay (in seconds) before the ramp will automatically retry when the ramp encounters an error."""
		return self._faulted_retry_delay
	@faulted_retry_delay.setter
	def faulted_retry_delay(self, value: Optional["int"]) -> None:
		"""The minimum delay (in seconds) before the ramp will automatically retry when the ramp encounters an error."""
		self._faulted_retry_delay = value
class RampExport:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"ramps": ("Ramps", "list", "Ramp"),
		"pipeline_defs": ("PipelineDefs", "list", "Pipeline"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		ramps: "List[Ramp]",
		pipeline_defs: "List[Pipeline]",
	) -> None:
		"""
		:param ramps:
		:type ramps: List[Ramp]
		:param pipeline_defs:
		:type pipeline_defs: List[Pipeline]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._ramps = cast(List[Ramp], kwargs.get("ramps"))
		self._pipeline_defs = cast(List[Pipeline], kwargs.get("pipeline_defs"))
	@property
	def ramps(self) -> "List[Ramp]":
		# pylint: disable=missing-function-docstring
		return self._ramps
	@ramps.setter
	def ramps(self, value: "List[Ramp]") -> None:
		# pylint: disable=missing-function-docstring
		self._ramps = value
	@property
	def pipeline_defs(self) -> "List[Pipeline]":
		# pylint: disable=missing-function-docstring
		return self._pipeline_defs
	@pipeline_defs.setter
	def pipeline_defs(self, value: "List[Pipeline]") -> None:
		# pylint: disable=missing-function-docstring
		self._pipeline_defs = value
class RampLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class RasterRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "str", None),
		"data_set": ("dataSet", "str", None),
		"xy_column": ("xyColumn", "str", None),
		"data_column": ("dataColumn", "str", None),
		"interpolate": ("interpolate", "bool", None),
		"cell_size": ("cellSize", "float", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		interpolate: "bool",
		cell_size: "float",
		account: Optional["str"] = None,
		data_set: Optional["str"] = None,
		xy_column: Optional["str"] = None,
		data_column: Optional["str"] = None,
	) -> None:
		"""
		:param interpolate:
		:type interpolate: bool
		:param cell_size:
		:type cell_size: float
		:param account:
		:type account: str or None
		:param data_set:
		:type data_set: str or None
		:param xy_column:
		:type xy_column: str or None
		:param data_column:
		:type data_column: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._account = cast(Optional[str], kwargs.get("account"))
		self._data_set = cast(Optional[str], kwargs.get("data_set"))
		self._xy_column = cast(Optional[str], kwargs.get("xy_column"))
		self._data_column = cast(Optional[str], kwargs.get("data_column"))
		self._interpolate = cast(bool, kwargs.get("interpolate"))
		self._cell_size = cast(float, kwargs.get("cell_size"))
	@property
	def account(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._account
	@account.setter
	def account(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._account = value
	@property
	def data_set(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._data_set
	@data_set.setter
	def data_set(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._data_set = value
	@property
	def xy_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._xy_column
	@xy_column.setter
	def xy_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xy_column = value
	@property
	def data_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._data_column
	@data_column.setter
	def data_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._data_column = value
	@property
	def interpolate(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._interpolate
	@interpolate.setter
	def interpolate(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._interpolate = value
	@property
	def cell_size(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._cell_size
	@cell_size.setter
	def cell_size(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._cell_size = value
class RasterSlice:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"xdimension": ("xDimension", "str", None),
		"xvariable": ("xVariable", "str", None),
		"ydimension": ("yDimension", "str", None),
		"yvariable": ("yVariable", "str", None),
		"metadata_variables": ("metadataVariables", "list", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		metadata_variables: "List[str]",
		xdimension: Optional["str"] = None,
		xvariable: Optional["str"] = None,
		ydimension: Optional["str"] = None,
		yvariable: Optional["str"] = None,
	) -> None:
		"""
		:param metadata_variables:
		:type metadata_variables: List[str]
		:param xdimension:
		:type xdimension: str or None
		:param xvariable:
		:type xvariable: str or None
		:param ydimension:
		:type ydimension: str or None
		:param yvariable:
		:type yvariable: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._xdimension = cast(Optional[str], kwargs.get("xdimension"))
		self._xvariable = cast(Optional[str], kwargs.get("xvariable"))
		self._ydimension = cast(Optional[str], kwargs.get("ydimension"))
		self._yvariable = cast(Optional[str], kwargs.get("yvariable"))
		self._metadata_variables = cast(List[str], kwargs.get("metadata_variables"))
	@property
	def xdimension(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._xdimension
	@xdimension.setter
	def xdimension(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xdimension = value
	@property
	def xvariable(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._xvariable
	@xvariable.setter
	def xvariable(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xvariable = value
	@property
	def ydimension(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._ydimension
	@ydimension.setter
	def ydimension(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._ydimension = value
	@property
	def yvariable(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._yvariable
	@yvariable.setter
	def yvariable(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._yvariable = value
	@property
	def metadata_variables(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._metadata_variables
	@metadata_variables.setter
	def metadata_variables(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._metadata_variables = value
class RasterTransform:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"center_x": ("CenterX", "float", None),
		"center_y": ("CenterY", "float", None),
		"translate_x": ("TranslateX", "float", None),
		"translate_y": ("TranslateY", "float", None),
		"rotation_angle_ccw_degrees": ("RotationAngleCCWDegrees", "float", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		rotation_angle_ccw_degrees: "float",
		center_x: Optional["float"] = None,
		center_y: Optional["float"] = None,
		translate_x: Optional["float"] = None,
		translate_y: Optional["float"] = None,
	) -> None:
		"""
		:param rotation_angle_ccw_degrees:
		:type rotation_angle_ccw_degrees: float
		:param center_x:
		:type center_x: float or None
		:param center_y:
		:type center_y: float or None
		:param translate_x:
		:type translate_x: float or None
		:param translate_y:
		:type translate_y: float or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._center_x = cast(Optional[float], kwargs.get("center_x"))
		self._center_y = cast(Optional[float], kwargs.get("center_y"))
		self._translate_x = cast(Optional[float], kwargs.get("translate_x"))
		self._translate_y = cast(Optional[float], kwargs.get("translate_y"))
		self._rotation_angle_ccw_degrees = cast(float, kwargs.get("rotation_angle_ccw_degrees"))
	@property
	def center_x(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._center_x
	@center_x.setter
	def center_x(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._center_x = value
	@property
	def center_y(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._center_y
	@center_y.setter
	def center_y(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._center_y = value
	@property
	def translate_x(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._translate_x
	@translate_x.setter
	def translate_x(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._translate_x = value
	@property
	def translate_y(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._translate_y
	@translate_y.setter
	def translate_y(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._translate_y = value
	@property
	def rotation_angle_ccw_degrees(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._rotation_angle_ccw_degrees
	@rotation_angle_ccw_degrees.setter
	def rotation_angle_ccw_degrees(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._rotation_angle_ccw_degrees = value


class RasterType(str, Enum):
	# pylint: disable=missing-class-docstring
	CONTOUR = 'contour'
	PIXEL = 'pixel'
	ARROW = 'arrow'
	BARB = 'barb'

class RealtimeOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"column": ("column", "str", None),
		"time": ("time", "str", None),
		"count": ("count", "int", None),
		"realtime_table_short_name": ("realtimeTableShortName", "str", None),
		"persisted_table_short_name": ("persistedTableShortName", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		time: "str",
		count: "int",
		column: Optional["str"] = None,
		realtime_table_short_name: Optional["str"] = None,
		persisted_table_short_name: Optional["str"] = None,
	) -> None:
		"""
		:param time:
		:type time: str
		:param count:
		:type count: int
		:param column:
		:type column: str or None
		:param realtime_table_short_name:
		:type realtime_table_short_name: str or None
		:param persisted_table_short_name:
		:type persisted_table_short_name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._column = cast(Optional[str], kwargs.get("column"))
		self._time = cast(str, kwargs.get("time"))
		self._count = cast(int, kwargs.get("count"))
		self._realtime_table_short_name = cast(Optional[str], kwargs.get("realtime_table_short_name"))
		self._persisted_table_short_name = cast(Optional[str], kwargs.get("persisted_table_short_name"))
	@property
	def column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._column
	@column.setter
	def column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column = value
	@property
	def time(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._time
	@time.setter
	def time(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._time = value
	@property
	def count(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._count
	@count.setter
	def count(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._count = value
	@property
	def realtime_table_short_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._realtime_table_short_name
	@realtime_table_short_name.setter
	def realtime_table_short_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._realtime_table_short_name = value
	@property
	def persisted_table_short_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._persisted_table_short_name
	@persisted_table_short_name.setter
	def persisted_table_short_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._persisted_table_short_name = value
class RecordTransformOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"maximum_number_of_detection_records": ("MaximumNumberOfDetectionRecords", "int", None),
		"steps": ("Steps", "list", "PipelineDefinitionStep"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		maximum_number_of_detection_records: Optional["int"] = None,
		steps: Optional["List[PipelineDefinitionStep]"] = None,
	) -> None:
		"""
		:param maximum_number_of_detection_records:
		:type maximum_number_of_detection_records: int or None
		:param steps: Record transformation steps performed on the data on import
		:type steps: List[PipelineDefinitionStep] or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._maximum_number_of_detection_records = cast(Optional[int], kwargs.get("maximum_number_of_detection_records"))
		self._steps = cast(Optional[List[PipelineDefinitionStep]], kwargs.get("steps"))
	@property
	def maximum_number_of_detection_records(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._maximum_number_of_detection_records
	@maximum_number_of_detection_records.setter
	def maximum_number_of_detection_records(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._maximum_number_of_detection_records = value
	@property
	def steps(self) -> Optional["List[PipelineDefinitionStep]"]:
		"""Record transformation steps performed on the data on import"""
		return self._steps
	@steps.setter
	def steps(self, value: Optional["List[PipelineDefinitionStep]"]) -> None:
		"""Record transformation steps performed on the data on import"""
		self._steps = value


class RelativeRotation(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	NORTH = 'North'
	MAP = 'Map'

class RemoteQueryOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"endpoint_key": ("EndpointKey", "str", None),
		"remote_uri": ("RemoteURI", "str", None),
		"ml_user": ("MLUser", "str", None),
		"ml_pass": ("MLPass", "str", None),
		"ml_token": ("MLToken", "str", None),
		"is_callback": ("IsCallback", "bool", None),
		"central_server_id": ("CentralServerId", "str", None),
		"client_mode": ("ClientMode", "DBClientQueryMode", None),
		"suppress": ("Suppress", "bool", None),
		"override_unversioned_hash": ("OverrideUnversionedHash", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		is_callback: "bool",
		client_mode: "DBClientQueryMode",
		suppress: "bool",
		endpoint_key: Optional["str"] = None,
		remote_uri: Optional["str"] = None,
		ml_user: Optional["str"] = None,
		ml_pass: Optional["str"] = None,
		ml_token: Optional["str"] = None,
		central_server_id: Optional["str"] = None,
		override_unversioned_hash: Optional["str"] = None,
	) -> None:
		"""
		:param is_callback:
		:type is_callback: bool
		:param client_mode:
		:type client_mode: DBClientQueryMode
		:param suppress:
		:type suppress: bool
		:param endpoint_key:
		:type endpoint_key: str or None
		:param remote_uri:
		:type remote_uri: str or None
		:param ml_user:
		:type ml_user: str or None
		:param ml_pass:
		:type ml_pass: str or None
		:param ml_token:
		:type ml_token: str or None
		:param central_server_id:
		:type central_server_id: str or None
		:param override_unversioned_hash:
		:type override_unversioned_hash: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._endpoint_key = cast(Optional[str], kwargs.get("endpoint_key"))
		self._remote_uri = cast(Optional[str], kwargs.get("remote_uri"))
		self._ml_user = cast(Optional[str], kwargs.get("ml_user"))
		self._ml_pass = cast(Optional[str], kwargs.get("ml_pass"))
		self._ml_token = cast(Optional[str], kwargs.get("ml_token"))
		self._is_callback = cast(bool, kwargs.get("is_callback"))
		self._central_server_id = cast(Optional[str], kwargs.get("central_server_id"))
		self._client_mode = cast(DBClientQueryMode, kwargs.get("client_mode"))
		self._suppress = cast(bool, kwargs.get("suppress"))
		self._override_unversioned_hash = cast(Optional[str], kwargs.get("override_unversioned_hash"))
	@property
	def endpoint_key(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._endpoint_key
	@endpoint_key.setter
	def endpoint_key(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._endpoint_key = value
	@property
	def remote_uri(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._remote_uri
	@remote_uri.setter
	def remote_uri(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._remote_uri = value
	@property
	def ml_user(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._ml_user
	@ml_user.setter
	def ml_user(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._ml_user = value
	@property
	def ml_pass(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._ml_pass
	@ml_pass.setter
	def ml_pass(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._ml_pass = value
	@property
	def ml_token(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._ml_token
	@ml_token.setter
	def ml_token(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._ml_token = value
	@property
	def is_callback(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._is_callback
	@is_callback.setter
	def is_callback(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._is_callback = value
	@property
	def central_server_id(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._central_server_id
	@central_server_id.setter
	def central_server_id(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._central_server_id = value
	@property
	def client_mode(self) -> "DBClientQueryMode":
		# pylint: disable=missing-function-docstring
		return self._client_mode
	@client_mode.setter
	def client_mode(self, value: "DBClientQueryMode") -> None:
		# pylint: disable=missing-function-docstring
		self._client_mode = value
	@property
	def suppress(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._suppress
	@suppress.setter
	def suppress(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._suppress = value
	@property
	def override_unversioned_hash(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._override_unversioned_hash
	@override_unversioned_hash.setter
	def override_unversioned_hash(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._override_unversioned_hash = value
class Resource:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "int", None),
		"urn": ("urn", "str", None),
		"account": ("account", "AccountReference", None),
		"item_type": ("itemType", "ResourceItemType", None),
		"type_": ("type", "ResourceType", None),
		"name": ("name", "str", None),
		"description": ("description", "str", None),
		"path": ("path", "str", None),
		"inherit_permissions": ("inheritPermissions", "bool", None),
		"permissions": ("permissions", "list", "ResourcePermission"),
		"parent": ("parent", "ResourceFolderReference", None),
		"links": ("_links", "ResourceLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "int",
		urn: "str",
		account: "AccountReference",
		item_type: "ResourceItemType",
		type_: "ResourceType",
		name: "str",
		path: "str",
		inherit_permissions: "bool",
		parent: "ResourceFolderReference",
		links: "ResourceLinks",
		description: Optional["str"] = None,
		permissions: Optional["List[ResourcePermission]"] = None,
	) -> None:
		"""
		:param id_: The unique numeric ID of the resource.
		:type id_: int
		:param urn: A URN of the format "maplarge://{accountcode}/{resourcetype}/{name}".
		:type urn: str
		:param account: The account this resource belongs to.
		:type account: AccountReference
		:param item_type: The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource.
		:type item_type: ResourceItemType
		:param type_: The type of resource.
* `Table` - A table.
* `Documentation` - Doc Portal Resource
		:type type_: ResourceType
		:param name: The name of the resource. Unique within the parent folder.
		:type name: str
		:param path: The full path of the resource, ending with this resource's `name`.
		:type path: str
		:param inherit_permissions: Flag indicating whether or not to include the parent folder's permissions with this resource's permissions.
		:type inherit_permissions: bool
		:param parent: The parent of this resource.
		:type parent: ResourceFolderReference
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: ResourceLinks
		:param description: The description of the resource.
		:type description: str or None
		:param permissions: The list of permissions assigned to this resource.
		:type permissions: List[ResourcePermission] or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(int, kwargs.get("id_"))
		self._urn = cast(str, kwargs.get("urn"))
		self._account = cast(AccountReference, kwargs.get("account"))
		self._item_type = cast(ResourceItemType, kwargs.get("item_type"))
		self._type_ = cast(ResourceType, kwargs.get("type_"))
		self._name = cast(str, kwargs.get("name"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._path = cast(str, kwargs.get("path"))
		self._inherit_permissions = cast(bool, kwargs.get("inherit_permissions"))
		self._permissions = cast(Optional[List[ResourcePermission]], kwargs.get("permissions"))
		self._parent = cast(ResourceFolderReference, kwargs.get("parent"))
		self._links = cast(ResourceLinks, kwargs.get("links"))
	@property
	def id_(self) -> "int":
		"""The unique numeric ID of the resource."""
		return self._id_
	@id_.setter
	def id_(self, value: "int") -> None:
		"""The unique numeric ID of the resource."""
		self._id_ = value
	@property
	def urn(self) -> "str":
		"""A URN of the format "maplarge://{accountcode}/{resourcetype}/{name}"."""
		return self._urn
	@urn.setter
	def urn(self, value: "str") -> None:
		"""A URN of the format "maplarge://{accountcode}/{resourcetype}/{name}"."""
		self._urn = value
	@property
	def account(self) -> "AccountReference":
		"""The account this resource belongs to."""
		return self._account
	@account.setter
	def account(self, value: "AccountReference") -> None:
		"""The account this resource belongs to."""
		self._account = value
	@property
	def item_type(self) -> "ResourceItemType":
		"""The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource."""
		return self._item_type
	@item_type.setter
	def item_type(self, value: "ResourceItemType") -> None:
		"""The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource."""
		self._item_type = value
	@property
	def type_(self) -> "ResourceType":
		"""The type of resource.
* `Table` - A table.
* `Documentation` - Doc Portal Resource"""
		return self._type_
	@type_.setter
	def type_(self, value: "ResourceType") -> None:
		"""The type of resource.
* `Table` - A table.
* `Documentation` - Doc Portal Resource"""
		self._type_ = value
	@property
	def name(self) -> "str":
		"""The name of the resource. Unique within the parent folder."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The name of the resource. Unique within the parent folder."""
		self._name = value
	@property
	def description(self) -> Optional["str"]:
		"""The description of the resource."""
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		"""The description of the resource."""
		self._description = value
	@property
	def path(self) -> "str":
		"""The full path of the resource, ending with this resource's `name`."""
		return self._path
	@path.setter
	def path(self, value: "str") -> None:
		"""The full path of the resource, ending with this resource's `name`."""
		self._path = value
	@property
	def inherit_permissions(self) -> "bool":
		"""Flag indicating whether or not to include the parent folder's permissions with this resource's permissions."""
		return self._inherit_permissions
	@inherit_permissions.setter
	def inherit_permissions(self, value: "bool") -> None:
		"""Flag indicating whether or not to include the parent folder's permissions with this resource's permissions."""
		self._inherit_permissions = value
	@property
	def permissions(self) -> Optional["List[ResourcePermission]"]:
		"""The list of permissions assigned to this resource."""
		return self._permissions
	@permissions.setter
	def permissions(self, value: Optional["List[ResourcePermission]"]) -> None:
		"""The list of permissions assigned to this resource."""
		self._permissions = value
	@property
	def parent(self) -> "ResourceFolderReference":
		"""The parent of this resource."""
		return self._parent
	@parent.setter
	def parent(self, value: "ResourceFolderReference") -> None:
		"""The parent of this resource."""
		self._parent = value
	@property
	def links(self) -> "ResourceLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "ResourceLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value



ResourceBase = Union["ResourceFolder", "Resource"]


class ResourceDeleteCascade(str, Enum):
	"""Specify what should be done with folder contents when the folder is deleted. Defaults to `Delete`."""
	DELETE = 'Delete'
	MOVE = 'Move'

ResourceDeleteCascade.DELETE.__doc__ = """Delete folder contents"""
ResourceDeleteCascade.MOVE.__doc__ = """Move folder contents up to the root folder"""
class ResourceFolder:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "int", None),
		"account": ("account", "AccountReference", None),
		"item_type": ("itemType", "ResourceItemType", None),
		"name": ("name", "str", None),
		"description": ("description", "str", None),
		"path": ("path", "str", None),
		"inherit_permissions": ("inheritPermissions", "bool", None),
		"permissions": ("permissions", "list", "ResourcePermission"),
		"contents": ("contents", "list", "ResourceReferenceBase"),
		"parent": ("parent", "ResourceFolderReference", None),
		"links": ("_links", "ResourceFolderLinks", None),
		"embedded": ("_embedded", "ResourceFolderContents", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "int",
		account: "AccountReference",
		item_type: "ResourceItemType",
		path: "str",
		inherit_permissions: "bool",
		links: "ResourceFolderLinks",
		name: Optional["str"] = None,
		description: Optional["str"] = None,
		permissions: Optional["List[ResourcePermission]"] = None,
		contents: Optional["List[ResourceReferenceBase]"] = None,
		parent: Optional["ResourceFolderReference"] = None,
		embedded: Optional["ResourceFolderContents"] = None,
	) -> None:
		"""
		:param id_: The unique numeric ID of the folder.
		:type id_: int
		:param account: The account this folder belongs to.
		:type account: AccountReference
		:param item_type: The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource.
		:type item_type: ResourceItemType
		:param path: The full path of the folder, ending with this folder's `name`.
		:type path: str
		:param inherit_permissions: Flag indicating whether or not to include the parent folder's permissions with this folder's permissions.
		:type inherit_permissions: bool
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: ResourceFolderLinks
		:param name: The name of the folder. Unique within the parent folder.
		:type name: str or None
		:param description: The description of the folder.
		:type description: str or None
		:param permissions: The list of permissions assigned to this folder.
		:type permissions: List[ResourcePermission] or None
		:param contents: The child folders and resources contained within this folder.
		:type contents: List[ResourceReferenceBase] or None
		:param parent: The parent of this folder.
		:type parent: ResourceFolderReference or None
		:param embedded:
		:type embedded: ResourceFolderContents or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(int, kwargs.get("id_"))
		self._account = cast(AccountReference, kwargs.get("account"))
		self._item_type = cast(ResourceItemType, kwargs.get("item_type"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._path = cast(str, kwargs.get("path"))
		self._inherit_permissions = cast(bool, kwargs.get("inherit_permissions"))
		self._permissions = cast(Optional[List[ResourcePermission]], kwargs.get("permissions"))
		self._contents = cast(Optional[List[ResourceReferenceBase]], kwargs.get("contents"))
		self._parent = cast(Optional[ResourceFolderReference], kwargs.get("parent"))
		self._links = cast(ResourceFolderLinks, kwargs.get("links"))
		self._embedded = cast(Optional[ResourceFolderContents], kwargs.get("embedded"))
	@property
	def id_(self) -> "int":
		"""The unique numeric ID of the folder."""
		return self._id_
	@id_.setter
	def id_(self, value: "int") -> None:
		"""The unique numeric ID of the folder."""
		self._id_ = value
	@property
	def account(self) -> "AccountReference":
		"""The account this folder belongs to."""
		return self._account
	@account.setter
	def account(self, value: "AccountReference") -> None:
		"""The account this folder belongs to."""
		self._account = value
	@property
	def item_type(self) -> "ResourceItemType":
		"""The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource."""
		return self._item_type
	@item_type.setter
	def item_type(self, value: "ResourceItemType") -> None:
		"""The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource."""
		self._item_type = value
	@property
	def name(self) -> Optional["str"]:
		"""The name of the folder. Unique within the parent folder."""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""The name of the folder. Unique within the parent folder."""
		self._name = value
	@property
	def description(self) -> Optional["str"]:
		"""The description of the folder."""
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		"""The description of the folder."""
		self._description = value
	@property
	def path(self) -> "str":
		"""The full path of the folder, ending with this folder's `name`."""
		return self._path
	@path.setter
	def path(self, value: "str") -> None:
		"""The full path of the folder, ending with this folder's `name`."""
		self._path = value
	@property
	def inherit_permissions(self) -> "bool":
		"""Flag indicating whether or not to include the parent folder's permissions with this folder's permissions."""
		return self._inherit_permissions
	@inherit_permissions.setter
	def inherit_permissions(self, value: "bool") -> None:
		"""Flag indicating whether or not to include the parent folder's permissions with this folder's permissions."""
		self._inherit_permissions = value
	@property
	def permissions(self) -> Optional["List[ResourcePermission]"]:
		"""The list of permissions assigned to this folder."""
		return self._permissions
	@permissions.setter
	def permissions(self, value: Optional["List[ResourcePermission]"]) -> None:
		"""The list of permissions assigned to this folder."""
		self._permissions = value
	@property
	def contents(self) -> Optional["List[ResourceReferenceBase]"]:
		"""The child folders and resources contained within this folder."""
		return self._contents
	@contents.setter
	def contents(self, value: Optional["List[ResourceReferenceBase]"]) -> None:
		"""The child folders and resources contained within this folder."""
		self._contents = value
	@property
	def parent(self) -> Optional["ResourceFolderReference"]:
		"""The parent of this folder."""
		return self._parent
	@parent.setter
	def parent(self, value: Optional["ResourceFolderReference"]) -> None:
		"""The parent of this folder."""
		self._parent = value
	@property
	def links(self) -> "ResourceFolderLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "ResourceFolderLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
	@property
	def embedded(self) -> Optional["ResourceFolderContents"]:
		# pylint: disable=missing-function-docstring
		return self._embedded
	@embedded.setter
	def embedded(self, value: Optional["ResourceFolderContents"]) -> None:
		# pylint: disable=missing-function-docstring
		self._embedded = value
class ResourceFolderContents:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"contents": ("contents", "RestList", "ResourceBase"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		contents: Optional["RestList[ResourceBase]"] = None,
	) -> None:
		"""
		:param contents: The child folders and resources contained within this folder.
		:type contents: RestList[ResourceBase] or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._contents = cast(Optional[RestList[ResourceBase]], kwargs.get("contents"))
	@property
	def contents(self) -> Optional["RestList[ResourceBase]"]:
		"""The child folders and resources contained within this folder."""
		return self._contents
	@contents.setter
	def contents(self, value: Optional["RestList[ResourceBase]"]) -> None:
		"""The child folders and resources contained within this folder."""
		self._contents = value
class ResourceLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"parent": ("parent", "Link", None),
		"account": ("account", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "Link",
		self_: "Link",
		parent: Optional["Link"] = None,
	) -> None:
		"""
		:param account: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type account: Link
		:param self_: A link to the current resource.
		:type self_: Link
		:param parent: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type parent: Link or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._parent = cast(Optional[Link], kwargs.get("parent"))
		self._account = cast(Link, kwargs.get("account"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def parent(self) -> Optional["Link"]:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._parent
	@parent.setter
	def parent(self, value: Optional["Link"]) -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._parent = value
	@property
	def account(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._account
	@account.setter
	def account(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._account = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class ResourceFolderLinks(ResourceLinks):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"contents": ("contents", "Link", None),
		"self_": ("self", "Link", None),
		"parent": ("parent", "Link", None),
		"account": ("account", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
		account: "Link",
		contents: Optional["Link"] = None,
		parent: Optional["Link"] = None,
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		:param account: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type account: Link
		:param contents: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type contents: Link or None
		:param parent: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type parent: Link or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		ResourceLinks.__init__(self,
			self_=kwargs.get("self_"),
			parent=kwargs.get("parent"),
			account=kwargs.get("account"),
		)
		self._contents = cast(Optional[Link], kwargs.get("contents"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def contents(self) -> Optional["Link"]:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._contents
	@contents.setter
	def contents(self, value: Optional["Link"]) -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._contents = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class ResourceFolderReference:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "AccountReference", None),
		"id_": ("id", "int", None),
		"path": ("path", "str", None),
		"item_type": ("itemType", "ResourceItemType", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "AccountReference",
		item_type: "ResourceItemType",
		id_: Optional["int"] = None,
		path: Optional["str"] = None,
	) -> None:
		"""
		:param account: The account this folder belongs to.
		:type account: AccountReference
		:param item_type: The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource.
		:type item_type: ResourceItemType
		:param id_: The unique numeric ID of the folder.
		:type id_: int or None
		:param path: The full path of the folder, ending with this folder's `name`.
		:type path: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._account = cast(AccountReference, kwargs.get("account"))
		self._id_ = cast(Optional[int], kwargs.get("id_"))
		self._path = cast(Optional[str], kwargs.get("path"))
		self._item_type = cast(ResourceItemType, kwargs.get("item_type"))
	@property
	def account(self) -> "AccountReference":
		"""The account this folder belongs to."""
		return self._account
	@account.setter
	def account(self, value: "AccountReference") -> None:
		"""The account this folder belongs to."""
		self._account = value
	@property
	def id_(self) -> Optional["int"]:
		"""The unique numeric ID of the folder."""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["int"]) -> None:
		"""The unique numeric ID of the folder."""
		self._id_ = value
	@property
	def path(self) -> Optional["str"]:
		"""The full path of the folder, ending with this folder's `name`."""
		return self._path
	@path.setter
	def path(self, value: Optional["str"]) -> None:
		"""The full path of the folder, ending with this folder's `name`."""
		self._path = value
	@property
	def item_type(self) -> "ResourceItemType":
		"""The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource."""
		return self._item_type
	@item_type.setter
	def item_type(self, value: "ResourceItemType") -> None:
		"""The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource."""
		self._item_type = value


class ResourceGrantEffect(str, Enum):
	"""Either "Allow" or "Deny". Deny permissions take precedence over Allow permissions."""
	ALLOW = 'Allow'
	DENY = 'Deny'

ResourceGrantEffect.ALLOW.__doc__ = """Allow the specified user or group access to these resources."""
ResourceGrantEffect.DENY.__doc__ = """Prevent the specified user or group from accessing these resources."""





class ResourceGrantPermissionEnum(str, Enum):
	"""Indicates the type of access that is to be allowed or denied: either read, write, or share access, or a combination of those."""
	NONE = 'None'
	READ = 'Read'
	WRITE = 'Write'
	SHARE = 'Share'


ResourceGrantPermission = Iterable[ResourceGrantPermissionEnum]


class ResourceItemType(str, Enum):
	"""The type of resource tree element."""
	FOLDER = 'folder'
	RESOURCE = 'resource'

ResourceItemType.FOLDER.__doc__ = """A folder containing other resources."""
ResourceItemType.RESOURCE.__doc__ = """A resource."""
class ResourcePermission:
	"""Indicates whether a user or group should or should not have access to certain recources."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"group": ("group", "GroupReference", None),
		"user": ("user", "UserReference", None),
		"permissions": ("permissions", "list", "ResourceGrantPermissionEnum"),
		"is_explicit": ("isExplicit", "bool", None),
		"effect": ("effect", "ResourceGrantEffect", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
		permissions: "ResourceGrantPermission",
		is_explicit: "bool",
		effect: "ResourceGrantEffect",
		group: Optional["GroupReference"] = None,
		user: Optional["UserReference"] = None,
	) -> None:
		"""
		:param id_: A GUID that uniquely identifies this permission.
		:type id_: str
		:param permissions:
		:type permissions: ResourceGrantPermission
		:param is_explicit: Indicates whether this permission was inherited from a parent folder (isExplicit: false) or if this permission is defined explicitly at this level (isExplicit: true). Readonly property - ignored on POST and PUT requests.
		:type is_explicit: bool
		:param effect: Either "Allow" or "Deny". Deny permissions take precedence over Allow permissions.
* `Allow` - Allow the specified user or group access to these resources.
* `Deny` - Prevent the specified user or group from accessing these resources.
		:type effect: ResourceGrantEffect
		:param group: The group that these permissions are assigned to. Either group or user (or neither) should be specified, not both. If both group and user are null, then this permission applies globally to all users.
		:type group: GroupReference or None
		:param user: The user that these permissions are assigned to.Either group or user (or neither) should be specified, not both. If both group and user are null, then this permission applies globally to all users.
		:type user: UserReference or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
		self._group = cast(Optional[GroupReference], kwargs.get("group"))
		self._user = cast(Optional[UserReference], kwargs.get("user"))
		self._permissions = cast(ResourceGrantPermission, kwargs.get("permissions"))
		self._is_explicit = cast(bool, kwargs.get("is_explicit"))
		self._effect = cast(ResourceGrantEffect, kwargs.get("effect"))
	@property
	def id_(self) -> "str":
		"""A GUID that uniquely identifies this permission."""
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		"""A GUID that uniquely identifies this permission."""
		self._id_ = value
	@property
	def group(self) -> Optional["GroupReference"]:
		"""The group that these permissions are assigned to. Either group or user (or neither) should be specified, not both. If both group and user are null, then this permission applies globally to all users."""
		return self._group
	@group.setter
	def group(self, value: Optional["GroupReference"]) -> None:
		"""The group that these permissions are assigned to. Either group or user (or neither) should be specified, not both. If both group and user are null, then this permission applies globally to all users."""
		self._group = value
	@property
	def user(self) -> Optional["UserReference"]:
		"""The user that these permissions are assigned to.Either group or user (or neither) should be specified, not both. If both group and user are null, then this permission applies globally to all users."""
		return self._user
	@user.setter
	def user(self, value: Optional["UserReference"]) -> None:
		"""The user that these permissions are assigned to.Either group or user (or neither) should be specified, not both. If both group and user are null, then this permission applies globally to all users."""
		self._user = value
	@property
	def permissions(self) -> "ResourceGrantPermission":
		# pylint: disable=missing-function-docstring
		return self._permissions
	@permissions.setter
	def permissions(self, value: "ResourceGrantPermission") -> None:
		# pylint: disable=missing-function-docstring
		self._permissions = value
	@property
	def is_explicit(self) -> "bool":
		"""Indicates whether this permission was inherited from a parent folder (isExplicit: false) or if this permission is defined explicitly at this level (isExplicit: true). Readonly property - ignored on POST and PUT requests."""
		return self._is_explicit
	@is_explicit.setter
	def is_explicit(self, value: "bool") -> None:
		"""Indicates whether this permission was inherited from a parent folder (isExplicit: false) or if this permission is defined explicitly at this level (isExplicit: true). Readonly property - ignored on POST and PUT requests."""
		self._is_explicit = value
	@property
	def effect(self) -> "ResourceGrantEffect":
		"""Either "Allow" or "Deny". Deny permissions take precedence over Allow permissions.
* `Allow` - Allow the specified user or group access to these resources.
* `Deny` - Prevent the specified user or group from accessing these resources."""
		return self._effect
	@effect.setter
	def effect(self, value: "ResourceGrantEffect") -> None:
		"""Either "Allow" or "Deny". Deny permissions take precedence over Allow permissions.
* `Allow` - Allow the specified user or group access to these resources.
* `Deny` - Prevent the specified user or group from accessing these resources."""
		self._effect = value
class ResourceReference:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "AccountReference", None),
		"id_": ("id", "int", None),
		"urn": ("urn", "str", None),
		"item_type": ("itemType", "ResourceItemType", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "AccountReference",
		urn: "str",
		item_type: "ResourceItemType",
		id_: Optional["int"] = None,
	) -> None:
		"""
		:param account: The account this resource belongs to.
		:type account: AccountReference
		:param urn: A URN of the format "maplarge://{accountcode}/{resourcetype}/{name}".
		:type urn: str
		:param item_type: The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource.
		:type item_type: ResourceItemType
		:param id_: The unique numeric ID of the resource.
		:type id_: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._account = cast(AccountReference, kwargs.get("account"))
		self._id_ = cast(Optional[int], kwargs.get("id_"))
		self._urn = cast(str, kwargs.get("urn"))
		self._item_type = cast(ResourceItemType, kwargs.get("item_type"))
	@property
	def account(self) -> "AccountReference":
		"""The account this resource belongs to."""
		return self._account
	@account.setter
	def account(self, value: "AccountReference") -> None:
		"""The account this resource belongs to."""
		self._account = value
	@property
	def id_(self) -> Optional["int"]:
		"""The unique numeric ID of the resource."""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["int"]) -> None:
		"""The unique numeric ID of the resource."""
		self._id_ = value
	@property
	def urn(self) -> "str":
		"""A URN of the format "maplarge://{accountcode}/{resourcetype}/{name}"."""
		return self._urn
	@urn.setter
	def urn(self, value: "str") -> None:
		"""A URN of the format "maplarge://{accountcode}/{resourcetype}/{name}"."""
		self._urn = value
	@property
	def item_type(self) -> "ResourceItemType":
		"""The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource."""
		return self._item_type
	@item_type.setter
	def item_type(self, value: "ResourceItemType") -> None:
		"""The type of resource tree element.
* `folder` - A folder containing other resources.
* `resource` - A resource."""
		self._item_type = value



ResourceReferenceBase = Union["ResourceFolderReference", "ResourceReference"]


class ResourceType(str, Enum):
	"""The type of resource."""
	TABLE = 'Table'
	RASTER_SET = 'RasterSet'
	JSON = 'Json'
	CONTAINER_IMAGE = 'ContainerImage'
	WORKLOAD = 'Workload'
	FOLDER = 'Folder'
	ALERT = 'Alert'
	RECURRING_JOB = 'RecurringJob'
	JOB = 'Job'
	CENTRAL_SERVER = 'CentralServer'
	DOCUMENTATION = 'Documentation'
	VFS = 'VFS'

ResourceType.TABLE.__doc__ = """A table."""
ResourceType.DOCUMENTATION.__doc__ = """Doc Portal Resource"""



RestListBase = Union[RestList[T], Page[T]]
class RestListItems(Generic[T]):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"items": ("items", "list", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		items: "List[T]",
	) -> None:
		"""
		:param items: The requested records.
		:type items: List[T]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._items = cast(List[T], kwargs.get("items"))
	@property
	def items(self) -> "List[T]":
		"""The requested records."""
		return self._items
	@items.setter
	def items(self, value: "List[T]") -> None:
		"""The requested records."""
		self._items = value
class RoadBaseMapTheme:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"interstates": ("interstates", "RoadStyleDescriptor", None),
		"highways": ("highways", "RoadStyleDescriptor", None),
		"primary": ("primary", "RoadStyleDescriptor", None),
		"other": ("other", "RoadStyleDescriptor", None),
		"ramps": ("ramps", "RoadStyleDescriptor", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		interstates: "RoadStyleDescriptor",
		highways: "RoadStyleDescriptor",
		primary: "RoadStyleDescriptor",
		other: "RoadStyleDescriptor",
		ramps: "RoadStyleDescriptor",
	) -> None:
		"""
		:param interstates:
		:type interstates: RoadStyleDescriptor
		:param highways:
		:type highways: RoadStyleDescriptor
		:param primary:
		:type primary: RoadStyleDescriptor
		:param other:
		:type other: RoadStyleDescriptor
		:param ramps:
		:type ramps: RoadStyleDescriptor
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._interstates = cast(RoadStyleDescriptor, kwargs.get("interstates"))
		self._highways = cast(RoadStyleDescriptor, kwargs.get("highways"))
		self._primary = cast(RoadStyleDescriptor, kwargs.get("primary"))
		self._other = cast(RoadStyleDescriptor, kwargs.get("other"))
		self._ramps = cast(RoadStyleDescriptor, kwargs.get("ramps"))
	@property
	def interstates(self) -> "RoadStyleDescriptor":
		# pylint: disable=missing-function-docstring
		return self._interstates
	@interstates.setter
	def interstates(self, value: "RoadStyleDescriptor") -> None:
		# pylint: disable=missing-function-docstring
		self._interstates = value
	@property
	def highways(self) -> "RoadStyleDescriptor":
		# pylint: disable=missing-function-docstring
		return self._highways
	@highways.setter
	def highways(self, value: "RoadStyleDescriptor") -> None:
		# pylint: disable=missing-function-docstring
		self._highways = value
	@property
	def primary(self) -> "RoadStyleDescriptor":
		# pylint: disable=missing-function-docstring
		return self._primary
	@primary.setter
	def primary(self, value: "RoadStyleDescriptor") -> None:
		# pylint: disable=missing-function-docstring
		self._primary = value
	@property
	def other(self) -> "RoadStyleDescriptor":
		# pylint: disable=missing-function-docstring
		return self._other
	@other.setter
	def other(self, value: "RoadStyleDescriptor") -> None:
		# pylint: disable=missing-function-docstring
		self._other = value
	@property
	def ramps(self) -> "RoadStyleDescriptor":
		# pylint: disable=missing-function-docstring
		return self._ramps
	@ramps.setter
	def ramps(self, value: "RoadStyleDescriptor") -> None:
		# pylint: disable=missing-function-docstring
		self._ramps = value
class RoadStyleDescriptor:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"type_": ("type", "RoadType", None),
		"color": ("color", "str", None),
		"border": ("border", "str", None),
		"show": ("show", "bool", None),
		"label_show": ("labelShow", "bool", None),
		"label_color": ("labelColor", "str", None),
		"shield_top_color": ("shieldTopColor", "str", None),
		"shield_bottom_color": ("shieldBottomColor", "str", None),
		"shield_text_color": ("shieldTextColor", "str", None),
		"shield_size": ("shieldSize", "str", None),
		"show_shield": ("showShield", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		type_: "RoadType",
		show: "bool",
		label_show: "bool",
		show_shield: "bool",
		color: Optional["str"] = None,
		border: Optional["str"] = None,
		label_color: Optional["str"] = None,
		shield_top_color: Optional["str"] = None,
		shield_bottom_color: Optional["str"] = None,
		shield_text_color: Optional["str"] = None,
		shield_size: Optional["str"] = None,
	) -> None:
		"""
		:param type_:
		:type type_: RoadType
		:param show:
		:type show: bool
		:param label_show:
		:type label_show: bool
		:param show_shield:
		:type show_shield: bool
		:param color:
		:type color: str or None
		:param border:
		:type border: str or None
		:param label_color:
		:type label_color: str or None
		:param shield_top_color:
		:type shield_top_color: str or None
		:param shield_bottom_color:
		:type shield_bottom_color: str or None
		:param shield_text_color:
		:type shield_text_color: str or None
		:param shield_size:
		:type shield_size: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._type_ = cast(RoadType, kwargs.get("type_"))
		self._color = cast(Optional[str], kwargs.get("color"))
		self._border = cast(Optional[str], kwargs.get("border"))
		self._show = cast(bool, kwargs.get("show"))
		self._label_show = cast(bool, kwargs.get("label_show"))
		self._label_color = cast(Optional[str], kwargs.get("label_color"))
		self._shield_top_color = cast(Optional[str], kwargs.get("shield_top_color"))
		self._shield_bottom_color = cast(Optional[str], kwargs.get("shield_bottom_color"))
		self._shield_text_color = cast(Optional[str], kwargs.get("shield_text_color"))
		self._shield_size = cast(Optional[str], kwargs.get("shield_size"))
		self._show_shield = cast(bool, kwargs.get("show_shield"))
	@property
	def type_(self) -> "RoadType":
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: "RoadType") -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._color = value
	@property
	def border(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._border
	@border.setter
	def border(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._border = value
	@property
	def show(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._show
	@show.setter
	def show(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._show = value
	@property
	def label_show(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._label_show
	@label_show.setter
	def label_show(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._label_show = value
	@property
	def label_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._label_color
	@label_color.setter
	def label_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._label_color = value
	@property
	def shield_top_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._shield_top_color
	@shield_top_color.setter
	def shield_top_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shield_top_color = value
	@property
	def shield_bottom_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._shield_bottom_color
	@shield_bottom_color.setter
	def shield_bottom_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shield_bottom_color = value
	@property
	def shield_text_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._shield_text_color
	@shield_text_color.setter
	def shield_text_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shield_text_color = value
	@property
	def shield_size(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._shield_size
	@shield_size.setter
	def shield_size(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shield_size = value
	@property
	def show_shield(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._show_shield
	@show_shield.setter
	def show_shield(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._show_shield = value


class RoadType(str, Enum):
	# pylint: disable=missing-class-docstring
	INTERSTATES = 'INTERSTATES'
	HIGHWAYS = 'HIGHWAYS'
	PRIMARY = 'PRIMARY'
	RAMPS = 'RAMPS'
	OTHER = 'OTHER'

class Role:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"role_name": ("roleName", "str", None),
		"account": ("account", "str", None),
		"precedence": ("precedence", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		role_name: Optional["str"] = None,
		account: Optional["str"] = None,
		precedence: Optional["str"] = None,
	) -> None:
		"""
		:param role_name: The name of the server role
		:type role_name: str or None
		:param account: The account associated with the server role
		:type account: str or None
		:param precedence: Indicates Primary or Secondary failover status
		:type precedence: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._role_name = cast(Optional[str], kwargs.get("role_name"))
		self._account = cast(Optional[str], kwargs.get("account"))
		self._precedence = cast(Optional[str], kwargs.get("precedence"))
	@property
	def role_name(self) -> Optional["str"]:
		"""The name of the server role"""
		return self._role_name
	@role_name.setter
	def role_name(self, value: Optional["str"]) -> None:
		"""The name of the server role"""
		self._role_name = value
	@property
	def account(self) -> Optional["str"]:
		"""The account associated with the server role"""
		return self._account
	@account.setter
	def account(self, value: Optional["str"]) -> None:
		"""The account associated with the server role"""
		self._account = value
	@property
	def precedence(self) -> Optional["str"]:
		"""Indicates Primary or Secondary failover status"""
		return self._precedence
	@precedence.setter
	def precedence(self, value: Optional["str"]) -> None:
		"""Indicates Primary or Secondary failover status"""
		self._precedence = value
class RowResponse:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"data": ("data", "dict", None),
		"sub_totals": ("subTotals", "dict", None),
		"index": ("index", "int", None),
		"lat": ("lat", "float", None),
		"lng": ("lng", "float", None),
		"a": ("a", "int", None),
		"r": ("r", "int", None),
		"g": ("g", "int", None),
		"b": ("b", "int", None),
		"type_": ("type", "str", None),
		"sub_type": ("subType", "str", None),
		"max_lat": ("maxLat", "float", None),
		"min_lng": ("minLng", "float", None),
		"mid_lat": ("midLat", "float", None),
		"mid_lng": ("midLng", "float", None),
		"long_table_id": ("longTableId", "str", None),
		"graph_entry_type": ("graphEntryType", "str", None),
		"icon_halign": ("iconHAlign", "HAlign", None),
		"icon_valign": ("iconVAlign", "VAlign", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		data: "Dict[str, Any]",
		sub_totals: "Dict[str, Any]",
		index: "int",
		lat: "float",
		lng: "float",
		a: "int",
		r: "int",
		g: "int",
		b: "int",
		max_lat: "float",
		min_lng: "float",
		mid_lat: "float",
		mid_lng: "float",
		icon_halign: "HAlign",
		icon_valign: "VAlign",
		type_: Optional["str"] = None,
		sub_type: Optional["str"] = None,
		long_table_id: Optional["str"] = None,
		graph_entry_type: Optional["str"] = None,
	) -> None:
		"""
		:param data:
		:type data: Dict[str, Any]
		:param sub_totals:
		:type sub_totals: Dict[str, Any]
		:param index:
		:type index: int
		:param lat:
		:type lat: float
		:param lng:
		:type lng: float
		:param a:
		:type a: int
		:param r:
		:type r: int
		:param g:
		:type g: int
		:param b:
		:type b: int
		:param max_lat:
		:type max_lat: float
		:param min_lng:
		:type min_lng: float
		:param mid_lat:
		:type mid_lat: float
		:param mid_lng:
		:type mid_lng: float
		:param icon_halign:
		:type icon_halign: HAlign
		:param icon_valign:
		:type icon_valign: VAlign
		:param type_:
		:type type_: str or None
		:param sub_type:
		:type sub_type: str or None
		:param long_table_id:
		:type long_table_id: str or None
		:param graph_entry_type:
		:type graph_entry_type: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._data = cast(Dict[str, Any], kwargs.get("data"))
		self._sub_totals = cast(Dict[str, Any], kwargs.get("sub_totals"))
		self._index = cast(int, kwargs.get("index"))
		self._lat = cast(float, kwargs.get("lat"))
		self._lng = cast(float, kwargs.get("lng"))
		self._a = cast(int, kwargs.get("a"))
		self._r = cast(int, kwargs.get("r"))
		self._g = cast(int, kwargs.get("g"))
		self._b = cast(int, kwargs.get("b"))
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._sub_type = cast(Optional[str], kwargs.get("sub_type"))
		self._max_lat = cast(float, kwargs.get("max_lat"))
		self._min_lng = cast(float, kwargs.get("min_lng"))
		self._mid_lat = cast(float, kwargs.get("mid_lat"))
		self._mid_lng = cast(float, kwargs.get("mid_lng"))
		self._long_table_id = cast(Optional[str], kwargs.get("long_table_id"))
		self._graph_entry_type = cast(Optional[str], kwargs.get("graph_entry_type"))
		self._icon_halign = cast(HAlign, kwargs.get("icon_halign"))
		self._icon_valign = cast(VAlign, kwargs.get("icon_valign"))
	@property
	def data(self) -> "Dict[str, Any]":
		# pylint: disable=missing-function-docstring
		return self._data
	@data.setter
	def data(self, value: "Dict[str, Any]") -> None:
		# pylint: disable=missing-function-docstring
		self._data = value
	@property
	def sub_totals(self) -> "Dict[str, Any]":
		# pylint: disable=missing-function-docstring
		return self._sub_totals
	@sub_totals.setter
	def sub_totals(self, value: "Dict[str, Any]") -> None:
		# pylint: disable=missing-function-docstring
		self._sub_totals = value
	@property
	def index(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._index
	@index.setter
	def index(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._index = value
	@property
	def lat(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._lat
	@lat.setter
	def lat(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._lat = value
	@property
	def lng(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._lng
	@lng.setter
	def lng(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._lng = value
	@property
	def a(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._a
	@a.setter
	def a(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._a = value
	@property
	def r(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._r
	@r.setter
	def r(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._r = value
	@property
	def g(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._g
	@g.setter
	def g(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._g = value
	@property
	def b(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._b
	@b.setter
	def b(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._b = value
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def sub_type(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._sub_type
	@sub_type.setter
	def sub_type(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._sub_type = value
	@property
	def max_lat(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._max_lat
	@max_lat.setter
	def max_lat(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._max_lat = value
	@property
	def min_lng(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._min_lng
	@min_lng.setter
	def min_lng(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._min_lng = value
	@property
	def mid_lat(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._mid_lat
	@mid_lat.setter
	def mid_lat(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._mid_lat = value
	@property
	def mid_lng(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._mid_lng
	@mid_lng.setter
	def mid_lng(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._mid_lng = value
	@property
	def long_table_id(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._long_table_id
	@long_table_id.setter
	def long_table_id(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._long_table_id = value
	@property
	def graph_entry_type(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._graph_entry_type
	@graph_entry_type.setter
	def graph_entry_type(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._graph_entry_type = value
	@property
	def icon_halign(self) -> "HAlign":
		# pylint: disable=missing-function-docstring
		return self._icon_halign
	@icon_halign.setter
	def icon_halign(self, value: "HAlign") -> None:
		# pylint: disable=missing-function-docstring
		self._icon_halign = value
	@property
	def icon_valign(self) -> "VAlign":
		# pylint: disable=missing-function-docstring
		return self._icon_valign
	@icon_valign.setter
	def icon_valign(self, value: "VAlign") -> None:
		# pylint: disable=missing-function-docstring
		self._icon_valign = value


class RuleMatchMode(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	FIRST = 'First'
	LAST = 'Last'
	ALL = 'All'
	ALL_EXCEPT_LAST = 'AllExceptLast'
	ALL_EXCEPT_LAST_EXCLUDED = 'AllExceptLastExcluded'



class RuleMatchOrder(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	IN_ORDER = 'InOrder'
	REVERSE = 'Reverse'

class S3Config(GenericAdapterConfig):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"aws_access_key": ("awsAccessKey", "str", None),
		"aws_secret_key": ("awsSecretKey", "str", None),
		"bucket": ("bucket", "str", None),
		"service_url": ("serviceUrl", "str", None),
		"region": ("region", "str", None),
		"name": ("name", "str", None),
		"config_guid": ("configGuid", "str", None),
		"transports": ("transports", "list", "AdapterTransportsEnum"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		transports: "AdapterTransports",
		aws_access_key: Optional["str"] = None,
		aws_secret_key: Optional["str"] = None,
		bucket: Optional["str"] = None,
		service_url: Optional["str"] = None,
		region: Optional["str"] = None,
		name: Optional["str"] = None,
		config_guid: Optional["str"] = None,
	) -> None:
		"""
		:param transports:
		:type transports: AdapterTransports
		:param aws_access_key:
		:type aws_access_key: str or None
		:param aws_secret_key:
		:type aws_secret_key: str or None
		:param bucket:
		:type bucket: str or None
		:param service_url:
		:type service_url: str or None
		:param region:
		:type region: str or None
		:param name:
		:type name: str or None
		:param config_guid:
		:type config_guid: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		GenericAdapterConfig.__init__(self,
			name=kwargs.get("name"),
			config_guid=kwargs.get("config_guid"),
			transports=kwargs.get("transports"),
		)
		self._aws_access_key = cast(Optional[str], kwargs.get("aws_access_key"))
		self._aws_secret_key = cast(Optional[str], kwargs.get("aws_secret_key"))
		self._bucket = cast(Optional[str], kwargs.get("bucket"))
		self._service_url = cast(Optional[str], kwargs.get("service_url"))
		self._region = cast(Optional[str], kwargs.get("region"))
	@property
	def aws_access_key(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._aws_access_key
	@aws_access_key.setter
	def aws_access_key(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._aws_access_key = value
	@property
	def aws_secret_key(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._aws_secret_key
	@aws_secret_key.setter
	def aws_secret_key(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._aws_secret_key = value
	@property
	def bucket(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._bucket
	@bucket.setter
	def bucket(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._bucket = value
	@property
	def service_url(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._service_url
	@service_url.setter
	def service_url(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._service_url = value
	@property
	def region(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._region
	@region.setter
	def region(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._region = value
class S57Config(GenericAdapterConfig):
	"""Use when importing S57 archives"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"layers_to_import": ("layersToImport", "list", "str"),
		"name": ("name", "str", None),
		"config_guid": ("configGuid", "str", None),
		"transports": ("transports", "list", "AdapterTransportsEnum"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		layers_to_import: "List[str]",
		transports: "AdapterTransports",
		name: Optional["str"] = None,
		config_guid: Optional["str"] = None,
	) -> None:
		"""
		:param layers_to_import: Specifies what layers to import. All layers will be imported if left blank
		:type layers_to_import: List[str]
		:param transports:
		:type transports: AdapterTransports
		:param name:
		:type name: str or None
		:param config_guid:
		:type config_guid: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		GenericAdapterConfig.__init__(self,
			name=kwargs.get("name"),
			config_guid=kwargs.get("config_guid"),
			transports=kwargs.get("transports"),
		)
		self._layers_to_import = cast(List[str], kwargs.get("layers_to_import"))
	@property
	def layers_to_import(self) -> "List[str]":
		"""Specifies what layers to import. All layers will be imported if left blank"""
		return self._layers_to_import
	@layers_to_import.setter
	def layers_to_import(self, value: "List[str]") -> None:
		"""Specifies what layers to import. All layers will be imported if left blank"""
		self._layers_to_import = value
class Session:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"name": ("name", "str", None),
		"path": ("path", "str", None),
		"type_": ("type", "str", None),
		"kernel": ("kernel", "Kernel", None),
		"notebook": ("notebook", "Notebook", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		kernel: "Kernel",
		notebook: "Notebook",
		id_: Optional["str"] = None,
		name: Optional["str"] = None,
		path: Optional["str"] = None,
		type_: Optional["str"] = None,
	) -> None:
		"""
		:param kernel:
		:type kernel: Kernel
		:param notebook:
		:type notebook: Notebook
		:param id_:
		:type id_: str or None
		:param name:
		:type name: str or None
		:param path:
		:type path: str or None
		:param type_:
		:type type_: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._path = cast(Optional[str], kwargs.get("path"))
		self._type_ = cast(Optional[str], kwargs.get("type_"))
		self._kernel = cast(Kernel, kwargs.get("kernel"))
		self._notebook = cast(Notebook, kwargs.get("notebook"))
	@property
	def id_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._path
	@path.setter
	def path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path = value
	@property
	def type_(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._type_
	@type_.setter
	def type_(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._type_ = value
	@property
	def kernel(self) -> "Kernel":
		# pylint: disable=missing-function-docstring
		return self._kernel
	@kernel.setter
	def kernel(self, value: "Kernel") -> None:
		# pylint: disable=missing-function-docstring
		self._kernel = value
	@property
	def notebook(self) -> "Notebook":
		# pylint: disable=missing-function-docstring
		return self._notebook
	@notebook.setter
	def notebook(self, value: "Notebook") -> None:
		# pylint: disable=missing-function-docstring
		self._notebook = value


class ShadeMethod(str, Enum):
	"""Core option"""
	DEFAULT = 'default'
	BASIC = 'basic'
	RULES = 'rules'
	INTERVAL = 'interval'
	SINGLEURL = 'singleurl'
	DYNAMIC = 'dynamic'

ShadeMethod.DEFAULT.__doc__ = """For dot layers, mark data with 18x18 red dot icons with black borders. For other layers, this is the same as `basic`."""
ShadeMethod.BASIC.__doc__ = """Mark data using the specified style settings, such as: shape, width, height, borderWidth, fillColor, borderColor, lineCap, lineDash, etc."""
ShadeMethod.RULES.__doc__ = """Specify a collection of style rules. `where` clauses indicate which `style` should be used."""
ShadeMethod.INTERVAL.__doc__ = """Use the column named in `shadeBy` to vary the foreground color or icon size. Specify the column value min/max range with `ranges`, the color min/max with `colors`, and the size min/max with `sizes`."""
ShadeMethod.SINGLEURL.__doc__ = """Mark data using the icon specified in `uri`."""


class ShaderStyle(str, Enum):
	"""Icon property: Specify the icon shape."""
	ROUND = 'round'
	RECTANGLE = 'rectangle'
	ICON_SQUARE = 'IconSquare'
	TRIANGLE = 'triangle'
	DIAMOND = 'diamond'
	PLUS = 'plus'
	STAR = 'star'
	X = 'x'
	CHEVRON = 'chevron'

ShaderStyle.ROUND.__doc__ = """Circular icons (or an ellipse)."""
ShaderStyle.RECTANGLE.__doc__ = """Square icons with rounded corners (or a rectangle)."""
ShaderStyle.TRIANGLE.__doc__ = """Triangular icons."""
ShaderStyle.DIAMOND.__doc__ = """Diamond icons (a rhombus)."""
ShaderStyle.PLUS.__doc__ = """Plus-sign, or cross, icons."""
ShaderStyle.STAR.__doc__ = """Five pointed star icons."""
ShaderStyle.X.__doc__ = """X-shaped icons."""
ShaderStyle.CHEVRON.__doc__ = """Chevron icon."""


class SkiaMicroChartPyramidMethod(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	HEIGHT = 'Height'
	AREA = 'Area'



class SkiaMicroChartPyramidSort(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	HEAVY = 'Heavy'
	LIGHT = 'Light'

class Snapshot:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"binary_version": ("binaryVersion", "int", None),
		"last_included_transaction": ("lastIncludedTransaction", "int", None),
		"created_timestamp": ("createdTimestamp", "datetime", None),
		"snapshot_creator": ("snapshotCreator", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		binary_version: Optional["int"] = None,
		last_included_transaction: Optional["int"] = None,
		created_timestamp: Optional["datetime"] = None,
		snapshot_creator: Optional["str"] = None,
	) -> None:
		"""
		:param binary_version: The binary encoding version of the database when the snapshot was made. May not change with BuildVersion.
		:type binary_version: int or None
		:param last_included_transaction: The highest transaction id included in the snapshot
		:type last_included_transaction: int or None
		:param created_timestamp: The date and time when the snapshot was created
		:type created_timestamp: datetime or None
		:param snapshot_creator: The name of the node that created the snapshot
		:type snapshot_creator: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._binary_version = cast(Optional[int], kwargs.get("binary_version"))
		self._last_included_transaction = cast(Optional[int], kwargs.get("last_included_transaction"))
		self._created_timestamp = cast(Optional[datetime], kwargs.get("created_timestamp"))
		self._snapshot_creator = cast(Optional[str], kwargs.get("snapshot_creator"))
	@property
	def binary_version(self) -> Optional["int"]:
		"""The binary encoding version of the database when the snapshot was made. May not change with BuildVersion."""
		return self._binary_version
	@binary_version.setter
	def binary_version(self, value: Optional["int"]) -> None:
		"""The binary encoding version of the database when the snapshot was made. May not change with BuildVersion."""
		self._binary_version = value
	@property
	def last_included_transaction(self) -> Optional["int"]:
		"""The highest transaction id included in the snapshot"""
		return self._last_included_transaction
	@last_included_transaction.setter
	def last_included_transaction(self, value: Optional["int"]) -> None:
		"""The highest transaction id included in the snapshot"""
		self._last_included_transaction = value
	@property
	def created_timestamp(self) -> Optional["datetime"]:
		"""The date and time when the snapshot was created"""
		return self._created_timestamp
	@created_timestamp.setter
	def created_timestamp(self, value: Optional["datetime"]) -> None:
		"""The date and time when the snapshot was created"""
		self._created_timestamp = value
	@property
	def snapshot_creator(self) -> Optional["str"]:
		"""The name of the node that created the snapshot"""
		return self._snapshot_creator
	@snapshot_creator.setter
	def snapshot_creator(self, value: Optional["str"]) -> None:
		"""The name of the node that created the snapshot"""
		self._snapshot_creator = value


class StackingBehavior(str, Enum):
	# pylint: disable=missing-class-docstring
	DRAW_FIRST = 'DrawFirst'
	DRAW_ALL = 'DrawAll'

class StateMachine:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"current_snapshot": ("currentSnapshot", "Snapshot", None),
		"queue_depths": ("queueDepths", "QueueDepths", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		current_snapshot: "Snapshot",
		queue_depths: "QueueDepths",
	) -> None:
		"""
		:param current_snapshot: Information about the most recent database snapshot
		:type current_snapshot: Snapshot
		:param queue_depths: Information about the most recent database snapshot
		:type queue_depths: QueueDepths
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._current_snapshot = cast(Snapshot, kwargs.get("current_snapshot"))
		self._queue_depths = cast(QueueDepths, kwargs.get("queue_depths"))
	@property
	def current_snapshot(self) -> "Snapshot":
		"""Information about the most recent database snapshot"""
		return self._current_snapshot
	@current_snapshot.setter
	def current_snapshot(self, value: "Snapshot") -> None:
		"""Information about the most recent database snapshot"""
		self._current_snapshot = value
	@property
	def queue_depths(self) -> "QueueDepths":
		"""Information about the most recent database snapshot"""
		return self._queue_depths
	@queue_depths.setter
	def queue_depths(self, value: "QueueDepths") -> None:
		"""Information about the most recent database snapshot"""
		self._queue_depths = value
class Style:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"draw_shapes": ("drawShapes", "bool", None),
		"draw_lines": ("drawLines", "bool", None),
		"method": ("method", "ShadeMethod", None),
		"buffer_size": ("bufferSize", "int", None),
		"stacking_behavior": ("stackingBehavior", "StackingBehavior", None),
		"color_transform": ("colorTransform", "LayerColorTransformValues", None),
		"rules": ("rules", "list", "StyleRule"),
		"hover": ("hover", "StyleHover", None),
		"water_mark": ("waterMark", "StyleWaterMark", None),
		"hover_style": ("hoverStyle", "Style", None),
		"click_style": ("clickStyle", "Style", None),
		"composites": ("composites", "list", "StyleComposite"),
		"draw_hover_grid": ("drawHoverGrid", "bool", None),
		"draw_hover_grid_time": ("drawHoverGridTime", "bool", None),
		"draw_render_time": ("drawRenderTime", "bool", None),
		"draw_tile_xyz": ("drawTileXYZ", "bool", None),
		"draw_tile_border": ("drawTileBorder", "bool", None),
		"overlay": ("overlay", "StyleOverlay", None),
		"numeric_label": ("numericLabel", "StyleText", None),
		"text": ("text", "StyleText", None),
		"xoffset": ("xOffset", "int", None),
		"yoffset": ("yOffset", "int", None),
		"width": ("width", "int", None),
		"height": ("height", "int", None),
		"blur_style": ("blurStyle", "BlurStyle", None),
		"blur_sigma": ("blurSigma", "float", None),
		"border_width": ("borderWidth", "int", None),
		"outline_width": ("outlineWidth", "int", None),
		"border_blur_style": ("borderBlurStyle", "BlurStyle", None),
		"border_blur_sigma": ("borderBlurSigma", "float", None),
		"inner_borders": ("innerBorders", "bool", None),
		"shield": ("shield", "StyleShield", None),
		"uri": ("uri", "str", None),
		"shape": ("shape", "ShaderStyle", None),
		"shape_custom_path": ("shapeCustomPath", "str", None),
		"svg": ("svg", "list", "StyleSvgAttribute"),
		"drop_shadow": ("dropShadow", "bool", None),
		"drop_shadow_length": ("dropShadowLength", "int", None),
		"drop_shadow_color": ("dropShadowColor", "str", None),
		"hide_icons_height": ("hideIconsHeight", "int", None),
		"hide_icons_width": ("hideIconsWidth", "int", None),
		"hover_icon_transparency": ("hoverIconTransparency", "bool", None),
		"icon_halign": ("iconHAlign", "HAlign", None),
		"icon_valign": ("iconVAlign", "VAlign", None),
		"rotation_angle": ("rotationAngle", "float", None),
		"rotation_relative_to": ("rotationRelativeTo", "RelativeRotation", None),
		"icon_data_color_type": ("iconDataColorType", "IconDataColorType", None),
		"icon_data_color_quant_depth": ("iconDataColorQuantDepth", "int", None),
		"icon_data_color_bins": ("iconDataColorBins", "int", None),
		"layers": ("layers", "list", "IconLayer"),
		"badges": ("badges", "list", "IconBadge"),
		"fill_color": ("fillColor", "str", None),
		"border_color": ("borderColor", "str", None),
		"outline_color": ("outlineColor", "str", None),
		"gradient_color_position": ("gradientColorPosition", "str", None),
		"border_color_offset": ("borderColorOffset", "int", None),
		"fill_color_alpha_offset": ("fillColorAlphaOffset", "int", None),
		"border_brightness": ("borderBrightness", "int", None),
		"colors": ("colors", None, None),
		"colorize_color": ("colorizeColor", "str", None),
		"hatch_color": ("hatchColor", "str", None),
		"shade_by": ("shadeBy", "str", None),
		"divide_by": ("divideBy", "str", None),
		"order_by": ("orderBy", "str", None),
		"sort_direction": ("sortDirection", "str", None),
		"hover_sort_direction": ("hoverSortDirection", "str", None),
		"shade_aggregate_type": ("shadeAggregateType", "TotalTypes", None),
		"shade_aggregate_type_divisor": ("shadeAggregateTypeDivisor", "TotalTypes", None),
		"default_divisor": ("defaultDivisor", "float", None),
		"steps": ("steps", "int", None),
		"ranges": ("ranges", None, None),
		"sizes": ("sizes", None, None),
		"dot_gradient_style": ("dotGradientStyle", "DotGradientStyle", None),
		"paint_edges_on_dateline": ("paintEdgesOnDateline", "bool", None),
		"border_clipping": ("borderClipping", "BorderClipping", None),
		"poly_path_fill_type": ("polyPathFillType", "PolyPathFillType", None),
		"poly_gradient_style": ("polyGradientStyle", "PolyGradientStyle", None),
		"poly_vertex_mode": ("polyVertexMode", "PolyVertexMode", None),
		"poly_vertex_color_style": ("polyVertexColorStyle", "PolyVertexColorStyle", None),
		"centroid": ("centroid", "StyleCentroid", None),
		"min_shape_size": ("minShapeSize", "int", None),
		"min_shape_transparent_border_fill": ("minShapeTransparentBorderFill", "bool", None),
		"min_shape_pixels": ("minShapePixels", "int", None),
		"hatch_style": ("hatchStyle", "HatchStyle", None),
		"min_shape": ("minShape", "Style", None),
		"blending": ("blending", "bool", None),
		"anti_aliasing": ("antiAliasing", "bool", None),
		"line_cap": ("lineCap", "LineCapStyle", None),
		"line_dash_color": ("lineDashColor", "list", "str"),
		"line_dash": ("lineDash", "LineDashStyle", None),
		"custom_line_dash": ("customLineDash", "list", "float"),
		"line_dash_phase": ("lineDashPhase", "float", None),
		"discrete_seg_length": ("discreteSegLength", "float", None),
		"discrete_deviation": ("discreteDeviation", "float", None),
		"line_gradient_style": ("lineGradientStyle", "LineGradientStyle", None),
		"stroke_join": ("strokeJoin", "LineStrokeJoin", None),
		"stroke_miter": ("strokeMiter", "float", None),
		"line_icon_width": ("lineIconWidth", "int", None),
		"hover_line_width": ("hoverLineWidth", "int", None),
		"line_icon_height": ("lineIconHeight", "int", None),
		"line_offset": ("lineOffset", "int", None),
		"angle_offset": ("angleOffset", "float", None),
		"rotate_with_line": ("rotateWithLine", "bool", None),
		"icon_spacing": ("iconSpacing", "int", None),
		"icon_xoffset": ("iconXOffset", "int", None),
		"icon_yoffset": ("iconYOffset", "int", None),
		"center_icon": ("centerIcon", "bool", None),
		"draw_first_point": ("drawFirstPoint", "bool", None),
		"draw_line": ("drawLine", "bool", None),
		"line_icon_mode": ("lineIconMode", "LineIconMode", None),
		"borders": ("borders", None, None),
		"path_1_d": ("path1D", "StylePath1D", None),
		"min_cluster_size": ("minClusterSize", "int", None),
		"auto_icon_enable": ("autoIconEnable", "bool", None),
		"auto_icon_size_spread": ("autoIconSizeSpread", "int", None),
		"auto_icon_color_set": ("autoIconColorSet", "int", None),
		"cluster_centroid": ("clusterCentroid", "ClusterCentroid", None),
		"snap_to_table": ("snapToTable", "str", None),
		"snap_to_column": ("snapToColumn", "str", None),
		"color_spread": ("colorSpread", "int", None),
		"size_spread": ("sizeSpread", "int", None),
		"color_set": ("colorSet", "int", None),
		"child_count_enable": ("childCountEnable", "bool", None),
		"child_count_point_size": ("childCountPointSize", "int", None),
		"child_count_font": ("childCountFont", "str", None),
		"child_count_color": ("childCountColor", "str", None),
		"child_count_offset_x": ("childCountOffsetX", "int", None),
		"child_count_offset_y": ("childCountOffsetY", "int", None),
		"clustering_distance": ("clusteringDistance", "int", None),
		"clustering_grid_size": ("clusteringGridSize", "int", None),
		"cluster_grid_spacing": ("clusterGridSpacing", "int", None),
		"max_margin_size": ("maxMarginSize", "int", None),
		"max_cluster_zoom": ("maxClusterZoom", "int", None),
		"overlap_threshold": ("overlapThreshold", "int", None),
		"auto_icon_color_spread": ("autoIconColorSpread", "int", None),
		"cluster": ("cluster", "Style", None),
		"icon_size": ("iconSize", "int", None),
		"density_threshold": ("densityThreshold", "int", None),
		"gradient": ("gradient", "str", None),
		"render_algo": ("renderAlgo", "str", None),
		"gradient_set": ("gradientSet", "int", None),
		"image": ("image", "StyleImageComponent", None),
		"super_resolution": ("superResolution", "bool", None),
		"image_filter_high_quality": ("imageFilterHighQuality", "bool", None),
		"image_force_reproject": ("imageForceReproject", "bool", None),
		"image_min_zoom": ("imageMinZoom", "int", None),
		"image_max_zoom": ("imageMaxZoom", "int", None),
		"raster_gradient": ("rasterGradient", "list", "GradientPair"),
		"scale_min": ("scaleMin", "float", None),
		"scale_max": ("scaleMax", "float", None),
		"scale_min_column_name": ("ScaleMinColumnName", "str", None),
		"scale_max_column_name": ("ScaleMaxColumnName", "str", None),
		"nodata": ("nodata", "float", None),
		"interpolate_start_zoom": ("interpolateStartZoom", "int", None),
		"uniform_downsampling": ("uniformDownsampling", "bool", None),
		"scale_log": ("scaleLog", "bool", None),
		"scale_transparent_below": ("scaleTransparentBelow", "bool", None),
		"scale_transparent_above": ("scaleTransparentAbove", "bool", None),
		"contour_start": ("contourStart", "float", None),
		"contour_step": ("contourStep", "float", None),
		"raster_type": ("rasterType", "RasterType", None),
		"raster_min_zoom": ("rasterMinZoom", "int", None),
		"raster_max_zoom": ("rasterMaxZoom", "int", None),
		"raster_select": ("rasterSelect", "str", None),
		"raster_cell_select": ("rasterCellSelect", "str", None),
		"raster_u": ("rasterU", "str", None),
		"raster_v": ("rasterV", "str", None),
		"interpolate": ("interpolate", "InterpolateMode", None),
		"aggregate": ("aggregate", "AggregateMode", None),
		"render_overlap": ("renderOverlap", "bool", None),
		"min_px_size": ("minPxSize", "int", None),
		"micro_chart_type": ("microChartType", "ChartType", None),
		"values": ("values", "list", "float"),
		"string_values": ("stringValues", "list", "str"),
		"values_min": ("valuesMin", "float", None),
		"values_max": ("valuesMax", "float", None),
		"inner_radius": ("innerRadius", "int", None),
		"pyramid_sort": ("pyramidSort", "SkiaMicroChartPyramidSort", None),
		"pyramid_method": ("pyramidMethod", "SkiaMicroChartPyramidMethod", None),
		"asset": ("asset", "StyleAsset", None),
		"military_symbol_enabled": ("militarySymbolEnabled", "bool", None),
		"military_symbol_standard": ("militarySymbolStandard", "str", None),
		"military_symbol_sidc": ("militarySymbolSidc", "str", None),
		"zoom_based_line_simplification": ("zoomBasedLineSimplification", "bool", None),
		"preload_zoom_based_line_simplification": ("preloadZoomBasedLineSimplification", "bool", None),
		"hover_short_circuit": ("hoverShortCircuit", "bool", None),
		"simplify_small_polygons": ("simplifySmallPolygons", "bool", None),
		"base_color": ("baseColor", "str", None),
		"base_transform": ("baseTransform", "list", "float"),
		"rule_match_mode": ("ruleMatchMode", "RuleMatchMode", None),
		"rule_match_order": ("ruleMatchOrder", "RuleMatchOrder", None),
		"unique_id": ("UniqueId", "str", None),
		"debug": ("debug", "bool", None),
		"additional_raster_style": ("additionalRasterStyle", "list", "StyleAdditionalRasterStyleComponent"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		water_mark: "StyleWaterMark",
		hover_icon_transparency: "bool",
		rotation_relative_to: "RelativeRotation",
		stroke_join: "LineStrokeJoin",
		stroke_miter: "float",
		image_filter_high_quality: "bool",
		image_force_reproject: "bool",
		base_transform: "List[float]",
		unique_id: "str",
		draw_shapes: Optional["bool"] = None,
		draw_lines: Optional["bool"] = None,
		method: Optional["ShadeMethod"] = None,
		buffer_size: Optional["int"] = None,
		stacking_behavior: Optional["StackingBehavior"] = None,
		color_transform: Optional["LayerColorTransformValues"] = None,
		rules: Optional["List[StyleRule]"] = None,
		hover: Optional["StyleHover"] = None,
		hover_style: Optional["Style"] = None,
		click_style: Optional["Style"] = None,
		composites: Optional["List[StyleComposite]"] = None,
		draw_hover_grid: Optional["bool"] = None,
		draw_hover_grid_time: Optional["bool"] = None,
		draw_render_time: Optional["bool"] = None,
		draw_tile_xyz: Optional["bool"] = None,
		draw_tile_border: Optional["bool"] = None,
		overlay: Optional["StyleOverlay"] = None,
		numeric_label: Optional["StyleText"] = None,
		text: Optional["StyleText"] = None,
		xoffset: Optional["int"] = None,
		yoffset: Optional["int"] = None,
		width: Optional["int"] = None,
		height: Optional["int"] = None,
		blur_style: Optional["BlurStyle"] = None,
		blur_sigma: Optional["float"] = None,
		border_width: Optional["int"] = None,
		outline_width: Optional["int"] = None,
		border_blur_style: Optional["BlurStyle"] = None,
		border_blur_sigma: Optional["float"] = None,
		inner_borders: Optional["bool"] = None,
		shield: Optional["StyleShield"] = None,
		uri: Optional["str"] = None,
		shape: Optional["ShaderStyle"] = None,
		shape_custom_path: Optional["str"] = None,
		svg: Optional["List[StyleSvgAttribute]"] = None,
		drop_shadow: Optional["bool"] = None,
		drop_shadow_length: Optional["int"] = None,
		drop_shadow_color: Optional["str"] = None,
		hide_icons_height: Optional["int"] = None,
		hide_icons_width: Optional["int"] = None,
		icon_halign: Optional["HAlign"] = None,
		icon_valign: Optional["VAlign"] = None,
		rotation_angle: Optional["float"] = None,
		icon_data_color_type: Optional["IconDataColorType"] = None,
		icon_data_color_quant_depth: Optional["int"] = None,
		icon_data_color_bins: Optional["int"] = None,
		layers: Optional["List[IconLayer]"] = None,
		badges: Optional["List[IconBadge]"] = None,
		fill_color: Optional["str"] = None,
		border_color: Optional["str"] = None,
		outline_color: Optional["str"] = None,
		gradient_color_position: Optional["str"] = None,
		border_color_offset: Optional["int"] = None,
		fill_color_alpha_offset: Optional["int"] = None,
		border_brightness: Optional["int"] = None,
		colors: Optional["Union[ColorRange, List[ColorRange]]"] = None,
		colorize_color: Optional["str"] = None,
		hatch_color: Optional["str"] = None,
		shade_by: Optional["str"] = None,
		divide_by: Optional["str"] = None,
		order_by: Optional["str"] = None,
		sort_direction: Optional["str"] = None,
		hover_sort_direction: Optional["str"] = None,
		shade_aggregate_type: Optional["TotalTypes"] = None,
		shade_aggregate_type_divisor: Optional["TotalTypes"] = None,
		default_divisor: Optional["float"] = None,
		steps: Optional["int"] = None,
		ranges: Optional["Union[NumberRange, List[NumberRange]]"] = None,
		sizes: Optional["Union[NumberRange, List[NumberRange]]"] = None,
		dot_gradient_style: Optional["DotGradientStyle"] = None,
		paint_edges_on_dateline: Optional["bool"] = None,
		border_clipping: Optional["BorderClipping"] = None,
		poly_path_fill_type: Optional["PolyPathFillType"] = None,
		poly_gradient_style: Optional["PolyGradientStyle"] = None,
		poly_vertex_mode: Optional["PolyVertexMode"] = None,
		poly_vertex_color_style: Optional["PolyVertexColorStyle"] = None,
		centroid: Optional["StyleCentroid"] = None,
		min_shape_size: Optional["int"] = None,
		min_shape_transparent_border_fill: Optional["bool"] = None,
		min_shape_pixels: Optional["int"] = None,
		hatch_style: Optional["HatchStyle"] = None,
		min_shape: Optional["Style"] = None,
		blending: Optional["bool"] = None,
		anti_aliasing: Optional["bool"] = None,
		line_cap: Optional["LineCapStyle"] = None,
		line_dash_color: Optional["List[str]"] = None,
		line_dash: Optional["LineDashStyle"] = None,
		custom_line_dash: Optional["List[float]"] = None,
		line_dash_phase: Optional["float"] = None,
		discrete_seg_length: Optional["float"] = None,
		discrete_deviation: Optional["float"] = None,
		line_gradient_style: Optional["LineGradientStyle"] = None,
		line_icon_width: Optional["int"] = None,
		hover_line_width: Optional["int"] = None,
		line_icon_height: Optional["int"] = None,
		line_offset: Optional["int"] = None,
		angle_offset: Optional["float"] = None,
		rotate_with_line: Optional["bool"] = None,
		icon_spacing: Optional["int"] = None,
		icon_xoffset: Optional["int"] = None,
		icon_yoffset: Optional["int"] = None,
		center_icon: Optional["bool"] = None,
		draw_first_point: Optional["bool"] = None,
		draw_line: Optional["bool"] = None,
		line_icon_mode: Optional["LineIconMode"] = None,
		borders: Optional["Union[StyleLineBorder, List[StyleLineBorder]]"] = None,
		path_1_d: Optional["StylePath1D"] = None,
		min_cluster_size: Optional["int"] = None,
		auto_icon_enable: Optional["bool"] = None,
		auto_icon_size_spread: Optional["int"] = None,
		auto_icon_color_set: Optional["int"] = None,
		cluster_centroid: Optional["ClusterCentroid"] = None,
		snap_to_table: Optional["str"] = None,
		snap_to_column: Optional["str"] = None,
		color_spread: Optional["int"] = None,
		size_spread: Optional["int"] = None,
		color_set: Optional["int"] = None,
		child_count_enable: Optional["bool"] = None,
		child_count_point_size: Optional["int"] = None,
		child_count_font: Optional["str"] = None,
		child_count_color: Optional["str"] = None,
		child_count_offset_x: Optional["int"] = None,
		child_count_offset_y: Optional["int"] = None,
		clustering_distance: Optional["int"] = None,
		clustering_grid_size: Optional["int"] = None,
		cluster_grid_spacing: Optional["int"] = None,
		max_margin_size: Optional["int"] = None,
		max_cluster_zoom: Optional["int"] = None,
		overlap_threshold: Optional["int"] = None,
		auto_icon_color_spread: Optional["int"] = None,
		cluster: Optional["Style"] = None,
		icon_size: Optional["int"] = None,
		density_threshold: Optional["int"] = None,
		gradient: Optional["str"] = None,
		render_algo: Optional["str"] = None,
		gradient_set: Optional["int"] = None,
		image: Optional["StyleImageComponent"] = None,
		super_resolution: Optional["bool"] = None,
		image_min_zoom: Optional["int"] = None,
		image_max_zoom: Optional["int"] = None,
		raster_gradient: Optional["List[GradientPair]"] = None,
		scale_min: Optional["float"] = None,
		scale_max: Optional["float"] = None,
		scale_min_column_name: Optional["str"] = None,
		scale_max_column_name: Optional["str"] = None,
		nodata: Optional["float"] = None,
		interpolate_start_zoom: Optional["int"] = None,
		uniform_downsampling: Optional["bool"] = None,
		scale_log: Optional["bool"] = None,
		scale_transparent_below: Optional["bool"] = None,
		scale_transparent_above: Optional["bool"] = None,
		contour_start: Optional["float"] = None,
		contour_step: Optional["float"] = None,
		raster_type: Optional["RasterType"] = None,
		raster_min_zoom: Optional["int"] = None,
		raster_max_zoom: Optional["int"] = None,
		raster_select: Optional["str"] = None,
		raster_cell_select: Optional["str"] = None,
		raster_u: Optional["str"] = None,
		raster_v: Optional["str"] = None,
		interpolate: Optional["InterpolateMode"] = None,
		aggregate: Optional["AggregateMode"] = None,
		render_overlap: Optional["bool"] = None,
		min_px_size: Optional["int"] = None,
		micro_chart_type: Optional["ChartType"] = None,
		values: Optional["List[float]"] = None,
		string_values: Optional["List[str]"] = None,
		values_min: Optional["float"] = None,
		values_max: Optional["float"] = None,
		inner_radius: Optional["int"] = None,
		pyramid_sort: Optional["SkiaMicroChartPyramidSort"] = None,
		pyramid_method: Optional["SkiaMicroChartPyramidMethod"] = None,
		asset: Optional["StyleAsset"] = None,
		military_symbol_enabled: Optional["bool"] = None,
		military_symbol_standard: Optional["str"] = None,
		military_symbol_sidc: Optional["str"] = None,
		zoom_based_line_simplification: Optional["bool"] = None,
		preload_zoom_based_line_simplification: Optional["bool"] = None,
		hover_short_circuit: Optional["bool"] = None,
		simplify_small_polygons: Optional["bool"] = None,
		base_color: Optional["str"] = None,
		rule_match_mode: Optional["RuleMatchMode"] = None,
		rule_match_order: Optional["RuleMatchOrder"] = None,
		debug: Optional["bool"] = None,
		additional_raster_style: Optional["List[StyleAdditionalRasterStyleComponent]"] = None,
	) -> None:
		"""
		:param water_mark:
		:type water_mark: StyleWaterMark
		:param hover_icon_transparency:
		:type hover_icon_transparency: bool
		:param rotation_relative_to:
		:type rotation_relative_to: RelativeRotation
		:param stroke_join: Line property
		:type stroke_join: LineStrokeJoin
		:param stroke_miter: Line property
		:type stroke_miter: float
		:param image_filter_high_quality:
		:type image_filter_high_quality: bool
		:param image_force_reproject:
		:type image_force_reproject: bool
		:param base_transform:
		:type base_transform: List[float]
		:param unique_id:
		:type unique_id: str
		:param draw_shapes: Core property
		:type draw_shapes: bool or None
		:param draw_lines: Core property
		:type draw_lines: bool or None
		:param method: Core option
* `default` - For dot layers, mark data with 18x18 red dot icons with black borders. For other layers, this is the same as `basic`.
* `basic` - Mark data using the specified style settings, such as: shape, width, height, borderWidth, fillColor, borderColor, lineCap, lineDash, etc.
* `rules` - Specify a collection of style rules. `where` clauses indicate which `style` should be used.
* `interval` - Use the column named in `shadeBy` to vary the foreground color or icon size. Specify the column value min/max range with `ranges`, the color min/max with `colors`, and the size min/max with `sizes`.
* `singleurl` - Mark data using the icon specified in `uri`.
		:type method: ShadeMethod or None
		:param buffer_size: Core property
		:type buffer_size: int or None
		:param stacking_behavior:
		:type stacking_behavior: StackingBehavior or None
		:param color_transform:
		:type color_transform: LayerColorTransformValues or None
		:param rules: Core property
		:type rules: List[StyleRule] or None
		:param hover:
		:type hover: StyleHover or None
		:param hover_style:
		:type hover_style: Style or None
		:param click_style:
		:type click_style: Style or None
		:param composites:
		:type composites: List[StyleComposite] or None
		:param draw_hover_grid: Debug property: highlight all of the 4x4 pixel squares that contain hover grid data in magenta.
		:type draw_hover_grid: bool or None
		:param draw_hover_grid_time: Debug property: write how long it took to calculate the hover grid data in the lower right corner of the tiles.
		:type draw_hover_grid_time: bool or None
		:param draw_render_time: Debug property: write how long it took to render the tile contents in the lower left corner of the tiles.
		:type draw_render_time: bool or None
		:param draw_tile_xyz: Debug property: write the X/Y coordinates and zoom level in the center of the tiles.
		:type draw_tile_xyz: bool or None
		:param draw_tile_border: Debug property: outline each tile.
		:type draw_tile_border: bool or None
		:param overlay: Core property
		:type overlay: StyleOverlay or None
		:param numeric_label:
		:type numeric_label: StyleText or None
		:param text:
		:type text: StyleText or None
		:param xoffset:
		:type xoffset: int or None
		:param yoffset:
		:type yoffset: int or None
		:param width: Size property
		:type width: int or None
		:param height: Size property
		:type height: int or None
		:param blur_style: Size property
		:type blur_style: BlurStyle or None
		:param blur_sigma: Size property
		:type blur_sigma: float or None
		:param border_width: Size property
		:type border_width: int or None
		:param outline_width: Size property
		:type outline_width: int or None
		:param border_blur_style: Size property
		:type border_blur_style: BlurStyle or None
		:param border_blur_sigma: Size property
		:type border_blur_sigma: float or None
		:param inner_borders: Size property
		:type inner_borders: bool or None
		:param shield:
		:type shield: StyleShield or None
		:param uri: Icon property: Use a custom image for the icon that is located at this publicly accessible URL.
		:type uri: str or None
		:param shape: Icon property: Specify the icon shape.
* `round` - Circular icons (or an ellipse).
* `rectangle` - Square icons with rounded corners (or a rectangle).
* `triangle` - Triangular icons.
* `diamond` - Diamond icons (a rhombus).
* `plus` - Plus-sign, or cross, icons.
* `star` - Five pointed star icons.
* `x` - X-shaped icons.
* `chevron` - Chevron icon.
		:type shape: ShaderStyle or None
		:param shape_custom_path:
		:type shape_custom_path: str or None
		:param svg: Icon property
		:type svg: List[StyleSvgAttribute] or None
		:param drop_shadow: Icon property
		:type drop_shadow: bool or None
		:param drop_shadow_length: Icon property
		:type drop_shadow_length: int or None
		:param drop_shadow_color: Icon property
		:type drop_shadow_color: str or None
		:param hide_icons_height:
		:type hide_icons_height: int or None
		:param hide_icons_width:
		:type hide_icons_width: int or None
		:param icon_halign:
		:type icon_halign: HAlign or None
		:param icon_valign:
		:type icon_valign: VAlign or None
		:param rotation_angle:
		:type rotation_angle: float or None
		:param icon_data_color_type:
		:type icon_data_color_type: IconDataColorType or None
		:param icon_data_color_quant_depth:
		:type icon_data_color_quant_depth: int or None
		:param icon_data_color_bins:
		:type icon_data_color_bins: int or None
		:param layers:
		:type layers: List[IconLayer] or None
		:param badges:
		:type badges: List[IconBadge] or None
		:param fill_color: Color property
		:type fill_color: str or None
		:param border_color: Color property
		:type border_color: str or None
		:param outline_color: Color property
		:type outline_color: str or None
		:param gradient_color_position: Color property: String containing a comma separated list of numbers.
		:type gradient_color_position: str or None
		:param border_color_offset: Color property
		:type border_color_offset: int or None
		:param fill_color_alpha_offset: Color property
		:type fill_color_alpha_offset: int or None
		:param border_brightness:
		:type border_brightness: int or None
		:param colors: Color property
		:type colors: Union[ColorRange, List[ColorRange]] or None
		:param colorize_color: Color property
		:type colorize_color: str or None
		:param hatch_color: Color property
		:type hatch_color: str or None
		:param shade_by: Data property: Either column, column.agg, table.column, table.column.agg, or divide(...column..., ...column...), where agg is one of 'avg', 'count', 'sum', 'max', or 'min'.
		:type shade_by: str or None
		:param divide_by:
		:type divide_by: str or None
		:param order_by: Data property: Either column or column.desc.
		:type order_by: str or None
		:param sort_direction: Data property: Override the sort direction. Accepts 'asc' or 'desc'.
		:type sort_direction: str or None
		:param hover_sort_direction: Data property: Override the hover sort direction. Accepts 'asc' or 'desc'
		:type hover_sort_direction: str or None
		:param shade_aggregate_type:
		:type shade_aggregate_type: TotalTypes or None
		:param shade_aggregate_type_divisor:
		:type shade_aggregate_type_divisor: TotalTypes or None
		:param default_divisor:
		:type default_divisor: float or None
		:param steps: Data property
		:type steps: int or None
		:param ranges: Data property
		:type ranges: Union[NumberRange, List[NumberRange]] or None
		:param sizes: Data property
		:type sizes: Union[NumberRange, List[NumberRange]] or None
		:param dot_gradient_style: Dot property
		:type dot_gradient_style: DotGradientStyle or None
		:param paint_edges_on_dateline: Polygon property
		:type paint_edges_on_dateline: bool or None
		:param border_clipping: Polygon property
		:type border_clipping: BorderClipping or None
		:param poly_path_fill_type: Polygon property
		:type poly_path_fill_type: PolyPathFillType or None
		:param poly_gradient_style: Polygon property
		:type poly_gradient_style: PolyGradientStyle or None
		:param poly_vertex_mode: Polygon property
		:type poly_vertex_mode: PolyVertexMode or None
		:param poly_vertex_color_style: Polygon property
		:type poly_vertex_color_style: PolyVertexColorStyle or None
		:param centroid: Polygon property
		:type centroid: StyleCentroid or None
		:param min_shape_size:
		:type min_shape_size: int or None
		:param min_shape_transparent_border_fill:
		:type min_shape_transparent_border_fill: bool or None
		:param min_shape_pixels:
		:type min_shape_pixels: int or None
		:param hatch_style:
		:type hatch_style: HatchStyle or None
		:param min_shape: Polygon property
		:type min_shape: Style or None
		:param blending: Line property
		:type blending: bool or None
		:param anti_aliasing: Line property: Specifies whether anti aliasing should be used to blend the edges of the lines with the underlying content for smoother appearance.
		:type anti_aliasing: bool or None
		:param line_cap: Line property
		:type line_cap: LineCapStyle or None
		:param line_dash_color: Line property
		:type line_dash_color: List[str] or None
		:param line_dash: Line property
		:type line_dash: LineDashStyle or None
		:param custom_line_dash: Line property
		:type custom_line_dash: List[float] or None
		:param line_dash_phase: Line property
		:type line_dash_phase: float or None
		:param discrete_seg_length: Line property
		:type discrete_seg_length: float or None
		:param discrete_deviation: Line property
		:type discrete_deviation: float or None
		:param line_gradient_style: Line property
		:type line_gradient_style: LineGradientStyle or None
		:param line_icon_width: Line property
		:type line_icon_width: int or None
		:param hover_line_width: Line property
		:type hover_line_width: int or None
		:param line_icon_height: Line property
		:type line_icon_height: int or None
		:param line_offset: Line property
		:type line_offset: int or None
		:param angle_offset: Line property
		:type angle_offset: float or None
		:param rotate_with_line: Line property
		:type rotate_with_line: bool or None
		:param icon_spacing: Line property
		:type icon_spacing: int or None
		:param icon_xoffset: Line property
		:type icon_xoffset: int or None
		:param icon_yoffset: Line property
		:type icon_yoffset: int or None
		:param center_icon: Line property
		:type center_icon: bool or None
		:param draw_first_point: Line property
		:type draw_first_point: bool or None
		:param draw_line: Line property
		:type draw_line: bool or None
		:param line_icon_mode: Line property
		:type line_icon_mode: LineIconMode or None
		:param borders: Line property
		:type borders: Union[StyleLineBorder, List[StyleLineBorder]] or None
		:param path_1_d: Line property
		:type path_1_d: StylePath1D or None
		:param min_cluster_size: Marker Cluster property
		:type min_cluster_size: int or None
		:param auto_icon_enable: Marker Cluster property
		:type auto_icon_enable: bool or None
		:param auto_icon_size_spread: Marker Cluster property
		:type auto_icon_size_spread: int or None
		:param auto_icon_color_set: Marker Cluster property
		:type auto_icon_color_set: int or None
		:param cluster_centroid: Marker Cluster property
		:type cluster_centroid: ClusterCentroid or None
		:param snap_to_table: Marker Cluster property
		:type snap_to_table: str or None
		:param snap_to_column: Marker Cluster property
		:type snap_to_column: str or None
		:param color_spread: Marker Cluster property
		:type color_spread: int or None
		:param size_spread: Marker Cluster property
		:type size_spread: int or None
		:param color_set: Marker Cluster property
		:type color_set: int or None
		:param child_count_enable: Marker Cluster property
		:type child_count_enable: bool or None
		:param child_count_point_size: Marker Cluster property
		:type child_count_point_size: int or None
		:param child_count_font: Marker Cluster property
		:type child_count_font: str or None
		:param child_count_color: Marker Cluster property
		:type child_count_color: str or None
		:param child_count_offset_x: Marker Cluster property
		:type child_count_offset_x: int or None
		:param child_count_offset_y: Marker Cluster property
		:type child_count_offset_y: int or None
		:param clustering_distance: Marker Cluster property
		:type clustering_distance: int or None
		:param clustering_grid_size: Marker Cluster property
		:type clustering_grid_size: int or None
		:param cluster_grid_spacing: Marker Cluster property
		:type cluster_grid_spacing: int or None
		:param max_margin_size: Marker Cluster property
		:type max_margin_size: int or None
		:param max_cluster_zoom: Marker Cluster property
		:type max_cluster_zoom: int or None
		:param overlap_threshold: Marker Cluster property
		:type overlap_threshold: int or None
		:param auto_icon_color_spread: Marker Cluster property
		:type auto_icon_color_spread: int or None
		:param cluster:
		:type cluster: Style or None
		:param icon_size:
		:type icon_size: int or None
		:param density_threshold:
		:type density_threshold: int or None
		:param gradient:
		:type gradient: str or None
		:param render_algo:
		:type render_algo: str or None
		:param gradient_set:
		:type gradient_set: int or None
		:param image:
		:type image: StyleImageComponent or None
		:param super_resolution:
		:type super_resolution: bool or None
		:param image_min_zoom:
		:type image_min_zoom: int or None
		:param image_max_zoom:
		:type image_max_zoom: int or None
		:param raster_gradient:
		:type raster_gradient: List[GradientPair] or None
		:param scale_min:
		:type scale_min: float or None
		:param scale_max:
		:type scale_max: float or None
		:param scale_min_column_name: Specify a column that contains the value for color scale minimum
		:type scale_min_column_name: str or None
		:param scale_max_column_name: Specify a column that contains the value for color scale maximum
		:type scale_max_column_name: str or None
		:param nodata:
		:type nodata: float or None
		:param interpolate_start_zoom:
		:type interpolate_start_zoom: int or None
		:param uniform_downsampling:
		:type uniform_downsampling: bool or None
		:param scale_log:
		:type scale_log: bool or None
		:param scale_transparent_below:
		:type scale_transparent_below: bool or None
		:param scale_transparent_above:
		:type scale_transparent_above: bool or None
		:param contour_start:
		:type contour_start: float or None
		:param contour_step:
		:type contour_step: float or None
		:param raster_type:
		:type raster_type: RasterType or None
		:param raster_min_zoom:
		:type raster_min_zoom: int or None
		:param raster_max_zoom:
		:type raster_max_zoom: int or None
		:param raster_select:
		:type raster_select: str or None
		:param raster_cell_select:
		:type raster_cell_select: str or None
		:param raster_u:
		:type raster_u: str or None
		:param raster_v:
		:type raster_v: str or None
		:param interpolate: Defines the interpolation method used to calculate the values in between the known data points
* `None` - No interpolation
* `Nearest` - Nearest-neighbor interpolation
* `Linear` - Bilinear interpolation
* `Cubic` - Bicubic interpolation
* `IDW` - Inverse distance weighted interpolation
* `Auto` - Attempts to set the interpolation mode based on the raster band data type
		:type interpolate: InterpolateMode or None
		:param aggregate: Defines the behavior when multiple values are in a single cell
* `Avg` - Uses the mean average of the values
* `Min` - Uses the minimum of the values
* `Max` - Uses the maximum of the values
* `TopOnly` - The highest value based on a sort column
		:type aggregate: AggregateMode or None
		:param render_overlap:
		:type render_overlap: bool or None
		:param min_px_size:
		:type min_px_size: int or None
		:param micro_chart_type:
		:type micro_chart_type: ChartType or None
		:param values:
		:type values: List[float] or None
		:param string_values:
		:type string_values: List[str] or None
		:param values_min:
		:type values_min: float or None
		:param values_max:
		:type values_max: float or None
		:param inner_radius:
		:type inner_radius: int or None
		:param pyramid_sort:
		:type pyramid_sort: SkiaMicroChartPyramidSort or None
		:param pyramid_method:
		:type pyramid_method: SkiaMicroChartPyramidMethod or None
		:param asset: CZML property
		:type asset: StyleAsset or None
		:param military_symbol_enabled:
		:type military_symbol_enabled: bool or None
		:param military_symbol_standard:
		:type military_symbol_standard: str or None
		:param military_symbol_sidc:
		:type military_symbol_sidc: str or None
		:param zoom_based_line_simplification:
		:type zoom_based_line_simplification: bool or None
		:param preload_zoom_based_line_simplification:
		:type preload_zoom_based_line_simplification: bool or None
		:param hover_short_circuit:
		:type hover_short_circuit: bool or None
		:param simplify_small_polygons:
		:type simplify_small_polygons: bool or None
		:param base_color:
		:type base_color: str or None
		:param rule_match_mode:
		:type rule_match_mode: RuleMatchMode or None
		:param rule_match_order:
		:type rule_match_order: RuleMatchOrder or None
		:param debug: Debug property: Turns on all debug style options: drawHoverGrid, drawHoverGridTime, drawTileXYZ, drawRenderTime, and drawTileBorder.
		:type debug: bool or None
		:param additional_raster_style:
		:type additional_raster_style: List[StyleAdditionalRasterStyleComponent] or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._draw_shapes = cast(Optional[bool], kwargs.get("draw_shapes"))
		self._draw_lines = cast(Optional[bool], kwargs.get("draw_lines"))
		self._method = cast(Optional[ShadeMethod], kwargs.get("method"))
		self._buffer_size = cast(Optional[int], kwargs.get("buffer_size"))
		self._stacking_behavior = cast(Optional[StackingBehavior], kwargs.get("stacking_behavior"))
		self._color_transform = cast(Optional[LayerColorTransformValues], kwargs.get("color_transform"))
		self._rules = cast(Optional[List[StyleRule]], kwargs.get("rules"))
		self._hover = cast(Optional[StyleHover], kwargs.get("hover"))
		self._water_mark = cast(StyleWaterMark, kwargs.get("water_mark"))
		self._hover_style = cast(Optional[Style], kwargs.get("hover_style"))
		self._click_style = cast(Optional[Style], kwargs.get("click_style"))
		self._composites = cast(Optional[List[StyleComposite]], kwargs.get("composites"))
		self._draw_hover_grid = cast(Optional[bool], kwargs.get("draw_hover_grid"))
		self._draw_hover_grid_time = cast(Optional[bool], kwargs.get("draw_hover_grid_time"))
		self._draw_render_time = cast(Optional[bool], kwargs.get("draw_render_time"))
		self._draw_tile_xyz = cast(Optional[bool], kwargs.get("draw_tile_xyz"))
		self._draw_tile_border = cast(Optional[bool], kwargs.get("draw_tile_border"))
		self._overlay = cast(Optional[StyleOverlay], kwargs.get("overlay"))
		self._numeric_label = cast(Optional[StyleText], kwargs.get("numeric_label"))
		self._text = cast(Optional[StyleText], kwargs.get("text"))
		self._xoffset = cast(Optional[int], kwargs.get("xoffset"))
		self._yoffset = cast(Optional[int], kwargs.get("yoffset"))
		self._width = cast(Optional[int], kwargs.get("width"))
		self._height = cast(Optional[int], kwargs.get("height"))
		self._blur_style = cast(Optional[BlurStyle], kwargs.get("blur_style"))
		self._blur_sigma = cast(Optional[float], kwargs.get("blur_sigma"))
		self._border_width = cast(Optional[int], kwargs.get("border_width"))
		self._outline_width = cast(Optional[int], kwargs.get("outline_width"))
		self._border_blur_style = cast(Optional[BlurStyle], kwargs.get("border_blur_style"))
		self._border_blur_sigma = cast(Optional[float], kwargs.get("border_blur_sigma"))
		self._inner_borders = cast(Optional[bool], kwargs.get("inner_borders"))
		self._shield = cast(Optional[StyleShield], kwargs.get("shield"))
		self._uri = cast(Optional[str], kwargs.get("uri"))
		self._shape = cast(Optional[ShaderStyle], kwargs.get("shape"))
		self._shape_custom_path = cast(Optional[str], kwargs.get("shape_custom_path"))
		self._svg = cast(Optional[List[StyleSvgAttribute]], kwargs.get("svg"))
		self._drop_shadow = cast(Optional[bool], kwargs.get("drop_shadow"))
		self._drop_shadow_length = cast(Optional[int], kwargs.get("drop_shadow_length"))
		self._drop_shadow_color = cast(Optional[str], kwargs.get("drop_shadow_color"))
		self._hide_icons_height = cast(Optional[int], kwargs.get("hide_icons_height"))
		self._hide_icons_width = cast(Optional[int], kwargs.get("hide_icons_width"))
		self._hover_icon_transparency = cast(bool, kwargs.get("hover_icon_transparency"))
		self._icon_halign = cast(Optional[HAlign], kwargs.get("icon_halign"))
		self._icon_valign = cast(Optional[VAlign], kwargs.get("icon_valign"))
		self._rotation_angle = cast(Optional[float], kwargs.get("rotation_angle"))
		self._rotation_relative_to = cast(RelativeRotation, kwargs.get("rotation_relative_to"))
		self._icon_data_color_type = cast(Optional[IconDataColorType], kwargs.get("icon_data_color_type"))
		self._icon_data_color_quant_depth = cast(Optional[int], kwargs.get("icon_data_color_quant_depth"))
		self._icon_data_color_bins = cast(Optional[int], kwargs.get("icon_data_color_bins"))
		self._layers = cast(Optional[List[IconLayer]], kwargs.get("layers"))
		self._badges = cast(Optional[List[IconBadge]], kwargs.get("badges"))
		self._fill_color = cast(Optional[str], kwargs.get("fill_color"))
		self._border_color = cast(Optional[str], kwargs.get("border_color"))
		self._outline_color = cast(Optional[str], kwargs.get("outline_color"))
		self._gradient_color_position = cast(Optional[str], kwargs.get("gradient_color_position"))
		self._border_color_offset = cast(Optional[int], kwargs.get("border_color_offset"))
		self._fill_color_alpha_offset = cast(Optional[int], kwargs.get("fill_color_alpha_offset"))
		self._border_brightness = cast(Optional[int], kwargs.get("border_brightness"))
		self._colors = cast(Optional[Union[ColorRange, List[ColorRange]]], kwargs.get("colors"))
		self._colorize_color = cast(Optional[str], kwargs.get("colorize_color"))
		self._hatch_color = cast(Optional[str], kwargs.get("hatch_color"))
		self._shade_by = cast(Optional[str], kwargs.get("shade_by"))
		self._divide_by = cast(Optional[str], kwargs.get("divide_by"))
		self._order_by = cast(Optional[str], kwargs.get("order_by"))
		self._sort_direction = cast(Optional[str], kwargs.get("sort_direction"))
		self._hover_sort_direction = cast(Optional[str], kwargs.get("hover_sort_direction"))
		self._shade_aggregate_type = cast(Optional[TotalTypes], kwargs.get("shade_aggregate_type"))
		self._shade_aggregate_type_divisor = cast(Optional[TotalTypes], kwargs.get("shade_aggregate_type_divisor"))
		self._default_divisor = cast(Optional[float], kwargs.get("default_divisor"))
		self._steps = cast(Optional[int], kwargs.get("steps"))
		self._ranges = cast(Optional[Union[NumberRange, List[NumberRange]]], kwargs.get("ranges"))
		self._sizes = cast(Optional[Union[NumberRange, List[NumberRange]]], kwargs.get("sizes"))
		self._dot_gradient_style = cast(Optional[DotGradientStyle], kwargs.get("dot_gradient_style"))
		self._paint_edges_on_dateline = cast(Optional[bool], kwargs.get("paint_edges_on_dateline"))
		self._border_clipping = cast(Optional[BorderClipping], kwargs.get("border_clipping"))
		self._poly_path_fill_type = cast(Optional[PolyPathFillType], kwargs.get("poly_path_fill_type"))
		self._poly_gradient_style = cast(Optional[PolyGradientStyle], kwargs.get("poly_gradient_style"))
		self._poly_vertex_mode = cast(Optional[PolyVertexMode], kwargs.get("poly_vertex_mode"))
		self._poly_vertex_color_style = cast(Optional[PolyVertexColorStyle], kwargs.get("poly_vertex_color_style"))
		self._centroid = cast(Optional[StyleCentroid], kwargs.get("centroid"))
		self._min_shape_size = cast(Optional[int], kwargs.get("min_shape_size"))
		self._min_shape_transparent_border_fill = cast(Optional[bool], kwargs.get("min_shape_transparent_border_fill"))
		self._min_shape_pixels = cast(Optional[int], kwargs.get("min_shape_pixels"))
		self._hatch_style = cast(Optional[HatchStyle], kwargs.get("hatch_style"))
		self._min_shape = cast(Optional[Style], kwargs.get("min_shape"))
		self._blending = cast(Optional[bool], kwargs.get("blending"))
		self._anti_aliasing = cast(Optional[bool], kwargs.get("anti_aliasing"))
		self._line_cap = cast(Optional[LineCapStyle], kwargs.get("line_cap"))
		self._line_dash_color = cast(Optional[List[str]], kwargs.get("line_dash_color"))
		self._line_dash = cast(Optional[LineDashStyle], kwargs.get("line_dash"))
		self._custom_line_dash = cast(Optional[List[float]], kwargs.get("custom_line_dash"))
		self._line_dash_phase = cast(Optional[float], kwargs.get("line_dash_phase"))
		self._discrete_seg_length = cast(Optional[float], kwargs.get("discrete_seg_length"))
		self._discrete_deviation = cast(Optional[float], kwargs.get("discrete_deviation"))
		self._line_gradient_style = cast(Optional[LineGradientStyle], kwargs.get("line_gradient_style"))
		self._stroke_join = cast(LineStrokeJoin, kwargs.get("stroke_join"))
		self._stroke_miter = cast(float, kwargs.get("stroke_miter"))
		self._line_icon_width = cast(Optional[int], kwargs.get("line_icon_width"))
		self._hover_line_width = cast(Optional[int], kwargs.get("hover_line_width"))
		self._line_icon_height = cast(Optional[int], kwargs.get("line_icon_height"))
		self._line_offset = cast(Optional[int], kwargs.get("line_offset"))
		self._angle_offset = cast(Optional[float], kwargs.get("angle_offset"))
		self._rotate_with_line = cast(Optional[bool], kwargs.get("rotate_with_line"))
		self._icon_spacing = cast(Optional[int], kwargs.get("icon_spacing"))
		self._icon_xoffset = cast(Optional[int], kwargs.get("icon_xoffset"))
		self._icon_yoffset = cast(Optional[int], kwargs.get("icon_yoffset"))
		self._center_icon = cast(Optional[bool], kwargs.get("center_icon"))
		self._draw_first_point = cast(Optional[bool], kwargs.get("draw_first_point"))
		self._draw_line = cast(Optional[bool], kwargs.get("draw_line"))
		self._line_icon_mode = cast(Optional[LineIconMode], kwargs.get("line_icon_mode"))
		self._borders = cast(Optional[Union[StyleLineBorder, List[StyleLineBorder]]], kwargs.get("borders"))
		self._path_1_d = cast(Optional[StylePath1D], kwargs.get("path_1_d"))
		self._min_cluster_size = cast(Optional[int], kwargs.get("min_cluster_size"))
		self._auto_icon_enable = cast(Optional[bool], kwargs.get("auto_icon_enable"))
		self._auto_icon_size_spread = cast(Optional[int], kwargs.get("auto_icon_size_spread"))
		self._auto_icon_color_set = cast(Optional[int], kwargs.get("auto_icon_color_set"))
		self._cluster_centroid = cast(Optional[ClusterCentroid], kwargs.get("cluster_centroid"))
		self._snap_to_table = cast(Optional[str], kwargs.get("snap_to_table"))
		self._snap_to_column = cast(Optional[str], kwargs.get("snap_to_column"))
		self._color_spread = cast(Optional[int], kwargs.get("color_spread"))
		self._size_spread = cast(Optional[int], kwargs.get("size_spread"))
		self._color_set = cast(Optional[int], kwargs.get("color_set"))
		self._child_count_enable = cast(Optional[bool], kwargs.get("child_count_enable"))
		self._child_count_point_size = cast(Optional[int], kwargs.get("child_count_point_size"))
		self._child_count_font = cast(Optional[str], kwargs.get("child_count_font"))
		self._child_count_color = cast(Optional[str], kwargs.get("child_count_color"))
		self._child_count_offset_x = cast(Optional[int], kwargs.get("child_count_offset_x"))
		self._child_count_offset_y = cast(Optional[int], kwargs.get("child_count_offset_y"))
		self._clustering_distance = cast(Optional[int], kwargs.get("clustering_distance"))
		self._clustering_grid_size = cast(Optional[int], kwargs.get("clustering_grid_size"))
		self._cluster_grid_spacing = cast(Optional[int], kwargs.get("cluster_grid_spacing"))
		self._max_margin_size = cast(Optional[int], kwargs.get("max_margin_size"))
		self._max_cluster_zoom = cast(Optional[int], kwargs.get("max_cluster_zoom"))
		self._overlap_threshold = cast(Optional[int], kwargs.get("overlap_threshold"))
		self._auto_icon_color_spread = cast(Optional[int], kwargs.get("auto_icon_color_spread"))
		self._cluster = cast(Optional[Style], kwargs.get("cluster"))
		self._icon_size = cast(Optional[int], kwargs.get("icon_size"))
		self._density_threshold = cast(Optional[int], kwargs.get("density_threshold"))
		self._gradient = cast(Optional[str], kwargs.get("gradient"))
		self._render_algo = cast(Optional[str], kwargs.get("render_algo"))
		self._gradient_set = cast(Optional[int], kwargs.get("gradient_set"))
		self._image = cast(Optional[StyleImageComponent], kwargs.get("image"))
		self._super_resolution = cast(Optional[bool], kwargs.get("super_resolution"))
		self._image_filter_high_quality = cast(bool, kwargs.get("image_filter_high_quality"))
		self._image_force_reproject = cast(bool, kwargs.get("image_force_reproject"))
		self._image_min_zoom = cast(Optional[int], kwargs.get("image_min_zoom"))
		self._image_max_zoom = cast(Optional[int], kwargs.get("image_max_zoom"))
		self._raster_gradient = cast(Optional[List[GradientPair]], kwargs.get("raster_gradient"))
		self._scale_min = cast(Optional[float], kwargs.get("scale_min"))
		self._scale_max = cast(Optional[float], kwargs.get("scale_max"))
		self._scale_min_column_name = cast(Optional[str], kwargs.get("scale_min_column_name"))
		self._scale_max_column_name = cast(Optional[str], kwargs.get("scale_max_column_name"))
		self._nodata = cast(Optional[float], kwargs.get("nodata"))
		self._interpolate_start_zoom = cast(Optional[int], kwargs.get("interpolate_start_zoom"))
		self._uniform_downsampling = cast(Optional[bool], kwargs.get("uniform_downsampling"))
		self._scale_log = cast(Optional[bool], kwargs.get("scale_log"))
		self._scale_transparent_below = cast(Optional[bool], kwargs.get("scale_transparent_below"))
		self._scale_transparent_above = cast(Optional[bool], kwargs.get("scale_transparent_above"))
		self._contour_start = cast(Optional[float], kwargs.get("contour_start"))
		self._contour_step = cast(Optional[float], kwargs.get("contour_step"))
		self._raster_type = cast(Optional[RasterType], kwargs.get("raster_type"))
		self._raster_min_zoom = cast(Optional[int], kwargs.get("raster_min_zoom"))
		self._raster_max_zoom = cast(Optional[int], kwargs.get("raster_max_zoom"))
		self._raster_select = cast(Optional[str], kwargs.get("raster_select"))
		self._raster_cell_select = cast(Optional[str], kwargs.get("raster_cell_select"))
		self._raster_u = cast(Optional[str], kwargs.get("raster_u"))
		self._raster_v = cast(Optional[str], kwargs.get("raster_v"))
		self._interpolate = cast(Optional[InterpolateMode], kwargs.get("interpolate"))
		self._aggregate = cast(Optional[AggregateMode], kwargs.get("aggregate"))
		self._render_overlap = cast(Optional[bool], kwargs.get("render_overlap"))
		self._min_px_size = cast(Optional[int], kwargs.get("min_px_size"))
		self._micro_chart_type = cast(Optional[ChartType], kwargs.get("micro_chart_type"))
		self._values = cast(Optional[List[float]], kwargs.get("values"))
		self._string_values = cast(Optional[List[str]], kwargs.get("string_values"))
		self._values_min = cast(Optional[float], kwargs.get("values_min"))
		self._values_max = cast(Optional[float], kwargs.get("values_max"))
		self._inner_radius = cast(Optional[int], kwargs.get("inner_radius"))
		self._pyramid_sort = cast(Optional[SkiaMicroChartPyramidSort], kwargs.get("pyramid_sort"))
		self._pyramid_method = cast(Optional[SkiaMicroChartPyramidMethod], kwargs.get("pyramid_method"))
		self._asset = cast(Optional[StyleAsset], kwargs.get("asset"))
		self._military_symbol_enabled = cast(Optional[bool], kwargs.get("military_symbol_enabled"))
		self._military_symbol_standard = cast(Optional[str], kwargs.get("military_symbol_standard"))
		self._military_symbol_sidc = cast(Optional[str], kwargs.get("military_symbol_sidc"))
		self._zoom_based_line_simplification = cast(Optional[bool], kwargs.get("zoom_based_line_simplification"))
		self._preload_zoom_based_line_simplification = cast(Optional[bool], kwargs.get("preload_zoom_based_line_simplification"))
		self._hover_short_circuit = cast(Optional[bool], kwargs.get("hover_short_circuit"))
		self._simplify_small_polygons = cast(Optional[bool], kwargs.get("simplify_small_polygons"))
		self._base_color = cast(Optional[str], kwargs.get("base_color"))
		self._base_transform = cast(List[float], kwargs.get("base_transform"))
		self._rule_match_mode = cast(Optional[RuleMatchMode], kwargs.get("rule_match_mode"))
		self._rule_match_order = cast(Optional[RuleMatchOrder], kwargs.get("rule_match_order"))
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._debug = cast(Optional[bool], kwargs.get("debug"))
		self._additional_raster_style = cast(Optional[List[StyleAdditionalRasterStyleComponent]], kwargs.get("additional_raster_style"))
	@property
	def draw_shapes(self) -> Optional["bool"]:
		"""Core property"""
		return self._draw_shapes
	@draw_shapes.setter
	def draw_shapes(self, value: Optional["bool"]) -> None:
		"""Core property"""
		self._draw_shapes = value
	@property
	def draw_lines(self) -> Optional["bool"]:
		"""Core property"""
		return self._draw_lines
	@draw_lines.setter
	def draw_lines(self, value: Optional["bool"]) -> None:
		"""Core property"""
		self._draw_lines = value
	@property
	def method(self) -> Optional["ShadeMethod"]:
		"""Core option
* `default` - For dot layers, mark data with 18x18 red dot icons with black borders. For other layers, this is the same as `basic`.
* `basic` - Mark data using the specified style settings, such as: shape, width, height, borderWidth, fillColor, borderColor, lineCap, lineDash, etc.
* `rules` - Specify a collection of style rules. `where` clauses indicate which `style` should be used.
* `interval` - Use the column named in `shadeBy` to vary the foreground color or icon size. Specify the column value min/max range with `ranges`, the color min/max with `colors`, and the size min/max with `sizes`.
* `singleurl` - Mark data using the icon specified in `uri`."""
		return self._method
	@method.setter
	def method(self, value: Optional["ShadeMethod"]) -> None:
		"""Core option
* `default` - For dot layers, mark data with 18x18 red dot icons with black borders. For other layers, this is the same as `basic`.
* `basic` - Mark data using the specified style settings, such as: shape, width, height, borderWidth, fillColor, borderColor, lineCap, lineDash, etc.
* `rules` - Specify a collection of style rules. `where` clauses indicate which `style` should be used.
* `interval` - Use the column named in `shadeBy` to vary the foreground color or icon size. Specify the column value min/max range with `ranges`, the color min/max with `colors`, and the size min/max with `sizes`.
* `singleurl` - Mark data using the icon specified in `uri`."""
		self._method = value
	@property
	def buffer_size(self) -> Optional["int"]:
		"""Core property"""
		return self._buffer_size
	@buffer_size.setter
	def buffer_size(self, value: Optional["int"]) -> None:
		"""Core property"""
		self._buffer_size = value
	@property
	def stacking_behavior(self) -> Optional["StackingBehavior"]:
		# pylint: disable=missing-function-docstring
		return self._stacking_behavior
	@stacking_behavior.setter
	def stacking_behavior(self, value: Optional["StackingBehavior"]) -> None:
		# pylint: disable=missing-function-docstring
		self._stacking_behavior = value
	@property
	def color_transform(self) -> Optional["LayerColorTransformValues"]:
		# pylint: disable=missing-function-docstring
		return self._color_transform
	@color_transform.setter
	def color_transform(self, value: Optional["LayerColorTransformValues"]) -> None:
		# pylint: disable=missing-function-docstring
		self._color_transform = value
	@property
	def rules(self) -> Optional["List[StyleRule]"]:
		"""Core property"""
		return self._rules
	@rules.setter
	def rules(self, value: Optional["List[StyleRule]"]) -> None:
		"""Core property"""
		self._rules = value
	@property
	def hover(self) -> Optional["StyleHover"]:
		# pylint: disable=missing-function-docstring
		return self._hover
	@hover.setter
	def hover(self, value: Optional["StyleHover"]) -> None:
		# pylint: disable=missing-function-docstring
		self._hover = value
	@property
	def water_mark(self) -> "StyleWaterMark":
		# pylint: disable=missing-function-docstring
		return self._water_mark
	@water_mark.setter
	def water_mark(self, value: "StyleWaterMark") -> None:
		# pylint: disable=missing-function-docstring
		self._water_mark = value
	@property
	def hover_style(self) -> Optional["Style"]:
		# pylint: disable=missing-function-docstring
		return self._hover_style
	@hover_style.setter
	def hover_style(self, value: Optional["Style"]) -> None:
		# pylint: disable=missing-function-docstring
		self._hover_style = value
	@property
	def click_style(self) -> Optional["Style"]:
		# pylint: disable=missing-function-docstring
		return self._click_style
	@click_style.setter
	def click_style(self, value: Optional["Style"]) -> None:
		# pylint: disable=missing-function-docstring
		self._click_style = value
	@property
	def composites(self) -> Optional["List[StyleComposite]"]:
		# pylint: disable=missing-function-docstring
		return self._composites
	@composites.setter
	def composites(self, value: Optional["List[StyleComposite]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._composites = value
	@property
	def draw_hover_grid(self) -> Optional["bool"]:
		"""Debug property: highlight all of the 4x4 pixel squares that contain hover grid data in magenta."""
		return self._draw_hover_grid
	@draw_hover_grid.setter
	def draw_hover_grid(self, value: Optional["bool"]) -> None:
		"""Debug property: highlight all of the 4x4 pixel squares that contain hover grid data in magenta."""
		self._draw_hover_grid = value
	@property
	def draw_hover_grid_time(self) -> Optional["bool"]:
		"""Debug property: write how long it took to calculate the hover grid data in the lower right corner of the tiles."""
		return self._draw_hover_grid_time
	@draw_hover_grid_time.setter
	def draw_hover_grid_time(self, value: Optional["bool"]) -> None:
		"""Debug property: write how long it took to calculate the hover grid data in the lower right corner of the tiles."""
		self._draw_hover_grid_time = value
	@property
	def draw_render_time(self) -> Optional["bool"]:
		"""Debug property: write how long it took to render the tile contents in the lower left corner of the tiles."""
		return self._draw_render_time
	@draw_render_time.setter
	def draw_render_time(self, value: Optional["bool"]) -> None:
		"""Debug property: write how long it took to render the tile contents in the lower left corner of the tiles."""
		self._draw_render_time = value
	@property
	def draw_tile_xyz(self) -> Optional["bool"]:
		"""Debug property: write the X/Y coordinates and zoom level in the center of the tiles."""
		return self._draw_tile_xyz
	@draw_tile_xyz.setter
	def draw_tile_xyz(self, value: Optional["bool"]) -> None:
		"""Debug property: write the X/Y coordinates and zoom level in the center of the tiles."""
		self._draw_tile_xyz = value
	@property
	def draw_tile_border(self) -> Optional["bool"]:
		"""Debug property: outline each tile."""
		return self._draw_tile_border
	@draw_tile_border.setter
	def draw_tile_border(self, value: Optional["bool"]) -> None:
		"""Debug property: outline each tile."""
		self._draw_tile_border = value
	@property
	def overlay(self) -> Optional["StyleOverlay"]:
		"""Core property"""
		return self._overlay
	@overlay.setter
	def overlay(self, value: Optional["StyleOverlay"]) -> None:
		"""Core property"""
		self._overlay = value
	@property
	def numeric_label(self) -> Optional["StyleText"]:
		# pylint: disable=missing-function-docstring
		return self._numeric_label
	@numeric_label.setter
	def numeric_label(self, value: Optional["StyleText"]) -> None:
		# pylint: disable=missing-function-docstring
		self._numeric_label = value
	@property
	def text(self) -> Optional["StyleText"]:
		# pylint: disable=missing-function-docstring
		return self._text
	@text.setter
	def text(self, value: Optional["StyleText"]) -> None:
		# pylint: disable=missing-function-docstring
		self._text = value
	@property
	def xoffset(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._xoffset
	@xoffset.setter
	def xoffset(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xoffset = value
	@property
	def yoffset(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._yoffset
	@yoffset.setter
	def yoffset(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._yoffset = value
	@property
	def width(self) -> Optional["int"]:
		"""Size property"""
		return self._width
	@width.setter
	def width(self, value: Optional["int"]) -> None:
		"""Size property"""
		self._width = value
	@property
	def height(self) -> Optional["int"]:
		"""Size property"""
		return self._height
	@height.setter
	def height(self, value: Optional["int"]) -> None:
		"""Size property"""
		self._height = value
	@property
	def blur_style(self) -> Optional["BlurStyle"]:
		"""Size property"""
		return self._blur_style
	@blur_style.setter
	def blur_style(self, value: Optional["BlurStyle"]) -> None:
		"""Size property"""
		self._blur_style = value
	@property
	def blur_sigma(self) -> Optional["float"]:
		"""Size property"""
		return self._blur_sigma
	@blur_sigma.setter
	def blur_sigma(self, value: Optional["float"]) -> None:
		"""Size property"""
		self._blur_sigma = value
	@property
	def border_width(self) -> Optional["int"]:
		"""Size property"""
		return self._border_width
	@border_width.setter
	def border_width(self, value: Optional["int"]) -> None:
		"""Size property"""
		self._border_width = value
	@property
	def outline_width(self) -> Optional["int"]:
		"""Size property"""
		return self._outline_width
	@outline_width.setter
	def outline_width(self, value: Optional["int"]) -> None:
		"""Size property"""
		self._outline_width = value
	@property
	def border_blur_style(self) -> Optional["BlurStyle"]:
		"""Size property"""
		return self._border_blur_style
	@border_blur_style.setter
	def border_blur_style(self, value: Optional["BlurStyle"]) -> None:
		"""Size property"""
		self._border_blur_style = value
	@property
	def border_blur_sigma(self) -> Optional["float"]:
		"""Size property"""
		return self._border_blur_sigma
	@border_blur_sigma.setter
	def border_blur_sigma(self, value: Optional["float"]) -> None:
		"""Size property"""
		self._border_blur_sigma = value
	@property
	def inner_borders(self) -> Optional["bool"]:
		"""Size property"""
		return self._inner_borders
	@inner_borders.setter
	def inner_borders(self, value: Optional["bool"]) -> None:
		"""Size property"""
		self._inner_borders = value
	@property
	def shield(self) -> Optional["StyleShield"]:
		# pylint: disable=missing-function-docstring
		return self._shield
	@shield.setter
	def shield(self, value: Optional["StyleShield"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shield = value
	@property
	def uri(self) -> Optional["str"]:
		"""Icon property: Use a custom image for the icon that is located at this publicly accessible URL."""
		return self._uri
	@uri.setter
	def uri(self, value: Optional["str"]) -> None:
		"""Icon property: Use a custom image for the icon that is located at this publicly accessible URL."""
		self._uri = value
	@property
	def shape(self) -> Optional["ShaderStyle"]:
		"""Icon property: Specify the icon shape.
* `round` - Circular icons (or an ellipse).
* `rectangle` - Square icons with rounded corners (or a rectangle).
* `triangle` - Triangular icons.
* `diamond` - Diamond icons (a rhombus).
* `plus` - Plus-sign, or cross, icons.
* `star` - Five pointed star icons.
* `x` - X-shaped icons.
* `chevron` - Chevron icon."""
		return self._shape
	@shape.setter
	def shape(self, value: Optional["ShaderStyle"]) -> None:
		"""Icon property: Specify the icon shape.
* `round` - Circular icons (or an ellipse).
* `rectangle` - Square icons with rounded corners (or a rectangle).
* `triangle` - Triangular icons.
* `diamond` - Diamond icons (a rhombus).
* `plus` - Plus-sign, or cross, icons.
* `star` - Five pointed star icons.
* `x` - X-shaped icons.
* `chevron` - Chevron icon."""
		self._shape = value
	@property
	def shape_custom_path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._shape_custom_path
	@shape_custom_path.setter
	def shape_custom_path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shape_custom_path = value
	@property
	def svg(self) -> Optional["List[StyleSvgAttribute]"]:
		"""Icon property"""
		return self._svg
	@svg.setter
	def svg(self, value: Optional["List[StyleSvgAttribute]"]) -> None:
		"""Icon property"""
		self._svg = value
	@property
	def drop_shadow(self) -> Optional["bool"]:
		"""Icon property"""
		return self._drop_shadow
	@drop_shadow.setter
	def drop_shadow(self, value: Optional["bool"]) -> None:
		"""Icon property"""
		self._drop_shadow = value
	@property
	def drop_shadow_length(self) -> Optional["int"]:
		"""Icon property"""
		return self._drop_shadow_length
	@drop_shadow_length.setter
	def drop_shadow_length(self, value: Optional["int"]) -> None:
		"""Icon property"""
		self._drop_shadow_length = value
	@property
	def drop_shadow_color(self) -> Optional["str"]:
		"""Icon property"""
		return self._drop_shadow_color
	@drop_shadow_color.setter
	def drop_shadow_color(self, value: Optional["str"]) -> None:
		"""Icon property"""
		self._drop_shadow_color = value
	@property
	def hide_icons_height(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._hide_icons_height
	@hide_icons_height.setter
	def hide_icons_height(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._hide_icons_height = value
	@property
	def hide_icons_width(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._hide_icons_width
	@hide_icons_width.setter
	def hide_icons_width(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._hide_icons_width = value
	@property
	def hover_icon_transparency(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._hover_icon_transparency
	@hover_icon_transparency.setter
	def hover_icon_transparency(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._hover_icon_transparency = value
	@property
	def icon_halign(self) -> Optional["HAlign"]:
		# pylint: disable=missing-function-docstring
		return self._icon_halign
	@icon_halign.setter
	def icon_halign(self, value: Optional["HAlign"]) -> None:
		# pylint: disable=missing-function-docstring
		self._icon_halign = value
	@property
	def icon_valign(self) -> Optional["VAlign"]:
		# pylint: disable=missing-function-docstring
		return self._icon_valign
	@icon_valign.setter
	def icon_valign(self, value: Optional["VAlign"]) -> None:
		# pylint: disable=missing-function-docstring
		self._icon_valign = value
	@property
	def rotation_angle(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._rotation_angle
	@rotation_angle.setter
	def rotation_angle(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rotation_angle = value
	@property
	def rotation_relative_to(self) -> "RelativeRotation":
		# pylint: disable=missing-function-docstring
		return self._rotation_relative_to
	@rotation_relative_to.setter
	def rotation_relative_to(self, value: "RelativeRotation") -> None:
		# pylint: disable=missing-function-docstring
		self._rotation_relative_to = value
	@property
	def icon_data_color_type(self) -> Optional["IconDataColorType"]:
		# pylint: disable=missing-function-docstring
		return self._icon_data_color_type
	@icon_data_color_type.setter
	def icon_data_color_type(self, value: Optional["IconDataColorType"]) -> None:
		# pylint: disable=missing-function-docstring
		self._icon_data_color_type = value
	@property
	def icon_data_color_quant_depth(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._icon_data_color_quant_depth
	@icon_data_color_quant_depth.setter
	def icon_data_color_quant_depth(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._icon_data_color_quant_depth = value
	@property
	def icon_data_color_bins(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._icon_data_color_bins
	@icon_data_color_bins.setter
	def icon_data_color_bins(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._icon_data_color_bins = value
	@property
	def layers(self) -> Optional["List[IconLayer]"]:
		# pylint: disable=missing-function-docstring
		return self._layers
	@layers.setter
	def layers(self, value: Optional["List[IconLayer]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._layers = value
	@property
	def badges(self) -> Optional["List[IconBadge]"]:
		# pylint: disable=missing-function-docstring
		return self._badges
	@badges.setter
	def badges(self, value: Optional["List[IconBadge]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._badges = value
	@property
	def fill_color(self) -> Optional["str"]:
		"""Color property"""
		return self._fill_color
	@fill_color.setter
	def fill_color(self, value: Optional["str"]) -> None:
		"""Color property"""
		self._fill_color = value
	@property
	def border_color(self) -> Optional["str"]:
		"""Color property"""
		return self._border_color
	@border_color.setter
	def border_color(self, value: Optional["str"]) -> None:
		"""Color property"""
		self._border_color = value
	@property
	def outline_color(self) -> Optional["str"]:
		"""Color property"""
		return self._outline_color
	@outline_color.setter
	def outline_color(self, value: Optional["str"]) -> None:
		"""Color property"""
		self._outline_color = value
	@property
	def gradient_color_position(self) -> Optional["str"]:
		"""Color property: String containing a comma separated list of numbers."""
		return self._gradient_color_position
	@gradient_color_position.setter
	def gradient_color_position(self, value: Optional["str"]) -> None:
		"""Color property: String containing a comma separated list of numbers."""
		self._gradient_color_position = value
	@property
	def border_color_offset(self) -> Optional["int"]:
		"""Color property"""
		return self._border_color_offset
	@border_color_offset.setter
	def border_color_offset(self, value: Optional["int"]) -> None:
		"""Color property"""
		self._border_color_offset = value
	@property
	def fill_color_alpha_offset(self) -> Optional["int"]:
		"""Color property"""
		return self._fill_color_alpha_offset
	@fill_color_alpha_offset.setter
	def fill_color_alpha_offset(self, value: Optional["int"]) -> None:
		"""Color property"""
		self._fill_color_alpha_offset = value
	@property
	def border_brightness(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._border_brightness
	@border_brightness.setter
	def border_brightness(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._border_brightness = value
	@property
	def colors(self) -> Optional["Union[ColorRange, List[ColorRange]]"]:
		"""Color property"""
		return self._colors
	@colors.setter
	def colors(self, value: Optional["Union[ColorRange, List[ColorRange]]"]) -> None:
		"""Color property"""
		self._colors = value
	@property
	def colorize_color(self) -> Optional["str"]:
		"""Color property"""
		return self._colorize_color
	@colorize_color.setter
	def colorize_color(self, value: Optional["str"]) -> None:
		"""Color property"""
		self._colorize_color = value
	@property
	def hatch_color(self) -> Optional["str"]:
		"""Color property"""
		return self._hatch_color
	@hatch_color.setter
	def hatch_color(self, value: Optional["str"]) -> None:
		"""Color property"""
		self._hatch_color = value
	@property
	def shade_by(self) -> Optional["str"]:
		"""Data property: Either column, column.agg, table.column, table.column.agg, or divide(...column..., ...column...), where agg is one of 'avg', 'count', 'sum', 'max', or 'min'."""
		return self._shade_by
	@shade_by.setter
	def shade_by(self, value: Optional["str"]) -> None:
		"""Data property: Either column, column.agg, table.column, table.column.agg, or divide(...column..., ...column...), where agg is one of 'avg', 'count', 'sum', 'max', or 'min'."""
		self._shade_by = value
	@property
	def divide_by(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._divide_by
	@divide_by.setter
	def divide_by(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._divide_by = value
	@property
	def order_by(self) -> Optional["str"]:
		"""Data property: Either column or column.desc."""
		return self._order_by
	@order_by.setter
	def order_by(self, value: Optional["str"]) -> None:
		"""Data property: Either column or column.desc."""
		self._order_by = value
	@property
	def sort_direction(self) -> Optional["str"]:
		"""Data property: Override the sort direction. Accepts 'asc' or 'desc'."""
		return self._sort_direction
	@sort_direction.setter
	def sort_direction(self, value: Optional["str"]) -> None:
		"""Data property: Override the sort direction. Accepts 'asc' or 'desc'."""
		self._sort_direction = value
	@property
	def hover_sort_direction(self) -> Optional["str"]:
		"""Data property: Override the hover sort direction. Accepts 'asc' or 'desc'"""
		return self._hover_sort_direction
	@hover_sort_direction.setter
	def hover_sort_direction(self, value: Optional["str"]) -> None:
		"""Data property: Override the hover sort direction. Accepts 'asc' or 'desc'"""
		self._hover_sort_direction = value
	@property
	def shade_aggregate_type(self) -> Optional["TotalTypes"]:
		# pylint: disable=missing-function-docstring
		return self._shade_aggregate_type
	@shade_aggregate_type.setter
	def shade_aggregate_type(self, value: Optional["TotalTypes"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shade_aggregate_type = value
	@property
	def shade_aggregate_type_divisor(self) -> Optional["TotalTypes"]:
		# pylint: disable=missing-function-docstring
		return self._shade_aggregate_type_divisor
	@shade_aggregate_type_divisor.setter
	def shade_aggregate_type_divisor(self, value: Optional["TotalTypes"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shade_aggregate_type_divisor = value
	@property
	def default_divisor(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._default_divisor
	@default_divisor.setter
	def default_divisor(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._default_divisor = value
	@property
	def steps(self) -> Optional["int"]:
		"""Data property"""
		return self._steps
	@steps.setter
	def steps(self, value: Optional["int"]) -> None:
		"""Data property"""
		self._steps = value
	@property
	def ranges(self) -> Optional["Union[NumberRange, List[NumberRange]]"]:
		"""Data property"""
		return self._ranges
	@ranges.setter
	def ranges(self, value: Optional["Union[NumberRange, List[NumberRange]]"]) -> None:
		"""Data property"""
		self._ranges = value
	@property
	def sizes(self) -> Optional["Union[NumberRange, List[NumberRange]]"]:
		"""Data property"""
		return self._sizes
	@sizes.setter
	def sizes(self, value: Optional["Union[NumberRange, List[NumberRange]]"]) -> None:
		"""Data property"""
		self._sizes = value
	@property
	def dot_gradient_style(self) -> Optional["DotGradientStyle"]:
		"""Dot property"""
		return self._dot_gradient_style
	@dot_gradient_style.setter
	def dot_gradient_style(self, value: Optional["DotGradientStyle"]) -> None:
		"""Dot property"""
		self._dot_gradient_style = value
	@property
	def paint_edges_on_dateline(self) -> Optional["bool"]:
		"""Polygon property"""
		return self._paint_edges_on_dateline
	@paint_edges_on_dateline.setter
	def paint_edges_on_dateline(self, value: Optional["bool"]) -> None:
		"""Polygon property"""
		self._paint_edges_on_dateline = value
	@property
	def border_clipping(self) -> Optional["BorderClipping"]:
		"""Polygon property"""
		return self._border_clipping
	@border_clipping.setter
	def border_clipping(self, value: Optional["BorderClipping"]) -> None:
		"""Polygon property"""
		self._border_clipping = value
	@property
	def poly_path_fill_type(self) -> Optional["PolyPathFillType"]:
		"""Polygon property"""
		return self._poly_path_fill_type
	@poly_path_fill_type.setter
	def poly_path_fill_type(self, value: Optional["PolyPathFillType"]) -> None:
		"""Polygon property"""
		self._poly_path_fill_type = value
	@property
	def poly_gradient_style(self) -> Optional["PolyGradientStyle"]:
		"""Polygon property"""
		return self._poly_gradient_style
	@poly_gradient_style.setter
	def poly_gradient_style(self, value: Optional["PolyGradientStyle"]) -> None:
		"""Polygon property"""
		self._poly_gradient_style = value
	@property
	def poly_vertex_mode(self) -> Optional["PolyVertexMode"]:
		"""Polygon property"""
		return self._poly_vertex_mode
	@poly_vertex_mode.setter
	def poly_vertex_mode(self, value: Optional["PolyVertexMode"]) -> None:
		"""Polygon property"""
		self._poly_vertex_mode = value
	@property
	def poly_vertex_color_style(self) -> Optional["PolyVertexColorStyle"]:
		"""Polygon property"""
		return self._poly_vertex_color_style
	@poly_vertex_color_style.setter
	def poly_vertex_color_style(self, value: Optional["PolyVertexColorStyle"]) -> None:
		"""Polygon property"""
		self._poly_vertex_color_style = value
	@property
	def centroid(self) -> Optional["StyleCentroid"]:
		"""Polygon property"""
		return self._centroid
	@centroid.setter
	def centroid(self, value: Optional["StyleCentroid"]) -> None:
		"""Polygon property"""
		self._centroid = value
	@property
	def min_shape_size(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._min_shape_size
	@min_shape_size.setter
	def min_shape_size(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_shape_size = value
	@property
	def min_shape_transparent_border_fill(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._min_shape_transparent_border_fill
	@min_shape_transparent_border_fill.setter
	def min_shape_transparent_border_fill(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_shape_transparent_border_fill = value
	@property
	def min_shape_pixels(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._min_shape_pixels
	@min_shape_pixels.setter
	def min_shape_pixels(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_shape_pixels = value
	@property
	def hatch_style(self) -> Optional["HatchStyle"]:
		# pylint: disable=missing-function-docstring
		return self._hatch_style
	@hatch_style.setter
	def hatch_style(self, value: Optional["HatchStyle"]) -> None:
		# pylint: disable=missing-function-docstring
		self._hatch_style = value
	@property
	def min_shape(self) -> Optional["Style"]:
		"""Polygon property"""
		return self._min_shape
	@min_shape.setter
	def min_shape(self, value: Optional["Style"]) -> None:
		"""Polygon property"""
		self._min_shape = value
	@property
	def blending(self) -> Optional["bool"]:
		"""Line property"""
		return self._blending
	@blending.setter
	def blending(self, value: Optional["bool"]) -> None:
		"""Line property"""
		self._blending = value
	@property
	def anti_aliasing(self) -> Optional["bool"]:
		"""Line property: Specifies whether anti aliasing should be used to blend the edges of the lines with the underlying content for smoother appearance."""
		return self._anti_aliasing
	@anti_aliasing.setter
	def anti_aliasing(self, value: Optional["bool"]) -> None:
		"""Line property: Specifies whether anti aliasing should be used to blend the edges of the lines with the underlying content for smoother appearance."""
		self._anti_aliasing = value
	@property
	def line_cap(self) -> Optional["LineCapStyle"]:
		"""Line property"""
		return self._line_cap
	@line_cap.setter
	def line_cap(self, value: Optional["LineCapStyle"]) -> None:
		"""Line property"""
		self._line_cap = value
	@property
	def line_dash_color(self) -> Optional["List[str]"]:
		"""Line property"""
		return self._line_dash_color
	@line_dash_color.setter
	def line_dash_color(self, value: Optional["List[str]"]) -> None:
		"""Line property"""
		self._line_dash_color = value
	@property
	def line_dash(self) -> Optional["LineDashStyle"]:
		"""Line property"""
		return self._line_dash
	@line_dash.setter
	def line_dash(self, value: Optional["LineDashStyle"]) -> None:
		"""Line property"""
		self._line_dash = value
	@property
	def custom_line_dash(self) -> Optional["List[float]"]:
		"""Line property"""
		return self._custom_line_dash
	@custom_line_dash.setter
	def custom_line_dash(self, value: Optional["List[float]"]) -> None:
		"""Line property"""
		self._custom_line_dash = value
	@property
	def line_dash_phase(self) -> Optional["float"]:
		"""Line property"""
		return self._line_dash_phase
	@line_dash_phase.setter
	def line_dash_phase(self, value: Optional["float"]) -> None:
		"""Line property"""
		self._line_dash_phase = value
	@property
	def discrete_seg_length(self) -> Optional["float"]:
		"""Line property"""
		return self._discrete_seg_length
	@discrete_seg_length.setter
	def discrete_seg_length(self, value: Optional["float"]) -> None:
		"""Line property"""
		self._discrete_seg_length = value
	@property
	def discrete_deviation(self) -> Optional["float"]:
		"""Line property"""
		return self._discrete_deviation
	@discrete_deviation.setter
	def discrete_deviation(self, value: Optional["float"]) -> None:
		"""Line property"""
		self._discrete_deviation = value
	@property
	def line_gradient_style(self) -> Optional["LineGradientStyle"]:
		"""Line property"""
		return self._line_gradient_style
	@line_gradient_style.setter
	def line_gradient_style(self, value: Optional["LineGradientStyle"]) -> None:
		"""Line property"""
		self._line_gradient_style = value
	@property
	def stroke_join(self) -> "LineStrokeJoin":
		"""Line property"""
		return self._stroke_join
	@stroke_join.setter
	def stroke_join(self, value: "LineStrokeJoin") -> None:
		"""Line property"""
		self._stroke_join = value
	@property
	def stroke_miter(self) -> "float":
		"""Line property"""
		return self._stroke_miter
	@stroke_miter.setter
	def stroke_miter(self, value: "float") -> None:
		"""Line property"""
		self._stroke_miter = value
	@property
	def line_icon_width(self) -> Optional["int"]:
		"""Line property"""
		return self._line_icon_width
	@line_icon_width.setter
	def line_icon_width(self, value: Optional["int"]) -> None:
		"""Line property"""
		self._line_icon_width = value
	@property
	def hover_line_width(self) -> Optional["int"]:
		"""Line property"""
		return self._hover_line_width
	@hover_line_width.setter
	def hover_line_width(self, value: Optional["int"]) -> None:
		"""Line property"""
		self._hover_line_width = value
	@property
	def line_icon_height(self) -> Optional["int"]:
		"""Line property"""
		return self._line_icon_height
	@line_icon_height.setter
	def line_icon_height(self, value: Optional["int"]) -> None:
		"""Line property"""
		self._line_icon_height = value
	@property
	def line_offset(self) -> Optional["int"]:
		"""Line property"""
		return self._line_offset
	@line_offset.setter
	def line_offset(self, value: Optional["int"]) -> None:
		"""Line property"""
		self._line_offset = value
	@property
	def angle_offset(self) -> Optional["float"]:
		"""Line property"""
		return self._angle_offset
	@angle_offset.setter
	def angle_offset(self, value: Optional["float"]) -> None:
		"""Line property"""
		self._angle_offset = value
	@property
	def rotate_with_line(self) -> Optional["bool"]:
		"""Line property"""
		return self._rotate_with_line
	@rotate_with_line.setter
	def rotate_with_line(self, value: Optional["bool"]) -> None:
		"""Line property"""
		self._rotate_with_line = value
	@property
	def icon_spacing(self) -> Optional["int"]:
		"""Line property"""
		return self._icon_spacing
	@icon_spacing.setter
	def icon_spacing(self, value: Optional["int"]) -> None:
		"""Line property"""
		self._icon_spacing = value
	@property
	def icon_xoffset(self) -> Optional["int"]:
		"""Line property"""
		return self._icon_xoffset
	@icon_xoffset.setter
	def icon_xoffset(self, value: Optional["int"]) -> None:
		"""Line property"""
		self._icon_xoffset = value
	@property
	def icon_yoffset(self) -> Optional["int"]:
		"""Line property"""
		return self._icon_yoffset
	@icon_yoffset.setter
	def icon_yoffset(self, value: Optional["int"]) -> None:
		"""Line property"""
		self._icon_yoffset = value
	@property
	def center_icon(self) -> Optional["bool"]:
		"""Line property"""
		return self._center_icon
	@center_icon.setter
	def center_icon(self, value: Optional["bool"]) -> None:
		"""Line property"""
		self._center_icon = value
	@property
	def draw_first_point(self) -> Optional["bool"]:
		"""Line property"""
		return self._draw_first_point
	@draw_first_point.setter
	def draw_first_point(self, value: Optional["bool"]) -> None:
		"""Line property"""
		self._draw_first_point = value
	@property
	def draw_line(self) -> Optional["bool"]:
		"""Line property"""
		return self._draw_line
	@draw_line.setter
	def draw_line(self, value: Optional["bool"]) -> None:
		"""Line property"""
		self._draw_line = value
	@property
	def line_icon_mode(self) -> Optional["LineIconMode"]:
		"""Line property"""
		return self._line_icon_mode
	@line_icon_mode.setter
	def line_icon_mode(self, value: Optional["LineIconMode"]) -> None:
		"""Line property"""
		self._line_icon_mode = value
	@property
	def borders(self) -> Optional["Union[StyleLineBorder, List[StyleLineBorder]]"]:
		"""Line property"""
		return self._borders
	@borders.setter
	def borders(self, value: Optional["Union[StyleLineBorder, List[StyleLineBorder]]"]) -> None:
		"""Line property"""
		self._borders = value
	@property
	def path_1_d(self) -> Optional["StylePath1D"]:
		"""Line property"""
		return self._path_1_d
	@path_1_d.setter
	def path_1_d(self, value: Optional["StylePath1D"]) -> None:
		"""Line property"""
		self._path_1_d = value
	@property
	def min_cluster_size(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._min_cluster_size
	@min_cluster_size.setter
	def min_cluster_size(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._min_cluster_size = value
	@property
	def auto_icon_enable(self) -> Optional["bool"]:
		"""Marker Cluster property"""
		return self._auto_icon_enable
	@auto_icon_enable.setter
	def auto_icon_enable(self, value: Optional["bool"]) -> None:
		"""Marker Cluster property"""
		self._auto_icon_enable = value
	@property
	def auto_icon_size_spread(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._auto_icon_size_spread
	@auto_icon_size_spread.setter
	def auto_icon_size_spread(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._auto_icon_size_spread = value
	@property
	def auto_icon_color_set(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._auto_icon_color_set
	@auto_icon_color_set.setter
	def auto_icon_color_set(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._auto_icon_color_set = value
	@property
	def cluster_centroid(self) -> Optional["ClusterCentroid"]:
		"""Marker Cluster property"""
		return self._cluster_centroid
	@cluster_centroid.setter
	def cluster_centroid(self, value: Optional["ClusterCentroid"]) -> None:
		"""Marker Cluster property"""
		self._cluster_centroid = value
	@property
	def snap_to_table(self) -> Optional["str"]:
		"""Marker Cluster property"""
		return self._snap_to_table
	@snap_to_table.setter
	def snap_to_table(self, value: Optional["str"]) -> None:
		"""Marker Cluster property"""
		self._snap_to_table = value
	@property
	def snap_to_column(self) -> Optional["str"]:
		"""Marker Cluster property"""
		return self._snap_to_column
	@snap_to_column.setter
	def snap_to_column(self, value: Optional["str"]) -> None:
		"""Marker Cluster property"""
		self._snap_to_column = value
	@property
	def color_spread(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._color_spread
	@color_spread.setter
	def color_spread(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._color_spread = value
	@property
	def size_spread(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._size_spread
	@size_spread.setter
	def size_spread(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._size_spread = value
	@property
	def color_set(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._color_set
	@color_set.setter
	def color_set(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._color_set = value
	@property
	def child_count_enable(self) -> Optional["bool"]:
		"""Marker Cluster property"""
		return self._child_count_enable
	@child_count_enable.setter
	def child_count_enable(self, value: Optional["bool"]) -> None:
		"""Marker Cluster property"""
		self._child_count_enable = value
	@property
	def child_count_point_size(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._child_count_point_size
	@child_count_point_size.setter
	def child_count_point_size(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._child_count_point_size = value
	@property
	def child_count_font(self) -> Optional["str"]:
		"""Marker Cluster property"""
		return self._child_count_font
	@child_count_font.setter
	def child_count_font(self, value: Optional["str"]) -> None:
		"""Marker Cluster property"""
		self._child_count_font = value
	@property
	def child_count_color(self) -> Optional["str"]:
		"""Marker Cluster property"""
		return self._child_count_color
	@child_count_color.setter
	def child_count_color(self, value: Optional["str"]) -> None:
		"""Marker Cluster property"""
		self._child_count_color = value
	@property
	def child_count_offset_x(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._child_count_offset_x
	@child_count_offset_x.setter
	def child_count_offset_x(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._child_count_offset_x = value
	@property
	def child_count_offset_y(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._child_count_offset_y
	@child_count_offset_y.setter
	def child_count_offset_y(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._child_count_offset_y = value
	@property
	def clustering_distance(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._clustering_distance
	@clustering_distance.setter
	def clustering_distance(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._clustering_distance = value
	@property
	def clustering_grid_size(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._clustering_grid_size
	@clustering_grid_size.setter
	def clustering_grid_size(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._clustering_grid_size = value
	@property
	def cluster_grid_spacing(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._cluster_grid_spacing
	@cluster_grid_spacing.setter
	def cluster_grid_spacing(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._cluster_grid_spacing = value
	@property
	def max_margin_size(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._max_margin_size
	@max_margin_size.setter
	def max_margin_size(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._max_margin_size = value
	@property
	def max_cluster_zoom(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._max_cluster_zoom
	@max_cluster_zoom.setter
	def max_cluster_zoom(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._max_cluster_zoom = value
	@property
	def overlap_threshold(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._overlap_threshold
	@overlap_threshold.setter
	def overlap_threshold(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._overlap_threshold = value
	@property
	def auto_icon_color_spread(self) -> Optional["int"]:
		"""Marker Cluster property"""
		return self._auto_icon_color_spread
	@auto_icon_color_spread.setter
	def auto_icon_color_spread(self, value: Optional["int"]) -> None:
		"""Marker Cluster property"""
		self._auto_icon_color_spread = value
	@property
	def cluster(self) -> Optional["Style"]:
		# pylint: disable=missing-function-docstring
		return self._cluster
	@cluster.setter
	def cluster(self, value: Optional["Style"]) -> None:
		# pylint: disable=missing-function-docstring
		self._cluster = value
	@property
	def icon_size(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._icon_size
	@icon_size.setter
	def icon_size(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._icon_size = value
	@property
	def density_threshold(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._density_threshold
	@density_threshold.setter
	def density_threshold(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._density_threshold = value
	@property
	def gradient(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._gradient
	@gradient.setter
	def gradient(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._gradient = value
	@property
	def render_algo(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._render_algo
	@render_algo.setter
	def render_algo(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._render_algo = value
	@property
	def gradient_set(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._gradient_set
	@gradient_set.setter
	def gradient_set(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._gradient_set = value
	@property
	def image(self) -> Optional["StyleImageComponent"]:
		# pylint: disable=missing-function-docstring
		return self._image
	@image.setter
	def image(self, value: Optional["StyleImageComponent"]) -> None:
		# pylint: disable=missing-function-docstring
		self._image = value
	@property
	def super_resolution(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._super_resolution
	@super_resolution.setter
	def super_resolution(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._super_resolution = value
	@property
	def image_filter_high_quality(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._image_filter_high_quality
	@image_filter_high_quality.setter
	def image_filter_high_quality(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._image_filter_high_quality = value
	@property
	def image_force_reproject(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._image_force_reproject
	@image_force_reproject.setter
	def image_force_reproject(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._image_force_reproject = value
	@property
	def image_min_zoom(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._image_min_zoom
	@image_min_zoom.setter
	def image_min_zoom(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._image_min_zoom = value
	@property
	def image_max_zoom(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._image_max_zoom
	@image_max_zoom.setter
	def image_max_zoom(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._image_max_zoom = value
	@property
	def raster_gradient(self) -> Optional["List[GradientPair]"]:
		# pylint: disable=missing-function-docstring
		return self._raster_gradient
	@raster_gradient.setter
	def raster_gradient(self, value: Optional["List[GradientPair]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_gradient = value
	@property
	def scale_min(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._scale_min
	@scale_min.setter
	def scale_min(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._scale_min = value
	@property
	def scale_max(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._scale_max
	@scale_max.setter
	def scale_max(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._scale_max = value
	@property
	def scale_min_column_name(self) -> Optional["str"]:
		"""Specify a column that contains the value for color scale minimum"""
		return self._scale_min_column_name
	@scale_min_column_name.setter
	def scale_min_column_name(self, value: Optional["str"]) -> None:
		"""Specify a column that contains the value for color scale minimum"""
		self._scale_min_column_name = value
	@property
	def scale_max_column_name(self) -> Optional["str"]:
		"""Specify a column that contains the value for color scale maximum"""
		return self._scale_max_column_name
	@scale_max_column_name.setter
	def scale_max_column_name(self, value: Optional["str"]) -> None:
		"""Specify a column that contains the value for color scale maximum"""
		self._scale_max_column_name = value
	@property
	def nodata(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._nodata
	@nodata.setter
	def nodata(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._nodata = value
	@property
	def interpolate_start_zoom(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._interpolate_start_zoom
	@interpolate_start_zoom.setter
	def interpolate_start_zoom(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._interpolate_start_zoom = value
	@property
	def uniform_downsampling(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._uniform_downsampling
	@uniform_downsampling.setter
	def uniform_downsampling(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._uniform_downsampling = value
	@property
	def scale_log(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._scale_log
	@scale_log.setter
	def scale_log(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._scale_log = value
	@property
	def scale_transparent_below(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._scale_transparent_below
	@scale_transparent_below.setter
	def scale_transparent_below(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._scale_transparent_below = value
	@property
	def scale_transparent_above(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._scale_transparent_above
	@scale_transparent_above.setter
	def scale_transparent_above(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._scale_transparent_above = value
	@property
	def contour_start(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._contour_start
	@contour_start.setter
	def contour_start(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._contour_start = value
	@property
	def contour_step(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._contour_step
	@contour_step.setter
	def contour_step(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._contour_step = value
	@property
	def raster_type(self) -> Optional["RasterType"]:
		# pylint: disable=missing-function-docstring
		return self._raster_type
	@raster_type.setter
	def raster_type(self, value: Optional["RasterType"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_type = value
	@property
	def raster_min_zoom(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._raster_min_zoom
	@raster_min_zoom.setter
	def raster_min_zoom(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_min_zoom = value
	@property
	def raster_max_zoom(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._raster_max_zoom
	@raster_max_zoom.setter
	def raster_max_zoom(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_max_zoom = value
	@property
	def raster_select(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._raster_select
	@raster_select.setter
	def raster_select(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_select = value
	@property
	def raster_cell_select(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._raster_cell_select
	@raster_cell_select.setter
	def raster_cell_select(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_cell_select = value
	@property
	def raster_u(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._raster_u
	@raster_u.setter
	def raster_u(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_u = value
	@property
	def raster_v(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._raster_v
	@raster_v.setter
	def raster_v(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_v = value
	@property
	def interpolate(self) -> Optional["InterpolateMode"]:
		"""Defines the interpolation method used to calculate the values in between the known data points
* `None` - No interpolation
* `Nearest` - Nearest-neighbor interpolation
* `Linear` - Bilinear interpolation
* `Cubic` - Bicubic interpolation
* `IDW` - Inverse distance weighted interpolation
* `Auto` - Attempts to set the interpolation mode based on the raster band data type"""
		return self._interpolate
	@interpolate.setter
	def interpolate(self, value: Optional["InterpolateMode"]) -> None:
		"""Defines the interpolation method used to calculate the values in between the known data points
* `None` - No interpolation
* `Nearest` - Nearest-neighbor interpolation
* `Linear` - Bilinear interpolation
* `Cubic` - Bicubic interpolation
* `IDW` - Inverse distance weighted interpolation
* `Auto` - Attempts to set the interpolation mode based on the raster band data type"""
		self._interpolate = value
	@property
	def aggregate(self) -> Optional["AggregateMode"]:
		"""Defines the behavior when multiple values are in a single cell
* `Avg` - Uses the mean average of the values
* `Min` - Uses the minimum of the values
* `Max` - Uses the maximum of the values
* `TopOnly` - The highest value based on a sort column"""
		return self._aggregate
	@aggregate.setter
	def aggregate(self, value: Optional["AggregateMode"]) -> None:
		"""Defines the behavior when multiple values are in a single cell
* `Avg` - Uses the mean average of the values
* `Min` - Uses the minimum of the values
* `Max` - Uses the maximum of the values
* `TopOnly` - The highest value based on a sort column"""
		self._aggregate = value
	@property
	def render_overlap(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._render_overlap
	@render_overlap.setter
	def render_overlap(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._render_overlap = value
	@property
	def min_px_size(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._min_px_size
	@min_px_size.setter
	def min_px_size(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_px_size = value
	@property
	def micro_chart_type(self) -> Optional["ChartType"]:
		# pylint: disable=missing-function-docstring
		return self._micro_chart_type
	@micro_chart_type.setter
	def micro_chart_type(self, value: Optional["ChartType"]) -> None:
		# pylint: disable=missing-function-docstring
		self._micro_chart_type = value
	@property
	def values(self) -> Optional["List[float]"]:
		# pylint: disable=missing-function-docstring
		return self._values
	@values.setter
	def values(self, value: Optional["List[float]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._values = value
	@property
	def string_values(self) -> Optional["List[str]"]:
		# pylint: disable=missing-function-docstring
		return self._string_values
	@string_values.setter
	def string_values(self, value: Optional["List[str]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._string_values = value
	@property
	def values_min(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._values_min
	@values_min.setter
	def values_min(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._values_min = value
	@property
	def values_max(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._values_max
	@values_max.setter
	def values_max(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._values_max = value
	@property
	def inner_radius(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._inner_radius
	@inner_radius.setter
	def inner_radius(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._inner_radius = value
	@property
	def pyramid_sort(self) -> Optional["SkiaMicroChartPyramidSort"]:
		# pylint: disable=missing-function-docstring
		return self._pyramid_sort
	@pyramid_sort.setter
	def pyramid_sort(self, value: Optional["SkiaMicroChartPyramidSort"]) -> None:
		# pylint: disable=missing-function-docstring
		self._pyramid_sort = value
	@property
	def pyramid_method(self) -> Optional["SkiaMicroChartPyramidMethod"]:
		# pylint: disable=missing-function-docstring
		return self._pyramid_method
	@pyramid_method.setter
	def pyramid_method(self, value: Optional["SkiaMicroChartPyramidMethod"]) -> None:
		# pylint: disable=missing-function-docstring
		self._pyramid_method = value
	@property
	def asset(self) -> Optional["StyleAsset"]:
		"""CZML property"""
		return self._asset
	@asset.setter
	def asset(self, value: Optional["StyleAsset"]) -> None:
		"""CZML property"""
		self._asset = value
	@property
	def military_symbol_enabled(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._military_symbol_enabled
	@military_symbol_enabled.setter
	def military_symbol_enabled(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._military_symbol_enabled = value
	@property
	def military_symbol_standard(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._military_symbol_standard
	@military_symbol_standard.setter
	def military_symbol_standard(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._military_symbol_standard = value
	@property
	def military_symbol_sidc(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._military_symbol_sidc
	@military_symbol_sidc.setter
	def military_symbol_sidc(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._military_symbol_sidc = value
	@property
	def zoom_based_line_simplification(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._zoom_based_line_simplification
	@zoom_based_line_simplification.setter
	def zoom_based_line_simplification(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._zoom_based_line_simplification = value
	@property
	def preload_zoom_based_line_simplification(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._preload_zoom_based_line_simplification
	@preload_zoom_based_line_simplification.setter
	def preload_zoom_based_line_simplification(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._preload_zoom_based_line_simplification = value
	@property
	def hover_short_circuit(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._hover_short_circuit
	@hover_short_circuit.setter
	def hover_short_circuit(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._hover_short_circuit = value
	@property
	def simplify_small_polygons(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._simplify_small_polygons
	@simplify_small_polygons.setter
	def simplify_small_polygons(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._simplify_small_polygons = value
	@property
	def base_color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._base_color
	@base_color.setter
	def base_color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._base_color = value
	@property
	def base_transform(self) -> "List[float]":
		# pylint: disable=missing-function-docstring
		return self._base_transform
	@base_transform.setter
	def base_transform(self, value: "List[float]") -> None:
		# pylint: disable=missing-function-docstring
		self._base_transform = value
	@property
	def rule_match_mode(self) -> Optional["RuleMatchMode"]:
		# pylint: disable=missing-function-docstring
		return self._rule_match_mode
	@rule_match_mode.setter
	def rule_match_mode(self, value: Optional["RuleMatchMode"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rule_match_mode = value
	@property
	def rule_match_order(self) -> Optional["RuleMatchOrder"]:
		# pylint: disable=missing-function-docstring
		return self._rule_match_order
	@rule_match_order.setter
	def rule_match_order(self, value: Optional["RuleMatchOrder"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rule_match_order = value
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def debug(self) -> Optional["bool"]:
		"""Debug property: Turns on all debug style options: drawHoverGrid, drawHoverGridTime, drawTileXYZ, drawRenderTime, and drawTileBorder."""
		return self._debug
	@debug.setter
	def debug(self, value: Optional["bool"]) -> None:
		"""Debug property: Turns on all debug style options: drawHoverGrid, drawHoverGridTime, drawTileXYZ, drawRenderTime, and drawTileBorder."""
		self._debug = value
	@property
	def additional_raster_style(self) -> Optional["List[StyleAdditionalRasterStyleComponent]"]:
		# pylint: disable=missing-function-docstring
		return self._additional_raster_style
	@additional_raster_style.setter
	def additional_raster_style(self, value: Optional["List[StyleAdditionalRasterStyleComponent]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._additional_raster_style = value
class StyleAdditionalRasterStyleComponent:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"gradient": ("gradient", "str", None),
		"color_transform": ("colorTransform", "dict", "float"),
		"raster_type": ("rasterType", "str", None),
		"raster_select": ("rasterSelect", "str", None),
		"raster_cell_select": ("rasterCellSelect", "str", None),
		"raster_u": ("rasterU", "str", None),
		"raster_v": ("rasterV", "str", None),
		"scale_min": ("scaleMin", "float", None),
		"scale_max": ("scaleMax", "float", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		color_transform: "Dict[str, float]",
		scale_min: "float",
		scale_max: "float",
		gradient: Optional["str"] = None,
		raster_type: Optional["str"] = None,
		raster_select: Optional["str"] = None,
		raster_cell_select: Optional["str"] = None,
		raster_u: Optional["str"] = None,
		raster_v: Optional["str"] = None,
	) -> None:
		"""
		:param color_transform:
		:type color_transform: Dict[str, float]
		:param scale_min:
		:type scale_min: float
		:param scale_max:
		:type scale_max: float
		:param gradient:
		:type gradient: str or None
		:param raster_type:
		:type raster_type: str or None
		:param raster_select:
		:type raster_select: str or None
		:param raster_cell_select:
		:type raster_cell_select: str or None
		:param raster_u:
		:type raster_u: str or None
		:param raster_v:
		:type raster_v: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._gradient = cast(Optional[str], kwargs.get("gradient"))
		self._color_transform = cast(Dict[str, float], kwargs.get("color_transform"))
		self._raster_type = cast(Optional[str], kwargs.get("raster_type"))
		self._raster_select = cast(Optional[str], kwargs.get("raster_select"))
		self._raster_cell_select = cast(Optional[str], kwargs.get("raster_cell_select"))
		self._raster_u = cast(Optional[str], kwargs.get("raster_u"))
		self._raster_v = cast(Optional[str], kwargs.get("raster_v"))
		self._scale_min = cast(float, kwargs.get("scale_min"))
		self._scale_max = cast(float, kwargs.get("scale_max"))
	@property
	def gradient(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._gradient
	@gradient.setter
	def gradient(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._gradient = value
	@property
	def color_transform(self) -> "Dict[str, float]":
		# pylint: disable=missing-function-docstring
		return self._color_transform
	@color_transform.setter
	def color_transform(self, value: "Dict[str, float]") -> None:
		# pylint: disable=missing-function-docstring
		self._color_transform = value
	@property
	def raster_type(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._raster_type
	@raster_type.setter
	def raster_type(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_type = value
	@property
	def raster_select(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._raster_select
	@raster_select.setter
	def raster_select(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_select = value
	@property
	def raster_cell_select(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._raster_cell_select
	@raster_cell_select.setter
	def raster_cell_select(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_cell_select = value
	@property
	def raster_u(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._raster_u
	@raster_u.setter
	def raster_u(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_u = value
	@property
	def raster_v(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._raster_v
	@raster_v.setter
	def raster_v(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._raster_v = value
	@property
	def scale_min(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._scale_min
	@scale_min.setter
	def scale_min(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._scale_min = value
	@property
	def scale_max(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._scale_max
	@scale_max.setter
	def scale_max(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._scale_max = value
class StyleAsset:
	"""CZML property"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"model": ("model", "StyleAssetModel", None),
		"image": ("image", "StyleAssetImage", None),
		"label": ("label", "StyleAssetLabel", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		model: Optional["StyleAssetModel"] = None,
		image: Optional["StyleAssetImage"] = None,
		label: Optional["StyleAssetLabel"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param model:
		:type model: StyleAssetModel or None
		:param image:
		:type image: StyleAssetImage or None
		:param label:
		:type label: StyleAssetLabel or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._model = cast(Optional[StyleAssetModel], kwargs.get("model"))
		self._image = cast(Optional[StyleAssetImage], kwargs.get("image"))
		self._label = cast(Optional[StyleAssetLabel], kwargs.get("label"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def model(self) -> Optional["StyleAssetModel"]:
		# pylint: disable=missing-function-docstring
		return self._model
	@model.setter
	def model(self, value: Optional["StyleAssetModel"]) -> None:
		# pylint: disable=missing-function-docstring
		self._model = value
	@property
	def image(self) -> Optional["StyleAssetImage"]:
		# pylint: disable=missing-function-docstring
		return self._image
	@image.setter
	def image(self, value: Optional["StyleAssetImage"]) -> None:
		# pylint: disable=missing-function-docstring
		self._image = value
	@property
	def label(self) -> Optional["StyleAssetLabel"]:
		# pylint: disable=missing-function-docstring
		return self._label
	@label.setter
	def label(self, value: Optional["StyleAssetLabel"]) -> None:
		# pylint: disable=missing-function-docstring
		self._label = value
class StyleAssetImage:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"url": ("url", "str", None),
		"scale": ("scale", "float", None),
		"xoffset": ("xOffset", "float", None),
		"yoffset": ("yOffset", "float", None),
		"halign": ("hAlign", "HAlign", None),
		"valign": ("vAlign", "VAlign", None),
		"color": ("color", "str", None),
		"rotation": ("rotation", "float", None),
		"size_in_meters": ("sizeInMeters", "bool", None),
		"width": ("width", "float", None),
		"height": ("height", "float", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		url: "str",
		scale: Optional["float"] = None,
		xoffset: Optional["float"] = None,
		yoffset: Optional["float"] = None,
		halign: Optional["HAlign"] = None,
		valign: Optional["VAlign"] = None,
		color: Optional["str"] = None,
		rotation: Optional["float"] = None,
		size_in_meters: Optional["bool"] = None,
		width: Optional["float"] = None,
		height: Optional["float"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param url:
		:type url: str
		:param scale: Defaults to 1.
		:type scale: float or None
		:param xoffset: Defaults to 0.
		:type xoffset: float or None
		:param yoffset: Defaults to 0.
		:type yoffset: float or None
		:param halign: Defaults to 'Center'.
		:type halign: HAlign or None
		:param valign: Defaults to 'Center'.
		:type valign: VAlign or None
		:param color: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type color: str or None
		:param rotation:
		:type rotation: float or None
		:param size_in_meters: Defaults to false.
		:type size_in_meters: bool or None
		:param width: Defaults to 0.
		:type width: float or None
		:param height: Defaults to 0.
		:type height: float or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._url = cast(str, kwargs.get("url"))
		self._scale = cast(Optional[float], kwargs.get("scale"))
		self._xoffset = cast(Optional[float], kwargs.get("xoffset"))
		self._yoffset = cast(Optional[float], kwargs.get("yoffset"))
		self._halign = cast(Optional[HAlign], kwargs.get("halign"))
		self._valign = cast(Optional[VAlign], kwargs.get("valign"))
		self._color = cast(Optional[str], kwargs.get("color"))
		self._rotation = cast(Optional[float], kwargs.get("rotation"))
		self._size_in_meters = cast(Optional[bool], kwargs.get("size_in_meters"))
		self._width = cast(Optional[float], kwargs.get("width"))
		self._height = cast(Optional[float], kwargs.get("height"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def url(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._url
	@url.setter
	def url(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._url = value
	@property
	def scale(self) -> Optional["float"]:
		"""Defaults to 1."""
		return self._scale
	@scale.setter
	def scale(self, value: Optional["float"]) -> None:
		"""Defaults to 1."""
		self._scale = value
	@property
	def xoffset(self) -> Optional["float"]:
		"""Defaults to 0."""
		return self._xoffset
	@xoffset.setter
	def xoffset(self, value: Optional["float"]) -> None:
		"""Defaults to 0."""
		self._xoffset = value
	@property
	def yoffset(self) -> Optional["float"]:
		"""Defaults to 0."""
		return self._yoffset
	@yoffset.setter
	def yoffset(self, value: Optional["float"]) -> None:
		"""Defaults to 0."""
		self._yoffset = value
	@property
	def halign(self) -> Optional["HAlign"]:
		"""Defaults to 'Center'."""
		return self._halign
	@halign.setter
	def halign(self, value: Optional["HAlign"]) -> None:
		"""Defaults to 'Center'."""
		self._halign = value
	@property
	def valign(self) -> Optional["VAlign"]:
		"""Defaults to 'Center'."""
		return self._valign
	@valign.setter
	def valign(self, value: Optional["VAlign"]) -> None:
		"""Defaults to 'Center'."""
		self._valign = value
	@property
	def color(self) -> Optional["str"]:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._color = value
	@property
	def rotation(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._rotation
	@rotation.setter
	def rotation(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rotation = value
	@property
	def size_in_meters(self) -> Optional["bool"]:
		"""Defaults to false."""
		return self._size_in_meters
	@size_in_meters.setter
	def size_in_meters(self, value: Optional["bool"]) -> None:
		"""Defaults to false."""
		self._size_in_meters = value
	@property
	def width(self) -> Optional["float"]:
		"""Defaults to 0."""
		return self._width
	@width.setter
	def width(self, value: Optional["float"]) -> None:
		"""Defaults to 0."""
		self._width = value
	@property
	def height(self) -> Optional["float"]:
		"""Defaults to 0."""
		return self._height
	@height.setter
	def height(self, value: Optional["float"]) -> None:
		"""Defaults to 0."""
		self._height = value
class StyleAssetLabel:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"text": ("text", "str", None),
		"size": ("size", "int", None),
		"font_family": ("fontFamily", "str", None),
		"scale": ("scale", "float", None),
		"xoffset": ("xOffset", "float", None),
		"yoffset": ("yOffset", "float", None),
		"halign": ("hAlign", "HAlign", None),
		"valign": ("vAlign", "VAlign", None),
		"color": ("color", "str", None),
		"outline_color": ("outlineColor", "str", None),
		"outline_width": ("outlineWidth", "float", None),
		"background_color": ("backgroundColor", "str", None),
		"background_padding_x": ("backgroundPaddingX", "float", None),
		"background_padding_y": ("backgroundPaddingY", "float", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		text: "str",
		size: Optional["int"] = None,
		font_family: Optional["str"] = None,
		scale: Optional["float"] = None,
		xoffset: Optional["float"] = None,
		yoffset: Optional["float"] = None,
		halign: Optional["HAlign"] = None,
		valign: Optional["VAlign"] = None,
		color: Optional["str"] = None,
		outline_color: Optional["str"] = None,
		outline_width: Optional["float"] = None,
		background_color: Optional["str"] = None,
		background_padding_x: Optional["float"] = None,
		background_padding_y: Optional["float"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param text:
		:type text: str
		:param size: Defaults to 30.
		:type size: int or None
		:param font_family: Defaults to sans-serif.
		:type font_family: str or None
		:param scale: Defaults to 1.
		:type scale: float or None
		:param xoffset: Defaults to 0.
		:type xoffset: float or None
		:param yoffset: Defaults to 0.
		:type yoffset: float or None
		:param halign: Defaults to 'Center'.
		:type halign: HAlign or None
		:param valign: Defaults to 'Center'.
		:type valign: VAlign or None
		:param color: Defaults to fully transparent.
		:type color: str or None
		:param outline_color: Defaults to fully transparent.
		:type outline_color: str or None
		:param outline_width: Defaults to 1.
		:type outline_width: float or None
		:param background_color: Defaults to fully transparent.
		:type background_color: str or None
		:param background_padding_x: Defaults to 7.
		:type background_padding_x: float or None
		:param background_padding_y: Defaults to 5.
		:type background_padding_y: float or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._text = cast(str, kwargs.get("text"))
		self._size = cast(Optional[int], kwargs.get("size"))
		self._font_family = cast(Optional[str], kwargs.get("font_family"))
		self._scale = cast(Optional[float], kwargs.get("scale"))
		self._xoffset = cast(Optional[float], kwargs.get("xoffset"))
		self._yoffset = cast(Optional[float], kwargs.get("yoffset"))
		self._halign = cast(Optional[HAlign], kwargs.get("halign"))
		self._valign = cast(Optional[VAlign], kwargs.get("valign"))
		self._color = cast(Optional[str], kwargs.get("color"))
		self._outline_color = cast(Optional[str], kwargs.get("outline_color"))
		self._outline_width = cast(Optional[float], kwargs.get("outline_width"))
		self._background_color = cast(Optional[str], kwargs.get("background_color"))
		self._background_padding_x = cast(Optional[float], kwargs.get("background_padding_x"))
		self._background_padding_y = cast(Optional[float], kwargs.get("background_padding_y"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def text(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._text
	@text.setter
	def text(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._text = value
	@property
	def size(self) -> Optional["int"]:
		"""Defaults to 30."""
		return self._size
	@size.setter
	def size(self, value: Optional["int"]) -> None:
		"""Defaults to 30."""
		self._size = value
	@property
	def font_family(self) -> Optional["str"]:
		"""Defaults to sans-serif."""
		return self._font_family
	@font_family.setter
	def font_family(self, value: Optional["str"]) -> None:
		"""Defaults to sans-serif."""
		self._font_family = value
	@property
	def scale(self) -> Optional["float"]:
		"""Defaults to 1."""
		return self._scale
	@scale.setter
	def scale(self, value: Optional["float"]) -> None:
		"""Defaults to 1."""
		self._scale = value
	@property
	def xoffset(self) -> Optional["float"]:
		"""Defaults to 0."""
		return self._xoffset
	@xoffset.setter
	def xoffset(self, value: Optional["float"]) -> None:
		"""Defaults to 0."""
		self._xoffset = value
	@property
	def yoffset(self) -> Optional["float"]:
		"""Defaults to 0."""
		return self._yoffset
	@yoffset.setter
	def yoffset(self, value: Optional["float"]) -> None:
		"""Defaults to 0."""
		self._yoffset = value
	@property
	def halign(self) -> Optional["HAlign"]:
		"""Defaults to 'Center'."""
		return self._halign
	@halign.setter
	def halign(self, value: Optional["HAlign"]) -> None:
		"""Defaults to 'Center'."""
		self._halign = value
	@property
	def valign(self) -> Optional["VAlign"]:
		"""Defaults to 'Center'."""
		return self._valign
	@valign.setter
	def valign(self, value: Optional["VAlign"]) -> None:
		"""Defaults to 'Center'."""
		self._valign = value
	@property
	def color(self) -> Optional["str"]:
		"""Defaults to fully transparent."""
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		"""Defaults to fully transparent."""
		self._color = value
	@property
	def outline_color(self) -> Optional["str"]:
		"""Defaults to fully transparent."""
		return self._outline_color
	@outline_color.setter
	def outline_color(self, value: Optional["str"]) -> None:
		"""Defaults to fully transparent."""
		self._outline_color = value
	@property
	def outline_width(self) -> Optional["float"]:
		"""Defaults to 1."""
		return self._outline_width
	@outline_width.setter
	def outline_width(self, value: Optional["float"]) -> None:
		"""Defaults to 1."""
		self._outline_width = value
	@property
	def background_color(self) -> Optional["str"]:
		"""Defaults to fully transparent."""
		return self._background_color
	@background_color.setter
	def background_color(self, value: Optional["str"]) -> None:
		"""Defaults to fully transparent."""
		self._background_color = value
	@property
	def background_padding_x(self) -> Optional["float"]:
		"""Defaults to 7."""
		return self._background_padding_x
	@background_padding_x.setter
	def background_padding_x(self, value: Optional["float"]) -> None:
		"""Defaults to 7."""
		self._background_padding_x = value
	@property
	def background_padding_y(self) -> Optional["float"]:
		"""Defaults to 5."""
		return self._background_padding_y
	@background_padding_y.setter
	def background_padding_y(self, value: Optional["float"]) -> None:
		"""Defaults to 5."""
		self._background_padding_y = value
class StyleAssetModel:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"url": ("url", "str", None),
		"scale": ("scale", "float", None),
		"minimum_pixel_size": ("minimumPixelSize", "float", None),
		"maximum_scale": ("maximumScale", "float", None),
		"run_animations": ("runAnimations", "bool", None),
		"orientation": ("orientation", "list", "float"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		url: "str",
		scale: Optional["float"] = None,
		minimum_pixel_size: Optional["float"] = None,
		maximum_scale: Optional["float"] = None,
		run_animations: Optional["bool"] = None,
		orientation: Optional["List[float]"] = None,
	) -> None:
		"""
		:param url:
		:type url: str
		:param scale: Defaults to 1.
		:type scale: float or None
		:param minimum_pixel_size: Defaults to 0.
		:type minimum_pixel_size: float or None
		:param maximum_scale: Defaults to 0.
		:type maximum_scale: float or None
		:param run_animations: Defaults to true.
		:type run_animations: bool or None
		:param orientation: An array of 4 numbers representing a unit quaternion.
		:type orientation: List[float] or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._url = cast(str, kwargs.get("url"))
		self._scale = cast(Optional[float], kwargs.get("scale"))
		self._minimum_pixel_size = cast(Optional[float], kwargs.get("minimum_pixel_size"))
		self._maximum_scale = cast(Optional[float], kwargs.get("maximum_scale"))
		self._run_animations = cast(Optional[bool], kwargs.get("run_animations"))
		self._orientation = cast(Optional[List[float]], kwargs.get("orientation"))
	@property
	def url(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._url
	@url.setter
	def url(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._url = value
	@property
	def scale(self) -> Optional["float"]:
		"""Defaults to 1."""
		return self._scale
	@scale.setter
	def scale(self, value: Optional["float"]) -> None:
		"""Defaults to 1."""
		self._scale = value
	@property
	def minimum_pixel_size(self) -> Optional["float"]:
		"""Defaults to 0."""
		return self._minimum_pixel_size
	@minimum_pixel_size.setter
	def minimum_pixel_size(self, value: Optional["float"]) -> None:
		"""Defaults to 0."""
		self._minimum_pixel_size = value
	@property
	def maximum_scale(self) -> Optional["float"]:
		"""Defaults to 0."""
		return self._maximum_scale
	@maximum_scale.setter
	def maximum_scale(self, value: Optional["float"]) -> None:
		"""Defaults to 0."""
		self._maximum_scale = value
	@property
	def run_animations(self) -> Optional["bool"]:
		"""Defaults to true."""
		return self._run_animations
	@run_animations.setter
	def run_animations(self, value: Optional["bool"]) -> None:
		"""Defaults to true."""
		self._run_animations = value
	@property
	def orientation(self) -> Optional["List[float]"]:
		"""An array of 4 numbers representing a unit quaternion."""
		return self._orientation
	@orientation.setter
	def orientation(self, value: Optional["List[float]"]) -> None:
		"""An array of 4 numbers representing a unit quaternion."""
		self._orientation = value
class StyleCentroid:
	"""Polygon property"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"fill_color": ("fillColor", "str", None),
		"width": ("width", "int", None),
		"height": ("height", "int", None),
		"holes_only": ("holesOnly", "bool", None),
		"non_holes_only": ("nonHolesOnly", "bool", None),
		"enabled": ("enabled", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		fill_color: Optional["str"] = None,
		width: Optional["int"] = None,
		height: Optional["int"] = None,
		holes_only: Optional["bool"] = None,
		non_holes_only: Optional["bool"] = None,
		enabled: Optional["bool"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param fill_color: A comma separated list of colors for a gradient. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type fill_color: str or None
		:param width: The horizontal radius of the oval in pixels. Defaults to 6.
		:type width: int or None
		:param height: The vertical radius of the oval in pixels. Defaults to 6.
		:type height: int or None
		:param holes_only:
		:type holes_only: bool or None
		:param non_holes_only:
		:type non_holes_only: bool or None
		:param enabled:
		:type enabled: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._fill_color = cast(Optional[str], kwargs.get("fill_color"))
		self._width = cast(Optional[int], kwargs.get("width"))
		self._height = cast(Optional[int], kwargs.get("height"))
		self._holes_only = cast(Optional[bool], kwargs.get("holes_only"))
		self._non_holes_only = cast(Optional[bool], kwargs.get("non_holes_only"))
		self._enabled = cast(Optional[bool], kwargs.get("enabled"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def fill_color(self) -> Optional["str"]:
		"""A comma separated list of colors for a gradient. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._fill_color
	@fill_color.setter
	def fill_color(self, value: Optional["str"]) -> None:
		"""A comma separated list of colors for a gradient. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._fill_color = value
	@property
	def width(self) -> Optional["int"]:
		"""The horizontal radius of the oval in pixels. Defaults to 6."""
		return self._width
	@width.setter
	def width(self, value: Optional["int"]) -> None:
		"""The horizontal radius of the oval in pixels. Defaults to 6."""
		self._width = value
	@property
	def height(self) -> Optional["int"]:
		"""The vertical radius of the oval in pixels. Defaults to 6."""
		return self._height
	@height.setter
	def height(self, value: Optional["int"]) -> None:
		"""The vertical radius of the oval in pixels. Defaults to 6."""
		self._height = value
	@property
	def holes_only(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._holes_only
	@holes_only.setter
	def holes_only(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._holes_only = value
	@property
	def non_holes_only(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._non_holes_only
	@non_holes_only.setter
	def non_holes_only(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._non_holes_only = value
	@property
	def enabled(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
class StyleComposite:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"enabled": ("enabled", "bool", None),
		"tag": ("tag", "str", None),
		"style": ("style", "Style", None),
		"order": ("order", "float", None),
		"xoffset": ("xOffset", "float", None),
		"yoffset": ("yOffset", "float", None),
		"halign": ("hAlign", "HAlign", None),
		"valign": ("vAlign", "VAlign", None),
		"blend_mode": ("blendMode", "BlendMode", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		style: "Style",
		xoffset: "float",
		yoffset: "float",
		halign: "HAlign",
		valign: "VAlign",
		blend_mode: "BlendMode",
		enabled: Optional["bool"] = None,
		tag: Optional["str"] = None,
		order: Optional["float"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param style:
		:type style: Style
		:param xoffset:
		:type xoffset: float
		:param yoffset:
		:type yoffset: float
		:param halign:
		:type halign: HAlign
		:param valign:
		:type valign: VAlign
		:param blend_mode:
		:type blend_mode: BlendMode
		:param enabled:
		:type enabled: bool or None
		:param tag:
		:type tag: str or None
		:param order:
		:type order: float or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._enabled = cast(Optional[bool], kwargs.get("enabled"))
		self._tag = cast(Optional[str], kwargs.get("tag"))
		self._style = cast(Style, kwargs.get("style"))
		self._order = cast(Optional[float], kwargs.get("order"))
		self._xoffset = cast(float, kwargs.get("xoffset"))
		self._yoffset = cast(float, kwargs.get("yoffset"))
		self._halign = cast(HAlign, kwargs.get("halign"))
		self._valign = cast(VAlign, kwargs.get("valign"))
		self._blend_mode = cast(BlendMode, kwargs.get("blend_mode"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def enabled(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def tag(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._tag
	@tag.setter
	def tag(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._tag = value
	@property
	def style(self) -> "Style":
		# pylint: disable=missing-function-docstring
		return self._style
	@style.setter
	def style(self, value: "Style") -> None:
		# pylint: disable=missing-function-docstring
		self._style = value
	@property
	def order(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._order
	@order.setter
	def order(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._order = value
	@property
	def xoffset(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._xoffset
	@xoffset.setter
	def xoffset(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._xoffset = value
	@property
	def yoffset(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._yoffset
	@yoffset.setter
	def yoffset(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._yoffset = value
	@property
	def halign(self) -> "HAlign":
		# pylint: disable=missing-function-docstring
		return self._halign
	@halign.setter
	def halign(self, value: "HAlign") -> None:
		# pylint: disable=missing-function-docstring
		self._halign = value
	@property
	def valign(self) -> "VAlign":
		# pylint: disable=missing-function-docstring
		return self._valign
	@valign.setter
	def valign(self, value: "VAlign") -> None:
		# pylint: disable=missing-function-docstring
		self._valign = value
	@property
	def blend_mode(self) -> "BlendMode":
		# pylint: disable=missing-function-docstring
		return self._blend_mode
	@blend_mode.setter
	def blend_mode(self, value: "BlendMode") -> None:
		# pylint: disable=missing-function-docstring
		self._blend_mode = value
class StyleHover:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"direction_icon_spacing": ("directionIconSpacing", "int", None),
		"direction_icon_xoffset": ("directionIconXOffset", "int", None),
		"direction_icon": ("directionIcon", "StyleShield", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		direction_icon_spacing: Optional["int"] = None,
		direction_icon_xoffset: Optional["int"] = None,
		direction_icon: Optional["StyleShield"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param direction_icon_spacing: Non-negative integer.
		:type direction_icon_spacing: int or None
		:param direction_icon_xoffset:
		:type direction_icon_xoffset: int or None
		:param direction_icon:
		:type direction_icon: StyleShield or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._direction_icon_spacing = cast(Optional[int], kwargs.get("direction_icon_spacing"))
		self._direction_icon_xoffset = cast(Optional[int], kwargs.get("direction_icon_xoffset"))
		self._direction_icon = cast(Optional[StyleShield], kwargs.get("direction_icon"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def direction_icon_spacing(self) -> Optional["int"]:
		"""Non-negative integer."""
		return self._direction_icon_spacing
	@direction_icon_spacing.setter
	def direction_icon_spacing(self, value: Optional["int"]) -> None:
		"""Non-negative integer."""
		self._direction_icon_spacing = value
	@property
	def direction_icon_xoffset(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._direction_icon_xoffset
	@direction_icon_xoffset.setter
	def direction_icon_xoffset(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._direction_icon_xoffset = value
	@property
	def direction_icon(self) -> Optional["StyleShield"]:
		# pylint: disable=missing-function-docstring
		return self._direction_icon
	@direction_icon.setter
	def direction_icon(self, value: Optional["StyleShield"]) -> None:
		# pylint: disable=missing-function-docstring
		self._direction_icon = value
class StyleImageComponent:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"filter_high_quality": ("filterHighQuality", "bool", None),
		"force_reproject": ("forceReproject", "bool", None),
		"super_resolution": ("superResolution", "bool", None),
		"min_zoom": ("minZoom", "int", None),
		"max_zoom": ("maxZoom", "int", None),
		"filters": ("filters", "list", "StyleImageFilterComponent"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		filter_high_quality: "bool",
		force_reproject: "bool",
		super_resolution: "bool",
		min_zoom: "int",
		max_zoom: "int",
		filters: "List[StyleImageFilterComponent]",
	) -> None:
		"""
		:param filter_high_quality:
		:type filter_high_quality: bool
		:param force_reproject:
		:type force_reproject: bool
		:param super_resolution:
		:type super_resolution: bool
		:param min_zoom:
		:type min_zoom: int
		:param max_zoom:
		:type max_zoom: int
		:param filters:
		:type filters: List[StyleImageFilterComponent]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._filter_high_quality = cast(bool, kwargs.get("filter_high_quality"))
		self._force_reproject = cast(bool, kwargs.get("force_reproject"))
		self._super_resolution = cast(bool, kwargs.get("super_resolution"))
		self._min_zoom = cast(int, kwargs.get("min_zoom"))
		self._max_zoom = cast(int, kwargs.get("max_zoom"))
		self._filters = cast(List[StyleImageFilterComponent], kwargs.get("filters"))
	@property
	def filter_high_quality(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._filter_high_quality
	@filter_high_quality.setter
	def filter_high_quality(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._filter_high_quality = value
	@property
	def force_reproject(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._force_reproject
	@force_reproject.setter
	def force_reproject(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._force_reproject = value
	@property
	def super_resolution(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._super_resolution
	@super_resolution.setter
	def super_resolution(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._super_resolution = value
	@property
	def min_zoom(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._min_zoom
	@min_zoom.setter
	def min_zoom(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._min_zoom = value
	@property
	def max_zoom(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._max_zoom
	@max_zoom.setter
	def max_zoom(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._max_zoom = value
	@property
	def filters(self) -> "List[StyleImageFilterComponent]":
		# pylint: disable=missing-function-docstring
		return self._filters
	@filters.setter
	def filters(self, value: "List[StyleImageFilterComponent]") -> None:
		# pylint: disable=missing-function-docstring
		self._filters = value
class StyleImageFilterComponent:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"amount": ("amount", "float", None),
		"radius": ("radius", "float", None),
		"thresholds": ("thresholds", "list", "float"),
		"color": ("color", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		amount: "float",
		radius: "float",
		thresholds: "List[float]",
		name: Optional["str"] = None,
		color: Optional["str"] = None,
	) -> None:
		"""
		:param amount:
		:type amount: float
		:param radius:
		:type radius: float
		:param thresholds:
		:type thresholds: List[float]
		:param name:
		:type name: str or None
		:param color:
		:type color: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._amount = cast(float, kwargs.get("amount"))
		self._radius = cast(float, kwargs.get("radius"))
		self._thresholds = cast(List[float], kwargs.get("thresholds"))
		self._color = cast(Optional[str], kwargs.get("color"))
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def amount(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._amount
	@amount.setter
	def amount(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._amount = value
	@property
	def radius(self) -> "float":
		# pylint: disable=missing-function-docstring
		return self._radius
	@radius.setter
	def radius(self, value: "float") -> None:
		# pylint: disable=missing-function-docstring
		self._radius = value
	@property
	def thresholds(self) -> "List[float]":
		# pylint: disable=missing-function-docstring
		return self._thresholds
	@thresholds.setter
	def thresholds(self, value: "List[float]") -> None:
		# pylint: disable=missing-function-docstring
		self._thresholds = value
	@property
	def color(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._color = value
class StyleLineBorder:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"fill_color": ("fillColor", "str", None),
		"width": ("width", "int", None),
		"blending": ("blending", "bool", None),
		"start_cap": ("startCap", "LineCapStyle", None),
		"line_dash": ("lineDash", "LineDashStyle", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		fill_color: "str",
		width: Optional["int"] = None,
		blending: Optional["bool"] = None,
		start_cap: Optional["LineCapStyle"] = None,
		line_dash: Optional["LineDashStyle"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param fill_color: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type fill_color: str
		:param width: Defaults to 10.
		:type width: int or None
		:param blending: Defaults to true.
		:type blending: bool or None
		:param start_cap: Defaults to 'Round'.
		:type start_cap: LineCapStyle or None
		:param line_dash: Defaults to 'Solid'.
		:type line_dash: LineDashStyle or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._fill_color = cast(str, kwargs.get("fill_color"))
		self._width = cast(Optional[int], kwargs.get("width"))
		self._blending = cast(Optional[bool], kwargs.get("blending"))
		self._start_cap = cast(Optional[LineCapStyle], kwargs.get("start_cap"))
		self._line_dash = cast(Optional[LineDashStyle], kwargs.get("line_dash"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def fill_color(self) -> "str":
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._fill_color
	@fill_color.setter
	def fill_color(self, value: "str") -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._fill_color = value
	@property
	def width(self) -> Optional["int"]:
		"""Defaults to 10."""
		return self._width
	@width.setter
	def width(self, value: Optional["int"]) -> None:
		"""Defaults to 10."""
		self._width = value
	@property
	def blending(self) -> Optional["bool"]:
		"""Defaults to true."""
		return self._blending
	@blending.setter
	def blending(self, value: Optional["bool"]) -> None:
		"""Defaults to true."""
		self._blending = value
	@property
	def start_cap(self) -> Optional["LineCapStyle"]:
		"""Defaults to 'Round'."""
		return self._start_cap
	@start_cap.setter
	def start_cap(self, value: Optional["LineCapStyle"]) -> None:
		"""Defaults to 'Round'."""
		self._start_cap = value
	@property
	def line_dash(self) -> Optional["LineDashStyle"]:
		"""Defaults to 'Solid'."""
		return self._line_dash
	@line_dash.setter
	def line_dash(self, value: Optional["LineDashStyle"]) -> None:
		"""Defaults to 'Solid'."""
		self._line_dash = value
class StyleOverlay:
	"""Core property"""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"text_overlay_mode": ("textOverlayMode", "TextOverlayMode", None),
		"text_collision_group_name": ("textCollisionGroupName", "str", None),
		"icon_collision_group_name": ("iconCollisionGroupName", "str", None),
		"blend_mode": ("blendMode", "BlendMode", None),
		"composite_blend_mode": ("compositeBlendMode", "CompositeBlendMode", None),
		"overlay_engine": ("overlayEngine", "OverlayEngineType", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		overlay_engine: "OverlayEngineType",
		text_overlay_mode: Optional["TextOverlayMode"] = None,
		text_collision_group_name: Optional["str"] = None,
		icon_collision_group_name: Optional["str"] = None,
		blend_mode: Optional["BlendMode"] = None,
		composite_blend_mode: Optional["CompositeBlendMode"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param overlay_engine:
		:type overlay_engine: OverlayEngineType
		:param text_overlay_mode:
		:type text_overlay_mode: TextOverlayMode or None
		:param text_collision_group_name:
		:type text_collision_group_name: str or None
		:param icon_collision_group_name:
		:type icon_collision_group_name: str or None
		:param blend_mode:
		:type blend_mode: BlendMode or None
		:param composite_blend_mode:
		:type composite_blend_mode: CompositeBlendMode or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._text_overlay_mode = cast(Optional[TextOverlayMode], kwargs.get("text_overlay_mode"))
		self._text_collision_group_name = cast(Optional[str], kwargs.get("text_collision_group_name"))
		self._icon_collision_group_name = cast(Optional[str], kwargs.get("icon_collision_group_name"))
		self._blend_mode = cast(Optional[BlendMode], kwargs.get("blend_mode"))
		self._composite_blend_mode = cast(Optional[CompositeBlendMode], kwargs.get("composite_blend_mode"))
		self._overlay_engine = cast(OverlayEngineType, kwargs.get("overlay_engine"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def text_overlay_mode(self) -> Optional["TextOverlayMode"]:
		# pylint: disable=missing-function-docstring
		return self._text_overlay_mode
	@text_overlay_mode.setter
	def text_overlay_mode(self, value: Optional["TextOverlayMode"]) -> None:
		# pylint: disable=missing-function-docstring
		self._text_overlay_mode = value
	@property
	def text_collision_group_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._text_collision_group_name
	@text_collision_group_name.setter
	def text_collision_group_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._text_collision_group_name = value
	@property
	def icon_collision_group_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._icon_collision_group_name
	@icon_collision_group_name.setter
	def icon_collision_group_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._icon_collision_group_name = value
	@property
	def blend_mode(self) -> Optional["BlendMode"]:
		# pylint: disable=missing-function-docstring
		return self._blend_mode
	@blend_mode.setter
	def blend_mode(self, value: Optional["BlendMode"]) -> None:
		# pylint: disable=missing-function-docstring
		self._blend_mode = value
	@property
	def composite_blend_mode(self) -> Optional["CompositeBlendMode"]:
		# pylint: disable=missing-function-docstring
		return self._composite_blend_mode
	@composite_blend_mode.setter
	def composite_blend_mode(self, value: Optional["CompositeBlendMode"]) -> None:
		# pylint: disable=missing-function-docstring
		self._composite_blend_mode = value
	@property
	def overlay_engine(self) -> "OverlayEngineType":
		# pylint: disable=missing-function-docstring
		return self._overlay_engine
	@overlay_engine.setter
	def overlay_engine(self, value: "OverlayEngineType") -> None:
		# pylint: disable=missing-function-docstring
		self._overlay_engine = value
class StylePath1D:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"enabled": ("enabled", "bool", None),
		"shape": ("shape", "ShaderStyle", None),
		"shape_custom_path": ("shapeCustomPath", "str", None),
		"width": ("width", "int", None),
		"height": ("height", "int", None),
		"border_width": ("borderWidth", "int", None),
		"xoffset": ("xOffset", "float", None),
		"yoffset": ("yOffset", "float", None),
		"xscale": ("xScale", "float", None),
		"yscale": ("yScale", "float", None),
		"halign": ("hAlign", "HAlign", None),
		"valign": ("vAlign", "VAlign", None),
		"rotation_angle": ("rotationAngle", "float", None),
		"border_blur_sigma": ("borderBlurSigma", "float", None),
		"border_blur_style": ("borderBlurStyle", "BlurStyle", None),
		"advance": ("advance", "float", None),
		"phase": ("phase", "float", None),
		"effect_style": ("effectStyle", "LinePath1DEffectStyle", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		enabled: Optional["bool"] = None,
		shape: Optional["ShaderStyle"] = None,
		shape_custom_path: Optional["str"] = None,
		width: Optional["int"] = None,
		height: Optional["int"] = None,
		border_width: Optional["int"] = None,
		xoffset: Optional["float"] = None,
		yoffset: Optional["float"] = None,
		xscale: Optional["float"] = None,
		yscale: Optional["float"] = None,
		halign: Optional["HAlign"] = None,
		valign: Optional["VAlign"] = None,
		rotation_angle: Optional["float"] = None,
		border_blur_sigma: Optional["float"] = None,
		border_blur_style: Optional["BlurStyle"] = None,
		advance: Optional["float"] = None,
		phase: Optional["float"] = None,
		effect_style: Optional["LinePath1DEffectStyle"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param enabled: If true, enable the Path 1D line dash effect. Recommended to also use style.optimization.simpleLineRendering = true.
		:type enabled: bool or None
		:param shape:
		:type shape: ShaderStyle or None
		:param shape_custom_path:
		:type shape_custom_path: str or None
		:param width:
		:type width: int or None
		:param height:
		:type height: int or None
		:param border_width:
		:type border_width: int or None
		:param xoffset:
		:type xoffset: float or None
		:param yoffset:
		:type yoffset: float or None
		:param xscale:
		:type xscale: float or None
		:param yscale:
		:type yscale: float or None
		:param halign:
		:type halign: HAlign or None
		:param valign:
		:type valign: VAlign or None
		:param rotation_angle:
		:type rotation_angle: float or None
		:param border_blur_sigma:
		:type border_blur_sigma: float or None
		:param border_blur_style:
		:type border_blur_style: BlurStyle or None
		:param advance:
		:type advance: float or None
		:param phase:
		:type phase: float or None
		:param effect_style:
		:type effect_style: LinePath1DEffectStyle or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._enabled = cast(Optional[bool], kwargs.get("enabled"))
		self._shape = cast(Optional[ShaderStyle], kwargs.get("shape"))
		self._shape_custom_path = cast(Optional[str], kwargs.get("shape_custom_path"))
		self._width = cast(Optional[int], kwargs.get("width"))
		self._height = cast(Optional[int], kwargs.get("height"))
		self._border_width = cast(Optional[int], kwargs.get("border_width"))
		self._xoffset = cast(Optional[float], kwargs.get("xoffset"))
		self._yoffset = cast(Optional[float], kwargs.get("yoffset"))
		self._xscale = cast(Optional[float], kwargs.get("xscale"))
		self._yscale = cast(Optional[float], kwargs.get("yscale"))
		self._halign = cast(Optional[HAlign], kwargs.get("halign"))
		self._valign = cast(Optional[VAlign], kwargs.get("valign"))
		self._rotation_angle = cast(Optional[float], kwargs.get("rotation_angle"))
		self._border_blur_sigma = cast(Optional[float], kwargs.get("border_blur_sigma"))
		self._border_blur_style = cast(Optional[BlurStyle], kwargs.get("border_blur_style"))
		self._advance = cast(Optional[float], kwargs.get("advance"))
		self._phase = cast(Optional[float], kwargs.get("phase"))
		self._effect_style = cast(Optional[LinePath1DEffectStyle], kwargs.get("effect_style"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def enabled(self) -> Optional["bool"]:
		"""If true, enable the Path 1D line dash effect. Recommended to also use style.optimization.simpleLineRendering = true."""
		return self._enabled
	@enabled.setter
	def enabled(self, value: Optional["bool"]) -> None:
		"""If true, enable the Path 1D line dash effect. Recommended to also use style.optimization.simpleLineRendering = true."""
		self._enabled = value
	@property
	def shape(self) -> Optional["ShaderStyle"]:
		# pylint: disable=missing-function-docstring
		return self._shape
	@shape.setter
	def shape(self, value: Optional["ShaderStyle"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shape = value
	@property
	def shape_custom_path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._shape_custom_path
	@shape_custom_path.setter
	def shape_custom_path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shape_custom_path = value
	@property
	def width(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._width
	@width.setter
	def width(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._width = value
	@property
	def height(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._height
	@height.setter
	def height(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._height = value
	@property
	def border_width(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._border_width
	@border_width.setter
	def border_width(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._border_width = value
	@property
	def xoffset(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._xoffset
	@xoffset.setter
	def xoffset(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xoffset = value
	@property
	def yoffset(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._yoffset
	@yoffset.setter
	def yoffset(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._yoffset = value
	@property
	def xscale(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._xscale
	@xscale.setter
	def xscale(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xscale = value
	@property
	def yscale(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._yscale
	@yscale.setter
	def yscale(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._yscale = value
	@property
	def halign(self) -> Optional["HAlign"]:
		# pylint: disable=missing-function-docstring
		return self._halign
	@halign.setter
	def halign(self, value: Optional["HAlign"]) -> None:
		# pylint: disable=missing-function-docstring
		self._halign = value
	@property
	def valign(self) -> Optional["VAlign"]:
		# pylint: disable=missing-function-docstring
		return self._valign
	@valign.setter
	def valign(self, value: Optional["VAlign"]) -> None:
		# pylint: disable=missing-function-docstring
		self._valign = value
	@property
	def rotation_angle(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._rotation_angle
	@rotation_angle.setter
	def rotation_angle(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rotation_angle = value
	@property
	def border_blur_sigma(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._border_blur_sigma
	@border_blur_sigma.setter
	def border_blur_sigma(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._border_blur_sigma = value
	@property
	def border_blur_style(self) -> Optional["BlurStyle"]:
		# pylint: disable=missing-function-docstring
		return self._border_blur_style
	@border_blur_style.setter
	def border_blur_style(self, value: Optional["BlurStyle"]) -> None:
		# pylint: disable=missing-function-docstring
		self._border_blur_style = value
	@property
	def advance(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._advance
	@advance.setter
	def advance(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._advance = value
	@property
	def phase(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._phase
	@phase.setter
	def phase(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._phase = value
	@property
	def effect_style(self) -> Optional["LinePath1DEffectStyle"]:
		# pylint: disable=missing-function-docstring
		return self._effect_style
	@effect_style.setter
	def effect_style(self, value: Optional["LinePath1DEffectStyle"]) -> None:
		# pylint: disable=missing-function-docstring
		self._effect_style = value
class StyleRule:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"enabled": ("enabled", "bool", None),
		"tag": ("tag", "str", None),
		"style": ("style", "Style", None),
		"where": ("where", "QueryWhere", None),
		"constraint": ("constraint", "StyleRuleConstraint", None),
		"legend": ("legend", "Legend", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		style: "Style",
		enabled: Optional["bool"] = None,
		tag: Optional["str"] = None,
		where: Optional["QueryWhere"] = None,
		constraint: Optional["StyleRuleConstraint"] = None,
		legend: Optional["Legend"] = None,
	) -> None:
		"""
		:param style:
		:type style: Style
		:param enabled:
		:type enabled: bool or None
		:param tag:
		:type tag: str or None
		:param where:
		:type where: QueryWhere or None
		:param constraint:
		:type constraint: StyleRuleConstraint or None
		:param legend:
		:type legend: Legend or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._enabled = cast(Optional[bool], kwargs.get("enabled"))
		self._tag = cast(Optional[str], kwargs.get("tag"))
		self._style = cast(Style, kwargs.get("style"))
		self._where = cast(Optional[QueryWhere], kwargs.get("where"))
		self._constraint = cast(Optional[StyleRuleConstraint], kwargs.get("constraint"))
		self._legend = cast(Optional[Legend], kwargs.get("legend"))
	@property
	def enabled(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def tag(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._tag
	@tag.setter
	def tag(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._tag = value
	@property
	def style(self) -> "Style":
		# pylint: disable=missing-function-docstring
		return self._style
	@style.setter
	def style(self, value: "Style") -> None:
		# pylint: disable=missing-function-docstring
		self._style = value
	@property
	def where(self) -> Optional["QueryWhere"]:
		# pylint: disable=missing-function-docstring
		return self._where
	@where.setter
	def where(self, value: Optional["QueryWhere"]) -> None:
		# pylint: disable=missing-function-docstring
		self._where = value
	@property
	def constraint(self) -> Optional["StyleRuleConstraint"]:
		# pylint: disable=missing-function-docstring
		return self._constraint
	@constraint.setter
	def constraint(self, value: Optional["StyleRuleConstraint"]) -> None:
		# pylint: disable=missing-function-docstring
		self._constraint = value
	@property
	def legend(self) -> Optional["Legend"]:
		# pylint: disable=missing-function-docstring
		return self._legend
	@legend.setter
	def legend(self, value: Optional["Legend"]) -> None:
		# pylint: disable=missing-function-docstring
		self._legend = value
class StyleRuleConstraint:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"min_zoom": ("minZoom", "float", None),
		"max_zoom": ("maxZoom", "float", None),
		"cluster": ("cluster", "bool", None),
		"graph_type": ("graphType", "GraphType", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		min_zoom: Optional["float"] = None,
		max_zoom: Optional["float"] = None,
		cluster: Optional["bool"] = None,
		graph_type: Optional["GraphType"] = None,
	) -> None:
		"""
		:param min_zoom:
		:type min_zoom: float or None
		:param max_zoom:
		:type max_zoom: float or None
		:param cluster:
		:type cluster: bool or None
		:param graph_type:
		:type graph_type: GraphType or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._min_zoom = cast(Optional[float], kwargs.get("min_zoom"))
		self._max_zoom = cast(Optional[float], kwargs.get("max_zoom"))
		self._cluster = cast(Optional[bool], kwargs.get("cluster"))
		self._graph_type = cast(Optional[GraphType], kwargs.get("graph_type"))
	@property
	def min_zoom(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._min_zoom
	@min_zoom.setter
	def min_zoom(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_zoom = value
	@property
	def max_zoom(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._max_zoom
	@max_zoom.setter
	def max_zoom(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_zoom = value
	@property
	def cluster(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._cluster
	@cluster.setter
	def cluster(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._cluster = value
	@property
	def graph_type(self) -> Optional["GraphType"]:
		# pylint: disable=missing-function-docstring
		return self._graph_type
	@graph_type.setter
	def graph_type(self, value: Optional["GraphType"]) -> None:
		# pylint: disable=missing-function-docstring
		self._graph_type = value
class StyleShield:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"enabled": ("enabled", "bool", None),
		"width": ("width", "int", None),
		"height": ("height", "int", None),
		"border_width": ("borderWidth", "int", None),
		"border_blur_style": ("borderBlurStyle", "BlurStyle", None),
		"border_blur_sigma": ("borderBlurSigma", "float", None),
		"inner_borders": ("innerBorders", "bool", None),
		"fill_color": ("fillColor", "str", None),
		"border_color": ("borderColor", "str", None),
		"text": ("text", "StyleText", None),
		"rotation_angle": ("rotationAngle", "float", None),
		"has_rotation_angle": ("hasRotationAngle", "bool", None),
		"uri": ("uri", "str", None),
		"svg": ("svg", "list", "StyleSvgAttribute"),
		"shape": ("shape", "ShaderStyle", None),
		"shape_custom_path": ("shapeCustomPath", "str", None),
		"border_color_offset": ("borderColorOffset", "int", None),
		"fill_color_alpha_offset": ("fillColorAlphaOffset", "int", None),
		"gradient_color_position": ("gradientColorPosition", "str", None),
		"gradient_style": ("gradientStyle", "DotGradientStyle", None),
		"line_dash": ("lineDash", "LineDashStyle", None),
		"stroke_join": ("strokeJoin", "LineStrokeJoin", None),
		"stroke_miter": ("strokeMiter", "float", None),
		"colorize_color": ("colorizeColor", "str", None),
		"color_transform": ("colorTransform", "LayerColorTransformValues", None),
		"drop_shadow": ("dropShadow", "bool", None),
		"drop_shadow_length": ("dropShadowLength", "int", None),
		"drop_shadow_color": ("dropShadowColor", "str", None),
		"unique_id": ("UniqueId", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		enabled: Optional["bool"] = None,
		width: Optional["int"] = None,
		height: Optional["int"] = None,
		border_width: Optional["int"] = None,
		border_blur_style: Optional["BlurStyle"] = None,
		border_blur_sigma: Optional["float"] = None,
		inner_borders: Optional["bool"] = None,
		fill_color: Optional["str"] = None,
		border_color: Optional["str"] = None,
		text: Optional["StyleText"] = None,
		rotation_angle: Optional["float"] = None,
		has_rotation_angle: Optional["bool"] = None,
		uri: Optional["str"] = None,
		svg: Optional["List[StyleSvgAttribute]"] = None,
		shape: Optional["ShaderStyle"] = None,
		shape_custom_path: Optional["str"] = None,
		border_color_offset: Optional["int"] = None,
		fill_color_alpha_offset: Optional["int"] = None,
		gradient_color_position: Optional["str"] = None,
		gradient_style: Optional["DotGradientStyle"] = None,
		line_dash: Optional["LineDashStyle"] = None,
		stroke_join: Optional["LineStrokeJoin"] = None,
		stroke_miter: Optional["float"] = None,
		colorize_color: Optional["str"] = None,
		color_transform: Optional["LayerColorTransformValues"] = None,
		drop_shadow: Optional["bool"] = None,
		drop_shadow_length: Optional["int"] = None,
		drop_shadow_color: Optional["str"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param enabled:
		:type enabled: bool or None
		:param width:
		:type width: int or None
		:param height:
		:type height: int or None
		:param border_width:
		:type border_width: int or None
		:param border_blur_style:
		:type border_blur_style: BlurStyle or None
		:param border_blur_sigma:
		:type border_blur_sigma: float or None
		:param inner_borders:
		:type inner_borders: bool or None
		:param fill_color: A comma separated list of colors for a gradient. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type fill_color: str or None
		:param border_color: A comma separated list of colors for a gradient. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type border_color: str or None
		:param text:
		:type text: StyleText or None
		:param rotation_angle:
		:type rotation_angle: float or None
		:param has_rotation_angle:
		:type has_rotation_angle: bool or None
		:param uri:
		:type uri: str or None
		:param svg:
		:type svg: List[StyleSvgAttribute] or None
		:param shape: Icon property: Specify the icon shape.
* `round` - Circular icons (or an ellipse).
* `rectangle` - Square icons with rounded corners (or a rectangle).
* `triangle` - Triangular icons.
* `diamond` - Diamond icons (a rhombus).
* `plus` - Plus-sign, or cross, icons.
* `star` - Five pointed star icons.
* `x` - X-shaped icons.
* `chevron` - Chevron icon.
		:type shape: ShaderStyle or None
		:param shape_custom_path:
		:type shape_custom_path: str or None
		:param border_color_offset:
		:type border_color_offset: int or None
		:param fill_color_alpha_offset:
		:type fill_color_alpha_offset: int or None
		:param gradient_color_position:
		:type gradient_color_position: str or None
		:param gradient_style:
		:type gradient_style: DotGradientStyle or None
		:param line_dash:
		:type line_dash: LineDashStyle or None
		:param stroke_join:
		:type stroke_join: LineStrokeJoin or None
		:param stroke_miter:
		:type stroke_miter: float or None
		:param colorize_color: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type colorize_color: str or None
		:param color_transform:
		:type color_transform: LayerColorTransformValues or None
		:param drop_shadow:
		:type drop_shadow: bool or None
		:param drop_shadow_length:
		:type drop_shadow_length: int or None
		:param drop_shadow_color: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type drop_shadow_color: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._enabled = cast(Optional[bool], kwargs.get("enabled"))
		self._width = cast(Optional[int], kwargs.get("width"))
		self._height = cast(Optional[int], kwargs.get("height"))
		self._border_width = cast(Optional[int], kwargs.get("border_width"))
		self._border_blur_style = cast(Optional[BlurStyle], kwargs.get("border_blur_style"))
		self._border_blur_sigma = cast(Optional[float], kwargs.get("border_blur_sigma"))
		self._inner_borders = cast(Optional[bool], kwargs.get("inner_borders"))
		self._fill_color = cast(Optional[str], kwargs.get("fill_color"))
		self._border_color = cast(Optional[str], kwargs.get("border_color"))
		self._text = cast(Optional[StyleText], kwargs.get("text"))
		self._rotation_angle = cast(Optional[float], kwargs.get("rotation_angle"))
		self._has_rotation_angle = cast(Optional[bool], kwargs.get("has_rotation_angle"))
		self._uri = cast(Optional[str], kwargs.get("uri"))
		self._svg = cast(Optional[List[StyleSvgAttribute]], kwargs.get("svg"))
		self._shape = cast(Optional[ShaderStyle], kwargs.get("shape"))
		self._shape_custom_path = cast(Optional[str], kwargs.get("shape_custom_path"))
		self._border_color_offset = cast(Optional[int], kwargs.get("border_color_offset"))
		self._fill_color_alpha_offset = cast(Optional[int], kwargs.get("fill_color_alpha_offset"))
		self._gradient_color_position = cast(Optional[str], kwargs.get("gradient_color_position"))
		self._gradient_style = cast(Optional[DotGradientStyle], kwargs.get("gradient_style"))
		self._line_dash = cast(Optional[LineDashStyle], kwargs.get("line_dash"))
		self._stroke_join = cast(Optional[LineStrokeJoin], kwargs.get("stroke_join"))
		self._stroke_miter = cast(Optional[float], kwargs.get("stroke_miter"))
		self._colorize_color = cast(Optional[str], kwargs.get("colorize_color"))
		self._color_transform = cast(Optional[LayerColorTransformValues], kwargs.get("color_transform"))
		self._drop_shadow = cast(Optional[bool], kwargs.get("drop_shadow"))
		self._drop_shadow_length = cast(Optional[int], kwargs.get("drop_shadow_length"))
		self._drop_shadow_color = cast(Optional[str], kwargs.get("drop_shadow_color"))
		self._unique_id = cast(str, kwargs.get("unique_id"))
	@property
	def enabled(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def width(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._width
	@width.setter
	def width(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._width = value
	@property
	def height(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._height
	@height.setter
	def height(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._height = value
	@property
	def border_width(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._border_width
	@border_width.setter
	def border_width(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._border_width = value
	@property
	def border_blur_style(self) -> Optional["BlurStyle"]:
		# pylint: disable=missing-function-docstring
		return self._border_blur_style
	@border_blur_style.setter
	def border_blur_style(self, value: Optional["BlurStyle"]) -> None:
		# pylint: disable=missing-function-docstring
		self._border_blur_style = value
	@property
	def border_blur_sigma(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._border_blur_sigma
	@border_blur_sigma.setter
	def border_blur_sigma(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._border_blur_sigma = value
	@property
	def inner_borders(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._inner_borders
	@inner_borders.setter
	def inner_borders(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._inner_borders = value
	@property
	def fill_color(self) -> Optional["str"]:
		"""A comma separated list of colors for a gradient. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._fill_color
	@fill_color.setter
	def fill_color(self, value: Optional["str"]) -> None:
		"""A comma separated list of colors for a gradient. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._fill_color = value
	@property
	def border_color(self) -> Optional["str"]:
		"""A comma separated list of colors for a gradient. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._border_color
	@border_color.setter
	def border_color(self, value: Optional["str"]) -> None:
		"""A comma separated list of colors for a gradient. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._border_color = value
	@property
	def text(self) -> Optional["StyleText"]:
		# pylint: disable=missing-function-docstring
		return self._text
	@text.setter
	def text(self, value: Optional["StyleText"]) -> None:
		# pylint: disable=missing-function-docstring
		self._text = value
	@property
	def rotation_angle(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._rotation_angle
	@rotation_angle.setter
	def rotation_angle(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rotation_angle = value
	@property
	def has_rotation_angle(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._has_rotation_angle
	@has_rotation_angle.setter
	def has_rotation_angle(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._has_rotation_angle = value
	@property
	def uri(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._uri
	@uri.setter
	def uri(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._uri = value
	@property
	def svg(self) -> Optional["List[StyleSvgAttribute]"]:
		# pylint: disable=missing-function-docstring
		return self._svg
	@svg.setter
	def svg(self, value: Optional["List[StyleSvgAttribute]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._svg = value
	@property
	def shape(self) -> Optional["ShaderStyle"]:
		"""Icon property: Specify the icon shape.
* `round` - Circular icons (or an ellipse).
* `rectangle` - Square icons with rounded corners (or a rectangle).
* `triangle` - Triangular icons.
* `diamond` - Diamond icons (a rhombus).
* `plus` - Plus-sign, or cross, icons.
* `star` - Five pointed star icons.
* `x` - X-shaped icons.
* `chevron` - Chevron icon."""
		return self._shape
	@shape.setter
	def shape(self, value: Optional["ShaderStyle"]) -> None:
		"""Icon property: Specify the icon shape.
* `round` - Circular icons (or an ellipse).
* `rectangle` - Square icons with rounded corners (or a rectangle).
* `triangle` - Triangular icons.
* `diamond` - Diamond icons (a rhombus).
* `plus` - Plus-sign, or cross, icons.
* `star` - Five pointed star icons.
* `x` - X-shaped icons.
* `chevron` - Chevron icon."""
		self._shape = value
	@property
	def shape_custom_path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._shape_custom_path
	@shape_custom_path.setter
	def shape_custom_path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._shape_custom_path = value
	@property
	def border_color_offset(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._border_color_offset
	@border_color_offset.setter
	def border_color_offset(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._border_color_offset = value
	@property
	def fill_color_alpha_offset(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._fill_color_alpha_offset
	@fill_color_alpha_offset.setter
	def fill_color_alpha_offset(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._fill_color_alpha_offset = value
	@property
	def gradient_color_position(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._gradient_color_position
	@gradient_color_position.setter
	def gradient_color_position(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._gradient_color_position = value
	@property
	def gradient_style(self) -> Optional["DotGradientStyle"]:
		# pylint: disable=missing-function-docstring
		return self._gradient_style
	@gradient_style.setter
	def gradient_style(self, value: Optional["DotGradientStyle"]) -> None:
		# pylint: disable=missing-function-docstring
		self._gradient_style = value
	@property
	def line_dash(self) -> Optional["LineDashStyle"]:
		# pylint: disable=missing-function-docstring
		return self._line_dash
	@line_dash.setter
	def line_dash(self, value: Optional["LineDashStyle"]) -> None:
		# pylint: disable=missing-function-docstring
		self._line_dash = value
	@property
	def stroke_join(self) -> Optional["LineStrokeJoin"]:
		# pylint: disable=missing-function-docstring
		return self._stroke_join
	@stroke_join.setter
	def stroke_join(self, value: Optional["LineStrokeJoin"]) -> None:
		# pylint: disable=missing-function-docstring
		self._stroke_join = value
	@property
	def stroke_miter(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._stroke_miter
	@stroke_miter.setter
	def stroke_miter(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._stroke_miter = value
	@property
	def colorize_color(self) -> Optional["str"]:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._colorize_color
	@colorize_color.setter
	def colorize_color(self, value: Optional["str"]) -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._colorize_color = value
	@property
	def color_transform(self) -> Optional["LayerColorTransformValues"]:
		# pylint: disable=missing-function-docstring
		return self._color_transform
	@color_transform.setter
	def color_transform(self, value: Optional["LayerColorTransformValues"]) -> None:
		# pylint: disable=missing-function-docstring
		self._color_transform = value
	@property
	def drop_shadow(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._drop_shadow
	@drop_shadow.setter
	def drop_shadow(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._drop_shadow = value
	@property
	def drop_shadow_length(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._drop_shadow_length
	@drop_shadow_length.setter
	def drop_shadow_length(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._drop_shadow_length = value
	@property
	def drop_shadow_color(self) -> Optional["str"]:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._drop_shadow_color
	@drop_shadow_color.setter
	def drop_shadow_color(self, value: Optional["str"]) -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._drop_shadow_color = value
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
class StyleSvgAttribute:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"unique_id": ("UniqueId", "str", None),
		"enabled": ("enabled", "bool", None),
		"path": ("path", "str", None),
		"attr": ("attr", "str", None),
		"value": ("value", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		unique_id: "str",
		path: "str",
		attr: "str",
		value: "str",
		enabled: Optional["bool"] = None,
	) -> None:
		"""
		:param unique_id:
		:type unique_id: str
		:param path:
		:type path: str
		:param attr:
		:type attr: str
		:param value:
		:type value: str
		:param enabled:
		:type enabled: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._unique_id = cast(str, kwargs.get("unique_id"))
		self._enabled = cast(Optional[bool], kwargs.get("enabled"))
		self._path = cast(str, kwargs.get("path"))
		self._attr = cast(str, kwargs.get("attr"))
		self._value = cast(str, kwargs.get("value"))
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
	@property
	def enabled(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def path(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._path
	@path.setter
	def path(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._path = value
	@property
	def attr(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._attr
	@attr.setter
	def attr(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._attr = value
	@property
	def value(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._value
	@value.setter
	def value(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._value = value
class StyleText:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"enabled": ("enabled", "bool", None),
		"text": ("text", "str", None),
		"max_width": ("maxWidth", "int", None),
		"min_zoom": ("minZoom", "float", None),
		"rotation_type": ("rotationType", "LabelRotationType", None),
		"rotation_lock": ("rotationLock", "LabelRotationLock", None),
		"rotation_angle": ("rotationAngle", "float", None),
		"no_overlap": ("noOverlap", "bool", None),
		"label_above_overlapping": ("labelAboveOverlapping", "str", None),
		"draw_label_text": ("drawLabelText", "bool", None),
		"line_join": ("lineJoin", "str", None),
		"display_non_printable_characters": ("displayNonPrintableCharacters", "bool", None),
		"background_padding_x": ("backgroundPaddingX", "float", None),
		"background_padding_y": ("backgroundPaddingY", "float", None),
		"background_corner_x": ("backgroundCornerX", "float", None),
		"background_corner_y": ("backgroundCornerY", "float", None),
		"color": ("color", "str", None),
		"back_color": ("backColor", "str", None),
		"background_color": ("backgroundColor", "str", None),
		"strike_through_color": ("strikeThroughColor", "str", None),
		"font_family": ("fontFamily", "str", None),
		"bold": ("bold", "bool", None),
		"italics": ("italics", "bool", None),
		"strike_through": ("strikeThrough", "bool", None),
		"size": ("size", "int", None),
		"strike_through_width": ("strikeThroughWidth", "int", None),
		"min_text_size": ("minTextSize", "float", None),
		"back_size": ("backSize", "float", None),
		"character_spacing": ("characterSpacing", "float", None),
		"poly_label_xoffset_percent": ("polyLabelXOffsetPercent", "int", None),
		"poly_label_yoffset_percent": ("polyLabelYOffsetPercent", "int", None),
		"draw_radius": ("drawRadius", "bool", None),
		"radius_angle": ("radiusAngle", "float", None),
		"draw_path": ("drawPath", "bool", None),
		"prefer_geo_centroid": ("preferGeoCentroid", "bool", None),
		"largest_bbox_only": ("largestBBoxOnly", "bool", None),
		"path_spacing": ("pathSpacing", "float", None),
		"path_max_angle": ("pathMaxAngle", "float", None),
		"path_max_bends": ("pathMaxBends", "int", None),
		"path_allow_flipped_text": ("pathAllowFlippedText", "bool", None),
		"path_reverse_valign": ("pathReverseVAlign", "bool", None),
		"path_no_wrap": ("pathNoWrap", "bool", None),
		"path_no_wrap_fit": ("pathNoWrapFit", "bool", None),
		"x": ("x", "int", None),
		"y": ("y", "int", None),
		"wrap_type": ("wrapType", "LabelWrapType", None),
		"line_spacing": ("lineSpacing", "float", None),
		"halign": ("hAlign", "HAlign", None),
		"valign": ("vAlign", "VAlign", None),
		"hposition": ("hPosition", "HAlign", None),
		"vposition": ("vPosition", "VAlign", None),
		"fit_mode": ("fitMode", "LabelFitMode", None),
		"clipping_tolerance": ("clippingTolerance", "float", None),
		"fit_text_content": ("fitTextContent", "str", None),
		"draw_fit_text": ("drawFitText", "bool", None),
		"unique_id": ("UniqueId", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		text: "str",
		display_non_printable_characters: "bool",
		unique_id: "str",
		enabled: Optional["bool"] = None,
		max_width: Optional["int"] = None,
		min_zoom: Optional["float"] = None,
		rotation_type: Optional["LabelRotationType"] = None,
		rotation_lock: Optional["LabelRotationLock"] = None,
		rotation_angle: Optional["float"] = None,
		no_overlap: Optional["bool"] = None,
		label_above_overlapping: Optional["str"] = None,
		draw_label_text: Optional["bool"] = None,
		line_join: Optional["str"] = None,
		background_padding_x: Optional["float"] = None,
		background_padding_y: Optional["float"] = None,
		background_corner_x: Optional["float"] = None,
		background_corner_y: Optional["float"] = None,
		color: Optional["str"] = None,
		back_color: Optional["str"] = None,
		background_color: Optional["str"] = None,
		strike_through_color: Optional["str"] = None,
		font_family: Optional["str"] = None,
		bold: Optional["bool"] = None,
		italics: Optional["bool"] = None,
		strike_through: Optional["bool"] = None,
		size: Optional["int"] = None,
		strike_through_width: Optional["int"] = None,
		min_text_size: Optional["float"] = None,
		back_size: Optional["float"] = None,
		character_spacing: Optional["float"] = None,
		poly_label_xoffset_percent: Optional["int"] = None,
		poly_label_yoffset_percent: Optional["int"] = None,
		draw_radius: Optional["bool"] = None,
		radius_angle: Optional["float"] = None,
		draw_path: Optional["bool"] = None,
		prefer_geo_centroid: Optional["bool"] = None,
		largest_bbox_only: Optional["bool"] = None,
		path_spacing: Optional["float"] = None,
		path_max_angle: Optional["float"] = None,
		path_max_bends: Optional["int"] = None,
		path_allow_flipped_text: Optional["bool"] = None,
		path_reverse_valign: Optional["bool"] = None,
		path_no_wrap: Optional["bool"] = None,
		path_no_wrap_fit: Optional["bool"] = None,
		x: Optional["int"] = None,
		y: Optional["int"] = None,
		wrap_type: Optional["LabelWrapType"] = None,
		line_spacing: Optional["float"] = None,
		halign: Optional["HAlign"] = None,
		valign: Optional["VAlign"] = None,
		hposition: Optional["HAlign"] = None,
		vposition: Optional["VAlign"] = None,
		fit_mode: Optional["LabelFitMode"] = None,
		clipping_tolerance: Optional["float"] = None,
		fit_text_content: Optional["str"] = None,
		draw_fit_text: Optional["bool"] = None,
	) -> None:
		"""
		:param text:
		:type text: str
		:param display_non_printable_characters:
		:type display_non_printable_characters: bool
		:param unique_id:
		:type unique_id: str
		:param enabled:
		:type enabled: bool or None
		:param max_width:
		:type max_width: int or None
		:param min_zoom:
		:type min_zoom: float or None
		:param rotation_type:
		:type rotation_type: LabelRotationType or None
		:param rotation_lock:
		:type rotation_lock: LabelRotationLock or None
		:param rotation_angle:
		:type rotation_angle: float or None
		:param no_overlap:
		:type no_overlap: bool or None
		:param label_above_overlapping:
		:type label_above_overlapping: str or None
		:param draw_label_text:
		:type draw_label_text: bool or None
		:param line_join:
		:type line_join: str or None
		:param background_padding_x:
		:type background_padding_x: float or None
		:param background_padding_y:
		:type background_padding_y: float or None
		:param background_corner_x:
		:type background_corner_x: float or None
		:param background_corner_y:
		:type background_corner_y: float or None
		:param color: The color of the text. Defaults to white.
		:type color: str or None
		:param back_color: The color to draw beneath the text. Can be useful if the text foreground color is semitransparent. Defaults to transparent.
		:type back_color: str or None
		:param background_color: The color of the rectangular background behind the text. Defaults to transparent.
		:type background_color: str or None
		:param strike_through_color: The color of the strike through line over the text. Defaults to black.
		:type strike_through_color: str or None
		:param font_family: The font. Defaults to a sans-serif font.
		:type font_family: str or None
		:param bold:
		:type bold: bool or None
		:param italics:
		:type italics: bool or None
		:param strike_through:
		:type strike_through: bool or None
		:param size: The font size in pixels. Defaults to 12.
		:type size: int or None
		:param strike_through_width: The width of the strike through line in pixels. Defaults to 1.
		:type strike_through_width: int or None
		:param min_text_size: The minimum font size when ClippingShrink is applied, no less than 6.
		:type min_text_size: float or None
		:param back_size:
		:type back_size: float or None
		:param character_spacing:
		:type character_spacing: float or None
		:param poly_label_xoffset_percent:
		:type poly_label_xoffset_percent: int or None
		:param poly_label_yoffset_percent:
		:type poly_label_yoffset_percent: int or None
		:param draw_radius:
		:type draw_radius: bool or None
		:param radius_angle:
		:type radius_angle: float or None
		:param draw_path:
		:type draw_path: bool or None
		:param prefer_geo_centroid:
		:type prefer_geo_centroid: bool or None
		:param largest_bbox_only:
		:type largest_bbox_only: bool or None
		:param path_spacing:
		:type path_spacing: float or None
		:param path_max_angle:
		:type path_max_angle: float or None
		:param path_max_bends:
		:type path_max_bends: int or None
		:param path_allow_flipped_text:
		:type path_allow_flipped_text: bool or None
		:param path_reverse_valign:
		:type path_reverse_valign: bool or None
		:param path_no_wrap:
		:type path_no_wrap: bool or None
		:param path_no_wrap_fit:
		:type path_no_wrap_fit: bool or None
		:param x:
		:type x: int or None
		:param y:
		:type y: int or None
		:param wrap_type:
		:type wrap_type: LabelWrapType or None
		:param line_spacing:
		:type line_spacing: float or None
		:param halign:
		:type halign: HAlign or None
		:param valign:
		:type valign: VAlign or None
		:param hposition:
		:type hposition: HAlign or None
		:param vposition:
		:type vposition: VAlign or None
		:param fit_mode:
		:type fit_mode: LabelFitMode or None
		:param clipping_tolerance:
		:type clipping_tolerance: float or None
		:param fit_text_content:
		:type fit_text_content: str or None
		:param draw_fit_text:
		:type draw_fit_text: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._enabled = cast(Optional[bool], kwargs.get("enabled"))
		self._text = cast(str, kwargs.get("text"))
		self._max_width = cast(Optional[int], kwargs.get("max_width"))
		self._min_zoom = cast(Optional[float], kwargs.get("min_zoom"))
		self._rotation_type = cast(Optional[LabelRotationType], kwargs.get("rotation_type"))
		self._rotation_lock = cast(Optional[LabelRotationLock], kwargs.get("rotation_lock"))
		self._rotation_angle = cast(Optional[float], kwargs.get("rotation_angle"))
		self._no_overlap = cast(Optional[bool], kwargs.get("no_overlap"))
		self._label_above_overlapping = cast(Optional[str], kwargs.get("label_above_overlapping"))
		self._draw_label_text = cast(Optional[bool], kwargs.get("draw_label_text"))
		self._line_join = cast(Optional[str], kwargs.get("line_join"))
		self._display_non_printable_characters = cast(bool, kwargs.get("display_non_printable_characters"))
		self._background_padding_x = cast(Optional[float], kwargs.get("background_padding_x"))
		self._background_padding_y = cast(Optional[float], kwargs.get("background_padding_y"))
		self._background_corner_x = cast(Optional[float], kwargs.get("background_corner_x"))
		self._background_corner_y = cast(Optional[float], kwargs.get("background_corner_y"))
		self._color = cast(Optional[str], kwargs.get("color"))
		self._back_color = cast(Optional[str], kwargs.get("back_color"))
		self._background_color = cast(Optional[str], kwargs.get("background_color"))
		self._strike_through_color = cast(Optional[str], kwargs.get("strike_through_color"))
		self._font_family = cast(Optional[str], kwargs.get("font_family"))
		self._bold = cast(Optional[bool], kwargs.get("bold"))
		self._italics = cast(Optional[bool], kwargs.get("italics"))
		self._strike_through = cast(Optional[bool], kwargs.get("strike_through"))
		self._size = cast(Optional[int], kwargs.get("size"))
		self._strike_through_width = cast(Optional[int], kwargs.get("strike_through_width"))
		self._min_text_size = cast(Optional[float], kwargs.get("min_text_size"))
		self._back_size = cast(Optional[float], kwargs.get("back_size"))
		self._character_spacing = cast(Optional[float], kwargs.get("character_spacing"))
		self._poly_label_xoffset_percent = cast(Optional[int], kwargs.get("poly_label_xoffset_percent"))
		self._poly_label_yoffset_percent = cast(Optional[int], kwargs.get("poly_label_yoffset_percent"))
		self._draw_radius = cast(Optional[bool], kwargs.get("draw_radius"))
		self._radius_angle = cast(Optional[float], kwargs.get("radius_angle"))
		self._draw_path = cast(Optional[bool], kwargs.get("draw_path"))
		self._prefer_geo_centroid = cast(Optional[bool], kwargs.get("prefer_geo_centroid"))
		self._largest_bbox_only = cast(Optional[bool], kwargs.get("largest_bbox_only"))
		self._path_spacing = cast(Optional[float], kwargs.get("path_spacing"))
		self._path_max_angle = cast(Optional[float], kwargs.get("path_max_angle"))
		self._path_max_bends = cast(Optional[int], kwargs.get("path_max_bends"))
		self._path_allow_flipped_text = cast(Optional[bool], kwargs.get("path_allow_flipped_text"))
		self._path_reverse_valign = cast(Optional[bool], kwargs.get("path_reverse_valign"))
		self._path_no_wrap = cast(Optional[bool], kwargs.get("path_no_wrap"))
		self._path_no_wrap_fit = cast(Optional[bool], kwargs.get("path_no_wrap_fit"))
		self._x = cast(Optional[int], kwargs.get("x"))
		self._y = cast(Optional[int], kwargs.get("y"))
		self._wrap_type = cast(Optional[LabelWrapType], kwargs.get("wrap_type"))
		self._line_spacing = cast(Optional[float], kwargs.get("line_spacing"))
		self._halign = cast(Optional[HAlign], kwargs.get("halign"))
		self._valign = cast(Optional[VAlign], kwargs.get("valign"))
		self._hposition = cast(Optional[HAlign], kwargs.get("hposition"))
		self._vposition = cast(Optional[VAlign], kwargs.get("vposition"))
		self._fit_mode = cast(Optional[LabelFitMode], kwargs.get("fit_mode"))
		self._clipping_tolerance = cast(Optional[float], kwargs.get("clipping_tolerance"))
		self._fit_text_content = cast(Optional[str], kwargs.get("fit_text_content"))
		self._draw_fit_text = cast(Optional[bool], kwargs.get("draw_fit_text"))
		self._unique_id = cast(str, kwargs.get("unique_id"))
	@property
	def enabled(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def text(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._text
	@text.setter
	def text(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._text = value
	@property
	def max_width(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._max_width
	@max_width.setter
	def max_width(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._max_width = value
	@property
	def min_zoom(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._min_zoom
	@min_zoom.setter
	def min_zoom(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._min_zoom = value
	@property
	def rotation_type(self) -> Optional["LabelRotationType"]:
		# pylint: disable=missing-function-docstring
		return self._rotation_type
	@rotation_type.setter
	def rotation_type(self, value: Optional["LabelRotationType"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rotation_type = value
	@property
	def rotation_lock(self) -> Optional["LabelRotationLock"]:
		# pylint: disable=missing-function-docstring
		return self._rotation_lock
	@rotation_lock.setter
	def rotation_lock(self, value: Optional["LabelRotationLock"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rotation_lock = value
	@property
	def rotation_angle(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._rotation_angle
	@rotation_angle.setter
	def rotation_angle(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._rotation_angle = value
	@property
	def no_overlap(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._no_overlap
	@no_overlap.setter
	def no_overlap(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._no_overlap = value
	@property
	def label_above_overlapping(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._label_above_overlapping
	@label_above_overlapping.setter
	def label_above_overlapping(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._label_above_overlapping = value
	@property
	def draw_label_text(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._draw_label_text
	@draw_label_text.setter
	def draw_label_text(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._draw_label_text = value
	@property
	def line_join(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._line_join
	@line_join.setter
	def line_join(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._line_join = value
	@property
	def display_non_printable_characters(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._display_non_printable_characters
	@display_non_printable_characters.setter
	def display_non_printable_characters(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._display_non_printable_characters = value
	@property
	def background_padding_x(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._background_padding_x
	@background_padding_x.setter
	def background_padding_x(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._background_padding_x = value
	@property
	def background_padding_y(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._background_padding_y
	@background_padding_y.setter
	def background_padding_y(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._background_padding_y = value
	@property
	def background_corner_x(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._background_corner_x
	@background_corner_x.setter
	def background_corner_x(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._background_corner_x = value
	@property
	def background_corner_y(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._background_corner_y
	@background_corner_y.setter
	def background_corner_y(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._background_corner_y = value
	@property
	def color(self) -> Optional["str"]:
		"""The color of the text. Defaults to white."""
		return self._color
	@color.setter
	def color(self, value: Optional["str"]) -> None:
		"""The color of the text. Defaults to white."""
		self._color = value
	@property
	def back_color(self) -> Optional["str"]:
		"""The color to draw beneath the text. Can be useful if the text foreground color is semitransparent. Defaults to transparent."""
		return self._back_color
	@back_color.setter
	def back_color(self, value: Optional["str"]) -> None:
		"""The color to draw beneath the text. Can be useful if the text foreground color is semitransparent. Defaults to transparent."""
		self._back_color = value
	@property
	def background_color(self) -> Optional["str"]:
		"""The color of the rectangular background behind the text. Defaults to transparent."""
		return self._background_color
	@background_color.setter
	def background_color(self, value: Optional["str"]) -> None:
		"""The color of the rectangular background behind the text. Defaults to transparent."""
		self._background_color = value
	@property
	def strike_through_color(self) -> Optional["str"]:
		"""The color of the strike through line over the text. Defaults to black."""
		return self._strike_through_color
	@strike_through_color.setter
	def strike_through_color(self, value: Optional["str"]) -> None:
		"""The color of the strike through line over the text. Defaults to black."""
		self._strike_through_color = value
	@property
	def font_family(self) -> Optional["str"]:
		"""The font. Defaults to a sans-serif font."""
		return self._font_family
	@font_family.setter
	def font_family(self, value: Optional["str"]) -> None:
		"""The font. Defaults to a sans-serif font."""
		self._font_family = value
	@property
	def bold(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._bold
	@bold.setter
	def bold(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._bold = value
	@property
	def italics(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._italics
	@italics.setter
	def italics(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._italics = value
	@property
	def strike_through(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._strike_through
	@strike_through.setter
	def strike_through(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._strike_through = value
	@property
	def size(self) -> Optional["int"]:
		"""The font size in pixels. Defaults to 12."""
		return self._size
	@size.setter
	def size(self, value: Optional["int"]) -> None:
		"""The font size in pixels. Defaults to 12."""
		self._size = value
	@property
	def strike_through_width(self) -> Optional["int"]:
		"""The width of the strike through line in pixels. Defaults to 1."""
		return self._strike_through_width
	@strike_through_width.setter
	def strike_through_width(self, value: Optional["int"]) -> None:
		"""The width of the strike through line in pixels. Defaults to 1."""
		self._strike_through_width = value
	@property
	def min_text_size(self) -> Optional["float"]:
		"""The minimum font size when ClippingShrink is applied, no less than 6."""
		return self._min_text_size
	@min_text_size.setter
	def min_text_size(self, value: Optional["float"]) -> None:
		"""The minimum font size when ClippingShrink is applied, no less than 6."""
		self._min_text_size = value
	@property
	def back_size(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._back_size
	@back_size.setter
	def back_size(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._back_size = value
	@property
	def character_spacing(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._character_spacing
	@character_spacing.setter
	def character_spacing(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._character_spacing = value
	@property
	def poly_label_xoffset_percent(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._poly_label_xoffset_percent
	@poly_label_xoffset_percent.setter
	def poly_label_xoffset_percent(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._poly_label_xoffset_percent = value
	@property
	def poly_label_yoffset_percent(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._poly_label_yoffset_percent
	@poly_label_yoffset_percent.setter
	def poly_label_yoffset_percent(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._poly_label_yoffset_percent = value
	@property
	def draw_radius(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._draw_radius
	@draw_radius.setter
	def draw_radius(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._draw_radius = value
	@property
	def radius_angle(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._radius_angle
	@radius_angle.setter
	def radius_angle(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._radius_angle = value
	@property
	def draw_path(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._draw_path
	@draw_path.setter
	def draw_path(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._draw_path = value
	@property
	def prefer_geo_centroid(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._prefer_geo_centroid
	@prefer_geo_centroid.setter
	def prefer_geo_centroid(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._prefer_geo_centroid = value
	@property
	def largest_bbox_only(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._largest_bbox_only
	@largest_bbox_only.setter
	def largest_bbox_only(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._largest_bbox_only = value
	@property
	def path_spacing(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._path_spacing
	@path_spacing.setter
	def path_spacing(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path_spacing = value
	@property
	def path_max_angle(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._path_max_angle
	@path_max_angle.setter
	def path_max_angle(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path_max_angle = value
	@property
	def path_max_bends(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._path_max_bends
	@path_max_bends.setter
	def path_max_bends(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path_max_bends = value
	@property
	def path_allow_flipped_text(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._path_allow_flipped_text
	@path_allow_flipped_text.setter
	def path_allow_flipped_text(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path_allow_flipped_text = value
	@property
	def path_reverse_valign(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._path_reverse_valign
	@path_reverse_valign.setter
	def path_reverse_valign(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path_reverse_valign = value
	@property
	def path_no_wrap(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._path_no_wrap
	@path_no_wrap.setter
	def path_no_wrap(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path_no_wrap = value
	@property
	def path_no_wrap_fit(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._path_no_wrap_fit
	@path_no_wrap_fit.setter
	def path_no_wrap_fit(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path_no_wrap_fit = value
	@property
	def x(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._x
	@x.setter
	def x(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._x = value
	@property
	def y(self) -> Optional["int"]:
		# pylint: disable=missing-function-docstring
		return self._y
	@y.setter
	def y(self, value: Optional["int"]) -> None:
		# pylint: disable=missing-function-docstring
		self._y = value
	@property
	def wrap_type(self) -> Optional["LabelWrapType"]:
		# pylint: disable=missing-function-docstring
		return self._wrap_type
	@wrap_type.setter
	def wrap_type(self, value: Optional["LabelWrapType"]) -> None:
		# pylint: disable=missing-function-docstring
		self._wrap_type = value
	@property
	def line_spacing(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._line_spacing
	@line_spacing.setter
	def line_spacing(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._line_spacing = value
	@property
	def halign(self) -> Optional["HAlign"]:
		# pylint: disable=missing-function-docstring
		return self._halign
	@halign.setter
	def halign(self, value: Optional["HAlign"]) -> None:
		# pylint: disable=missing-function-docstring
		self._halign = value
	@property
	def valign(self) -> Optional["VAlign"]:
		# pylint: disable=missing-function-docstring
		return self._valign
	@valign.setter
	def valign(self, value: Optional["VAlign"]) -> None:
		# pylint: disable=missing-function-docstring
		self._valign = value
	@property
	def hposition(self) -> Optional["HAlign"]:
		# pylint: disable=missing-function-docstring
		return self._hposition
	@hposition.setter
	def hposition(self, value: Optional["HAlign"]) -> None:
		# pylint: disable=missing-function-docstring
		self._hposition = value
	@property
	def vposition(self) -> Optional["VAlign"]:
		# pylint: disable=missing-function-docstring
		return self._vposition
	@vposition.setter
	def vposition(self, value: Optional["VAlign"]) -> None:
		# pylint: disable=missing-function-docstring
		self._vposition = value
	@property
	def fit_mode(self) -> Optional["LabelFitMode"]:
		# pylint: disable=missing-function-docstring
		return self._fit_mode
	@fit_mode.setter
	def fit_mode(self, value: Optional["LabelFitMode"]) -> None:
		# pylint: disable=missing-function-docstring
		self._fit_mode = value
	@property
	def clipping_tolerance(self) -> Optional["float"]:
		# pylint: disable=missing-function-docstring
		return self._clipping_tolerance
	@clipping_tolerance.setter
	def clipping_tolerance(self, value: Optional["float"]) -> None:
		# pylint: disable=missing-function-docstring
		self._clipping_tolerance = value
	@property
	def fit_text_content(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._fit_text_content
	@fit_text_content.setter
	def fit_text_content(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._fit_text_content = value
	@property
	def draw_fit_text(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._draw_fit_text
	@draw_fit_text.setter
	def draw_fit_text(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._draw_fit_text = value
	@property
	def unique_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._unique_id = value
class StyleWaterMark:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"enabled": ("enabled", "bool", None),
		"tag": ("tag", "str", None),
		"uri": ("uri", "str", None),
		"width": ("width", "int", None),
		"height": ("height", "int", None),
		"x": ("x", "int", None),
		"y": ("y", "int", None),
		"opacity": ("opacity", "float", None),
		"tiled": ("tiled", "bool", None),
		"has_text": ("hasText", "bool", None),
		"has_uri": ("hasUri", "bool", None),
		"text": ("text", "StyleText", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		x: "int",
		y: "int",
		opacity: "float",
		tiled: "bool",
		has_text: "bool",
		has_uri: "bool",
		text: "StyleText",
		enabled: Optional["bool"] = None,
		tag: Optional["str"] = None,
		uri: Optional["str"] = None,
		width: Optional["int"] = None,
		height: Optional["int"] = None,
	) -> None:
		"""
		:param x: Watermark x position within the tile.
		:type x: int
		:param y: Watermark y position within the tile.
		:type y: int
		:param opacity: Watermark opacity value in percent, converted to int
		:type opacity: float
		:param tiled: Watermark is drawn with a tiling effect
		:type tiled: bool
		:param has_text:
		:type has_text: bool
		:param has_uri:
		:type has_uri: bool
		:param text: Text to be displayed as a watermark.  This is only used if there is no URI.
		:type text: StyleText
		:param enabled:
		:type enabled: bool or None
		:param tag:
		:type tag: str or None
		:param uri: Uri of the waterMark image.
		:type uri: str or None
		:param width: Watermark width
		:type width: int or None
		:param height: Watermark height
		:type height: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._enabled = cast(Optional[bool], kwargs.get("enabled"))
		self._tag = cast(Optional[str], kwargs.get("tag"))
		self._uri = cast(Optional[str], kwargs.get("uri"))
		self._width = cast(Optional[int], kwargs.get("width"))
		self._height = cast(Optional[int], kwargs.get("height"))
		self._x = cast(int, kwargs.get("x"))
		self._y = cast(int, kwargs.get("y"))
		self._opacity = cast(float, kwargs.get("opacity"))
		self._tiled = cast(bool, kwargs.get("tiled"))
		self._has_text = cast(bool, kwargs.get("has_text"))
		self._has_uri = cast(bool, kwargs.get("has_uri"))
		self._text = cast(StyleText, kwargs.get("text"))
	@property
	def enabled(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def tag(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._tag
	@tag.setter
	def tag(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._tag = value
	@property
	def uri(self) -> Optional["str"]:
		"""Uri of the waterMark image."""
		return self._uri
	@uri.setter
	def uri(self, value: Optional["str"]) -> None:
		"""Uri of the waterMark image."""
		self._uri = value
	@property
	def width(self) -> Optional["int"]:
		"""Watermark width"""
		return self._width
	@width.setter
	def width(self, value: Optional["int"]) -> None:
		"""Watermark width"""
		self._width = value
	@property
	def height(self) -> Optional["int"]:
		"""Watermark height"""
		return self._height
	@height.setter
	def height(self, value: Optional["int"]) -> None:
		"""Watermark height"""
		self._height = value
	@property
	def x(self) -> "int":
		"""Watermark x position within the tile."""
		return self._x
	@x.setter
	def x(self, value: "int") -> None:
		"""Watermark x position within the tile."""
		self._x = value
	@property
	def y(self) -> "int":
		"""Watermark y position within the tile."""
		return self._y
	@y.setter
	def y(self, value: "int") -> None:
		"""Watermark y position within the tile."""
		self._y = value
	@property
	def opacity(self) -> "float":
		"""Watermark opacity value in percent, converted to int"""
		return self._opacity
	@opacity.setter
	def opacity(self, value: "float") -> None:
		"""Watermark opacity value in percent, converted to int"""
		self._opacity = value
	@property
	def tiled(self) -> "bool":
		"""Watermark is drawn with a tiling effect"""
		return self._tiled
	@tiled.setter
	def tiled(self, value: "bool") -> None:
		"""Watermark is drawn with a tiling effect"""
		self._tiled = value
	@property
	def has_text(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._has_text
	@has_text.setter
	def has_text(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._has_text = value
	@property
	def has_uri(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._has_uri
	@has_uri.setter
	def has_uri(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._has_uri = value
	@property
	def text(self) -> "StyleText":
		"""Text to be displayed as a watermark.  This is only used if there is no URI."""
		return self._text
	@text.setter
	def text(self, value: "StyleText") -> None:
		"""Text to be displayed as a watermark.  This is only used if there is no URI."""
		self._text = value
class SyncedAccountPair:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"server": ("server", "CentralServerReference", None),
		"sync_mode": ("syncMode", "list", "SyncModeEnum"),
		"status": ("status", "str", None),
		"last_process_time": ("lastProcessTime", "datetime", None),
		"process_interval": ("processInterval", "str", None),
		"central_account": ("centralAccount", "str", None),
		"edge_account": ("edgeAccount", "str", None),
		"transfer_table_index_information": ("transferTableIndexInformation", "bool", None),
		"transfer_table_strictness": ("transferTableStrictness", "bool", None),
		"links": ("_links", "SyncedAccountPairLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
		server: "CentralServerReference",
		sync_mode: "SyncMode",
		transfer_table_index_information: "bool",
		transfer_table_strictness: "bool",
		links: "SyncedAccountPairLinks",
		status: Optional["str"] = None,
		last_process_time: Optional["datetime"] = None,
		process_interval: Optional["str"] = None,
		central_account: Optional["str"] = None,
		edge_account: Optional["str"] = None,
	) -> None:
		"""
		:param id_: Guid that uniquely identifies this account pair.
		:type id_: str
		:param server: Reference to the central (remote) server record.
		:type server: CentralServerReference
		:param sync_mode:
		:type sync_mode: SyncMode
		:param transfer_table_index_information: Determines if index information is transferred between Edge and Central server.
		:type transfer_table_index_information: bool
		:param transfer_table_strictness: Determines if schema strictness is transferred between Edge and Central server.
		:type transfer_table_strictness: bool
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: SyncedAccountPairLinks
		:param status: Status message from last time the pair was processed.
		:type status: str or None
		:param last_process_time: The last time this pair was evaluated regardless of if action was taken.
		:type last_process_time: datetime or None
		:param process_interval: The amount of time between processing. The system default value will be used if not specified.
		:type process_interval: str or None
		:param central_account:
		:type central_account: str or None
		:param edge_account:
		:type edge_account: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
		self._server = cast(CentralServerReference, kwargs.get("server"))
		self._sync_mode = cast(SyncMode, kwargs.get("sync_mode"))
		self._status = cast(Optional[str], kwargs.get("status"))
		self._last_process_time = cast(Optional[datetime], kwargs.get("last_process_time"))
		self._process_interval = cast(Optional[str], kwargs.get("process_interval"))
		self._central_account = cast(Optional[str], kwargs.get("central_account"))
		self._edge_account = cast(Optional[str], kwargs.get("edge_account"))
		self._transfer_table_index_information = cast(bool, kwargs.get("transfer_table_index_information"))
		self._transfer_table_strictness = cast(bool, kwargs.get("transfer_table_strictness"))
		self._links = cast(SyncedAccountPairLinks, kwargs.get("links"))
	@property
	def id_(self) -> "str":
		"""Guid that uniquely identifies this account pair."""
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		"""Guid that uniquely identifies this account pair."""
		self._id_ = value
	@property
	def server(self) -> "CentralServerReference":
		"""Reference to the central (remote) server record."""
		return self._server
	@server.setter
	def server(self, value: "CentralServerReference") -> None:
		"""Reference to the central (remote) server record."""
		self._server = value
	@property
	def sync_mode(self) -> "SyncMode":
		# pylint: disable=missing-function-docstring
		return self._sync_mode
	@sync_mode.setter
	def sync_mode(self, value: "SyncMode") -> None:
		# pylint: disable=missing-function-docstring
		self._sync_mode = value
	@property
	def status(self) -> Optional["str"]:
		"""Status message from last time the pair was processed."""
		return self._status
	@status.setter
	def status(self, value: Optional["str"]) -> None:
		"""Status message from last time the pair was processed."""
		self._status = value
	@property
	def last_process_time(self) -> Optional["datetime"]:
		"""The last time this pair was evaluated regardless of if action was taken."""
		return self._last_process_time
	@last_process_time.setter
	def last_process_time(self, value: Optional["datetime"]) -> None:
		"""The last time this pair was evaluated regardless of if action was taken."""
		self._last_process_time = value
	@property
	def process_interval(self) -> Optional["str"]:
		"""The amount of time between processing. The system default value will be used if not specified."""
		return self._process_interval
	@process_interval.setter
	def process_interval(self, value: Optional["str"]) -> None:
		"""The amount of time between processing. The system default value will be used if not specified."""
		self._process_interval = value
	@property
	def central_account(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._central_account
	@central_account.setter
	def central_account(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._central_account = value
	@property
	def edge_account(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._edge_account
	@edge_account.setter
	def edge_account(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._edge_account = value
	@property
	def transfer_table_index_information(self) -> "bool":
		"""Determines if index information is transferred between Edge and Central server."""
		return self._transfer_table_index_information
	@transfer_table_index_information.setter
	def transfer_table_index_information(self, value: "bool") -> None:
		"""Determines if index information is transferred between Edge and Central server."""
		self._transfer_table_index_information = value
	@property
	def transfer_table_strictness(self) -> "bool":
		"""Determines if schema strictness is transferred between Edge and Central server."""
		return self._transfer_table_strictness
	@transfer_table_strictness.setter
	def transfer_table_strictness(self, value: "bool") -> None:
		"""Determines if schema strictness is transferred between Edge and Central server."""
		self._transfer_table_strictness = value
	@property
	def links(self) -> "SyncedAccountPairLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "SyncedAccountPairLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class SyncedAccountPairLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"server": ("server", "Link", None),
		"edge_account": ("edgeAccount", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		server: "Link",
		edge_account: "Link",
		self_: "Link",
	) -> None:
		"""
		:param server: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type server: Link
		:param edge_account: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type edge_account: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._server = cast(Link, kwargs.get("server"))
		self._edge_account = cast(Link, kwargs.get("edge_account"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def server(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._server
	@server.setter
	def server(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._server = value
	@property
	def edge_account(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._edge_account
	@edge_account.setter
	def edge_account(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._edge_account = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class SyncedTablePair:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "str", None),
		"server": ("server", "CentralServerReference", None),
		"sync_mode": ("syncMode", "list", "SyncModeEnum"),
		"priority": ("priority", "int", None),
		"status": ("status", "str", None),
		"last_sync": ("lastSync", "datetime", None),
		"last_process_time": ("lastProcessTime", "datetime", None),
		"process_interval": ("processInterval", "str", None),
		"filter_": ("filter", "QueryWhere", None),
		"push_filter": ("pushFilter", "QueryWhere", None),
		"tags_to_ignore": ("tagsToIgnore", "list", "str"),
		"central_table": ("centralTable", "TableReference", None),
		"central_table_sync_info": ("centralTableSyncInfo", "TableSyncInfo", None),
		"edge_table": ("edgeTable", "TableReference", None),
		"edge_table_sync_info": ("edgeTableSyncInfo", "TableSyncInfo", None),
		"transfer_index_information": ("transferIndexInformation", "bool", None),
		"transfer_strictness": ("transferStrictness", "bool", None),
		"links": ("_links", "SyncedTablePairLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		server: "CentralServerReference",
		sync_mode: "SyncMode",
		tags_to_ignore: "List[str]",
		central_table: "TableReference",
		central_table_sync_info: "TableSyncInfo",
		edge_table: "TableReference",
		edge_table_sync_info: "TableSyncInfo",
		links: "SyncedTablePairLinks",
		id_: Optional["str"] = None,
		priority: Optional["int"] = None,
		status: Optional["str"] = None,
		last_sync: Optional["datetime"] = None,
		last_process_time: Optional["datetime"] = None,
		process_interval: Optional["str"] = None,
		filter_: Optional["QueryWhere"] = None,
		push_filter: Optional["QueryWhere"] = None,
		transfer_index_information: Optional["bool"] = None,
		transfer_strictness: Optional["bool"] = None,
	) -> None:
		"""
		:param server: Reference to the central (remote) server record.
		:type server: CentralServerReference
		:param sync_mode:
		:type sync_mode: SyncMode
		:param tags_to_ignore: List of keys of table tags that the edge (local) server will not push to the central (remote) server and not process if pulled from the central server.
		:type tags_to_ignore: List[str]
		:param central_table: Table on the central (remote) server.
		:type central_table: TableReference
		:param central_table_sync_info: Information about the synchronization status of the table on the central (remote) server.
		:type central_table_sync_info: TableSyncInfo
		:param edge_table: Table on the edge (local) server.
		:type edge_table: TableReference
		:param edge_table_sync_info: Information about the synchronization status of the table on the edge (local) server.
		:type edge_table_sync_info: TableSyncInfo
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: SyncedTablePairLinks
		:param id_: Guid that uniquely identifies this table pair. Null if not set.
		:type id_: str or None
		:param priority: The relative priority of this pair. Lower priority items will wait for higher priority items. Default is 0.
		:type priority: int or None
		:param status: Status message from last time the pair was processed.
		:type status: str or None
		:param last_sync: Last time this pair did a pull or push.
		:type last_sync: datetime or None
		:param last_process_time: The last time this pair was evaluated regardless of if action was taken.
		:type last_process_time: datetime or None
		:param process_interval: The amount of time between processing. The system default value will be used if not specified.
		:type process_interval: str or None
		:param filter_: Filters what data is synchronized between Central (remote) and Edge (local) server.
		:type filter_: QueryWhere or None
		:param push_filter: Filters what data is synchronized between Edge (local) and Central (remote) server.
		:type push_filter: QueryWhere or None
		:param transfer_index_information: Determines if index information is transferred between Edge and Central server.
		:type transfer_index_information: bool or None
		:param transfer_strictness: Determines if schema strictness is transferred between Edge and Central server.
		:type transfer_strictness: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(Optional[str], kwargs.get("id_"))
		self._server = cast(CentralServerReference, kwargs.get("server"))
		self._sync_mode = cast(SyncMode, kwargs.get("sync_mode"))
		self._priority = cast(Optional[int], kwargs.get("priority"))
		self._status = cast(Optional[str], kwargs.get("status"))
		self._last_sync = cast(Optional[datetime], kwargs.get("last_sync"))
		self._last_process_time = cast(Optional[datetime], kwargs.get("last_process_time"))
		self._process_interval = cast(Optional[str], kwargs.get("process_interval"))
		self._filter_ = cast(Optional[QueryWhere], kwargs.get("filter_"))
		self._push_filter = cast(Optional[QueryWhere], kwargs.get("push_filter"))
		self._tags_to_ignore = cast(List[str], kwargs.get("tags_to_ignore"))
		self._central_table = cast(TableReference, kwargs.get("central_table"))
		self._central_table_sync_info = cast(TableSyncInfo, kwargs.get("central_table_sync_info"))
		self._edge_table = cast(TableReference, kwargs.get("edge_table"))
		self._edge_table_sync_info = cast(TableSyncInfo, kwargs.get("edge_table_sync_info"))
		self._transfer_index_information = cast(Optional[bool], kwargs.get("transfer_index_information"))
		self._transfer_strictness = cast(Optional[bool], kwargs.get("transfer_strictness"))
		self._links = cast(SyncedTablePairLinks, kwargs.get("links"))
	@property
	def id_(self) -> Optional["str"]:
		"""Guid that uniquely identifies this table pair. Null if not set."""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		"""Guid that uniquely identifies this table pair. Null if not set."""
		self._id_ = value
	@property
	def server(self) -> "CentralServerReference":
		"""Reference to the central (remote) server record."""
		return self._server
	@server.setter
	def server(self, value: "CentralServerReference") -> None:
		"""Reference to the central (remote) server record."""
		self._server = value
	@property
	def sync_mode(self) -> "SyncMode":
		# pylint: disable=missing-function-docstring
		return self._sync_mode
	@sync_mode.setter
	def sync_mode(self, value: "SyncMode") -> None:
		# pylint: disable=missing-function-docstring
		self._sync_mode = value
	@property
	def priority(self) -> Optional["int"]:
		"""The relative priority of this pair. Lower priority items will wait for higher priority items. Default is 0."""
		return self._priority
	@priority.setter
	def priority(self, value: Optional["int"]) -> None:
		"""The relative priority of this pair. Lower priority items will wait for higher priority items. Default is 0."""
		self._priority = value
	@property
	def status(self) -> Optional["str"]:
		"""Status message from last time the pair was processed."""
		return self._status
	@status.setter
	def status(self, value: Optional["str"]) -> None:
		"""Status message from last time the pair was processed."""
		self._status = value
	@property
	def last_sync(self) -> Optional["datetime"]:
		"""Last time this pair did a pull or push."""
		return self._last_sync
	@last_sync.setter
	def last_sync(self, value: Optional["datetime"]) -> None:
		"""Last time this pair did a pull or push."""
		self._last_sync = value
	@property
	def last_process_time(self) -> Optional["datetime"]:
		"""The last time this pair was evaluated regardless of if action was taken."""
		return self._last_process_time
	@last_process_time.setter
	def last_process_time(self, value: Optional["datetime"]) -> None:
		"""The last time this pair was evaluated regardless of if action was taken."""
		self._last_process_time = value
	@property
	def process_interval(self) -> Optional["str"]:
		"""The amount of time between processing. The system default value will be used if not specified."""
		return self._process_interval
	@process_interval.setter
	def process_interval(self, value: Optional["str"]) -> None:
		"""The amount of time between processing. The system default value will be used if not specified."""
		self._process_interval = value
	@property
	def filter_(self) -> Optional["QueryWhere"]:
		"""Filters what data is synchronized between Central (remote) and Edge (local) server."""
		return self._filter_
	@filter_.setter
	def filter_(self, value: Optional["QueryWhere"]) -> None:
		"""Filters what data is synchronized between Central (remote) and Edge (local) server."""
		self._filter_ = value
	@property
	def push_filter(self) -> Optional["QueryWhere"]:
		"""Filters what data is synchronized between Edge (local) and Central (remote) server."""
		return self._push_filter
	@push_filter.setter
	def push_filter(self, value: Optional["QueryWhere"]) -> None:
		"""Filters what data is synchronized between Edge (local) and Central (remote) server."""
		self._push_filter = value
	@property
	def tags_to_ignore(self) -> "List[str]":
		"""List of keys of table tags that the edge (local) server will not push to the central (remote) server and not process if pulled from the central server."""
		return self._tags_to_ignore
	@tags_to_ignore.setter
	def tags_to_ignore(self, value: "List[str]") -> None:
		"""List of keys of table tags that the edge (local) server will not push to the central (remote) server and not process if pulled from the central server."""
		self._tags_to_ignore = value
	@property
	def central_table(self) -> "TableReference":
		"""Table on the central (remote) server."""
		return self._central_table
	@central_table.setter
	def central_table(self, value: "TableReference") -> None:
		"""Table on the central (remote) server."""
		self._central_table = value
	@property
	def central_table_sync_info(self) -> "TableSyncInfo":
		"""Information about the synchronization status of the table on the central (remote) server."""
		return self._central_table_sync_info
	@central_table_sync_info.setter
	def central_table_sync_info(self, value: "TableSyncInfo") -> None:
		"""Information about the synchronization status of the table on the central (remote) server."""
		self._central_table_sync_info = value
	@property
	def edge_table(self) -> "TableReference":
		"""Table on the edge (local) server."""
		return self._edge_table
	@edge_table.setter
	def edge_table(self, value: "TableReference") -> None:
		"""Table on the edge (local) server."""
		self._edge_table = value
	@property
	def edge_table_sync_info(self) -> "TableSyncInfo":
		"""Information about the synchronization status of the table on the edge (local) server."""
		return self._edge_table_sync_info
	@edge_table_sync_info.setter
	def edge_table_sync_info(self, value: "TableSyncInfo") -> None:
		"""Information about the synchronization status of the table on the edge (local) server."""
		self._edge_table_sync_info = value
	@property
	def transfer_index_information(self) -> Optional["bool"]:
		"""Determines if index information is transferred between Edge and Central server."""
		return self._transfer_index_information
	@transfer_index_information.setter
	def transfer_index_information(self, value: Optional["bool"]) -> None:
		"""Determines if index information is transferred between Edge and Central server."""
		self._transfer_index_information = value
	@property
	def transfer_strictness(self) -> Optional["bool"]:
		"""Determines if schema strictness is transferred between Edge and Central server."""
		return self._transfer_strictness
	@transfer_strictness.setter
	def transfer_strictness(self, value: Optional["bool"]) -> None:
		"""Determines if schema strictness is transferred between Edge and Central server."""
		self._transfer_strictness = value
	@property
	def links(self) -> "SyncedTablePairLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "SyncedTablePairLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class SyncedTablePairLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"server": ("server", "Link", None),
		"edge_table": ("edgeTable", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		server: "Link",
		edge_table: "Link",
		self_: "Link",
	) -> None:
		"""
		:param server: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type server: Link
		:param edge_table: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type edge_table: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._server = cast(Link, kwargs.get("server"))
		self._edge_table = cast(Link, kwargs.get("edge_table"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def server(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._server
	@server.setter
	def server(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._server = value
	@property
	def edge_table(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._edge_table
	@edge_table.setter
	def edge_table(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._edge_table = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value





class SyncModeEnum(str, Enum):
	"""Sync behavior for this table pair."""
	NONE = 'None'
	PUSH = 'Push'
	PULL = 'Pull'
	FULL = 'Full'
	ONCE = 'Once'

SyncModeEnum.NONE.__doc__ = """Changes are not replicated, but the Edge (local) server retains a record of the Synced Table Pair."""
SyncModeEnum.PUSH.__doc__ = """Changes made on the Edge (local) server will be pushed to a table on the Central (remote) server, but changes will not flow the other way.  The Central server will end up with all the data the Edge server has, but possibly more if the table is also updated through some other mechanism."""
SyncModeEnum.PULL.__doc__ = """Changes made on the Central (remote) Server are pulled to a table on the Edge (local) server but changes made on the Edge do not get synchronized to the Central Server."""
SyncModeEnum.FULL.__doc__ = """ Changes made on the Edge (local) server are pushed to the Central (remote) server, and changes made on the Central server are pulled to the edge server.  The Central and Edge server will have the same data for this table."""

SyncMode = Iterable[SyncModeEnum]
class SyncSyncedTablePairRequest:
	"""Options that control how the sync is performed."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"reset_tracking": ("resetTracking", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		reset_tracking: Optional["bool"] = None,
	) -> None:
		"""
		:param reset_tracking: When true, ResetTracking will force a full resynchronization of the table pair.
		:type reset_tracking: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._reset_tracking = cast(Optional[bool], kwargs.get("reset_tracking"))
	@property
	def reset_tracking(self) -> Optional["bool"]:
		"""When true, ResetTracking will force a full resynchronization of the table pair."""
		return self._reset_tracking
	@reset_tracking.setter
	def reset_tracking(self, value: Optional["bool"]) -> None:
		"""When true, ResetTracking will force a full resynchronization of the table pair."""
		self._reset_tracking = value
class TableError:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"table_name": ("TableName", "str", None),
		"error_message": ("ErrorMessage", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		table_name: Optional["str"] = None,
		error_message: Optional["str"] = None,
	) -> None:
		"""
		:param table_name: The name of the table which failed to migrate, in account/table format.
		:type table_name: str or None
		:param error_message: The relevant error message for the migration failure.
		:type error_message: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._table_name = cast(Optional[str], kwargs.get("table_name"))
		self._error_message = cast(Optional[str], kwargs.get("error_message"))
	@property
	def table_name(self) -> Optional["str"]:
		"""The name of the table which failed to migrate, in account/table format."""
		return self._table_name
	@table_name.setter
	def table_name(self, value: Optional["str"]) -> None:
		"""The name of the table which failed to migrate, in account/table format."""
		self._table_name = value
	@property
	def error_message(self) -> Optional["str"]:
		"""The relevant error message for the migration failure."""
		return self._error_message
	@error_message.setter
	def error_message(self, value: Optional["str"]) -> None:
		"""The relevant error message for the migration failure."""
		self._error_message = value
class TableLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"versions": ("versions", "Link", None),
		"export": ("export", "Link", None),
		"tags": ("tags", "Link", None),
		"indexes": ("indexes", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		versions: "Link",
		export: "Link",
		tags: "Link",
		indexes: "Link",
		self_: "Link",
	) -> None:
		"""
		:param versions: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type versions: Link
		:param export: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type export: Link
		:param tags: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type tags: Link
		:param indexes: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type indexes: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._versions = cast(Link, kwargs.get("versions"))
		self._export = cast(Link, kwargs.get("export"))
		self._tags = cast(Link, kwargs.get("tags"))
		self._indexes = cast(Link, kwargs.get("indexes"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def versions(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._versions
	@versions.setter
	def versions(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._versions = value
	@property
	def export(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._export
	@export.setter
	def export(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._export = value
	@property
	def tags(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._tags
	@tags.setter
	def tags(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._tags = value
	@property
	def indexes(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._indexes
	@indexes.setter
	def indexes(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._indexes = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class TableModification:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"new_version": ("newVersion", "TableVersionReference", None),
		"links": ("_links", "TableModificationLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		new_version: "TableVersionReference",
		links: "TableModificationLinks",
	) -> None:
		"""
		:param new_version: The resulting table version after the modifications.
		:type new_version: TableVersionReference
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: TableModificationLinks
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._new_version = cast(TableVersionReference, kwargs.get("new_version"))
		self._links = cast(TableModificationLinks, kwargs.get("links"))
	@property
	def new_version(self) -> "TableVersionReference":
		"""The resulting table version after the modifications."""
		return self._new_version
	@new_version.setter
	def new_version(self, value: "TableVersionReference") -> None:
		"""The resulting table version after the modifications."""
		self._new_version = value
	@property
	def links(self) -> "TableModificationLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "TableModificationLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class TableModificationLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"new_version": ("newVersion", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		new_version: "Link",
		self_: "Link",
	) -> None:
		"""
		:param new_version: The resulting table version after the modifications.
		:type new_version: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._new_version = cast(Link, kwargs.get("new_version"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def new_version(self) -> "Link":
		"""The resulting table version after the modifications."""
		return self._new_version
	@new_version.setter
	def new_version(self, value: "Link") -> None:
		"""The resulting table version after the modifications."""
		self._new_version = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class TablePartitionerInfo:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"master_table_col_name": ("masterTableColName", "list", "str"),
		"col": ("col", "str", None),
		"method": ("method", "str", None),
		"args": ("args", "list", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		master_table_col_name: "List[str]",
		args: "List[str]",
		col: Optional["str"] = None,
		method: Optional["str"] = None,
	) -> None:
		"""
		:param master_table_col_name:
		:type master_table_col_name: List[str]
		:param args:
		:type args: List[str]
		:param col:
		:type col: str or None
		:param method:
		:type method: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._master_table_col_name = cast(List[str], kwargs.get("master_table_col_name"))
		self._col = cast(Optional[str], kwargs.get("col"))
		self._method = cast(Optional[str], kwargs.get("method"))
		self._args = cast(List[str], kwargs.get("args"))
	@property
	def master_table_col_name(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._master_table_col_name
	@master_table_col_name.setter
	def master_table_col_name(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._master_table_col_name = value
	@property
	def col(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._col
	@col.setter
	def col(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._col = value
	@property
	def method(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._method
	@method.setter
	def method(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._method = value
	@property
	def args(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._args
	@args.setter
	def args(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._args = value
class TableReference:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "AccountReference", None),
		"name": ("name", "str", None),
		"short_table_id": ("shortTableID", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "AccountReference",
		name: Optional["str"] = None,
		short_table_id: Optional["str"] = None,
	) -> None:
		"""
		:param account: The account that owns the table.
		:type account: AccountReference
		:param name: The name of the table.
		:type name: str or None
		:param short_table_id: The "short" Id of the table, without version. I.e. the "active" version. Formatted like "{accountName}/{tableName}".
		:type short_table_id: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._account = cast(AccountReference, kwargs.get("account"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._short_table_id = cast(Optional[str], kwargs.get("short_table_id"))
	@property
	def account(self) -> "AccountReference":
		"""The account that owns the table."""
		return self._account
	@account.setter
	def account(self, value: "AccountReference") -> None:
		"""The account that owns the table."""
		self._account = value
	@property
	def name(self) -> Optional["str"]:
		"""The name of the table."""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""The name of the table."""
		self._name = value
	@property
	def short_table_id(self) -> Optional["str"]:
		"""The "short" Id of the table, without version. I.e. the "active" version. Formatted like "{accountName}/{tableName}"."""
		return self._short_table_id
	@short_table_id.setter
	def short_table_id(self, value: Optional["str"]) -> None:
		"""The "short" Id of the table, without version. I.e. the "active" version. Formatted like "{accountName}/{tableName}"."""
		self._short_table_id = value
class TableResult:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"table_name": ("TableName", "str", None),
		"row_count": ("RowCount", "int", None),
		"column_count": ("ColumnCount", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		row_count: "int",
		column_count: "int",
		table_name: Optional["str"] = None,
	) -> None:
		"""
		:param row_count: The number of rows in the migrated table.
		:type row_count: int
		:param column_count: The number of columns in the migrated table.
		:type column_count: int
		:param table_name: The name of the migrated table, int account/table/version format.
		:type table_name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._table_name = cast(Optional[str], kwargs.get("table_name"))
		self._row_count = cast(int, kwargs.get("row_count"))
		self._column_count = cast(int, kwargs.get("column_count"))
	@property
	def table_name(self) -> Optional["str"]:
		"""The name of the migrated table, int account/table/version format."""
		return self._table_name
	@table_name.setter
	def table_name(self, value: Optional["str"]) -> None:
		"""The name of the migrated table, int account/table/version format."""
		self._table_name = value
	@property
	def row_count(self) -> "int":
		"""The number of rows in the migrated table."""
		return self._row_count
	@row_count.setter
	def row_count(self, value: "int") -> None:
		"""The number of rows in the migrated table."""
		self._row_count = value
	@property
	def column_count(self) -> "int":
		"""The number of columns in the migrated table."""
		return self._column_count
	@column_count.setter
	def column_count(self, value: "int") -> None:
		"""The number of columns in the migrated table."""
		self._column_count = value


class TablesVersionsExportAcceptType(str, Enum):
	"""The content types that `tables_versions_export` is able to return."""
	TEXT_CSV = 'text/csv'
	APPLICATION_VND_GOOGLE_EARTH_KML_XML = 'application/vnd.google-earth.kml+xml'
	APPLICATION_GEO_JSON = 'application/geo+json'
	APPLICATION_VND_SHP = 'application/vnd.shp'
	APPLICATION_GML_XML = 'application/gml+xml'
	APPLICATION_X_FLT_ZIP = 'application/x-flt+zip'
	APPLICATION_X_NETCDF = 'application/x-netcdf'
	APPLICATION_GRAPHML_XML = 'application/graphml+xml'
	APPLICATION_LD_JSON = 'application/ld+json'
	APPLICATION_X_GEOTIFF = 'application/x-geotiff'
	APPLICATION_VND_APACHE_PARQUET = 'application/vnd.apache.parquet'
	APPLICATION_VND_SQLITE_3 = 'application/vnd.sqlite3'

class TableSyncInfo:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"last_version_created_by_sync": ("lastVersionCreatedBySync", "str", None),
		"versions_to_exclude_from_sync": ("versionsToExcludeFromSync", "list", "str"),
		"last_version_synced": ("lastVersionSynced", "str", None),
		"last_sync_dth_version": ("lastSyncDTHVersion", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		versions_to_exclude_from_sync: "List[str]",
		last_version_created_by_sync: Optional["str"] = None,
		last_version_synced: Optional["str"] = None,
		last_sync_dth_version: Optional["str"] = None,
	) -> None:
		"""
		:param versions_to_exclude_from_sync: Versions on the server that should not be synchronized to the other server.
		:type versions_to_exclude_from_sync: List[str]
		:param last_version_created_by_sync: The most recent version created on the server by synchronizing from the other server.
		:type last_version_created_by_sync: str or None
		:param last_version_synced: The table version on the server that was most recently synchronized to the other server.
		:type last_version_synced: str or None
		:param last_sync_dth_version: The DTH of LastVersionSynced.
		:type last_sync_dth_version: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._last_version_created_by_sync = cast(Optional[str], kwargs.get("last_version_created_by_sync"))
		self._versions_to_exclude_from_sync = cast(List[str], kwargs.get("versions_to_exclude_from_sync"))
		self._last_version_synced = cast(Optional[str], kwargs.get("last_version_synced"))
		self._last_sync_dth_version = cast(Optional[str], kwargs.get("last_sync_dth_version"))
	@property
	def last_version_created_by_sync(self) -> Optional["str"]:
		"""The most recent version created on the server by synchronizing from the other server."""
		return self._last_version_created_by_sync
	@last_version_created_by_sync.setter
	def last_version_created_by_sync(self, value: Optional["str"]) -> None:
		"""The most recent version created on the server by synchronizing from the other server."""
		self._last_version_created_by_sync = value
	@property
	def versions_to_exclude_from_sync(self) -> "List[str]":
		"""Versions on the server that should not be synchronized to the other server."""
		return self._versions_to_exclude_from_sync
	@versions_to_exclude_from_sync.setter
	def versions_to_exclude_from_sync(self, value: "List[str]") -> None:
		"""Versions on the server that should not be synchronized to the other server."""
		self._versions_to_exclude_from_sync = value
	@property
	def last_version_synced(self) -> Optional["str"]:
		"""The table version on the server that was most recently synchronized to the other server."""
		return self._last_version_synced
	@last_version_synced.setter
	def last_version_synced(self, value: Optional["str"]) -> None:
		"""The table version on the server that was most recently synchronized to the other server."""
		self._last_version_synced = value
	@property
	def last_sync_dth_version(self) -> Optional["str"]:
		"""The DTH of LastVersionSynced."""
		return self._last_sync_dth_version
	@last_sync_dth_version.setter
	def last_sync_dth_version(self, value: Optional["str"]) -> None:
		"""The DTH of LastVersionSynced."""
		self._last_sync_dth_version = value
class TableTag:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"table": ("table", "TableReference", None),
		"key": ("key", "str", None),
		"value": ("value", "str", None),
		"issues": ("issues", "list", "CodeIssue"),
		"links": ("_links", "TableTagLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		table: "TableReference",
		key: "str",
		value: "str",
		issues: "List[CodeIssue]",
		links: "TableTagLinks",
	) -> None:
		"""
		:param table: The table that owns the tag.
		:type table: TableReference
		:param key: The key which identifies this tag.
		:type key: str
		:param value:
		:type value: str
		:param issues: A list of validation issues with the tag value that may prevent it from functioning properly. Not present in the tables_tags_list response.
		:type issues: List[CodeIssue]
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: TableTagLinks
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._table = cast(TableReference, kwargs.get("table"))
		self._key = cast(str, kwargs.get("key"))
		self._value = cast(str, kwargs.get("value"))
		self._issues = cast(List[CodeIssue], kwargs.get("issues"))
		self._links = cast(TableTagLinks, kwargs.get("links"))
	@property
	def table(self) -> "TableReference":
		"""The table that owns the tag."""
		return self._table
	@table.setter
	def table(self, value: "TableReference") -> None:
		"""The table that owns the tag."""
		self._table = value
	@property
	def key(self) -> "str":
		"""The key which identifies this tag."""
		return self._key
	@key.setter
	def key(self, value: "str") -> None:
		"""The key which identifies this tag."""
		self._key = value
	@property
	def value(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._value
	@value.setter
	def value(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._value = value
	@property
	def issues(self) -> "List[CodeIssue]":
		"""A list of validation issues with the tag value that may prevent it from functioning properly. Not present in the tables_tags_list response."""
		return self._issues
	@issues.setter
	def issues(self, value: "List[CodeIssue]") -> None:
		"""A list of validation issues with the tag value that may prevent it from functioning properly. Not present in the tables_tags_list response."""
		self._issues = value
	@property
	def links(self) -> "TableTagLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "TableTagLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class TableTagLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"table": ("table", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		table: "Link",
		self_: "Link",
	) -> None:
		"""
		:param table: A link to the table that owns this tag.
		:type table: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._table = cast(Link, kwargs.get("table"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def table(self) -> "Link":
		"""A link to the table that owns this tag."""
		return self._table
	@table.setter
	def table(self, value: "Link") -> None:
		"""A link to the table that owns this tag."""
		self._table = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class TableVersion:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "AccountReference", None),
		"name": ("name", "str", None),
		"version": ("version", "int", None),
		"id_": ("id", "str", None),
		"short_table_id": ("shortTableID", "str", None),
		"is_active": ("isActive", "bool", None),
		"visibility": ("visibility", "TableVisibility", None),
		"created": ("created", "datetime", None),
		"in_ram": ("inRam", "bool", None),
		"columns": ("columns", "list", "Column"),
		"row_count": ("rowCount", "int", None),
		"tags": ("tags", "list", "Tag"),
		"effective_permissions": ("effectivePermissions", "EffectiveResourcePermissions", None),
		"extra_info": ("extraInfo", "str", None),
		"geocoded": ("geocoded", "bool", None),
		"schema_strictness": ("schemaStrictness", "str", None),
		"links": ("_links", "TableLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "AccountReference",
		name: "str",
		version: "int",
		id_: "str",
		short_table_id: "str",
		is_active: "bool",
		visibility: "TableVisibility",
		created: "datetime",
		in_ram: "bool",
		columns: "List[Column]",
		row_count: "int",
		tags: "List[Tag]",
		effective_permissions: "EffectiveResourcePermissions",
		geocoded: "bool",
		links: "TableLinks",
		extra_info: Optional["str"] = None,
		schema_strictness: Optional["str"] = None,
	) -> None:
		"""
		:param account: The account that owns the table.
		:type account: AccountReference
		:param name: The name of the table.
		:type name: str
		:param version: The version number of the table.
		:type version: int
		:param id_: The "long" Id of the table version. Formatted like "{accountName}/{tableName}/{tableVersion}".
		:type id_: str
		:param short_table_id: The "short" Id of the table, without version. I.e. the "active" version. Formatted like "{accountName}/{tableName}".
		:type short_table_id: str
		:param is_active: Flag indicating if this table version is the active table version (the one that is returned when no table version is specified).
		:type is_active: bool
		:param visibility: Indicates how accessible the table is.
* `Private` - Table is only accessible to those who are granted access to the account it belongs to.
* `PublicUnlisted` - Table is publicly accessible, but links to it are not publicly visible within the MapLarge application.
* `Public` - Table is publicly accessible. Corresponds to `publictable = true` on the classic MapLarge API.
		:type visibility: TableVisibility
		:param created: The UTC date/time when this table was created.
		:type created: datetime
		:param in_ram: Indicates whether the table has been loaded from disk to memory or not.
		:type in_ram: bool
		:param columns: The list of columns belonging to the table, with their ids and data types.
		:type columns: List[Column]
		:param row_count: The number of rows in the table.
		:type row_count: int
		:param tags: The key-value-pair tags that have been attached to the table.
		:type tags: List[Tag]
		:param effective_permissions: Permissions granted to the current user on this table.
		:type effective_permissions: EffectiveResourcePermissions
		:param geocoded: Flag indicating whether or not this table has been geocoded yet.
		:type geocoded: bool
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: TableLinks
		:param extra_info: Notes or warnings about this table produced by the import process.
		:type extra_info: str or None
		:param schema_strictness: The schema strict mode for this table.
		:type schema_strictness: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._account = cast(AccountReference, kwargs.get("account"))
		self._name = cast(str, kwargs.get("name"))
		self._version = cast(int, kwargs.get("version"))
		self._id_ = cast(str, kwargs.get("id_"))
		self._short_table_id = cast(str, kwargs.get("short_table_id"))
		self._is_active = cast(bool, kwargs.get("is_active"))
		self._visibility = cast(TableVisibility, kwargs.get("visibility"))
		self._created = cast(datetime, kwargs.get("created"))
		self._in_ram = cast(bool, kwargs.get("in_ram"))
		self._columns = cast(List[Column], kwargs.get("columns"))
		self._row_count = cast(int, kwargs.get("row_count"))
		self._tags = cast(List[Tag], kwargs.get("tags"))
		self._effective_permissions = cast(EffectiveResourcePermissions, kwargs.get("effective_permissions"))
		self._extra_info = cast(Optional[str], kwargs.get("extra_info"))
		self._geocoded = cast(bool, kwargs.get("geocoded"))
		self._schema_strictness = cast(Optional[str], kwargs.get("schema_strictness"))
		self._links = cast(TableLinks, kwargs.get("links"))
	@property
	def account(self) -> "AccountReference":
		"""The account that owns the table."""
		return self._account
	@account.setter
	def account(self, value: "AccountReference") -> None:
		"""The account that owns the table."""
		self._account = value
	@property
	def name(self) -> "str":
		"""The name of the table."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The name of the table."""
		self._name = value
	@property
	def version(self) -> "int":
		"""The version number of the table."""
		return self._version
	@version.setter
	def version(self, value: "int") -> None:
		"""The version number of the table."""
		self._version = value
	@property
	def id_(self) -> "str":
		"""The "long" Id of the table version. Formatted like "{accountName}/{tableName}/{tableVersion}"."""
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		"""The "long" Id of the table version. Formatted like "{accountName}/{tableName}/{tableVersion}"."""
		self._id_ = value
	@property
	def short_table_id(self) -> "str":
		"""The "short" Id of the table, without version. I.e. the "active" version. Formatted like "{accountName}/{tableName}"."""
		return self._short_table_id
	@short_table_id.setter
	def short_table_id(self, value: "str") -> None:
		"""The "short" Id of the table, without version. I.e. the "active" version. Formatted like "{accountName}/{tableName}"."""
		self._short_table_id = value
	@property
	def is_active(self) -> "bool":
		"""Flag indicating if this table version is the active table version (the one that is returned when no table version is specified)."""
		return self._is_active
	@is_active.setter
	def is_active(self, value: "bool") -> None:
		"""Flag indicating if this table version is the active table version (the one that is returned when no table version is specified)."""
		self._is_active = value
	@property
	def visibility(self) -> "TableVisibility":
		"""Indicates how accessible the table is.
* `Private` - Table is only accessible to those who are granted access to the account it belongs to.
* `PublicUnlisted` - Table is publicly accessible, but links to it are not publicly visible within the MapLarge application.
* `Public` - Table is publicly accessible. Corresponds to `publictable = true` on the classic MapLarge API."""
		return self._visibility
	@visibility.setter
	def visibility(self, value: "TableVisibility") -> None:
		"""Indicates how accessible the table is.
* `Private` - Table is only accessible to those who are granted access to the account it belongs to.
* `PublicUnlisted` - Table is publicly accessible, but links to it are not publicly visible within the MapLarge application.
* `Public` - Table is publicly accessible. Corresponds to `publictable = true` on the classic MapLarge API."""
		self._visibility = value
	@property
	def created(self) -> "datetime":
		"""The UTC date/time when this table was created."""
		return self._created
	@created.setter
	def created(self, value: "datetime") -> None:
		"""The UTC date/time when this table was created."""
		self._created = value
	@property
	def in_ram(self) -> "bool":
		"""Indicates whether the table has been loaded from disk to memory or not."""
		return self._in_ram
	@in_ram.setter
	def in_ram(self, value: "bool") -> None:
		"""Indicates whether the table has been loaded from disk to memory or not."""
		self._in_ram = value
	@property
	def columns(self) -> "List[Column]":
		"""The list of columns belonging to the table, with their ids and data types."""
		return self._columns
	@columns.setter
	def columns(self, value: "List[Column]") -> None:
		"""The list of columns belonging to the table, with their ids and data types."""
		self._columns = value
	@property
	def row_count(self) -> "int":
		"""The number of rows in the table."""
		return self._row_count
	@row_count.setter
	def row_count(self, value: "int") -> None:
		"""The number of rows in the table."""
		self._row_count = value
	@property
	def tags(self) -> "List[Tag]":
		"""The key-value-pair tags that have been attached to the table."""
		return self._tags
	@tags.setter
	def tags(self, value: "List[Tag]") -> None:
		"""The key-value-pair tags that have been attached to the table."""
		self._tags = value
	@property
	def effective_permissions(self) -> "EffectiveResourcePermissions":
		"""Permissions granted to the current user on this table."""
		return self._effective_permissions
	@effective_permissions.setter
	def effective_permissions(self, value: "EffectiveResourcePermissions") -> None:
		"""Permissions granted to the current user on this table."""
		self._effective_permissions = value
	@property
	def extra_info(self) -> Optional["str"]:
		"""Notes or warnings about this table produced by the import process."""
		return self._extra_info
	@extra_info.setter
	def extra_info(self, value: Optional["str"]) -> None:
		"""Notes or warnings about this table produced by the import process."""
		self._extra_info = value
	@property
	def geocoded(self) -> "bool":
		"""Flag indicating whether or not this table has been geocoded yet."""
		return self._geocoded
	@geocoded.setter
	def geocoded(self, value: "bool") -> None:
		"""Flag indicating whether or not this table has been geocoded yet."""
		self._geocoded = value
	@property
	def schema_strictness(self) -> Optional["str"]:
		"""The schema strict mode for this table."""
		return self._schema_strictness
	@schema_strictness.setter
	def schema_strictness(self, value: Optional["str"]) -> None:
		"""The schema strict mode for this table."""
		self._schema_strictness = value
	@property
	def links(self) -> "TableLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "TableLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class TableVersionActive:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"active_version": ("activeVersion", "TableVersionReference", None),
		"links": ("_links", "TableLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		active_version: "TableVersionReference",
		links: "TableLinks",
	) -> None:
		"""
		:param active_version: The resulting table version after the modifications.
		:type active_version: TableVersionReference
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: TableLinks
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._active_version = cast(TableVersionReference, kwargs.get("active_version"))
		self._links = cast(TableLinks, kwargs.get("links"))
	@property
	def active_version(self) -> "TableVersionReference":
		"""The resulting table version after the modifications."""
		return self._active_version
	@active_version.setter
	def active_version(self, value: "TableVersionReference") -> None:
		"""The resulting table version after the modifications."""
		self._active_version = value
	@property
	def links(self) -> "TableLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "TableLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class TableVersionReference(TableReference):
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"version": ("version", "int", None),
		"id_": ("id", "str", None),
		"account": ("account", "AccountReference", None),
		"name": ("name", "str", None),
		"short_table_id": ("shortTableID", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		version: "int",
		account: "AccountReference",
		id_: Optional["str"] = None,
		name: Optional["str"] = None,
		short_table_id: Optional["str"] = None,
	) -> None:
		"""
		:param version: The version number of the table.
		:type version: int
		:param account: The account that owns the table.
		:type account: AccountReference
		:param id_: The "long" Id of the table version. Formatted like "{accountName}/{tableName}/{tableVersion}".
		:type id_: str or None
		:param name: The name of the table.
		:type name: str or None
		:param short_table_id: The "short" Id of the table, without version. I.e. the "active" version. Formatted like "{accountName}/{tableName}".
		:type short_table_id: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		TableReference.__init__(self,
			account=kwargs.get("account"),
			name=kwargs.get("name"),
			short_table_id=kwargs.get("short_table_id"),
		)
		self._version = cast(int, kwargs.get("version"))
		self._id_ = cast(Optional[str], kwargs.get("id_"))
	@property
	def version(self) -> "int":
		"""The version number of the table."""
		return self._version
	@version.setter
	def version(self, value: "int") -> None:
		"""The version number of the table."""
		self._version = value
	@property
	def id_(self) -> Optional["str"]:
		"""The "long" Id of the table version. Formatted like "{accountName}/{tableName}/{tableVersion}"."""
		return self._id_
	@id_.setter
	def id_(self, value: Optional["str"]) -> None:
		"""The "long" Id of the table version. Formatted like "{accountName}/{tableName}/{tableVersion}"."""
		self._id_ = value


class TableVisibility(str, Enum):
	"""Indicates how accessible the table is."""
	PRIVATE = 'Private'
	PUBLIC_UNLISTED = 'PublicUnlisted'
	PUBLIC = 'Public'

TableVisibility.PRIVATE.__doc__ = """Table is only accessible to those who are granted access to the account it belongs to."""
TableVisibility.PUBLIC_UNLISTED.__doc__ = """Table is publicly accessible, but links to it are not publicly visible within the MapLarge application."""
TableVisibility.PUBLIC.__doc__ = """Table is publicly accessible. Corresponds to `publictable = true` on the classic MapLarge API."""
class Tag:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"key": ("key", "str", None),
		"value": ("value", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		key: "str",
		value: "str",
	) -> None:
		"""
		:param key:
		:type key: str
		:param value:
		:type value: str
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._key = cast(str, kwargs.get("key"))
		self._value = cast(str, kwargs.get("value"))
	@property
	def key(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._key
	@key.setter
	def key(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._key = value
	@property
	def value(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._value
	@value.setter
	def value(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._value = value
class TemporalWMS:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"column": ("column", "str", None),
		"table": ("table", "str", None),
		"geotype": ("geotype", "LayerType", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		geotype: "LayerType",
		column: Optional["str"] = None,
		table: Optional["str"] = None,
	) -> None:
		"""
		:param geotype: The type of geospatial data to select.
		:type geotype: LayerType
		:param column:
		:type column: str or None
		:param table:
		:type table: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._column = cast(Optional[str], kwargs.get("column"))
		self._table = cast(Optional[str], kwargs.get("table"))
		self._geotype = cast(LayerType, kwargs.get("geotype"))
	@property
	def column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._column
	@column.setter
	def column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column = value
	@property
	def table(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._table
	@table.setter
	def table(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._table = value
	@property
	def geotype(self) -> "LayerType":
		"""The type of geospatial data to select."""
		return self._geotype
	@geotype.setter
	def geotype(self, value: "LayerType") -> None:
		"""The type of geospatial data to select."""
		self._geotype = value


class TestSymbol(str, Enum):
	"""The comparison operator. Compares `column` against `value`."""
	GREATER = 'Greater'
	GREATER_OR = 'GreaterOR'
	BETWEEN = 'Between'
	NOT_BETWEEN = 'NotBetween'
	LESS = 'Less'
	LESS_OR = 'LessOR'
	EQUAL = 'Equal'
	EQUAL_NOT = 'EqualNot'
	EQUAL_ANY = 'EqualAny'
	EQUAL_NONE = 'EqualNone'
	EQUAL_ANY_LIST = 'EqualAnyList'
	EQUAL_ALL_LIST = 'EqualAllList'
	IEQUAL = 'IEqual'
	IEQUAL_NOT = 'IEqualNot'
	CONTAINS = 'Contains'
	CONTAINS_NOT = 'ContainsNot'
	CONTAINS_OR = 'ContainsOr'
	CONTAINS_ANY = 'ContainsAny'
	ANY_CONTAINS = 'AnyContains'
	EXACT_MATCH = 'ExactMatch'
	IS_FUZZY_MATCH = 'IsFuzzyMatch'
	IS_IN_PROXIMITY = 'IsInProximity'
	ANY_CONTAINS_PATTERN = 'AnyContainsPattern'
	CONTAINS_PATTERN = 'ContainsPattern'
	RANGE_SEARCH_STRING = 'RangeSearchString'
	CONTAINS_ALL = 'ContainsAll'
	CONTAINS_NONE = 'ContainsNone'
	CONTAINS_ORDERED_LIST = 'ContainsOrderedList'
	CONTAINS_ORDERED_LIST_SEQUENTIAL = 'ContainsOrderedListSequential'
	STARTS_WITH = 'StartsWith'
	ISTARTS_WITH = 'IStartsWith'
	STARTS_WITH_NOT = 'StartsWithNot'
	ENDS_WITH = 'EndsWith'
	IENDS_WITH = 'IEndsWith'
	FUZZY = 'Fuzzy'
	IS_EMPTY = 'IsEmpty'
	IS_NOT_EMPTY = 'IsNotEmpty'
	LIKE = 'Like'
	ILIKE = 'ILike'
	IS_NULL = 'IsNull'
	IS_NOT_NULL = 'IsNotNull'
	REVERSE_CONTAINS_ALL = 'ReverseContainsAll'
	TOP = 'Top'
	BOTTOM = 'Bottom'
	ANY = 'Any'
	NONE = 'None'
	DECIMATE = 'Decimate'
	ALWAYS_FALSE = 'AlwaysFalse'
	DWITHIN = 'DWithin'
	NOT_DWITHIN = 'NotDWithin'
	OVERLAPS = 'Overlaps'
	NOT_OVERLAPS = 'NotOverlaps'
	NEAREST = 'Nearest'
	NOT = 'Not_'
	CATCH_ALL = 'CatchAll'
	GEO_CONTAINS = 'GeoContains'
	GEO_NOT_CONTAINS = 'GeoNotContains'
	GEO_REGION_CONTAINS = 'GeoRegionContains'
	GEO_REGION_NOT_CONTAINS = 'GeoRegionNotContains'
	GEO_OVERLAPS = 'GeoOverlaps'
	GEO_NOT_OVERLAPS = 'GeoNotOverlaps'
	GEO_DWITHIN = 'GeoDWithin'
	GEO_NOT_DWITHIN = 'GeoNotDWithin'
	GEO_LENGTH_EQUAL = 'GeoLengthEqual'
	GEO_LENGTH_GREATER = 'GeoLengthGreater'
	GEO_LENGTH_LESS = 'GeoLengthLess'
	GEO_AREA_EQUAL = 'GeoAreaEqual'
	GEO_AREA_LESS = 'GeoAreaLess'
	GEO_AREA_GREATER = 'GeoAreaGreater'
	DAY_OF_WEEK = 'DayOfWeek'
	HOUR_OF_DAY = 'HourOfDay'
	WITHIN_LAST = 'WithinLast'
	WITHIN_LAST_RANGE = 'WithinLastRange'
	IS_CURRENT = 'IsCurrent'
	IS_NODE = 'IsNode'
	IS_EDGE = 'IsEdge'

TestSymbol.GREATER.__doc__ = """Greater than."""
TestSymbol.GREATER_OR.__doc__ = """Greater than or equal to."""
TestSymbol.BETWEEN.__doc__ = """Between a min and max value, inclusive (may be equal to the min or max).  Format as `1/10` to return values between 1 and 10.  Multiple ranges supported as `1/10,20/30`."""
TestSymbol.NOT_BETWEEN.__doc__ = """Outside of a min and max, exclusive (not equal to the min or max)."""
TestSymbol.LESS.__doc__ = """Less than."""
TestSymbol.LESS_OR.__doc__ = """Less than or equal to."""
TestSymbol.EQUAL.__doc__ = """Equal to - exact match."""
TestSymbol.EQUAL_NOT.__doc__ = """Not equal to."""
TestSymbol.EQUAL_ANY.__doc__ = """Equal to any value in a comma-delimited list."""
TestSymbol.EQUAL_NONE.__doc__ = """Not equal to any value in a comma-delimited list."""
TestSymbol.IEQUAL.__doc__ = """Equal, case-insensitive."""
TestSymbol.IEQUAL_NOT.__doc__ = """Not equal, case-insensitive."""
TestSymbol.CONTAINS.__doc__ = """Contains a substring, case-insensitive."""
TestSymbol.CONTAINS_NOT.__doc__ = """Does not contain a substring, case-insensitive."""
TestSymbol.CONTAINS_OR.__doc__ = """Contains any substring in a comma-delimited list, case-insensitive."""
TestSymbol.CONTAINS_ANY.__doc__ = """Contains any substring in a comma-delimited list, case-insensitive."""
TestSymbol.CONTAINS_ALL.__doc__ = """Contains every substring in a comma-delimited list, case-insensitive."""
TestSymbol.CONTAINS_NONE.__doc__ = """Contains no substrings in a comma-delimited list, case-insensitive."""
TestSymbol.CONTAINS_ORDERED_LIST.__doc__ = """Contains every substring in a comma-delimited list, in order, case-sensitive."""
TestSymbol.CONTAINS_ORDERED_LIST_SEQUENTIAL.__doc__ = """Contains every substring in a comma-delimited list, in sequential order, case-sensitive."""
TestSymbol.STARTS_WITH.__doc__ = """Does start with a substring, case-sensitive."""
TestSymbol.ISTARTS_WITH.__doc__ = """Does start with a substring, case-insensitive."""
TestSymbol.STARTS_WITH_NOT.__doc__ = """Does not start with a substring, case-sensitive."""
TestSymbol.ENDS_WITH.__doc__ = """Ends with a substring, case-sensitive."""
TestSymbol.IENDS_WITH.__doc__ = """Ends with a substring, case-insensitive."""
TestSymbol.FUZZY.__doc__ = """Approximate string match (Levenshtein distance <= 25), case-insensitive."""
TestSymbol.IS_EMPTY.__doc__ = """String is null or whitespace."""
TestSymbol.IS_NOT_EMPTY.__doc__ = """String is non-empty and not whitespace."""
TestSymbol.LIKE.__doc__ = """String pattern match, case-sensitive."""
TestSymbol.ILIKE.__doc__ = """String pattern match, case-insensitive."""
TestSymbol.IS_NULL.__doc__ = """Is null."""
TestSymbol.IS_NOT_NULL.__doc__ = """Is not null."""
TestSymbol.REVERSE_CONTAINS_ALL.__doc__ = """The column value is a comma-delimited list of substrings to search for, and the test value contains all of the elements of that list."""
TestSymbol.TOP.__doc__ = """Row is one of the first `x` rows."""
TestSymbol.BOTTOM.__doc__ = """Row is one of the last `x` rows."""
TestSymbol.ANY.__doc__ = """Get specific rows - where the row indexes are in a comma-delimited list."""
TestSymbol.NONE.__doc__ = """Get specific rows - where the row indexes are all those _not_ in a comma-delimited list."""
TestSymbol.DECIMATE.__doc__ = """Return a specific number of rows from the table, spaced throughout the table.  No order by needed."""
TestSymbol.ALWAYS_FALSE.__doc__ = """Always false, regardless of the `value`."""
TestSymbol.DWITHIN.__doc__ = """The column value is within a specified radius of the value WKT."""
TestSymbol.NOT_DWITHIN.__doc__ = """The column value is not within a specified radius of the value WKT."""
TestSymbol.OVERLAPS.__doc__ = """The column value overlaps the value WKT."""
TestSymbol.NOT_OVERLAPS.__doc__ = """The column value does not overlap the value WKT."""
TestSymbol.NEAREST.__doc__ = """The column value is the closest to the value WKT."""
TestSymbol.NOT.__doc__ = """When any test symbol is prefixed with `Not_`, the results of the test are inverted."""
TestSymbol.CATCH_ALL.__doc__ = """Always true, regardless of the `value`."""
TestSymbol.DAY_OF_WEEK.__doc__ = """The date falls on the specified day of the week.  Valid test `value`s are: Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Weekend, Weekday, Any, None."""
TestSymbol.HOUR_OF_DAY.__doc__ = """The date falls on the specified hour of the day.  Test `value` may be in 12 hour format (8am, 8 pm) or 24 hour format (no suffix)."""
TestSymbol.WITHIN_LAST.__doc__ = """The date is within the last range, specified as yyyy-mm-dd or mm-dd or a .NET TimeSpan."""
TestSymbol.IS_CURRENT.__doc__ = """After a table is appended, returns only those rows in the current version of the table that is being queried."""


class TextOverlayMode(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	OVER = 'Over'
	UNDER = 'Under'

class Tick:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"size": ("size", "int", None),
		"text": ("text", "str", None),
		"color": ("color", "str", None),
		"draw_gridlines": ("drawGridlines", "bool", None),
		"gridline_color": ("gridlineColor", "str", None),
		"number_of_ticks": ("numberOfTicks", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		size: "int",
		color: "str",
		draw_gridlines: "bool",
		gridline_color: "str",
		number_of_ticks: "int",
		text: Optional["str"] = None,
	) -> None:
		"""
		:param size:
		:type size: int
		:param color: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type color: str
		:param draw_gridlines:
		:type draw_gridlines: bool
		:param gridline_color: A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`
		:type gridline_color: str
		:param number_of_ticks:
		:type number_of_ticks: int
		:param text:
		:type text: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._size = cast(int, kwargs.get("size"))
		self._text = cast(Optional[str], kwargs.get("text"))
		self._color = cast(str, kwargs.get("color"))
		self._draw_gridlines = cast(bool, kwargs.get("draw_gridlines"))
		self._gridline_color = cast(str, kwargs.get("gridline_color"))
		self._number_of_ticks = cast(int, kwargs.get("number_of_ticks"))
	@property
	def size(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._size
	@size.setter
	def size(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._size = value
	@property
	def text(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._text
	@text.setter
	def text(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._text = value
	@property
	def color(self) -> "str":
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._color
	@color.setter
	def color(self, value: "str") -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._color = value
	@property
	def draw_gridlines(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._draw_gridlines
	@draw_gridlines.setter
	def draw_gridlines(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._draw_gridlines = value
	@property
	def gridline_color(self) -> "str":
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		return self._gridline_color
	@gridline_color.setter
	def gridline_color(self, value: "str") -> None:
		"""A color. Accepted color formats are:
* Hexadecimal notation: `[#]RGB[A]` or `[#]RRGGBB[AA]` - example: `#FF000080`
* CSS functional notation: `rgb[a](R, G, B[, A])` or `rgb[a](R G B[ / A])` - example: `rgba(255, 0, 0, 50%)
* Color name: `[A-]name` - example: `128-red`)
* Dashed notation: `[A-]R-G-B` - example: `128-255-0-0`"""
		self._gridline_color = value
	@property
	def number_of_ticks(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._number_of_ticks
	@number_of_ticks.setter
	def number_of_ticks(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._number_of_ticks = value
class TileSet:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "AccountReference", None),
		"name": ("name", "str", None),
		"zoom": ("zoom", "IntRange", None),
		"x": ("x", "IntRange", None),
		"y": ("y", "IntRange", None),
		"links": ("_links", "TileSetLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "AccountReference",
		name: "str",
		zoom: "IntRange",
		x: "IntRange",
		y: "IntRange",
		links: "TileSetLinks",
	) -> None:
		"""
		:param account: The account code that this tile set belongs to.
		:type account: AccountReference
		:param name: The name of the tile set.
		:type name: str
		:param zoom: The minimum and maximum zoom level for which tiles exist in this tile set.
		:type zoom: IntRange
		:param x: The tile set's west-most and east-most X-coordinate at the maximum zoom level.
		:type x: IntRange
		:param y: The tile set's north-most and south-most Y-coordinate at the maximum zoom level.
		:type y: IntRange
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: TileSetLinks
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._account = cast(AccountReference, kwargs.get("account"))
		self._name = cast(str, kwargs.get("name"))
		self._zoom = cast(IntRange, kwargs.get("zoom"))
		self._x = cast(IntRange, kwargs.get("x"))
		self._y = cast(IntRange, kwargs.get("y"))
		self._links = cast(TileSetLinks, kwargs.get("links"))
	@property
	def account(self) -> "AccountReference":
		"""The account code that this tile set belongs to."""
		return self._account
	@account.setter
	def account(self, value: "AccountReference") -> None:
		"""The account code that this tile set belongs to."""
		self._account = value
	@property
	def name(self) -> "str":
		"""The name of the tile set."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The name of the tile set."""
		self._name = value
	@property
	def zoom(self) -> "IntRange":
		"""The minimum and maximum zoom level for which tiles exist in this tile set."""
		return self._zoom
	@zoom.setter
	def zoom(self, value: "IntRange") -> None:
		"""The minimum and maximum zoom level for which tiles exist in this tile set."""
		self._zoom = value
	@property
	def x(self) -> "IntRange":
		"""The tile set's west-most and east-most X-coordinate at the maximum zoom level."""
		return self._x
	@x.setter
	def x(self, value: "IntRange") -> None:
		"""The tile set's west-most and east-most X-coordinate at the maximum zoom level."""
		self._x = value
	@property
	def y(self) -> "IntRange":
		"""The tile set's north-most and south-most Y-coordinate at the maximum zoom level."""
		return self._y
	@y.setter
	def y(self, value: "IntRange") -> None:
		"""The tile set's north-most and south-most Y-coordinate at the maximum zoom level."""
		self._y = value
	@property
	def links(self) -> "TileSetLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "TileSetLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class TileSetLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"account": ("account", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		account: "Link",
		self_: "Link",
	) -> None:
		"""
		:param account: A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08).
		:type account: Link
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._account = cast(Link, kwargs.get("account"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def account(self) -> "Link":
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		return self._account
	@account.setter
	def account(self, value: "Link") -> None:
		"""A pointer to a resource in the REST API. Formatted according to [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08)."""
		self._account = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value


class TimeIncrement(str, Enum):
	# pylint: disable=missing-class-docstring
	YEAR = 'Year'
	MONTH = 'Month'
	DAY = 'Day'
	HOUR = 'Hour'
	MINUTE = 'Minute'
	SECOND = 'Second'

class TinyUrlEntity:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"key": ("Key", "str", None),
		"user_id": ("UserId", "int", None),
		"last_update": ("LastUpdate", "datetime", None),
		"full_url": ("FullUrl", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		user_id: "int",
		last_update: "datetime",
		key: Optional["str"] = None,
		full_url: Optional["str"] = None,
	) -> None:
		"""
		:param user_id:
		:type user_id: int
		:param last_update:
		:type last_update: datetime
		:param key:
		:type key: str or None
		:param full_url:
		:type full_url: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._key = cast(Optional[str], kwargs.get("key"))
		self._user_id = cast(int, kwargs.get("user_id"))
		self._last_update = cast(datetime, kwargs.get("last_update"))
		self._full_url = cast(Optional[str], kwargs.get("full_url"))
	@property
	def key(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._key
	@key.setter
	def key(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._key = value
	@property
	def user_id(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._user_id
	@user_id.setter
	def user_id(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._user_id = value
	@property
	def last_update(self) -> "datetime":
		# pylint: disable=missing-function-docstring
		return self._last_update
	@last_update.setter
	def last_update(self, value: "datetime") -> None:
		# pylint: disable=missing-function-docstring
		self._last_update = value
	@property
	def full_url(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._full_url
	@full_url.setter
	def full_url(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._full_url = value
class TinyUrlRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"full_url": ("fullUrl", "str", None),
		"key_length": ("keyLength", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		full_url: "str",
		key_length: Optional["int"] = None,
	) -> None:
		"""
		:param full_url: The full URL that is the redirect destination
		:type full_url: str
		:param key_length: The string length of the shortened URL key
		:type key_length: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._full_url = cast(str, kwargs.get("full_url"))
		self._key_length = cast(Optional[int], kwargs.get("key_length"))
	@property
	def full_url(self) -> "str":
		"""The full URL that is the redirect destination"""
		return self._full_url
	@full_url.setter
	def full_url(self, value: "str") -> None:
		"""The full URL that is the redirect destination"""
		self._full_url = value
	@property
	def key_length(self) -> Optional["int"]:
		"""The string length of the shortened URL key"""
		return self._key_length
	@key_length.setter
	def key_length(self, value: Optional["int"]) -> None:
		"""The string length of the shortened URL key"""
		self._key_length = value


class TotalTypes(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	COUNT = 'Count'
	AVG = 'Avg'
	SUM = 'Sum'
	MIN = 'Min'
	MAX = 'Max'
	UNIQUE = 'Unique'
	KEY = 'Key'
	CONCAT = 'Concat'
	RANK = 'Rank'
	PERCENTILE = 'Percentile'
	RASTER = 'Raster'
	RASTER_AVG = 'RasterAvg'
	RASTER_MIN = 'RasterMin'
	RASTER_MAX = 'RasterMax'
	RASTER_PROFILE = 'RasterProfile'
	LEAD = 'Lead'
	LAG = 'Lag'
	FIRST_VALUE = 'First_Value'
	LAST_VALUE = 'Last_Value'
	NTH_VALUE = 'Nth_Value'
	PAST_GATE = 'Past_Gate'
	ANALYTIC_MIN = 'AnalyticMin'
	ANALYTIC_MAX = 'AnalyticMax'
	ANALYTIC_AVG = 'AnalyticAvg'
	ANALYTIC_SUM = 'AnalyticSum'
	ANALYTIC_COUNT = 'AnalyticCount'
	START_NODE = 'Start_Node'
	END_NODE = 'End_Node'
	ADJACENT_NODES = 'Adjacent_Nodes'
	BINNED = 'Binned'
	DECIMATE = 'Decimate'
	COURSE_CHANGE = 'CourseChange'
	SPEED_METERS_PER_SECOND = 'SpeedMetersPerSecond'
	TWIST_SCORE = 'TwistScore'
	DIST_FROM_PREVIOUS_POINT_KM = 'DistFromPreviousPointKm'
	MAX_SEGMENT_DIST_KM = 'MaxSegmentDistKm'
	JUMP_SCORE = 'JumpScore'
	FIXED_SIZE = 'FixedSize'
	DWELL = 'Dwell'

class TraceLayerModuleTraceOpts:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_column_name": ("idColumnName", "str", None),
		"timestamp_column_name": ("timestampColumnName", "str", None),
		"time_increment_seconds": ("timeIncrementSeconds", "int", None),
		"filter_": ("filter", "QueryWhere", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		time_increment_seconds: "int",
		filter_: "QueryWhere",
		id_column_name: Optional["str"] = None,
		timestamp_column_name: Optional["str"] = None,
	) -> None:
		"""
		:param time_increment_seconds:
		:type time_increment_seconds: int
		:param filter_:
		:type filter_: QueryWhere
		:param id_column_name:
		:type id_column_name: str or None
		:param timestamp_column_name:
		:type timestamp_column_name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_column_name = cast(Optional[str], kwargs.get("id_column_name"))
		self._timestamp_column_name = cast(Optional[str], kwargs.get("timestamp_column_name"))
		self._time_increment_seconds = cast(int, kwargs.get("time_increment_seconds"))
		self._filter_ = cast(QueryWhere, kwargs.get("filter_"))
	@property
	def id_column_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._id_column_name
	@id_column_name.setter
	def id_column_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._id_column_name = value
	@property
	def timestamp_column_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._timestamp_column_name
	@timestamp_column_name.setter
	def timestamp_column_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._timestamp_column_name = value
	@property
	def time_increment_seconds(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._time_increment_seconds
	@time_increment_seconds.setter
	def time_increment_seconds(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._time_increment_seconds = value
	@property
	def filter_(self) -> "QueryWhere":
		# pylint: disable=missing-function-docstring
		return self._filter_
	@filter_.setter
	def filter_(self, value: "QueryWhere") -> None:
		# pylint: disable=missing-function-docstring
		self._filter_ = value


class TransactedTableHandleSchemaStrictMode(str, Enum):
	# pylint: disable=missing-class-docstring
	PERMISSIVE = 'Permissive'
	STRICT_BY_COLUMN_ALLOW_NEW_COLUMNS = 'StrictByColumnAllowNewColumns'
	STRICT_ALLOW_NEW_COLUMNS = 'StrictAllowNewColumns'
	STRICT = 'Strict'



class TransactionConsistencyStatus(str, Enum):
	# pylint: disable=missing-class-docstring
	NONE = 'None'
	IN_DOUBT = 'InDoubt'
	LOGICAL_FAILURE = 'LogicalFailure'
	AMBIENT_FAILURE = 'AmbientFailure'
	VOIDED = 'Voided'

class TransformDirective:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"src_field": ("srcField", "str", None),
		"input_fields": ("inputFields", "list", "TransformDirective"),
		"dest_column": ("destColumn", "str", None),
		"src_type": ("srcType", "ColumnType", None),
		"dest_type": ("destType", "ColumnType", None),
		"designation": ("designation", "DirectedOutputs", None),
		"col_value": ("colValue", "str", None),
		"format_str": ("formatStr", "str", None),
		"time_increment": ("timeIncrement", "TimeIncrement", None),
		"log_msg": ("logMsg", "str", None),
		"encrypt_column": ("encryptColumn", "bool", None),
		"strict": ("strict", "bool", None),
		"fail_on_type_mismatch": ("failOnTypeMismatch", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		src_field: Optional["str"] = None,
		input_fields: Optional["List[TransformDirective]"] = None,
		dest_column: Optional["str"] = None,
		src_type: Optional["ColumnType"] = None,
		dest_type: Optional["ColumnType"] = None,
		designation: Optional["DirectedOutputs"] = None,
		col_value: Optional["str"] = None,
		format_str: Optional["str"] = None,
		time_increment: Optional["TimeIncrement"] = None,
		log_msg: Optional["str"] = None,
		encrypt_column: Optional["bool"] = None,
		strict: Optional["bool"] = None,
		fail_on_type_mismatch: Optional["bool"] = None,
	) -> None:
		"""
		:param src_field:
		:type src_field: str or None
		:param input_fields:
		:type input_fields: List[TransformDirective] or None
		:param dest_column:
		:type dest_column: str or None
		:param src_type: The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data.
		:type src_type: ColumnType or None
		:param dest_type: The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data.
		:type dest_type: ColumnType or None
		:param designation:
		:type designation: DirectedOutputs or None
		:param col_value:
		:type col_value: str or None
		:param format_str:
		:type format_str: str or None
		:param time_increment:
		:type time_increment: TimeIncrement or None
		:param log_msg:
		:type log_msg: str or None
		:param encrypt_column:
		:type encrypt_column: bool or None
		:param strict:
		:type strict: bool or None
		:param fail_on_type_mismatch:
		:type fail_on_type_mismatch: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._src_field = cast(Optional[str], kwargs.get("src_field"))
		self._input_fields = cast(Optional[List[TransformDirective]], kwargs.get("input_fields"))
		self._dest_column = cast(Optional[str], kwargs.get("dest_column"))
		self._src_type = cast(Optional[ColumnType], kwargs.get("src_type"))
		self._dest_type = cast(Optional[ColumnType], kwargs.get("dest_type"))
		self._designation = cast(Optional[DirectedOutputs], kwargs.get("designation"))
		self._col_value = cast(Optional[str], kwargs.get("col_value"))
		self._format_str = cast(Optional[str], kwargs.get("format_str"))
		self._time_increment = cast(Optional[TimeIncrement], kwargs.get("time_increment"))
		self._log_msg = cast(Optional[str], kwargs.get("log_msg"))
		self._encrypt_column = cast(Optional[bool], kwargs.get("encrypt_column"))
		self._strict = cast(Optional[bool], kwargs.get("strict"))
		self._fail_on_type_mismatch = cast(Optional[bool], kwargs.get("fail_on_type_mismatch"))
	@property
	def src_field(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._src_field
	@src_field.setter
	def src_field(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._src_field = value
	@property
	def input_fields(self) -> Optional["List[TransformDirective]"]:
		# pylint: disable=missing-function-docstring
		return self._input_fields
	@input_fields.setter
	def input_fields(self, value: Optional["List[TransformDirective]"]) -> None:
		# pylint: disable=missing-function-docstring
		self._input_fields = value
	@property
	def dest_column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._dest_column
	@dest_column.setter
	def dest_column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._dest_column = value
	@property
	def src_type(self) -> Optional["ColumnType"]:
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		return self._src_type
	@src_type.setter
	def src_type(self, value: Optional["ColumnType"]) -> None:
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		self._src_type = value
	@property
	def dest_type(self) -> Optional["ColumnType"]:
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		return self._dest_type
	@dest_type.setter
	def dest_type(self, value: Optional["ColumnType"]) -> None:
		"""The type of data contained in the column.
* `None` - No data type.
* `Int32` - 32 bit signed integer.
* `Int64` - 64 bit signed integer.
* `Guid` - Globally Unique Identifier
* `Double` - Floating point number.
* `Vector` - Floating point number.
* `Json` - Binary Encoded JSON.
* `String` - Variable length Unicode text.
* `MessagingShard` - Messaging shard
* `Poly` - Geospatial polygon.
* `Line` - Geospatial line.
* `XY` - Geospatial point.
* `Multipoint` - Geospatial points.
* `DateTime` - Date/time value, with offset relative to UTC.
* `Graph` - A node in a directed graph.
* `Binary` - An array of bytes.
* `Recurrence` - Rules describing a date/time recurrence pattern.
* `Raster` - Geospatial raster data."""
		self._dest_type = value
	@property
	def designation(self) -> Optional["DirectedOutputs"]:
		# pylint: disable=missing-function-docstring
		return self._designation
	@designation.setter
	def designation(self, value: Optional["DirectedOutputs"]) -> None:
		# pylint: disable=missing-function-docstring
		self._designation = value
	@property
	def col_value(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._col_value
	@col_value.setter
	def col_value(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._col_value = value
	@property
	def format_str(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._format_str
	@format_str.setter
	def format_str(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._format_str = value
	@property
	def time_increment(self) -> Optional["TimeIncrement"]:
		# pylint: disable=missing-function-docstring
		return self._time_increment
	@time_increment.setter
	def time_increment(self, value: Optional["TimeIncrement"]) -> None:
		# pylint: disable=missing-function-docstring
		self._time_increment = value
	@property
	def log_msg(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._log_msg
	@log_msg.setter
	def log_msg(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._log_msg = value
	@property
	def encrypt_column(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._encrypt_column
	@encrypt_column.setter
	def encrypt_column(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._encrypt_column = value
	@property
	def strict(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._strict
	@strict.setter
	def strict(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._strict = value
	@property
	def fail_on_type_mismatch(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._fail_on_type_mismatch
	@fail_on_type_mismatch.setter
	def fail_on_type_mismatch(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._fail_on_type_mismatch = value
class UpdateAccountRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"description": ("description", "str", None),
		"estimated_size_limit": ("estimatedSizeLimit", "int", None),
		"max_row_limit": ("maxRowLimit", "int", None),
		"max_cell_limit": ("maxCellLimit", "int", None),
		"allow_anonymous_downloads": ("allowAnonymousDownloads", "bool", None),
		"use_resource_permissions": ("useResourcePermissions", "bool", None),
		"is_organization": ("isOrganization", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: Optional["str"] = None,
		description: Optional["str"] = None,
		estimated_size_limit: Optional["int"] = None,
		max_row_limit: Optional["int"] = None,
		max_cell_limit: Optional["int"] = None,
		allow_anonymous_downloads: Optional["bool"] = None,
		use_resource_permissions: Optional["bool"] = None,
		is_organization: Optional["bool"] = None,
	) -> None:
		"""
		:param name: Account name. Usually matches `code`. Passing null will leave the value on the server unchanged.
		:type name: str or None
		:param description: Account description. Passing null will leave the value on the server unchanged.
		:type description: str or None
		:param estimated_size_limit: The number of table cells this account is allowed to store, across all tables. Passing null will leave the value on the server unchanged.
		:type estimated_size_limit: int or None
		:param max_row_limit: Maximum number of rows this account may export at one time. Passing null will leave the value on the server unchanged.
		:type max_row_limit: int or None
		:param max_cell_limit: Maximum number of cells this account may export from a raster at one time. Passing null will leave the value on the server unchanged.
		:type max_cell_limit: int or None
		:param allow_anonymous_downloads: Allow downloads from this account without authentication. Passing null will leave the value on the server unchanged.
		:type allow_anonymous_downloads: bool or None
		:param use_resource_permissions: Set to true to enable fine-grained access control over tables and other resources. Passing null will leave the value on the server unchanged.
		:type use_resource_permissions: bool or None
		:param is_organization: Set to true if this account is an organization and adminstrators can issue public registration links from it. Passing null will leave the value on the server unchanged.
		:type is_organization: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._estimated_size_limit = cast(Optional[int], kwargs.get("estimated_size_limit"))
		self._max_row_limit = cast(Optional[int], kwargs.get("max_row_limit"))
		self._max_cell_limit = cast(Optional[int], kwargs.get("max_cell_limit"))
		self._allow_anonymous_downloads = cast(Optional[bool], kwargs.get("allow_anonymous_downloads"))
		self._use_resource_permissions = cast(Optional[bool], kwargs.get("use_resource_permissions"))
		self._is_organization = cast(Optional[bool], kwargs.get("is_organization"))
	@property
	def name(self) -> Optional["str"]:
		"""Account name. Usually matches `code`. Passing null will leave the value on the server unchanged."""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""Account name. Usually matches `code`. Passing null will leave the value on the server unchanged."""
		self._name = value
	@property
	def description(self) -> Optional["str"]:
		"""Account description. Passing null will leave the value on the server unchanged."""
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		"""Account description. Passing null will leave the value on the server unchanged."""
		self._description = value
	@property
	def estimated_size_limit(self) -> Optional["int"]:
		"""The number of table cells this account is allowed to store, across all tables. Passing null will leave the value on the server unchanged."""
		return self._estimated_size_limit
	@estimated_size_limit.setter
	def estimated_size_limit(self, value: Optional["int"]) -> None:
		"""The number of table cells this account is allowed to store, across all tables. Passing null will leave the value on the server unchanged."""
		self._estimated_size_limit = value
	@property
	def max_row_limit(self) -> Optional["int"]:
		"""Maximum number of rows this account may export at one time. Passing null will leave the value on the server unchanged."""
		return self._max_row_limit
	@max_row_limit.setter
	def max_row_limit(self, value: Optional["int"]) -> None:
		"""Maximum number of rows this account may export at one time. Passing null will leave the value on the server unchanged."""
		self._max_row_limit = value
	@property
	def max_cell_limit(self) -> Optional["int"]:
		"""Maximum number of cells this account may export from a raster at one time. Passing null will leave the value on the server unchanged."""
		return self._max_cell_limit
	@max_cell_limit.setter
	def max_cell_limit(self, value: Optional["int"]) -> None:
		"""Maximum number of cells this account may export from a raster at one time. Passing null will leave the value on the server unchanged."""
		self._max_cell_limit = value
	@property
	def allow_anonymous_downloads(self) -> Optional["bool"]:
		"""Allow downloads from this account without authentication. Passing null will leave the value on the server unchanged."""
		return self._allow_anonymous_downloads
	@allow_anonymous_downloads.setter
	def allow_anonymous_downloads(self, value: Optional["bool"]) -> None:
		"""Allow downloads from this account without authentication. Passing null will leave the value on the server unchanged."""
		self._allow_anonymous_downloads = value
	@property
	def use_resource_permissions(self) -> Optional["bool"]:
		"""Set to true to enable fine-grained access control over tables and other resources. Passing null will leave the value on the server unchanged."""
		return self._use_resource_permissions
	@use_resource_permissions.setter
	def use_resource_permissions(self, value: Optional["bool"]) -> None:
		"""Set to true to enable fine-grained access control over tables and other resources. Passing null will leave the value on the server unchanged."""
		self._use_resource_permissions = value
	@property
	def is_organization(self) -> Optional["bool"]:
		"""Set to true if this account is an organization and adminstrators can issue public registration links from it. Passing null will leave the value on the server unchanged."""
		return self._is_organization
	@is_organization.setter
	def is_organization(self, value: Optional["bool"]) -> None:
		"""Set to true if this account is an organization and adminstrators can issue public registration links from it. Passing null will leave the value on the server unchanged."""
		self._is_organization = value
class UpdateBandwidthLimitRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"limit_bytes": ("limitBytes", "int", None),
		"period": ("period", "str", None),
		"bandwidth_limit_type": ("bandwidthLimitType", "BandwidthLimitType", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		limit_bytes: "int",
		period: "str",
		bandwidth_limit_type: Optional["BandwidthLimitType"] = None,
	) -> None:
		"""
		:param limit_bytes: The target number of bytes to send or receive in the defined Period.
		:type limit_bytes: int
		:param period: The amount of time that the bandwidth limit applies to.  Specified in HH:MM:SS or DD.HH:MM:SS formats
		:type period: str
		:param bandwidth_limit_type: Defines how the bandwidth limit is applied. Options are 'Additional' or 'Exception'
		:type bandwidth_limit_type: BandwidthLimitType or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._limit_bytes = cast(int, kwargs.get("limit_bytes"))
		self._period = cast(str, kwargs.get("period"))
		self._bandwidth_limit_type = cast(Optional[BandwidthLimitType], kwargs.get("bandwidth_limit_type"))
	@property
	def limit_bytes(self) -> "int":
		"""The target number of bytes to send or receive in the defined Period."""
		return self._limit_bytes
	@limit_bytes.setter
	def limit_bytes(self, value: "int") -> None:
		"""The target number of bytes to send or receive in the defined Period."""
		self._limit_bytes = value
	@property
	def period(self) -> "str":
		"""The amount of time that the bandwidth limit applies to.  Specified in HH:MM:SS or DD.HH:MM:SS formats"""
		return self._period
	@period.setter
	def period(self, value: "str") -> None:
		"""The amount of time that the bandwidth limit applies to.  Specified in HH:MM:SS or DD.HH:MM:SS formats"""
		self._period = value
	@property
	def bandwidth_limit_type(self) -> Optional["BandwidthLimitType"]:
		"""Defines how the bandwidth limit is applied. Options are 'Additional' or 'Exception'"""
		return self._bandwidth_limit_type
	@bandwidth_limit_type.setter
	def bandwidth_limit_type(self, value: Optional["BandwidthLimitType"]) -> None:
		"""Defines how the bandwidth limit is applied. Options are 'Additional' or 'Exception'"""
		self._bandwidth_limit_type = value
class UpdateCentralServerRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"target_url": ("targetURL", "str", None),
		"auth_provider_type": ("authProviderType", "AuthProviderType", None),
		"auth_url": ("authURL", "str", None),
		"auth_username": ("authUsername", "str", None),
		"auth_password": ("authPassword", "str", None),
		"tag_behavior": ("tagBehavior", None, None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: Optional["str"] = None,
		target_url: Optional["str"] = None,
		auth_provider_type: Optional["AuthProviderType"] = None,
		auth_url: Optional["str"] = None,
		auth_username: Optional["str"] = None,
		auth_password: Optional["str"] = None,
		tag_behavior: Optional["Any"] = None,
	) -> None:
		"""
		:param name:
		:type name: str or None
		:param target_url:
		:type target_url: str or None
		:param auth_provider_type: 
* `Basic` - Standard MapLarge authentication.
		:type auth_provider_type: AuthProviderType or None
		:param auth_url:
		:type auth_url: str or None
		:param auth_username:
		:type auth_username: str or None
		:param auth_password:
		:type auth_password: str or None
		:param tag_behavior:
		:type tag_behavior: Any or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._target_url = cast(Optional[str], kwargs.get("target_url"))
		self._auth_provider_type = cast(Optional[AuthProviderType], kwargs.get("auth_provider_type"))
		self._auth_url = cast(Optional[str], kwargs.get("auth_url"))
		self._auth_username = cast(Optional[str], kwargs.get("auth_username"))
		self._auth_password = cast(Optional[str], kwargs.get("auth_password"))
		self._tag_behavior = kwargs.get("tag_behavior")
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def target_url(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._target_url
	@target_url.setter
	def target_url(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._target_url = value
	@property
	def auth_provider_type(self) -> Optional["AuthProviderType"]:
		"""
* `Basic` - Standard MapLarge authentication."""
		return self._auth_provider_type
	@auth_provider_type.setter
	def auth_provider_type(self, value: Optional["AuthProviderType"]) -> None:
		"""
* `Basic` - Standard MapLarge authentication."""
		self._auth_provider_type = value
	@property
	def auth_url(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._auth_url
	@auth_url.setter
	def auth_url(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._auth_url = value
	@property
	def auth_username(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._auth_username
	@auth_username.setter
	def auth_username(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._auth_username = value
	@property
	def auth_password(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._auth_password
	@auth_password.setter
	def auth_password(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._auth_password = value
	@property
	def tag_behavior(self) -> Optional["Any"]:
		# pylint: disable=missing-function-docstring
		return self._tag_behavior
	@tag_behavior.setter
	def tag_behavior(self, value: Optional["Any"]) -> None:
		# pylint: disable=missing-function-docstring
		self._tag_behavior = value
class UpdateConstraint:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"tests": ("tests", "list", "UpdateConstraintTest"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		tests: "List[UpdateConstraintTest]",
	) -> None:
		"""
		:param tests:
		:type tests: List[UpdateConstraintTest]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._tests = cast(List[UpdateConstraintTest], kwargs.get("tests"))
	@property
	def tests(self) -> "List[UpdateConstraintTest]":
		# pylint: disable=missing-function-docstring
		return self._tests
	@tests.setter
	def tests(self, value: "List[UpdateConstraintTest]") -> None:
		# pylint: disable=missing-function-docstring
		self._tests = value
class UpdateConstraintTest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"column": ("column", "str", None),
		"test": ("test", "str", None),
		"constant_constraint": ("constantConstraint", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		column: Optional["str"] = None,
		test: Optional["str"] = None,
		constant_constraint: Optional["str"] = None,
	) -> None:
		"""
		:param column:
		:type column: str or None
		:param test:
		:type test: str or None
		:param constant_constraint:
		:type constant_constraint: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._column = cast(Optional[str], kwargs.get("column"))
		self._test = cast(Optional[str], kwargs.get("test"))
		self._constant_constraint = cast(Optional[str], kwargs.get("constant_constraint"))
	@property
	def column(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._column
	@column.setter
	def column(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column = value
	@property
	def test(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._test
	@test.setter
	def test(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._test = value
	@property
	def constant_constraint(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._constant_constraint
	@constant_constraint.setter
	def constant_constraint(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._constant_constraint = value
class UpdateDataStreamResourceRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"unique_id": ("uniqueID", "str", None),
		"resource_definition": ("resourceDefinition", "str", None),
		"resource_bytes": ("resourceBytes", "File", None),
		"is_binary_resource": ("isBinaryResource", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		resource_bytes: "File",
		is_binary_resource: "bool",
		unique_id: Optional["str"] = None,
		resource_definition: Optional["str"] = None,
	) -> None:
		"""
		:param name: The ramp's unique human friendly identifier
		:type name: str
		:param resource_bytes: A binary resource byte array
		:type resource_bytes: File
		:param is_binary_resource: A string indicating whether or not a resource is binary. 'true' for binary, 'false' for plain text
		:type is_binary_resource: bool
		:param unique_id: The resource's unique id
		:type unique_id: str or None
		:param resource_definition: A plain text resource
		:type resource_definition: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._unique_id = cast(Optional[str], kwargs.get("unique_id"))
		self._resource_definition = cast(Optional[str], kwargs.get("resource_definition"))
		self._resource_bytes = cast(File, kwargs.get("resource_bytes"))
		self._is_binary_resource = cast(bool, kwargs.get("is_binary_resource"))
	@property
	def name(self) -> "str":
		"""The ramp's unique human friendly identifier"""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The ramp's unique human friendly identifier"""
		self._name = value
	@property
	def unique_id(self) -> Optional["str"]:
		"""The resource's unique id"""
		return self._unique_id
	@unique_id.setter
	def unique_id(self, value: Optional["str"]) -> None:
		"""The resource's unique id"""
		self._unique_id = value
	@property
	def resource_definition(self) -> Optional["str"]:
		"""A plain text resource"""
		return self._resource_definition
	@resource_definition.setter
	def resource_definition(self, value: Optional["str"]) -> None:
		"""A plain text resource"""
		self._resource_definition = value
	@property
	def resource_bytes(self) -> "File":
		"""A binary resource byte array"""
		return self._resource_bytes
	@resource_bytes.setter
	def resource_bytes(self, value: "File") -> None:
		"""A binary resource byte array"""
		self._resource_bytes = value
	@property
	def is_binary_resource(self) -> "bool":
		"""A string indicating whether or not a resource is binary. 'true' for binary, 'false' for plain text"""
		return self._is_binary_resource
	@is_binary_resource.setter
	def is_binary_resource(self, value: "bool") -> None:
		"""A string indicating whether or not a resource is binary. 'true' for binary, 'false' for plain text"""
		self._is_binary_resource = value
class UpdateGroupRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"description": ("description", "str", None),
		"permission_level": ("permissionLevel", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: Optional["str"] = None,
		description: Optional["str"] = None,
		permission_level: Optional["str"] = None,
	) -> None:
		"""
		:param name: The name of the group. Unique within an account. Passing null will leave the value on the server unchanged.
		:type name: str or None
		:param description: The group description. Passing null will leave the value on the server unchanged.
		:type description: str or None
		:param permission_level: The level of access assigned to this group. Typical values are: viewer, editor, admin, and custom. The possible values are configurable. Passing null will leave the value on the server unchanged.
		:type permission_level: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._description = cast(Optional[str], kwargs.get("description"))
		self._permission_level = cast(Optional[str], kwargs.get("permission_level"))
	@property
	def name(self) -> Optional["str"]:
		"""The name of the group. Unique within an account. Passing null will leave the value on the server unchanged."""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""The name of the group. Unique within an account. Passing null will leave the value on the server unchanged."""
		self._name = value
	@property
	def description(self) -> Optional["str"]:
		"""The group description. Passing null will leave the value on the server unchanged."""
		return self._description
	@description.setter
	def description(self, value: Optional["str"]) -> None:
		"""The group description. Passing null will leave the value on the server unchanged."""
		self._description = value
	@property
	def permission_level(self) -> Optional["str"]:
		"""The level of access assigned to this group. Typical values are: viewer, editor, admin, and custom. The possible values are configurable. Passing null will leave the value on the server unchanged."""
		return self._permission_level
	@permission_level.setter
	def permission_level(self, value: Optional["str"]) -> None:
		"""The level of access assigned to this group. Typical values are: viewer, editor, admin, and custom. The possible values are configurable. Passing null will leave the value on the server unchanged."""
		self._permission_level = value
class UpdatePipelineRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"pipeline_definition": ("pipelineDefinition", None, None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: "str",
		pipeline_definition: Optional["Any"] = None,
	) -> None:
		"""
		:param name: The ramp's unique human friendly identifier
		:type name: str
		:param pipeline_definition: A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified.
		:type pipeline_definition: Any or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(str, kwargs.get("name"))
		self._pipeline_definition = kwargs.get("pipeline_definition")
	@property
	def name(self) -> "str":
		"""The ramp's unique human friendly identifier"""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The ramp's unique human friendly identifier"""
		self._name = value
	@property
	def pipeline_definition(self) -> Optional["Any"]:
		"""A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified."""
		return self._pipeline_definition
	@pipeline_definition.setter
	def pipeline_definition(self, value: Optional["Any"]) -> None:
		"""A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified."""
		self._pipeline_definition = value
class UpdateRampRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"well_known_pipeline_id": ("wellKnownPipelineId", "str", None),
		"name": ("name", "str", None),
		"requested_status": ("requestedStatus", "str", None),
		"connector_app_name": ("connectorAppName", "str", None),
		"connector_plugin_name": ("connectorPluginName", "str", None),
		"connector_options": ("connectorOptions", None, None),
		"pipeline_definition": ("pipelineDefinition", None, None),
		"required_cluster_role": ("requiredClusterRole", "str", None),
		"pipeline_parameters": ("pipelineParameters", "dict", "str"),
		"verbose_logging": ("verboseLogging", "bool", None),
		"table_logging": ("tableLogging", "bool", None),
		"faulted_retry_attempts": ("faultedRetryAttempts", "int", None),
		"faulted_retry_delay": ("faultedRetryDelay", "int", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		pipeline_parameters: "Dict[str, str]",
		verbose_logging: "bool",
		table_logging: "bool",
		well_known_pipeline_id: Optional["str"] = None,
		name: Optional["str"] = None,
		requested_status: Optional["str"] = None,
		connector_app_name: Optional["str"] = None,
		connector_plugin_name: Optional["str"] = None,
		connector_options: Optional["Any"] = None,
		pipeline_definition: Optional["Any"] = None,
		required_cluster_role: Optional["str"] = None,
		faulted_retry_attempts: Optional["int"] = None,
		faulted_retry_delay: Optional["int"] = None,
	) -> None:
		"""
		:param pipeline_parameters: A collection of key value pairs containing specific pipeline run options and their values
		:type pipeline_parameters: Dict[str, str]
		:param verbose_logging: If true, detailed pipeline execution results are added to the server log if Information level logging is enabled.
		:type verbose_logging: bool
		:param table_logging: If true, detailed pipeline execution results are logged to a table.
		:type table_logging: bool
		:param well_known_pipeline_id: The id of an existing pipeline. Either this or PipelineDefinition must be specified.
		:type well_known_pipeline_id: str or None
		:param name: The ramp's unique human friendly identifier
		:type name: str or None
		:param requested_status: The ramp's desired execution state. Either 'Started' or 'Stopped'
		:type requested_status: str or None
		:param connector_app_name: The name of the Maplarge application that contains the connector or observer plugin. Either 'MapLargeCore' or the name of a custom application build with the Maplarge Development Kit (ADK).'
		:type connector_app_name: str or None
		:param connector_plugin_name: The name of the connector or observer plugin.
		:type connector_plugin_name: str or None
		:param connector_options: A JSON object containing parameters for the specified connector or observer.
		:type connector_options: Any or None
		:param pipeline_definition: A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified.
		:type pipeline_definition: Any or None
		:param required_cluster_role: The required role of node within a cluster required to execute the ramp, if any. May be required if duplicates are possible in the pipeline input.
		:type required_cluster_role: str or None
		:param faulted_retry_attempts: The number of times that MapLarge will automatically retry when the ramp encounters an error.
		:type faulted_retry_attempts: int or None
		:param faulted_retry_delay: The minimum delay (in seconds) before the ramp will automatically retry when the ramp encounters an error.
		:type faulted_retry_delay: int or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._well_known_pipeline_id = cast(Optional[str], kwargs.get("well_known_pipeline_id"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._requested_status = cast(Optional[str], kwargs.get("requested_status"))
		self._connector_app_name = cast(Optional[str], kwargs.get("connector_app_name"))
		self._connector_plugin_name = cast(Optional[str], kwargs.get("connector_plugin_name"))
		self._connector_options = kwargs.get("connector_options")
		self._pipeline_definition = kwargs.get("pipeline_definition")
		self._required_cluster_role = cast(Optional[str], kwargs.get("required_cluster_role"))
		self._pipeline_parameters = cast(Dict[str, str], kwargs.get("pipeline_parameters"))
		self._verbose_logging = cast(bool, kwargs.get("verbose_logging"))
		self._table_logging = cast(bool, kwargs.get("table_logging"))
		self._faulted_retry_attempts = cast(Optional[int], kwargs.get("faulted_retry_attempts"))
		self._faulted_retry_delay = cast(Optional[int], kwargs.get("faulted_retry_delay"))
	@property
	def well_known_pipeline_id(self) -> Optional["str"]:
		"""The id of an existing pipeline. Either this or PipelineDefinition must be specified."""
		return self._well_known_pipeline_id
	@well_known_pipeline_id.setter
	def well_known_pipeline_id(self, value: Optional["str"]) -> None:
		"""The id of an existing pipeline. Either this or PipelineDefinition must be specified."""
		self._well_known_pipeline_id = value
	@property
	def name(self) -> Optional["str"]:
		"""The ramp's unique human friendly identifier"""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""The ramp's unique human friendly identifier"""
		self._name = value
	@property
	def requested_status(self) -> Optional["str"]:
		"""The ramp's desired execution state. Either 'Started' or 'Stopped'"""
		return self._requested_status
	@requested_status.setter
	def requested_status(self, value: Optional["str"]) -> None:
		"""The ramp's desired execution state. Either 'Started' or 'Stopped'"""
		self._requested_status = value
	@property
	def connector_app_name(self) -> Optional["str"]:
		"""The name of the Maplarge application that contains the connector or observer plugin. Either 'MapLargeCore' or the name of a custom application build with the Maplarge Development Kit (ADK).'"""
		return self._connector_app_name
	@connector_app_name.setter
	def connector_app_name(self, value: Optional["str"]) -> None:
		"""The name of the Maplarge application that contains the connector or observer plugin. Either 'MapLargeCore' or the name of a custom application build with the Maplarge Development Kit (ADK).'"""
		self._connector_app_name = value
	@property
	def connector_plugin_name(self) -> Optional["str"]:
		"""The name of the connector or observer plugin."""
		return self._connector_plugin_name
	@connector_plugin_name.setter
	def connector_plugin_name(self, value: Optional["str"]) -> None:
		"""The name of the connector or observer plugin."""
		self._connector_plugin_name = value
	@property
	def connector_options(self) -> Optional["Any"]:
		"""A JSON object containing parameters for the specified connector or observer."""
		return self._connector_options
	@connector_options.setter
	def connector_options(self, value: Optional["Any"]) -> None:
		"""A JSON object containing parameters for the specified connector or observer."""
		self._connector_options = value
	@property
	def pipeline_definition(self) -> Optional["Any"]:
		"""A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified."""
		return self._pipeline_definition
	@pipeline_definition.setter
	def pipeline_definition(self, value: Optional["Any"]) -> None:
		"""A JSON object describing an adhoc pipeline. Either this or WellKnownPipelineId must be specified."""
		self._pipeline_definition = value
	@property
	def required_cluster_role(self) -> Optional["str"]:
		"""The required role of node within a cluster required to execute the ramp, if any. May be required if duplicates are possible in the pipeline input."""
		return self._required_cluster_role
	@required_cluster_role.setter
	def required_cluster_role(self, value: Optional["str"]) -> None:
		"""The required role of node within a cluster required to execute the ramp, if any. May be required if duplicates are possible in the pipeline input."""
		self._required_cluster_role = value
	@property
	def pipeline_parameters(self) -> "Dict[str, str]":
		"""A collection of key value pairs containing specific pipeline run options and their values"""
		return self._pipeline_parameters
	@pipeline_parameters.setter
	def pipeline_parameters(self, value: "Dict[str, str]") -> None:
		"""A collection of key value pairs containing specific pipeline run options and their values"""
		self._pipeline_parameters = value
	@property
	def verbose_logging(self) -> "bool":
		"""If true, detailed pipeline execution results are added to the server log if Information level logging is enabled."""
		return self._verbose_logging
	@verbose_logging.setter
	def verbose_logging(self, value: "bool") -> None:
		"""If true, detailed pipeline execution results are added to the server log if Information level logging is enabled."""
		self._verbose_logging = value
	@property
	def table_logging(self) -> "bool":
		"""If true, detailed pipeline execution results are logged to a table."""
		return self._table_logging
	@table_logging.setter
	def table_logging(self, value: "bool") -> None:
		"""If true, detailed pipeline execution results are logged to a table."""
		self._table_logging = value
	@property
	def faulted_retry_attempts(self) -> Optional["int"]:
		"""The number of times that MapLarge will automatically retry when the ramp encounters an error."""
		return self._faulted_retry_attempts
	@faulted_retry_attempts.setter
	def faulted_retry_attempts(self, value: Optional["int"]) -> None:
		"""The number of times that MapLarge will automatically retry when the ramp encounters an error."""
		self._faulted_retry_attempts = value
	@property
	def faulted_retry_delay(self) -> Optional["int"]:
		"""The minimum delay (in seconds) before the ramp will automatically retry when the ramp encounters an error."""
		return self._faulted_retry_delay
	@faulted_retry_delay.setter
	def faulted_retry_delay(self, value: Optional["int"]) -> None:
		"""The minimum delay (in seconds) before the ramp will automatically retry when the ramp encounters an error."""
		self._faulted_retry_delay = value
class UpdateResourceFolderRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"path": ("path", "str", None),
		"inherit_permissions": ("inheritPermissions", "bool", None),
		"copy_permissions_from_parent": ("copyPermissionsFromParent", "bool", None),
		"permissions": ("permissions", "list", "ResourcePermission"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		permissions: "List[ResourcePermission]",
		path: Optional["str"] = None,
		inherit_permissions: Optional["bool"] = None,
		copy_permissions_from_parent: Optional["bool"] = None,
	) -> None:
		"""
		:param permissions: The list of permissions assigned to this folder. Passing null will leave the value on the server unchanged.
		:type permissions: List[ResourcePermission]
		:param path: The full path of the folder, ending with this folder's `name`. Passing null will leave the value on the server unchanged.
		:type path: str or None
		:param inherit_permissions: Flag indicating whether or not to include the parent folder's permissions with this folder's permissions. Passing null will leave the value on the server unchanged.
		:type inherit_permissions: bool or None
		:param copy_permissions_from_parent:
		:type copy_permissions_from_parent: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._path = cast(Optional[str], kwargs.get("path"))
		self._inherit_permissions = cast(Optional[bool], kwargs.get("inherit_permissions"))
		self._copy_permissions_from_parent = cast(Optional[bool], kwargs.get("copy_permissions_from_parent"))
		self._permissions = cast(List[ResourcePermission], kwargs.get("permissions"))
	@property
	def path(self) -> Optional["str"]:
		"""The full path of the folder, ending with this folder's `name`. Passing null will leave the value on the server unchanged."""
		return self._path
	@path.setter
	def path(self, value: Optional["str"]) -> None:
		"""The full path of the folder, ending with this folder's `name`. Passing null will leave the value on the server unchanged."""
		self._path = value
	@property
	def inherit_permissions(self) -> Optional["bool"]:
		"""Flag indicating whether or not to include the parent folder's permissions with this folder's permissions. Passing null will leave the value on the server unchanged."""
		return self._inherit_permissions
	@inherit_permissions.setter
	def inherit_permissions(self, value: Optional["bool"]) -> None:
		"""Flag indicating whether or not to include the parent folder's permissions with this folder's permissions. Passing null will leave the value on the server unchanged."""
		self._inherit_permissions = value
	@property
	def copy_permissions_from_parent(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._copy_permissions_from_parent
	@copy_permissions_from_parent.setter
	def copy_permissions_from_parent(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._copy_permissions_from_parent = value
	@property
	def permissions(self) -> "List[ResourcePermission]":
		"""The list of permissions assigned to this folder. Passing null will leave the value on the server unchanged."""
		return self._permissions
	@permissions.setter
	def permissions(self, value: "List[ResourcePermission]") -> None:
		"""The list of permissions assigned to this folder. Passing null will leave the value on the server unchanged."""
		self._permissions = value
class UpdateResourceRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"path": ("path", "str", None),
		"urn": ("urn", "str", None),
		"inherit_permissions": ("inheritPermissions", "bool", None),
		"copy_permissions_from_parent": ("copyPermissionsFromParent", "bool", None),
		"permissions": ("permissions", "list", "ResourcePermission"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		urn: "str",
		permissions: "List[ResourcePermission]",
		path: Optional["str"] = None,
		inherit_permissions: Optional["bool"] = None,
		copy_permissions_from_parent: Optional["bool"] = None,
	) -> None:
		"""
		:param urn: A URN of the format "maplarge://{accountcode}/{resourcetype}/{name}".
		:type urn: str
		:param permissions:
		:type permissions: List[ResourcePermission]
		:param path:
		:type path: str or None
		:param inherit_permissions:
		:type inherit_permissions: bool or None
		:param copy_permissions_from_parent:
		:type copy_permissions_from_parent: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._path = cast(Optional[str], kwargs.get("path"))
		self._urn = cast(str, kwargs.get("urn"))
		self._inherit_permissions = cast(Optional[bool], kwargs.get("inherit_permissions"))
		self._copy_permissions_from_parent = cast(Optional[bool], kwargs.get("copy_permissions_from_parent"))
		self._permissions = cast(List[ResourcePermission], kwargs.get("permissions"))
	@property
	def path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._path
	@path.setter
	def path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path = value
	@property
	def urn(self) -> "str":
		"""A URN of the format "maplarge://{accountcode}/{resourcetype}/{name}"."""
		return self._urn
	@urn.setter
	def urn(self, value: "str") -> None:
		"""A URN of the format "maplarge://{accountcode}/{resourcetype}/{name}"."""
		self._urn = value
	@property
	def inherit_permissions(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._inherit_permissions
	@inherit_permissions.setter
	def inherit_permissions(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._inherit_permissions = value
	@property
	def copy_permissions_from_parent(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._copy_permissions_from_parent
	@copy_permissions_from_parent.setter
	def copy_permissions_from_parent(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._copy_permissions_from_parent = value
	@property
	def permissions(self) -> "List[ResourcePermission]":
		# pylint: disable=missing-function-docstring
		return self._permissions
	@permissions.setter
	def permissions(self, value: "List[ResourcePermission]") -> None:
		# pylint: disable=missing-function-docstring
		self._permissions = value
class UpdateSelfRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"password": ("password", "str", None),
		"first_name": ("firstName", "str", None),
		"last_name": ("lastName", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		password: Optional["str"] = None,
		first_name: Optional["str"] = None,
		last_name: Optional["str"] = None,
	) -> None:
		"""
		:param password: The user's new password.
		:type password: str or None
		:param first_name: The first name of the user.
		:type first_name: str or None
		:param last_name: The last name of the user.
		:type last_name: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._password = cast(Optional[str], kwargs.get("password"))
		self._first_name = cast(Optional[str], kwargs.get("first_name"))
		self._last_name = cast(Optional[str], kwargs.get("last_name"))
	@property
	def password(self) -> Optional["str"]:
		"""The user's new password."""
		return self._password
	@password.setter
	def password(self, value: Optional["str"]) -> None:
		"""The user's new password."""
		self._password = value
	@property
	def first_name(self) -> Optional["str"]:
		"""The first name of the user."""
		return self._first_name
	@first_name.setter
	def first_name(self, value: Optional["str"]) -> None:
		"""The first name of the user."""
		self._first_name = value
	@property
	def last_name(self) -> Optional["str"]:
		"""The last name of the user."""
		return self._last_name
	@last_name.setter
	def last_name(self, value: Optional["str"]) -> None:
		"""The last name of the user."""
		self._last_name = value
class UpdateTableTagOptions:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"preview": ("preview", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		preview: Optional["bool"] = None,
	) -> None:
		"""
		:param preview: If true, only perform validation - do not persist any changes.
		:type preview: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._preview = cast(Optional[bool], kwargs.get("preview"))
	@property
	def preview(self) -> Optional["bool"]:
		"""If true, only perform validation - do not persist any changes."""
		return self._preview
	@preview.setter
	def preview(self, value: Optional["bool"]) -> None:
		"""If true, only perform validation - do not persist any changes."""
		self._preview = value
class UpdateTableTagRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"value": ("value", "str", None),
		"options": ("options", "UpdateTableTagOptions", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		value: "str",
		options: Optional["UpdateTableTagOptions"] = None,
	) -> None:
		"""
		:param value:
		:type value: str
		:param options:
		:type options: UpdateTableTagOptions or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._value = cast(str, kwargs.get("value"))
		self._options = cast(Optional[UpdateTableTagOptions], kwargs.get("options"))
	@property
	def value(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._value
	@value.setter
	def value(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._value = value
	@property
	def options(self) -> Optional["UpdateTableTagOptions"]:
		# pylint: disable=missing-function-docstring
		return self._options
	@options.setter
	def options(self, value: Optional["UpdateTableTagOptions"]) -> None:
		# pylint: disable=missing-function-docstring
		self._options = value
class UpdateUserRequest:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"name": ("name", "str", None),
		"email": ("email", "str", None),
		"first_name": ("firstName", "str", None),
		"last_name": ("lastName", "str", None),
		"password": ("password", "str", None),
		"user_disabled": ("userDisabled", "bool", None),
		"imports_disabled": ("importsDisabled", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		name: Optional["str"] = None,
		email: Optional["str"] = None,
		first_name: Optional["str"] = None,
		last_name: Optional["str"] = None,
		password: Optional["str"] = None,
		user_disabled: Optional["bool"] = None,
		imports_disabled: Optional["bool"] = None,
	) -> None:
		"""
		:param name: The name of the user. Passing null will leave the value on the server unchanged.
		:type name: str or None
		:param email: The user's email address. Must be unique. Passing null will leave the value on the server unchanged.
		:type email: str or None
		:param first_name: The first name of the user.
		:type first_name: str or None
		:param last_name: The last name of the user.
		:type last_name: str or None
		:param password: The user's password. Passing null will leave the value on the server unchanged.
		:type password: str or None
		:param user_disabled: Disabled users are not allowed to successfully authenticate. Passing null will leave the value on the server unchanged.
		:type user_disabled: bool or None
		:param imports_disabled: Flag indicating whether this user may currently import new tables. Passing null will leave the value on the server unchanged.
		:type imports_disabled: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._name = cast(Optional[str], kwargs.get("name"))
		self._email = cast(Optional[str], kwargs.get("email"))
		self._first_name = cast(Optional[str], kwargs.get("first_name"))
		self._last_name = cast(Optional[str], kwargs.get("last_name"))
		self._password = cast(Optional[str], kwargs.get("password"))
		self._user_disabled = cast(Optional[bool], kwargs.get("user_disabled"))
		self._imports_disabled = cast(Optional[bool], kwargs.get("imports_disabled"))
	@property
	def name(self) -> Optional["str"]:
		"""The name of the user. Passing null will leave the value on the server unchanged."""
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		"""The name of the user. Passing null will leave the value on the server unchanged."""
		self._name = value
	@property
	def email(self) -> Optional["str"]:
		"""The user's email address. Must be unique. Passing null will leave the value on the server unchanged."""
		return self._email
	@email.setter
	def email(self, value: Optional["str"]) -> None:
		"""The user's email address. Must be unique. Passing null will leave the value on the server unchanged."""
		self._email = value
	@property
	def first_name(self) -> Optional["str"]:
		"""The first name of the user."""
		return self._first_name
	@first_name.setter
	def first_name(self, value: Optional["str"]) -> None:
		"""The first name of the user."""
		self._first_name = value
	@property
	def last_name(self) -> Optional["str"]:
		"""The last name of the user."""
		return self._last_name
	@last_name.setter
	def last_name(self, value: Optional["str"]) -> None:
		"""The last name of the user."""
		self._last_name = value
	@property
	def password(self) -> Optional["str"]:
		"""The user's password. Passing null will leave the value on the server unchanged."""
		return self._password
	@password.setter
	def password(self, value: Optional["str"]) -> None:
		"""The user's password. Passing null will leave the value on the server unchanged."""
		self._password = value
	@property
	def user_disabled(self) -> Optional["bool"]:
		"""Disabled users are not allowed to successfully authenticate. Passing null will leave the value on the server unchanged."""
		return self._user_disabled
	@user_disabled.setter
	def user_disabled(self, value: Optional["bool"]) -> None:
		"""Disabled users are not allowed to successfully authenticate. Passing null will leave the value on the server unchanged."""
		self._user_disabled = value
	@property
	def imports_disabled(self) -> Optional["bool"]:
		"""Flag indicating whether this user may currently import new tables. Passing null will leave the value on the server unchanged."""
		return self._imports_disabled
	@imports_disabled.setter
	def imports_disabled(self, value: Optional["bool"]) -> None:
		"""Flag indicating whether this user may currently import new tables. Passing null will leave the value on the server unchanged."""
		self._imports_disabled = value
class User:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "int", None),
		"name": ("name", "str", None),
		"email": ("email", "str", None),
		"first_name": ("firstName", "str", None),
		"last_name": ("lastName", "str", None),
		"tags": ("tags", "list", "str"),
		"last_password_update": ("lastPasswordUpdate", "datetime", None),
		"password_change_required": ("passwordChangeRequired", "bool", None),
		"last_login": ("lastLogin", "datetime", None),
		"user_disabled": ("userDisabled", "bool", None),
		"imports_disabled": ("importsDisabled", "bool", None),
		"disable_reason": ("disableReason", "UserDisableReason", None),
		"password_expires_on": ("passwordExpiresOn", "datetime", None),
		"phone_number": ("phoneNumber", "str", None),
		"friendly_name": ("friendlyName", "str", None),
		"personal_account": ("personalAccount", "AccountReference", None),
		"links": ("_links", "UserLinks", None),
		"embedded": ("_embedded", "UserResources", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "int",
		name: "str",
		email: "str",
		first_name: "str",
		last_name: "str",
		tags: "List[str]",
		password_change_required: "bool",
		user_disabled: "bool",
		imports_disabled: "bool",
		disable_reason: "UserDisableReason",
		links: "UserLinks",
		last_password_update: Optional["datetime"] = None,
		last_login: Optional["datetime"] = None,
		password_expires_on: Optional["datetime"] = None,
		phone_number: Optional["str"] = None,
		friendly_name: Optional["str"] = None,
		personal_account: Optional["AccountReference"] = None,
		embedded: Optional["UserResources"] = None,
	) -> None:
		"""
		:param id_: The unique numeric ID of the user.
		:type id_: int
		:param name: The name of the user.
		:type name: str
		:param email: The user's email address. Must be unique.
		:type email: str
		:param first_name: The first name of the user.
		:type first_name: str
		:param last_name: The last name of the user.
		:type last_name: str
		:param tags: A collection of string identifiers applied to a user, which can be used for a variety of purposes. This property is not available in the `users/self` response.
		:type tags: List[str]
		:param password_change_required: Flag indicating whether this user will be required to change their password at next log in.
		:type password_change_required: bool
		:param user_disabled: Disabled users are not allowed to successfully authenticate.
		:type user_disabled: bool
		:param imports_disabled: Flag indicating whether this user may currently import new tables.
		:type imports_disabled: bool
		:param disable_reason: The reason the user has been disabled.
* `None` - The user is not disabled.
* `Manual` - The user was manually disabled.
* `PasswordFailure` - The user was automatically disabled because of too many invalid password attempts.
		:type disable_reason: UserDisableReason
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: UserLinks
		:param last_password_update: The UTC date/time when this user's password was last changed.
		:type last_password_update: datetime or None
		:param last_login: The UTC date/time when this user last successfully authenticated.
		:type last_login: datetime or None
		:param password_expires_on: The UTC date/time when this user will be required to change their password.
		:type password_expires_on: datetime or None
		:param phone_number: The user's phone number.
		:type phone_number: str or None
		:param friendly_name: The name used in eamils sent to the user.
		:type friendly_name: str or None
		:param personal_account: An account that belongs specifically to this user. This property is only available in the `users/self` response.
		:type personal_account: AccountReference or None
		:param embedded:
		:type embedded: UserResources or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(int, kwargs.get("id_"))
		self._name = cast(str, kwargs.get("name"))
		self._email = cast(str, kwargs.get("email"))
		self._first_name = cast(str, kwargs.get("first_name"))
		self._last_name = cast(str, kwargs.get("last_name"))
		self._tags = cast(List[str], kwargs.get("tags"))
		self._last_password_update = cast(Optional[datetime], kwargs.get("last_password_update"))
		self._password_change_required = cast(bool, kwargs.get("password_change_required"))
		self._last_login = cast(Optional[datetime], kwargs.get("last_login"))
		self._user_disabled = cast(bool, kwargs.get("user_disabled"))
		self._imports_disabled = cast(bool, kwargs.get("imports_disabled"))
		self._disable_reason = cast(UserDisableReason, kwargs.get("disable_reason"))
		self._password_expires_on = cast(Optional[datetime], kwargs.get("password_expires_on"))
		self._phone_number = cast(Optional[str], kwargs.get("phone_number"))
		self._friendly_name = cast(Optional[str], kwargs.get("friendly_name"))
		self._personal_account = cast(Optional[AccountReference], kwargs.get("personal_account"))
		self._links = cast(UserLinks, kwargs.get("links"))
		self._embedded = cast(Optional[UserResources], kwargs.get("embedded"))
	@property
	def id_(self) -> "int":
		"""The unique numeric ID of the user."""
		return self._id_
	@id_.setter
	def id_(self, value: "int") -> None:
		"""The unique numeric ID of the user."""
		self._id_ = value
	@property
	def name(self) -> "str":
		"""The name of the user."""
		return self._name
	@name.setter
	def name(self, value: "str") -> None:
		"""The name of the user."""
		self._name = value
	@property
	def email(self) -> "str":
		"""The user's email address. Must be unique."""
		return self._email
	@email.setter
	def email(self, value: "str") -> None:
		"""The user's email address. Must be unique."""
		self._email = value
	@property
	def first_name(self) -> "str":
		"""The first name of the user."""
		return self._first_name
	@first_name.setter
	def first_name(self, value: "str") -> None:
		"""The first name of the user."""
		self._first_name = value
	@property
	def last_name(self) -> "str":
		"""The last name of the user."""
		return self._last_name
	@last_name.setter
	def last_name(self, value: "str") -> None:
		"""The last name of the user."""
		self._last_name = value
	@property
	def tags(self) -> "List[str]":
		"""A collection of string identifiers applied to a user, which can be used for a variety of purposes. This property is not available in the `users/self` response."""
		return self._tags
	@tags.setter
	def tags(self, value: "List[str]") -> None:
		"""A collection of string identifiers applied to a user, which can be used for a variety of purposes. This property is not available in the `users/self` response."""
		self._tags = value
	@property
	def last_password_update(self) -> Optional["datetime"]:
		"""The UTC date/time when this user's password was last changed."""
		return self._last_password_update
	@last_password_update.setter
	def last_password_update(self, value: Optional["datetime"]) -> None:
		"""The UTC date/time when this user's password was last changed."""
		self._last_password_update = value
	@property
	def password_change_required(self) -> "bool":
		"""Flag indicating whether this user will be required to change their password at next log in."""
		return self._password_change_required
	@password_change_required.setter
	def password_change_required(self, value: "bool") -> None:
		"""Flag indicating whether this user will be required to change their password at next log in."""
		self._password_change_required = value
	@property
	def last_login(self) -> Optional["datetime"]:
		"""The UTC date/time when this user last successfully authenticated."""
		return self._last_login
	@last_login.setter
	def last_login(self, value: Optional["datetime"]) -> None:
		"""The UTC date/time when this user last successfully authenticated."""
		self._last_login = value
	@property
	def user_disabled(self) -> "bool":
		"""Disabled users are not allowed to successfully authenticate."""
		return self._user_disabled
	@user_disabled.setter
	def user_disabled(self, value: "bool") -> None:
		"""Disabled users are not allowed to successfully authenticate."""
		self._user_disabled = value
	@property
	def imports_disabled(self) -> "bool":
		"""Flag indicating whether this user may currently import new tables."""
		return self._imports_disabled
	@imports_disabled.setter
	def imports_disabled(self, value: "bool") -> None:
		"""Flag indicating whether this user may currently import new tables."""
		self._imports_disabled = value
	@property
	def disable_reason(self) -> "UserDisableReason":
		"""The reason the user has been disabled.
* `None` - The user is not disabled.
* `Manual` - The user was manually disabled.
* `PasswordFailure` - The user was automatically disabled because of too many invalid password attempts."""
		return self._disable_reason
	@disable_reason.setter
	def disable_reason(self, value: "UserDisableReason") -> None:
		"""The reason the user has been disabled.
* `None` - The user is not disabled.
* `Manual` - The user was manually disabled.
* `PasswordFailure` - The user was automatically disabled because of too many invalid password attempts."""
		self._disable_reason = value
	@property
	def password_expires_on(self) -> Optional["datetime"]:
		"""The UTC date/time when this user will be required to change their password."""
		return self._password_expires_on
	@password_expires_on.setter
	def password_expires_on(self, value: Optional["datetime"]) -> None:
		"""The UTC date/time when this user will be required to change their password."""
		self._password_expires_on = value
	@property
	def phone_number(self) -> Optional["str"]:
		"""The user's phone number."""
		return self._phone_number
	@phone_number.setter
	def phone_number(self, value: Optional["str"]) -> None:
		"""The user's phone number."""
		self._phone_number = value
	@property
	def friendly_name(self) -> Optional["str"]:
		"""The name used in eamils sent to the user."""
		return self._friendly_name
	@friendly_name.setter
	def friendly_name(self, value: Optional["str"]) -> None:
		"""The name used in eamils sent to the user."""
		self._friendly_name = value
	@property
	def personal_account(self) -> Optional["AccountReference"]:
		"""An account that belongs specifically to this user. This property is only available in the `users/self` response."""
		return self._personal_account
	@personal_account.setter
	def personal_account(self, value: Optional["AccountReference"]) -> None:
		"""An account that belongs specifically to this user. This property is only available in the `users/self` response."""
		self._personal_account = value
	@property
	def links(self) -> "UserLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "UserLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
	@property
	def embedded(self) -> Optional["UserResources"]:
		# pylint: disable=missing-function-docstring
		return self._embedded
	@embedded.setter
	def embedded(self, value: Optional["UserResources"]) -> None:
		# pylint: disable=missing-function-docstring
		self._embedded = value


class UserDisableReason(str, Enum):
	"""The reason the user has been disabled."""
	NONE = 'None'
	MANUAL = 'Manual'
	PASSWORD_FAILURE = 'PasswordFailure'

UserDisableReason.NONE.__doc__ = """The user is not disabled."""
UserDisableReason.MANUAL.__doc__ = """The user was manually disabled."""
UserDisableReason.PASSWORD_FAILURE.__doc__ = """The user was automatically disabled because of too many invalid password attempts."""
class UserLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"groups": ("groups", "Link", None),
		"personal_account": ("personalAccount", "Link", None),
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		groups: "Link",
		self_: "Link",
		personal_account: Optional["Link"] = None,
	) -> None:
		"""
		:param groups: A link to fetch the list of groups the user is a member of.
		:type groups: Link
		:param self_: A link to the current resource.
		:type self_: Link
		:param personal_account: An account that belongs specifically to this user. This property is only available in the `users/self` response.
		:type personal_account: Link or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._groups = cast(Link, kwargs.get("groups"))
		self._personal_account = cast(Optional[Link], kwargs.get("personal_account"))
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def groups(self) -> "Link":
		"""A link to fetch the list of groups the user is a member of."""
		return self._groups
	@groups.setter
	def groups(self, value: "Link") -> None:
		"""A link to fetch the list of groups the user is a member of."""
		self._groups = value
	@property
	def personal_account(self) -> Optional["Link"]:
		"""An account that belongs specifically to this user. This property is only available in the `users/self` response."""
		return self._personal_account
	@personal_account.setter
	def personal_account(self, value: Optional["Link"]) -> None:
		"""An account that belongs specifically to this user. This property is only available in the `users/self` response."""
		self._personal_account = value
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class UserReference:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("id", "int", None),
		"email": ("email", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "int",
		email: Optional["str"] = None,
	) -> None:
		"""
		:param id_: The unique numeric ID of the user.
		:type id_: int
		:param email: The user's email address. Must be unique.
		:type email: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(int, kwargs.get("id_"))
		self._email = cast(Optional[str], kwargs.get("email"))
	@property
	def id_(self) -> "int":
		"""The unique numeric ID of the user."""
		return self._id_
	@id_.setter
	def id_(self, value: "int") -> None:
		"""The unique numeric ID of the user."""
		self._id_ = value
	@property
	def email(self) -> Optional["str"]:
		"""The user's email address. Must be unique."""
		return self._email
	@email.setter
	def email(self, value: Optional["str"]) -> None:
		"""The user's email address. Must be unique."""
		self._email = value
class UserResources:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"groups": ("groups", "RestList", "Group"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		groups: Optional["RestList[Group]"] = None,
	) -> None:
		"""
		:param groups: The list of groups the user is a member of. When fetching a single user, the full group objects will be embedded here.
		:type groups: RestList[Group] or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._groups = cast(Optional[RestList[Group]], kwargs.get("groups"))
	@property
	def groups(self) -> Optional["RestList[Group]"]:
		"""The list of groups the user is a member of. When fetching a single user, the full group objects will be embedded here."""
		return self._groups
	@groups.setter
	def groups(self, value: Optional["RestList[Group]"]) -> None:
		"""The list of groups the user is a member of. When fetching a single user, the full group objects will be embedded here."""
		self._groups = value
class ValidationProblemDetails(ProblemDetails):
	"""[RFC 7808](https://tools.ietf.org/html/rfc7807) compliant error information."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"errors": ("errors", "dict", "list"),
		"detail": ("detail", "str", None),
		"instance": ("instance", "str", None),
		"status": ("status", "int", None),
		"title": ("title", "str", None),
		"type_": ("type", "str", None),
		"messages": ("messages", "list", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		errors: "Dict[str, List[str]]",
		messages: "List[str]",
		detail: Optional["str"] = None,
		instance: Optional["str"] = None,
		status: Optional["int"] = None,
		title: Optional["str"] = None,
		type_: Optional["str"] = None,
	) -> None:
		"""
		:param errors:
		:type errors: Dict[str, List[str]]
		:param messages:
		:type messages: List[str]
		:param detail: A human-readable explanation specific to this occurrence of the problem.
		:type detail: str or None
		:param instance: A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
		:type instance: str or None
		:param status: The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
		:type status: int or None
		:param title: A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization(e.g., using proactive content negotiation; see[RFC7231], Section 3.4).
		:type title: str or None
		:param type_: A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank".
		:type type_: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		ProblemDetails.__init__(self,
			detail=kwargs.get("detail"),
			instance=kwargs.get("instance"),
			status=kwargs.get("status"),
			title=kwargs.get("title"),
			type_=kwargs.get("type_"),
			messages=kwargs.get("messages"),
		)
		self._errors = cast(Dict[str, List[str]], kwargs.get("errors"))
	@property
	def errors(self) -> "Dict[str, List[str]]":
		# pylint: disable=missing-function-docstring
		return self._errors
	@errors.setter
	def errors(self, value: "Dict[str, List[str]]") -> None:
		# pylint: disable=missing-function-docstring
		self._errors = value


class VAlign(str, Enum):
	# pylint: disable=missing-class-docstring
	TOP = 'Top'
	CENTER = 'Center'
	CENTER_BBOX = 'CenterBBox'
	BOTTOM = 'Bottom'

class Version:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"binary_version": ("binaryVersion", "int", None),
		"build_version": ("buildVersion", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		binary_version: "int",
		build_version: Optional["str"] = None,
	) -> None:
		"""
		:param binary_version: The binary encoding version of the database. May not change with BuildVersion.
		:type binary_version: int
		:param build_version: The build version of the software
		:type build_version: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._binary_version = cast(int, kwargs.get("binary_version"))
		self._build_version = cast(Optional[str], kwargs.get("build_version"))
	@property
	def binary_version(self) -> "int":
		"""The binary encoding version of the database. May not change with BuildVersion."""
		return self._binary_version
	@binary_version.setter
	def binary_version(self, value: "int") -> None:
		"""The binary encoding version of the database. May not change with BuildVersion."""
		self._binary_version = value
	@property
	def build_version(self) -> Optional["str"]:
		"""The build version of the software"""
		return self._build_version
	@build_version.setter
	def build_version(self, value: Optional["str"]) -> None:
		"""The build version of the software"""
		self._build_version = value
class VFSControllerCreateDirectoryResult:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"directory_info": ("directoryInfo", "VFSDirectoryInfo", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		directory_info: "VFSDirectoryInfo",
	) -> None:
		"""
		:param directory_info:
		:type directory_info: VFSDirectoryInfo
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._directory_info = cast(VFSDirectoryInfo, kwargs.get("directory_info"))
	@property
	def directory_info(self) -> "VFSDirectoryInfo":
		# pylint: disable=missing-function-docstring
		return self._directory_info
	@directory_info.setter
	def directory_info(self, value: "VFSDirectoryInfo") -> None:
		# pylint: disable=missing-function-docstring
		self._directory_info = value
class VFSControllerDeleteDirectoryResult:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"deleted_paths": ("DeletedPaths", "list", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		deleted_paths: "List[str]",
	) -> None:
		"""
		:param deleted_paths:
		:type deleted_paths: List[str]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._deleted_paths = cast(List[str], kwargs.get("deleted_paths"))
	@property
	def deleted_paths(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._deleted_paths
	@deleted_paths.setter
	def deleted_paths(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._deleted_paths = value
class VFSControllerDeleteFileResult:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"deleted_file_paths": ("DeletedFilePaths", "list", "str"),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		deleted_file_paths: "List[str]",
	) -> None:
		"""
		:param deleted_file_paths:
		:type deleted_file_paths: List[str]
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._deleted_file_paths = cast(List[str], kwargs.get("deleted_file_paths"))
	@property
	def deleted_file_paths(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._deleted_file_paths
	@deleted_file_paths.setter
	def deleted_file_paths(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._deleted_file_paths = value
class VfsCreateDirectory:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"path": ("path", "str", None),
		"account": ("account", "str", None),
		"dataset": ("dataset", "str", None),
		"dsclass": ("dsclass", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		path: "str",
		account: "str",
		dataset: "str",
		dsclass: "str",
	) -> None:
		"""
		:param path: The full path from the vfs root for the directory
		:type path: str
		:param account: The account for the directory to be created under.
		:type account: str
		:param dataset: The data set for the directory. Ex. VfsExplorer
		:type dataset: str
		:param dsclass: The ds class for the directory. Ex. manualUpload
		:type dsclass: str
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._path = cast(str, kwargs.get("path"))
		self._account = cast(str, kwargs.get("account"))
		self._dataset = cast(str, kwargs.get("dataset"))
		self._dsclass = cast(str, kwargs.get("dsclass"))
	@property
	def path(self) -> "str":
		"""The full path from the vfs root for the directory"""
		return self._path
	@path.setter
	def path(self, value: "str") -> None:
		"""The full path from the vfs root for the directory"""
		self._path = value
	@property
	def account(self) -> "str":
		"""The account for the directory to be created under."""
		return self._account
	@account.setter
	def account(self, value: "str") -> None:
		"""The account for the directory to be created under."""
		self._account = value
	@property
	def dataset(self) -> "str":
		"""The data set for the directory. Ex. VfsExplorer"""
		return self._dataset
	@dataset.setter
	def dataset(self, value: "str") -> None:
		"""The data set for the directory. Ex. VfsExplorer"""
		self._dataset = value
	@property
	def dsclass(self) -> "str":
		"""The ds class for the directory. Ex. manualUpload"""
		return self._dsclass
	@dsclass.setter
	def dsclass(self, value: "str") -> None:
		"""The ds class for the directory. Ex. manualUpload"""
		self._dsclass = value
class VFSDirectoryInfo:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"directory_name": ("directory_name", "str", None),
		"dsclass": ("dsclass", "str", None),
		"account": ("account", "str", None),
		"dataset": ("dataset", "str", None),
		"path": ("path", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		directory_name: Optional["str"] = None,
		dsclass: Optional["str"] = None,
		account: Optional["str"] = None,
		dataset: Optional["str"] = None,
		path: Optional["str"] = None,
	) -> None:
		"""
		:param directory_name:
		:type directory_name: str or None
		:param dsclass:
		:type dsclass: str or None
		:param account:
		:type account: str or None
		:param dataset:
		:type dataset: str or None
		:param path:
		:type path: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._directory_name = cast(Optional[str], kwargs.get("directory_name"))
		self._dsclass = cast(Optional[str], kwargs.get("dsclass"))
		self._account = cast(Optional[str], kwargs.get("account"))
		self._dataset = cast(Optional[str], kwargs.get("dataset"))
		self._path = cast(Optional[str], kwargs.get("path"))
	@property
	def directory_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._directory_name
	@directory_name.setter
	def directory_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._directory_name = value
	@property
	def dsclass(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._dsclass
	@dsclass.setter
	def dsclass(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._dsclass = value
	@property
	def account(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._account
	@account.setter
	def account(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._account = value
	@property
	def dataset(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._dataset
	@dataset.setter
	def dataset(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._dataset = value
	@property
	def path(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._path
	@path.setter
	def path(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._path = value
class VfsEditDirectory:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"old_path": ("oldPath", "str", None),
		"new_path": ("newPath", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		old_path: "str",
		new_path: "str",
	) -> None:
		"""
		:param old_path: The full path from the vfs root for the directory
		:type old_path: str
		:param new_path: The full path from the vfs root for the directory
		:type new_path: str
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._old_path = cast(str, kwargs.get("old_path"))
		self._new_path = cast(str, kwargs.get("new_path"))
	@property
	def old_path(self) -> "str":
		"""The full path from the vfs root for the directory"""
		return self._old_path
	@old_path.setter
	def old_path(self, value: "str") -> None:
		"""The full path from the vfs root for the directory"""
		self._old_path = value
	@property
	def new_path(self) -> "str":
		"""The full path from the vfs root for the directory"""
		return self._new_path
	@new_path.setter
	def new_path(self, value: "str") -> None:
		"""The full path from the vfs root for the directory"""
		self._new_path = value
class VideoConfig:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"generate_scaled_frames": ("generateScaledFrames", "bool", None),
		"ingest_as_media_archive": ("ingestAsMediaArchive", "bool", None),
		"segment_time_seconds": ("segmentTimeSeconds", "int", None),
		"create_thumbnails_on_import": ("createThumbnailsOnImport", "bool", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		ingest_as_media_archive: "bool",
		segment_time_seconds: "int",
		create_thumbnails_on_import: "bool",
		generate_scaled_frames: Optional["bool"] = None,
	) -> None:
		"""
		:param ingest_as_media_archive:
		:type ingest_as_media_archive: bool
		:param segment_time_seconds:
		:type segment_time_seconds: int
		:param create_thumbnails_on_import:
		:type create_thumbnails_on_import: bool
		:param generate_scaled_frames:
		:type generate_scaled_frames: bool or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._generate_scaled_frames = cast(Optional[bool], kwargs.get("generate_scaled_frames"))
		self._ingest_as_media_archive = cast(bool, kwargs.get("ingest_as_media_archive"))
		self._segment_time_seconds = cast(int, kwargs.get("segment_time_seconds"))
		self._create_thumbnails_on_import = cast(bool, kwargs.get("create_thumbnails_on_import"))
	@property
	def generate_scaled_frames(self) -> Optional["bool"]:
		# pylint: disable=missing-function-docstring
		return self._generate_scaled_frames
	@generate_scaled_frames.setter
	def generate_scaled_frames(self, value: Optional["bool"]) -> None:
		# pylint: disable=missing-function-docstring
		self._generate_scaled_frames = value
	@property
	def ingest_as_media_archive(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._ingest_as_media_archive
	@ingest_as_media_archive.setter
	def ingest_as_media_archive(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._ingest_as_media_archive = value
	@property
	def segment_time_seconds(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._segment_time_seconds
	@segment_time_seconds.setter
	def segment_time_seconds(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._segment_time_seconds = value
	@property
	def create_thumbnails_on_import(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._create_thumbnails_on_import
	@create_thumbnails_on_import.setter
	def create_thumbnails_on_import(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._create_thumbnails_on_import = value





class WktDimsEnum(str, Enum):
	# pylint: disable=missing-class-docstring
	XY = 'XY'
	Z = 'Z'
	M = 'M'


WktDims = Iterable[WktDimsEnum]
class Workflow:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("Id", "str", None),
		"last_update": ("LastUpdate", "datetime", None),
		"name": ("Name", "str", None),
		"enabled": ("Enabled", "bool", None),
		"options": ("Options", "str", None),
		"account_name": ("AccountName", "str", None),
		"user_id": ("UserId", "int", None),
		"project_id": ("ProjectId", "str", None),
		"nodes": ("Nodes", "list", "WorkflowNode"),
		"created": ("Created", "datetime", None),
		"version": ("Version", "str", None),
		"links": ("Links", "WorkflowLinks", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
		last_update: "datetime",
		enabled: "bool",
		user_id: "int",
		project_id: "str",
		nodes: "List[WorkflowNode]",
		created: "datetime",
		links: "WorkflowLinks",
		name: Optional["str"] = None,
		options: Optional["str"] = None,
		account_name: Optional["str"] = None,
		version: Optional["str"] = None,
	) -> None:
		"""
		:param id_:
		:type id_: str
		:param last_update:
		:type last_update: datetime
		:param enabled:
		:type enabled: bool
		:param user_id:
		:type user_id: int
		:param project_id:
		:type project_id: str
		:param nodes:
		:type nodes: List[WorkflowNode]
		:param created:
		:type created: datetime
		:param links: [JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource.
		:type links: WorkflowLinks
		:param name:
		:type name: str or None
		:param options: A Json serialized represenation of a S3MessageChannelOptions object, or spefications for: queueMode, loadTableTriggerData, and/or useDatabaseTransaction
		:type options: str or None
		:param account_name:
		:type account_name: str or None
		:param version:
		:type version: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
		self._last_update = cast(datetime, kwargs.get("last_update"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._enabled = cast(bool, kwargs.get("enabled"))
		self._options = cast(Optional[str], kwargs.get("options"))
		self._account_name = cast(Optional[str], kwargs.get("account_name"))
		self._user_id = cast(int, kwargs.get("user_id"))
		self._project_id = cast(str, kwargs.get("project_id"))
		self._nodes = cast(List[WorkflowNode], kwargs.get("nodes"))
		self._created = cast(datetime, kwargs.get("created"))
		self._version = cast(Optional[str], kwargs.get("version"))
		self._links = cast(WorkflowLinks, kwargs.get("links"))
	@property
	def id_(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value
	@property
	def last_update(self) -> "datetime":
		# pylint: disable=missing-function-docstring
		return self._last_update
	@last_update.setter
	def last_update(self, value: "datetime") -> None:
		# pylint: disable=missing-function-docstring
		self._last_update = value
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def enabled(self) -> "bool":
		# pylint: disable=missing-function-docstring
		return self._enabled
	@enabled.setter
	def enabled(self, value: "bool") -> None:
		# pylint: disable=missing-function-docstring
		self._enabled = value
	@property
	def options(self) -> Optional["str"]:
		"""A Json serialized represenation of a S3MessageChannelOptions object, or spefications for: queueMode, loadTableTriggerData, and/or useDatabaseTransaction"""
		return self._options
	@options.setter
	def options(self, value: Optional["str"]) -> None:
		"""A Json serialized represenation of a S3MessageChannelOptions object, or spefications for: queueMode, loadTableTriggerData, and/or useDatabaseTransaction"""
		self._options = value
	@property
	def account_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._account_name
	@account_name.setter
	def account_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._account_name = value
	@property
	def user_id(self) -> "int":
		# pylint: disable=missing-function-docstring
		return self._user_id
	@user_id.setter
	def user_id(self, value: "int") -> None:
		# pylint: disable=missing-function-docstring
		self._user_id = value
	@property
	def project_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._project_id
	@project_id.setter
	def project_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._project_id = value
	@property
	def nodes(self) -> "List[WorkflowNode]":
		# pylint: disable=missing-function-docstring
		return self._nodes
	@nodes.setter
	def nodes(self, value: "List[WorkflowNode]") -> None:
		# pylint: disable=missing-function-docstring
		self._nodes = value
	@property
	def created(self) -> "datetime":
		# pylint: disable=missing-function-docstring
		return self._created
	@created.setter
	def created(self, value: "datetime") -> None:
		# pylint: disable=missing-function-docstring
		self._created = value
	@property
	def version(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._version
	@version.setter
	def version(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._version = value
	@property
	def links(self) -> "WorkflowLinks":
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		return self._links
	@links.setter
	def links(self, value: "WorkflowLinks") -> None:
		"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
		self._links = value
class WorkflowLinks(Links):
	"""[JSON HAL](https://tools.ietf.org/html/draft-kelly-json-hal-08) links related to this resource."""
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"self_": ("self", "Link", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		self_: "Link",
	) -> None:
		"""
		:param self_: A link to the current resource.
		:type self_: Link
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		Links.__init__(self,
			self_=kwargs.get("self_"),
		)
		self._self_ = cast(Link, kwargs.get("self_"))
	@property
	def self_(self) -> "Link":
		"""A link to the current resource."""
		return self._self_
	@self_.setter
	def self_(self, value: "Link") -> None:
		"""A link to the current resource."""
		self._self_ = value
class WorkflowNode:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"id_": ("Id", "str", None),
		"workflow_id": ("WorkflowId", "str", None),
		"name": ("Name", "str", None),
		"action_type": ("ActionType", "str", None),
		"sources": ("Sources", "list", "str"),
		"options": ("Options", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		id_: "str",
		workflow_id: "str",
		sources: "List[str]",
		name: Optional["str"] = None,
		action_type: Optional["str"] = None,
		options: Optional["str"] = None,
	) -> None:
		"""
		:param id_:
		:type id_: str
		:param workflow_id:
		:type workflow_id: str
		:param sources:
		:type sources: List[str]
		:param name:
		:type name: str or None
		:param action_type:
		:type action_type: str or None
		:param options:
		:type options: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._id_ = cast(str, kwargs.get("id_"))
		self._workflow_id = cast(str, kwargs.get("workflow_id"))
		self._name = cast(Optional[str], kwargs.get("name"))
		self._action_type = cast(Optional[str], kwargs.get("action_type"))
		self._sources = cast(List[str], kwargs.get("sources"))
		self._options = cast(Optional[str], kwargs.get("options"))
	@property
	def id_(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._id_
	@id_.setter
	def id_(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._id_ = value
	@property
	def workflow_id(self) -> "str":
		# pylint: disable=missing-function-docstring
		return self._workflow_id
	@workflow_id.setter
	def workflow_id(self, value: "str") -> None:
		# pylint: disable=missing-function-docstring
		self._workflow_id = value
	@property
	def name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._name
	@name.setter
	def name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._name = value
	@property
	def action_type(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._action_type
	@action_type.setter
	def action_type(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._action_type = value
	@property
	def sources(self) -> "List[str]":
		# pylint: disable=missing-function-docstring
		return self._sources
	@sources.setter
	def sources(self, value: "List[str]") -> None:
		# pylint: disable=missing-function-docstring
		self._sources = value
	@property
	def options(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._options
	@options.setter
	def options(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._options = value
class XPathItem:
	# pylint: disable=missing-class-docstring
	JSON_NAMES: ClassVar[Dict[str, Tuple[str, Optional[str], Optional[str]]]] = {
		"processing_mode": ("processingMode", "XPathProcessingMode", None),
		"xpath": ("xPath", "str", None),
		"column_name": ("columnName", "str", None),
		"children": ("children", "list", "XPathItem"),
		"join_seperator": ("joinSeperator", "str", None),
	}
	JSON_NAMES_INVERSE: ClassVar[Dict[str, str]] = {v[0]:k for k,v in JSON_NAMES.items()}

	@overload
	def __init__(self, *,
		processing_mode: "XPathProcessingMode",
		children: "List[XPathItem]",
		xpath: Optional["str"] = None,
		column_name: Optional["str"] = None,
		join_seperator: Optional["str"] = None,
	) -> None:
		"""
		:param processing_mode:
		:type processing_mode: XPathProcessingMode
		:param children:
		:type children: List[XPathItem]
		:param xpath:
		:type xpath: str or None
		:param column_name:
		:type column_name: str or None
		:param join_seperator:
		:type join_seperator: str or None
		"""
	@overload
	def __init__(self, **kwargs: Any) -> None:
		pass
	def __init__(self, **kwargs: Any) -> None:
		self._processing_mode = cast(XPathProcessingMode, kwargs.get("processing_mode"))
		self._xpath = cast(Optional[str], kwargs.get("xpath"))
		self._column_name = cast(Optional[str], kwargs.get("column_name"))
		self._children = cast(List[XPathItem], kwargs.get("children"))
		self._join_seperator = cast(Optional[str], kwargs.get("join_seperator"))
	@property
	def processing_mode(self) -> "XPathProcessingMode":
		# pylint: disable=missing-function-docstring
		return self._processing_mode
	@processing_mode.setter
	def processing_mode(self, value: "XPathProcessingMode") -> None:
		# pylint: disable=missing-function-docstring
		self._processing_mode = value
	@property
	def xpath(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._xpath
	@xpath.setter
	def xpath(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._xpath = value
	@property
	def column_name(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._column_name
	@column_name.setter
	def column_name(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._column_name = value
	@property
	def children(self) -> "List[XPathItem]":
		# pylint: disable=missing-function-docstring
		return self._children
	@children.setter
	def children(self, value: "List[XPathItem]") -> None:
		# pylint: disable=missing-function-docstring
		self._children = value
	@property
	def join_seperator(self) -> Optional["str"]:
		# pylint: disable=missing-function-docstring
		return self._join_seperator
	@join_seperator.setter
	def join_seperator(self, value: Optional["str"]) -> None:
		# pylint: disable=missing-function-docstring
		self._join_seperator = value


class XPathProcessingMode(str, Enum):
	# pylint: disable=missing-class-docstring
	DEFAULT = 'Default'
	ARRAY = 'Array'
	JOIN_VALUES = 'JoinValues'
	CHILDREN_JSON = 'ChildrenJSON'
	EVALUATE = 'Evaluate'



class ZoomToFit(str, Enum):
	# pylint: disable=missing-class-docstring
	FALSE = 'false'
	TRUE = 'true'
	FILL = 'fill'

ZoomToFit.FALSE.__doc__ = """Don't zoom in any extra beyond the integer zoom level, and also don't include any extra imagery outside of the lat/lng extents and padding."""
ZoomToFit.TRUE.__doc__ = """Zoom to a non-integer zoom level so that the lat/lng extents plus padding touches the requested image dimensions, and include extra imagery outside the lat/lng extents so that the requested image dimensions are filled."""
ZoomToFit.FILL.__doc__ = """Don't zoom in any extra beyond the integer zoom level, but include extra imagery outside the lat/lng extents so that the requested image dimensions are filled."""
