import os
from typing import (
    Any,
    AsyncContextManager,
    Awaitable,
    Dict,
    Generic,
    List,
    Optional,
    SupportsBytes,
    Tuple,
    Type,
    TypeVar,
    Union,
    type_check_only,
)

import numpy as np

__all__ = [
    "FuriosaRuntimeError",
    "FuriosaRuntimeWarning",
    "Axis",
    "ModelSource",
    "Axis",
    "DataType",
    "Tensor",
    "TensorArray",
    "TensorDesc",
    "Model",
    "Runtime",
    "Runner",
    "Submitter",
    "Receiver",
    "create_runner",
    "create_queue",
    "full_version",
]

__version__: str = ...
__full_version__: str = ...
__git_short_hash__: str = ...
__build_timestamp__: str = ...

def full_version() -> str: ...

_T_co = TypeVar("_T_co", covariant=True)

@type_check_only
class _ContextfulFuture(Generic[_T_co], Awaitable[_T_co], AsyncContextManager[_T_co]):
    pass

class FuriosaRuntimeError(Exception):
    pass

class SessionClosed(FuriosaRuntimeError):
    pass

class SessionTerminated(FuriosaRuntimeError):
    pass

class DeviceBusy(FuriosaRuntimeError):
    pass

class InvalidInput(FuriosaRuntimeError):
    pass

class QueueWaitTimeout(FuriosaRuntimeError):
    pass

class TensorNameNotFound(FuriosaRuntimeError):
    pass

class FuriosaRuntimeWarning(RuntimeWarning):
    pass

ModelSource = Union[Union[str, os.PathLike], Union[bytes, SupportsBytes]]

class Axis:
    WIDTH = ...
    HEIGHT = ...
    CHANNEL = ...
    BATCH = ...
    WIDTH_OUTER = ...
    HEIGHT_OUTER = ...
    CHANNEL_OUTER = ...
    BATCH_OUTER = ...
    GROUP = ...
    GROUP_OUTER = ...
    UNKNOWN = ...

    def __repr__(self) -> str: ...

class DataType:
    FLOAT32 = ...
    UINT8 = ...
    INT8 = ...
    INT32 = ...
    INT64 = ...
    BFLOAT16 = ...
    BOOL = ...
    INT4 = ...
    INT4_DECODED = ...
    FLOAT8E4M3 = ...
    FLOAT8E5M2 = ...
    DOUBLE_INT4 = ...
    INT16 = ...
    FLOAT16 = ...

    @property
    def numpy(self) -> np.dtype: ...
    @property
    def numpy_dtype(self) -> Type[np.generic]: ...
    def __repr__(self) -> str: ...

Tensor = Union[np.ndarray, np.generic]
TensorArray = List[Tensor]

class TensorDesc:
    @property
    def name(self) -> Optional[str]: ...
    @property
    def ndim(self) -> int: ...
    def dim(self, idx: int) -> int: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    def axis(self, idx: int) -> Axis: ...
    @property
    def size(self) -> int: ...
    def stride(self, idx: int) -> int: ...
    @property
    def length(self) -> int: ...
    @property
    def format(self) -> str: ...
    @property
    def dtype(self) -> DataType: ...
    @property
    def numpy_dtype(self) -> np.dtype: ...
    def __repr__(self) -> str: ...

class Model:
    @property
    def input_num(self) -> int: ...
    @property
    def output_num(self) -> int: ...
    def input(self, idx: int) -> TensorDesc: ...
    def inputs(self) -> List[TensorDesc]: ...
    def output(self, idx: int) -> TensorDesc: ...
    def outputs(self) -> List[TensorDesc]: ...
    def summary(self) -> str: ...
    def print_summary(self) -> None: ...

class Runtime(AsyncContextManager["Runtime"]):
    _Self = TypeVar("_Self", bound=Runtime)
    def __new__(
        cls,
        device: Optional[str] = None,
    ) -> Runtime: ...
    def create_runner(
        self,
        model: ModelSource,
        *,
        worker_num: Optional[int] = None,
        batch_size: Optional[int] = None,
        compiler_config: Optional[dict[str, Any]] = None,
    ) -> _ContextfulFuture[Runner]: ...
    def create_queue(
        self,
        model: ModelSource,
        *,
        worker_num: Optional[int] = None,
        batch_size: Optional[int] = None,
        input_queue_size: Optional[int] = None,
        output_queue_size: Optional[int] = None,
        compiler_config: Optional[dict[str, Any]] = None,
    ) -> _ContextfulFuture[Tuple[Submitter, Receiver]]: ...
    def close(self) -> Awaitable[bool]: ...
    def __aenter__(self: _Self) -> Awaitable[_Self]: ...
    def __aexit__(self, type, value, traceback) -> Awaitable[None]: ...

class Runner(AsyncContextManager["Runner"]):
    _Self = TypeVar("_Self", bound=Runner)
    @property
    def model(self) -> Model: ...
    def allocate(self) -> List[Tensor]: ...
    def run(self, inputs: Union[Tensor, List[Tensor]]) -> Awaitable[List[Tensor]]: ...
    def run_with(
        self, output_names: List[str], inputs: Dict[str, Tensor]
    ) -> Awaitable[List[Tensor]]: ...
    def close(self) -> Awaitable[bool]: ...
    def __aenter__(self: _Self) -> Awaitable[_Self]: ...
    def __aexit__(self, type, value, traceback) -> Awaitable[None]: ...

class Submitter(AsyncContextManager["Submitter"]):
    _Self = TypeVar("_Self", bound=Submitter)
    @property
    def model(self) -> Model: ...
    def allocate(self) -> List[Tensor]: ...
    def submit(
        self,
        inputs: Union[Tensor, List[Tensor]],
        context: Optional[Any] = None,
    ) -> Awaitable[None]: ...
    def close(self) -> Awaitable[bool]: ...
    def __aenter__(self: _Self) -> Awaitable[_Self]: ...
    def __aexit__(self, type, value, traceback) -> Awaitable[None]: ...

class Receiver(AsyncContextManager["Receiver"]):
    _Self = TypeVar("_Self", bound=Receiver)
    @property
    def model(self) -> Model: ...
    def recv(self) -> Awaitable[Tuple[Optional[Any], List[Tensor]]]: ...
    def close(self) -> Awaitable[bool]: ...
    def __aiter__(self: _Self) -> _Self: ...
    def __anext__(self) -> Awaitable[Tuple[Optional[Any], List[Tensor]]]: ...
    def __aenter__(self: _Self) -> Awaitable[_Self]: ...
    def __aexit__(self, type, value, traceback) -> Awaitable[None]: ...

def create_runner(
    model: ModelSource,
    *,
    device: Optional[str] = None,
    worker_num: Optional[int] = None,
    batch_size: Optional[int] = None,
    compiler_config: Optional[dict[str, Any]] = None,
) -> _ContextfulFuture[Runner]: ...
def create_queue(
    model: ModelSource,
    *,
    device: Optional[str] = None,
    worker_num: Optional[int] = None,
    batch_size: Optional[int] = None,
    input_queue_size: Optional[int] = None,
    output_queue_size: Optional[int] = None,
    compiler_config: Optional[dict[str, Any]] = None,
) -> _ContextfulFuture[Tuple[Submitter, Receiver]]: ...
