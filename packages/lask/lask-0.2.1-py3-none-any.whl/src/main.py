#!/usr/bin/env python3
"""
lask: A CLI tool to prompt ChatGPT and other LLMs from the terminal.
Usage:
    lask                     # Start interactive REPL mode
    lask Your prompt here    # One-off prompt
    echo "Your prompt here" | lask
This tool supports multiple LLM providers including OpenAI, Anthropic, and AWS Bedrock.
Configure your API keys and preferences in the ~/.lask-config file.

Features:
- Interactive REPL mode: Run 'lask' without arguments to start a chat session
  where conversation context is maintained between prompts.
- Streaming responses: By default, responses are streamed in real-time as they're
  generated by the LLM. This can be disabled in the config with `streaming = false`.
- Pipe input: You can pipe content into lask as input instead of providing it as a command line argument.
"""

import sys
import os
from typing import Union, Iterator, List, Dict
import readline  # For better input handling in REPL mode
import atexit

import configparser
from src.config import LaskConfig
from src.providers import call_provider_api


def prompt_for_config_creation() -> None:
    """
    Prompt the user to create a configuration file with preset options.
    """
    print("\nNo configuration file found at ~/.lask-config")
    print("\nWould you like to create a configuration file? Choose an option:")
    print("  0. No, don't create a config file (or press Enter)")
    print("  1. Yes, create a config with 'Short and concise' system prompt")
    print("  2. Yes, create a config that always responds in a specific language")
    print("  3. Yes, create a config with a detailed, helpful assistant")
    print("  4. Yes, create a minimal config (just API keys)")
    print("  5. Yes, create a config with your own custom system prompt")

    choice = input("\nEnter your choice (0-5): ").strip()

    # Default to 0 if no input or invalid input
    if not choice or choice == "0" or choice.lower() == "no":
        print("No configuration file created. You can create one manually later.")
        return

    # Create a ConfigParser object
    config = configparser.ConfigParser()
    config["default"] = {
        "provider": "openai",
    }

    # Provider section with placeholders for API keys
    config["openai"] = {
        "api_key": "YOUR_OPENAI_API_KEY",
        "model": "gpt-4o",
        "temperature": "0.7",
        "streaming": "true",
    }

    # Add other providers as commented examples
    config["anthropic"] = {
        "api_key": "YOUR_ANTHROPIC_API_KEY",
        "model": "claude-3-opus-20240229",
        "temperature": "0.7",
        "streaming": "true",
    }

    config["aws"] = {
        "api_key": "YOUR_AWS_API_KEY",
        "region": "us-east-1",
        "model_id": "anthropic.claude-3-sonnet-20240229-v1:0",
        "temperature": "0.7",
        "streaming": "true",
    }

    config["azure"] = {
        "api_key": "YOUR_AZURE_API_KEY",
        "resource_name": "your-resource-name",
        "deployment_id": "your-deployment-id",
        "api_version": "2023-05-15",
        "model": "gpt-4",
        "temperature": "0.7",
        "streaming": "true",
    }

    # Add system prompt based on choice
    if choice == "1":
        config["default"]["system_prompt"] = (
            "Provide short, concise responses without unnecessary details."
        )

    elif choice == "2":
        language = input(
            "Enter the language you want responses in (e.g., Spanish, French, German): "
        ).strip()
        config["default"]["system_prompt"] = (
            f"Always respond in {language}, regardless of the language used in the prompt."
        )

    elif choice == "3":
        config["default"]["system_prompt"] = (
            "You are a helpful, detailed assistant. Provide comprehensive responses with examples and explanations when appropriate. Be thorough and clear in your communication."
        )

    elif choice == "4":
        # Minimal config, no system prompt
        pass

    elif choice == "5":
        print("\nWrite a custom system prompt that defines the assistant's behavior.")
        print("Examples:")
        print("  - You are an expert programmer who explains code in detail")
        print("  - You are a creative writing assistant who helps with story ideas")
        print("  - You are a concise technical expert who responds with bullet points")
        custom_prompt = input("\nEnter your custom system prompt: ").strip()
        config["openai"]["system_prompt"] = custom_prompt

    else:
        print("Invalid choice. No configuration file created.")
        return

    # Write the configuration to file
    try:
        with open(LaskConfig.CONFIG_PATH, "w") as configfile:
            config.write(configfile)

        print(f"\nConfiguration file created at {LaskConfig.CONFIG_PATH}")
        print(
            "Please edit this file to add your API keys and customize settings as needed."
        )
        print("\nThis configuration includes settings for all supported providers:")
        print("  - OpenAI (default)")
        print("  - Anthropic (Claude)")
        print("  - AWS Bedrock")
        print("  - Azure OpenAI")
        print("\nYou can change the default provider in the [default] section.")
        sys.exit(0)

    except Exception as e:
        print(f"Error creating configuration file: {e}")
        sys.exit(1)


def setup_readline():
    """
    Configure readline for better line editing in REPL mode.
    Enables:
    - Left/right cursor movement
    - Command history
    - History persistence between sessions
    - Editing with arrow keys
    - Optional Vi editing mode
    """
    # Set up history file
    history_file = os.path.join(os.path.expanduser("~"), ".lask_history")

    # Create history file if it doesn't exist
    if not os.path.exists(history_file):
        try:
            open(history_file, "w").close()
        except FileNotFoundError:
            # If we can't create the history file, just continue without it
            pass

    # Try to read the history file
    try:
        readline.read_history_file(history_file)
        # Set history length
        readline.set_history_length(1000)
    except Exception:
        # If we can't read the history, just continue without it
        pass

    # Save history on exit
    atexit.register(readline.write_history_file, history_file)

    # Configure readline behavior
    try:
        # These are common readline settings that improve the editing experience

        # Enable tab completion
        readline.parse_and_bind("tab: complete")

        # Make arrow keys work on different platforms
        if sys.platform == "darwin":  # macOS
            # Bind arrow keys for Mac
            readline.parse_and_bind('"\\e[A": previous-history')  # Up arrow
            readline.parse_and_bind('"\\e[B": next-history')  # Down arrow
            readline.parse_and_bind('"\\e[C": forward-char')  # Right arrow
            readline.parse_and_bind('"\\e[D": backward-char')  # Left arrow
        else:
            # Linux/Windows style bindings
            readline.parse_and_bind(
                '"\\e[A": history-search-backward'
            )  # Up arrow with search
            readline.parse_and_bind(
                '"\\e[B": history-search-forward'
            )  # Down arrow with search

        # Some additional useful bindings
        readline.parse_and_bind(
            '"\\C-a": beginning-of-line'
        )  # Ctrl+A: go to beginning of line
        readline.parse_and_bind('"\\C-e": end-of-line')  # Ctrl+E: go to end of line
        readline.parse_and_bind('"\\C-l": clear-screen')  # Ctrl+L: clear screen
        readline.parse_and_bind('"\\C-k": kill-line')  # Ctrl+K: delete to end of line

        # Check if user has a preference for vi mode in their ~/.inputrc
        vi_mode = False
        try:
            with open(os.path.expanduser("~/.inputrc"), "r") as f:
                if "set editing-mode vi" in f.read():
                    vi_mode = True
        except FileNotFoundError:
            pass

        # Set editing mode based on user preference or environment variable
        if vi_mode or os.environ.get("LASK_VI_MODE", "").lower() in (
            "1",
            "true",
            "yes",
        ):
            readline.parse_and_bind("set editing-mode vi")
            # Add a visual indicator for vi mode
            os.environ["LASK_EDITING_MODE"] = "vi"
        else:
            readline.parse_and_bind("set editing-mode emacs")
            os.environ["LASK_EDITING_MODE"] = "emacs"

    except Exception:
        # If any readline configuration fails, just continue with default settings
        pass


def setup_conversation(config: LaskConfig, provider: str) -> List[Dict[str, str]]:
    """
    Set up the initial conversation with system prompt if available.

    Args:
        config (LaskConfig): Configuration object
        provider (str): The provider name

    Returns:
        List[Dict[str, str]]: Initial conversation history
    """
    conversation: List[Dict[str, str]] = []

    # Add system message if specified in config
    provider_config = config.get_provider_config(provider)
    provider_system_prompt = provider_config.system_prompt
    default_system_prompt = config.system_prompt

    if provider_system_prompt is not None:
        conversation.append({"role": "system", "content": provider_system_prompt})
    elif default_system_prompt is not None:
        conversation.append({"role": "system", "content": default_system_prompt})

    return conversation


def process_response(result: Union[str, Iterator[str]]) -> str:
    """
    Process the response from the provider.

    Args:
        result: Response from the provider API

    Returns:
        str: The full response text
    """
    full_response = ""

    try:
        # Handle streaming vs non-streaming responses
        if isinstance(result, str):
            # Non-streaming response
            print(result)
            full_response = result
        else:
            # Streaming response
            for chunk in result:
                print(chunk, end="", flush=True)
                full_response += chunk
            print()  # Add a newline at the end
    except KeyboardInterrupt:
        # Handle Ctrl+C during response generation
        print("\n\nResponse interrupted.")

    return full_response


def handle_repl_command(cmd, conversation):
    """
    Handle special REPL commands starting with !

    Args:
        cmd (str): The command without the ! prefix
        conversation (List): The current conversation history

    Returns:
        bool: True if the command was handled, False otherwise
    """
    if cmd == "help":
        print("\nREPL Commands:")
        print("  !help     - Show this help")
        print("  !clear    - Clear the screen")
        print("  !history  - Show command history")
        print("  !vi       - Switch to Vi editing mode")
        print("  !emacs    - Switch to Emacs editing mode")
        print("  exit/quit - Exit the REPL")
        return True
    elif cmd == "clear":
        os.system("cls" if os.name == "nt" else "clear")
        return True
    elif cmd == "history":
        # Show command history
        hist_len = readline.get_current_history_length()
        for i in range(1, hist_len + 1):
            item = readline.get_history_item(i)
            if item and not item.startswith("!"):  # Skip REPL commands
                print(f"{i}: {item}")
        return True
    elif cmd == "vi":
        readline.parse_and_bind("set editing-mode vi")
        os.environ["LASK_EDITING_MODE"] = "vi"
        print("Switched to Vi editing mode")
        return True
    elif cmd == "emacs":
        readline.parse_and_bind("set editing-mode emacs")
        os.environ["LASK_EDITING_MODE"] = "emacs"
        print("Switched to Emacs editing mode")
        return True
    return False


def display_repl_help():
    """Display help information for REPL mode"""
    print("\n==== Lask REPL Mode ====")

    # Show editing mode-specific help
    if os.environ.get("LASK_EDITING_MODE") == "vi":
        print("Using Vi editing mode:")
        print("- Press ESC then 'i' to enter insert mode")
        print("- Use h,j,k,l for movement in command mode")
        print("- Use standard Vi commands for editing")
    else:
        print("Using Emacs editing mode:")
        print("- Use arrow keys to navigate and edit your input")
        print(
            "- Keyboard shortcuts: Ctrl+A (start of line), Ctrl+E (end of line), Ctrl+K (delete to end)"
        )

    # Show common commands
    print("\nCommon commands:")
    print("- Type '!help' for REPL help")
    print("- Type '!clear' to clear the screen")
    print("- Type '!history' to show command history")
    print("- Type 'exit' or 'quit' to end the session")
    print("- Press Ctrl+C to interrupt a response")


def repl_mode(config: LaskConfig) -> None:
    """
    Run lask in REPL (Read-Eval-Print Loop) mode.
    This mode maintains conversation context between prompts.

    Args:
        config (LaskConfig): Configuration object
    """
    # Determine which provider to use
    provider: str = config.get("provider", "openai").lower()

    # Check if provider is supported
    if provider not in LaskConfig.SUPPORTED_PROVIDERS:
        print(
            f"Error: Unsupported provider '{provider}'. Supported providers are: {', '.join(LaskConfig.SUPPORTED_PROVIDERS)}"
        )
        sys.exit(1)

    # Configure readline for better line editing
    setup_readline()

    # Initialize conversation history
    conversation = setup_conversation(config, provider)

    # Display welcome message
    print("\n==== Lask REPL Mode ====")
    print(f"Using provider: {provider}")

    # Show help information
    display_repl_help()

    # REPL loop
    try:
        while True:
            # Get user input with readline support for cursor movement and history
            try:
                # Use a colored prompt to make it stand out
                mode_indicator = (
                    "[vi]" if os.environ.get("LASK_EDITING_MODE") == "vi" else ""
                )
                prompt = (
                    f"\n\033[1;32m{mode_indicator}>\033[0m "
                    if sys.stdout.isatty()
                    else f"\n{mode_indicator}> "
                )
                user_input = input(prompt)
            except EOFError:  # Handle Ctrl+D
                print("\nExiting...")
                break

            # Check for exit commands
            if user_input.lower() in ("exit", "quit"):
                print("Exiting...")
                break

            # Check for special REPL commands
            if user_input.startswith("!"):
                cmd = user_input[1:].strip().lower()
                if handle_repl_command(cmd, conversation):
                    continue

            # Skip empty inputs
            if not user_input.strip():
                continue

            # Add user message to conversation
            conversation.append({"role": "user", "content": user_input})

            try:
                # Call the provider API with the full conversation history
                result = call_provider_api(provider, config, user_input, conversation)

                # Process the response and get the full text
                full_response = process_response(result)

                # Add assistant's response to conversation history
                conversation.append({"role": "assistant", "content": full_response})

            except Exception as e:
                print(f"\nError: {str(e)}")

    except KeyboardInterrupt:
        # Handle Ctrl+C at input prompt
        print("\nExiting...")


def main() -> None:
    """
    Main entry point for the lask CLI tool.
    Parses command line arguments, loads configuration,
    and calls the appropriate provider API.

    Supports:
    - REPL mode: lask
    - One-off prompts: lask Your prompt here
    - Pipe input: echo "Your prompt here" | lask
    """
    # Load config from file
    config = LaskConfig.load()

    # Check if input is coming from a pipe
    if not sys.stdin.isatty():
        # Read from stdin (pipe)
        prompt = sys.stdin.read().strip()
        if not prompt:
            print("Error: Empty input from pipe")
            sys.exit(1)

        # Process the piped input as a one-off prompt
        process_one_off_prompt(config, prompt)

    # If no input from pipe, check command line arguments
    elif len(sys.argv) < 2:
        # No arguments provided, enter REPL mode

        # First check if config file exists
        if not LaskConfig.config_exists():
            # No config file and no arguments, prompt to create config
            prompt_for_config_creation()

        # Start REPL mode
        repl_mode(config)
    else:
        # Get the prompt from command line arguments
        prompt: str = " ".join(sys.argv[1:])

        # Process the command line input as a one-off prompt
        process_one_off_prompt(config, prompt)


def process_one_off_prompt(config: LaskConfig, prompt: str) -> None:
    """
    Process a one-off prompt without maintaining conversation context.

    Args:
        config (LaskConfig): Configuration object
        prompt (str): The user prompt
    """
    # Determine which provider to use
    provider: str = config.get("provider", "openai").lower()

    # Check if provider is supported
    if provider not in LaskConfig.SUPPORTED_PROVIDERS:
        print(
            f"Error: Unsupported provider '{provider}'. Supported providers are: {', '.join(LaskConfig.SUPPORTED_PROVIDERS)}"
        )
        sys.exit(1)

    try:
        # Call the appropriate API based on the provider using the provider modules
        result: Union[str, Iterator[str]] = call_provider_api(provider, config, prompt)

        # Handle streaming vs non-streaming responses
        if isinstance(result, str):
            # Non-streaming response - full text is returned at once
            print(result)
        else:
            # Streaming response - print chunks as they arrive in real-time
            # This provides immediate feedback as the LLM generates content
            for chunk in result:
                # Print without buffering and without newline to create a continuous output
                print(chunk, end="", flush=True)
            print()  # Add a newline at the end of the complete response

    except ImportError as e:
        print(f"Error: {str(e)}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()
