"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from datetime import datetime
from kintsugi_tax_platform_sdk import errors, models, utils
from kintsugi_tax_platform_sdk._hooks import HookContext
from kintsugi_tax_platform_sdk.types import Nullable, OptionalNullable, UNSET
from kintsugi_tax_platform_sdk.utils.unmarshal_json_response import (
    unmarshal_json_response,
)
from typing import Any, List, Mapping, Optional, Union


class TaxEstimation(BaseSDK):
    def estimate_tax(
        self,
        *,
        security: Union[
            models.EstimateTaxV1TaxEstimatePostSecurity,
            models.EstimateTaxV1TaxEstimatePostSecurityTypedDict,
        ],
        x_organization_id: Nullable[str],
        date_: datetime,
        external_id: str,
        currency: models.CurrencyEnum,
        transaction_items: Union[
            List[models.TransactionItemEstimateBase],
            List[models.TransactionItemEstimateBaseTypedDict],
        ],
        addresses: Union[
            List[models.TransactionEstimatePublicRequestAddress],
            List[models.TransactionEstimatePublicRequestAddressTypedDict],
        ],
        simulate_nexus_met: Optional[bool] = None,
        total_amount: Optional[
            Union[
                models.TotalAmountOfTheTransactionAfterDiscounts,
                models.TotalAmountOfTheTransactionAfterDiscountsTypedDict,
            ]
        ] = None,
        description: OptionalNullable[str] = UNSET,
        source: OptionalNullable[models.SourceEnum] = UNSET,
        marketplace: OptionalNullable[bool] = UNSET,
        customer: OptionalNullable[
            Union[models.CustomerBasePublic, models.CustomerBasePublicTypedDict]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PageTransactionEstimateResponse:
        r"""Estimate Tax

        The Estimate Tax API calculates the estimated tax for a specific
        transaction based on the provided details, including organization nexus,
        transaction details, customer details, and addresses. Optionally simulates nexus being met for tax calculation purposes. The `simulate_nexus_met` parameter is deprecated and will be removed in future releases.

        :param security:
        :param x_organization_id: The unique identifier for the organization making the request
        :param date_: The date of the transaction in ISO 8601 format (e.g., 2025-01-25T12:00:00Z).
        :param external_id: Unique identifier of this transaction in the source system.
        :param currency:
        :param transaction_items: List of items involved in the transaction.
        :param addresses: List of addresses related to the transaction. At least one BILL_TO or SHIP_TO address must be provided. The address will be validated during estimation, and the transaction may be rejected if the address does not pass validation. The SHIP_TO will be preferred to use for determining tax liability.
        :param simulate_nexus_met: **Deprecated:** Use `simulate_active_registration` in the request body instead.
        :param total_amount: Total amount of the transaction.
        :param description: An optional description of the transaction.
        :param source: While currently not used, it may be used in the future to determine taxability. The source of the transaction (e.g., OTHER).
        :param marketplace: Indicates if the transaction involves a marketplace.
        :param customer: Details about the customer. If the customer is not found, it will be ignored.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EstimateTaxV1TaxEstimatePostRequest(
            simulate_nexus_met=simulate_nexus_met,
            x_organization_id=x_organization_id,
            transaction_estimate_public_request=models.TransactionEstimatePublicRequest(
                date_=date_,
                external_id=external_id,
                total_amount=total_amount,
                currency=currency,
                description=description,
                source=source,
                marketplace=marketplace,
                transaction_items=utils.get_pydantic_model(
                    transaction_items, List[models.TransactionItemEstimateBase]
                ),
                customer=utils.get_pydantic_model(
                    customer, OptionalNullable[models.CustomerBasePublic]
                ),
                addresses=utils.get_pydantic_model(
                    addresses, List[models.TransactionEstimatePublicRequestAddress]
                ),
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/tax/estimate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.EstimateTaxV1TaxEstimatePostSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.transaction_estimate_public_request,
                False,
                False,
                "json",
                models.TransactionEstimatePublicRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="estimate_tax_v1_tax_estimate_post",
                oauth2_scopes=None,
                security_source=security,
            ),
            request=req,
            error_status_codes=["401", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.PageTransactionEstimateResponse, http_res
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.BackendSrcTaxEstimationResponsesValidationErrorResponseData,
                http_res,
            )
            raise errors.BackendSrcTaxEstimationResponsesValidationErrorResponse(
                response_data, http_res
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def estimate_tax_async(
        self,
        *,
        security: Union[
            models.EstimateTaxV1TaxEstimatePostSecurity,
            models.EstimateTaxV1TaxEstimatePostSecurityTypedDict,
        ],
        x_organization_id: Nullable[str],
        date_: datetime,
        external_id: str,
        currency: models.CurrencyEnum,
        transaction_items: Union[
            List[models.TransactionItemEstimateBase],
            List[models.TransactionItemEstimateBaseTypedDict],
        ],
        addresses: Union[
            List[models.TransactionEstimatePublicRequestAddress],
            List[models.TransactionEstimatePublicRequestAddressTypedDict],
        ],
        simulate_nexus_met: Optional[bool] = None,
        total_amount: Optional[
            Union[
                models.TotalAmountOfTheTransactionAfterDiscounts,
                models.TotalAmountOfTheTransactionAfterDiscountsTypedDict,
            ]
        ] = None,
        description: OptionalNullable[str] = UNSET,
        source: OptionalNullable[models.SourceEnum] = UNSET,
        marketplace: OptionalNullable[bool] = UNSET,
        customer: OptionalNullable[
            Union[models.CustomerBasePublic, models.CustomerBasePublicTypedDict]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PageTransactionEstimateResponse:
        r"""Estimate Tax

        The Estimate Tax API calculates the estimated tax for a specific
        transaction based on the provided details, including organization nexus,
        transaction details, customer details, and addresses. Optionally simulates nexus being met for tax calculation purposes. The `simulate_nexus_met` parameter is deprecated and will be removed in future releases.

        :param security:
        :param x_organization_id: The unique identifier for the organization making the request
        :param date_: The date of the transaction in ISO 8601 format (e.g., 2025-01-25T12:00:00Z).
        :param external_id: Unique identifier of this transaction in the source system.
        :param currency:
        :param transaction_items: List of items involved in the transaction.
        :param addresses: List of addresses related to the transaction. At least one BILL_TO or SHIP_TO address must be provided. The address will be validated during estimation, and the transaction may be rejected if the address does not pass validation. The SHIP_TO will be preferred to use for determining tax liability.
        :param simulate_nexus_met: **Deprecated:** Use `simulate_active_registration` in the request body instead.
        :param total_amount: Total amount of the transaction.
        :param description: An optional description of the transaction.
        :param source: While currently not used, it may be used in the future to determine taxability. The source of the transaction (e.g., OTHER).
        :param marketplace: Indicates if the transaction involves a marketplace.
        :param customer: Details about the customer. If the customer is not found, it will be ignored.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EstimateTaxV1TaxEstimatePostRequest(
            simulate_nexus_met=simulate_nexus_met,
            x_organization_id=x_organization_id,
            transaction_estimate_public_request=models.TransactionEstimatePublicRequest(
                date_=date_,
                external_id=external_id,
                total_amount=total_amount,
                currency=currency,
                description=description,
                source=source,
                marketplace=marketplace,
                transaction_items=utils.get_pydantic_model(
                    transaction_items, List[models.TransactionItemEstimateBase]
                ),
                customer=utils.get_pydantic_model(
                    customer, OptionalNullable[models.CustomerBasePublic]
                ),
                addresses=utils.get_pydantic_model(
                    addresses, List[models.TransactionEstimatePublicRequestAddress]
                ),
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/tax/estimate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.EstimateTaxV1TaxEstimatePostSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.transaction_estimate_public_request,
                False,
                False,
                "json",
                models.TransactionEstimatePublicRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="estimate_tax_v1_tax_estimate_post",
                oauth2_scopes=None,
                security_source=security,
            ),
            request=req,
            error_status_codes=["401", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.PageTransactionEstimateResponse, http_res
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.BackendSrcTaxEstimationResponsesValidationErrorResponseData,
                http_res,
            )
            raise errors.BackendSrcTaxEstimationResponsesValidationErrorResponse(
                response_data, http_res
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)
