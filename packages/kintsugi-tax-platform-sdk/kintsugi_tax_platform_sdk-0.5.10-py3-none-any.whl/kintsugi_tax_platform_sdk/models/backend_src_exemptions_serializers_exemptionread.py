"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .attachmentread import AttachmentRead, AttachmentReadTypedDict
from .countrycodeenum import CountryCodeEnum
from .customerread import CustomerRead, CustomerReadTypedDict
from .exemptionstatus import ExemptionStatus
from .exemptiontype import ExemptionType
from datetime import date
from kintsugi_tax_platform_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class BackendSrcExemptionsSerializersExemptionReadTypedDict(TypedDict):
    start_date: date
    r"""Start date for the exemption validity period (YYYY-MM-DD format)"""
    id: str
    r"""Unique identifier for the exemption"""
    exemption_type: ExemptionType
    status: ExemptionStatus
    country_code: NotRequired[Nullable[CountryCodeEnum]]
    r"""Country code in ISO 3166-1 alpha-2 format (e.g., 'US')"""
    jurisdiction: NotRequired[Nullable[str]]
    r"""The jurisdiction identifier for the exemption"""
    end_date: NotRequired[Nullable[date]]
    r"""End date for the exemption validity period (YYYY-MM-DD format)"""
    transaction_id: NotRequired[Nullable[str]]
    r"""Unique identifier for the transaction, if applicable"""
    reseller: NotRequired[bool]
    r"""Indicates whether the exemption is for a reseller"""
    fein: NotRequired[Nullable[str]]
    r"""Federal Employer Identification Number"""
    sales_tax_id: NotRequired[Nullable[str]]
    r"""Sales tax ID for the exemption"""
    customer: NotRequired[Nullable[CustomerReadTypedDict]]
    r"""Details of the customer associated with the exemption"""
    attachment: NotRequired[Nullable[List[AttachmentReadTypedDict]]]
    r"""List of attachments related to the exemption"""


class BackendSrcExemptionsSerializersExemptionRead(BaseModel):
    start_date: date
    r"""Start date for the exemption validity period (YYYY-MM-DD format)"""

    id: str
    r"""Unique identifier for the exemption"""

    exemption_type: ExemptionType

    status: ExemptionStatus

    country_code: OptionalNullable[CountryCodeEnum] = UNSET
    r"""Country code in ISO 3166-1 alpha-2 format (e.g., 'US')"""

    jurisdiction: OptionalNullable[str] = UNSET
    r"""The jurisdiction identifier for the exemption"""

    end_date: OptionalNullable[date] = UNSET
    r"""End date for the exemption validity period (YYYY-MM-DD format)"""

    transaction_id: OptionalNullable[str] = UNSET
    r"""Unique identifier for the transaction, if applicable"""

    reseller: Optional[bool] = False
    r"""Indicates whether the exemption is for a reseller"""

    fein: Annotated[OptionalNullable[str], pydantic.Field(alias="FEIN")] = UNSET
    r"""Federal Employer Identification Number"""

    sales_tax_id: OptionalNullable[str] = UNSET
    r"""Sales tax ID for the exemption"""

    customer: OptionalNullable[CustomerRead] = UNSET
    r"""Details of the customer associated with the exemption"""

    attachment: OptionalNullable[List[AttachmentRead]] = UNSET
    r"""List of attachments related to the exemption"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "country_code",
            "jurisdiction",
            "end_date",
            "transaction_id",
            "reseller",
            "FEIN",
            "sales_tax_id",
            "customer",
            "attachment",
        ]
        nullable_fields = [
            "country_code",
            "jurisdiction",
            "end_date",
            "transaction_id",
            "FEIN",
            "sales_tax_id",
            "customer",
            "attachment",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
