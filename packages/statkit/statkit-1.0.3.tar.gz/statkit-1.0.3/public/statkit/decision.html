<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>statkit.decision API documentation</title>
<meta name="description" content="Evaluate models using decision curve analysis." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>statkit.decision</code></h1>
</header>
<section id="section-intro">
<p>Evaluate models using decision curve analysis.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Evaluate models using decision curve analysis.&#34;&#34;&#34;

from typing import Literal, Optional

from matplotlib import pyplot as plt  # type: ignore
from numpy import array, divide, linspace, ones_like, r_, zeros_like
from numpy.typing import NDArray
from pandas import Series
from sklearn.metrics import confusion_matrix  # type: ignore
from sklearn.utils import column_or_1d  # type: ignore


def _binary_classification_thresholds(y_true, y_proba, thresholds):
    &#34;&#34;&#34;Compute false and true positives for given probability thresholds.&#34;&#34;&#34;
    y_true = column_or_1d(y_true)
    y_proba = column_or_1d(y_proba)
    matrices = []
    for t in thresholds:
        if t &lt; 1:
            y_pred = (y_proba &gt; t).astype(int)
        else:
            y_pred = (y_proba &gt;= t).astype(int)
        cm = confusion_matrix(y_true, y_pred)
        matrices.append(cm)
    matrices = array(matrices)
    tns = matrices[:, 0, 0]
    fps = matrices[:, 0, 1]
    fns = matrices[:, 1, 0]
    tps = matrices[:, 1, 1]
    return tns, fps, fns, tps


def net_benefit(
    y_true: Series | NDArray,
    y_pred: Series | NDArray,
    thresholds=100,
    action: bool = True,
):
    &#34;&#34;&#34;Net benefit of taking an action using a model&#39;s predictions.

    Args:
        y_true: Binary ground truth label (1: positive, 0: negative class).
        y_pred: Probability of positive class label.
        thresholds: When an array, evaluate net benefit at these coordinates (the
            probability thresholds). When an int, the number of x coordinates.
        action: When `True` (`False`), estimate net benefit of taking (not taking) an
            action/intervention/treatment.

    Returns:
        thresholds: Probability threshold of prediction a positive class.
        benefit: The net benefit corresponding to the thresholds.

    References:
        [1]: Vickers-Elkin. &#34;Decision curve analysis: a novel method for evaluating
        prediction models.&#34; Medical Decision Making 26.6 (2006): 565-574.

        [2]: Rousson-Zumbrunn. &#34;Decision curve analysis revisited: overall net
        benefit, relationships to ROC curve analysis, and application to case-control
        studies.&#34; BMC medical informatics and decision making 11.1 (2011): 1â€“9.
    &#34;&#34;&#34;
    if set(y_true.astype(int)) != {0, 1}:
        raise ValueError(
            &#34;Decision curve analysis only supports binary classification (with labels 1 and 0).&#34;
        )

    if isinstance(thresholds, int):
        thresholds = linspace(0, 1, num=thresholds)

    N = len(y_true)
    tns, fps, fns, tps = _binary_classification_thresholds(y_true, y_pred, thresholds)
    if action:
        loss_over_profit = divide(
            thresholds, 1 - thresholds, where=thresholds &lt; 1, out=zeros_like(thresholds)
        )

        benefit = tps / N - fps / N * loss_over_profit
    else:
        # Invert 0&lt;--&gt;1 so that true positives are true negatives, and false positives
        # are false negatives.
        profit_over_loss = divide(
            1 - thresholds,
            thresholds,
            where=thresholds != 0,
            out=zeros_like(thresholds),
        )
        benefit = tns / N - fns / N * profit_over_loss
    return thresholds, benefit


def net_benefit_oracle(y_true, action: bool = True) -&gt; float:
    &#34;&#34;&#34;Net benefit of omniscient strategy, i.e., a hypothetical perfect predictor.&#34;&#34;&#34;
    if action:
        return y_true.mean()
    return 1 - y_true.mean()


def net_benefit_action(y_true, thresholds, action: bool = True):
    &#34;&#34;&#34;Net benefit of always doing an action/intervention/treatment.

    Args:
        action: When `False`, invert positive label in `y_true`.
    &#34;&#34;&#34;
    if action:
        loss_over_profit = divide(
            thresholds,
            1 - thresholds,
            where=thresholds &lt; 1,
            out=1e9 * ones_like(thresholds),
        )
        return y_true.mean() - (1 - y_true.mean()) * loss_over_profit
    profit_over_loss = divide(
        1 - thresholds,
        thresholds,
        where=thresholds != 0,
        out=1e9 * ones_like(thresholds),
    )
    return 1 - y_true.mean() - y_true.mean() * profit_over_loss


def overall_net_benefit(y_true, y_pred, n_thresholds: int = 100):
    &#34;&#34;&#34;Net benefit combining both taking and not-taking action.&#34;&#34;&#34;
    thresholds_action, benefit_action = net_benefit(
        y_true, y_pred, n_thresholds, action=True
    )
    _, benefit_no_action = net_benefit(y_true, y_pred, thresholds_action, action=False)
    return thresholds_action, benefit_action + benefit_no_action


class NetBenefitDisplay:
    &#34;&#34;&#34;Net benefit decision curve analysis visualisation.

    Example:
        Create some toy data and fit a model:
        ```python
        from sklearn.datasets import make_blobs
        from sklearn.linear_model import LogisticRegression

        centers = [[0, 0], [1, 1]]
        X_train, y_train = make_blobs(
            centers=centers, cluster_std=1, n_samples=20, random_state=5
        )
        X_test, y_test = make_blobs(
            centers=centers, cluster_std=1, n_samples=20, random_state=1005
        )

        clf = LogisticRegression(random_state=5).fit(X_train, y_train)
        ```

        Use the model&#39;s predictions to make a net benefit curve:

        ```python
        from statkit.decision import NetBenefitDisplay

        y_pred_base = clf.predict_proba(X_test)[:, 1]
        NetBenefitDisplay.from_predictions(y_test, y_pred_base, name=&#39;Logistic Regression&#39;)
        ```

    Args:
        threshold_probability: Probability to dichotomise the predicted probability
            of the model.
        net_benefit: Net benefit of taking an action as a function of
            `threshold_probability`.
        oracle: The (constant) net benefit of a perfect predictor.
        benefit_type: Literal[&#34;action&#34;, &#34;noop&#34;, &#34;overall&#34;] = &#34;action&#34;,
    &#34;&#34;&#34;

    def __init__(
        self,
        threshold_probability,
        net_benefit,
        net_benefit_action=None,
        net_benefit_noop=None,
        benefit_type: Literal[&#34;action&#34;, &#34;noop&#34;, &#34;overall&#34;] = &#34;action&#34;,
        oracle: Optional[float] = None,
        estimator_name: Optional[str] = None,
    ):
        self.threshold_probability = threshold_probability
        self.net_benefit = net_benefit
        self.net_benefit_action = net_benefit_action
        self.net_benefit_noop = net_benefit_noop
        self.benefit_type = benefit_type
        self.estimator_name = estimator_name
        self.oracle = oracle

    def plot(self, show_references: bool = True, ax=None):
        &#34;&#34;&#34;
        Args:
            show_references: Show oracle (requires prevalence) and no
                action/treatment/intervention reference curves.
            ax: Optional axes object to plot on. If `None`, a new figure and axes is
                created.
        &#34;&#34;&#34;
        if ax is None:
            _, ax = plt.subplots()
        self.ax_ = ax
        self.figure_ = ax.figure

        ax.plot(
            self.threshold_probability, self.net_benefit, &#34;-&#34;, label=self.estimator_name
        )
        if show_references:
            ax.plot(
                self.threshold_probability,
                self.net_benefit_action,
                &#34;:&#34;,
                label=&#34;Always act&#34;,
            )
            ax.plot(
                self.threshold_probability,
                self.net_benefit_noop,
                &#34;-.&#34;,
                label=&#34;Never act&#34;,
            )

            if self.oracle is not None:
                ax.plot([0, 1], [self.oracle, self.oracle], &#34;--&#34;, label=&#34;Oracle&#34;)

        ylabel = &#34;Net benefit&#34;
        if self.benefit_type == &#34;action&#34;:
            ylabel = &#34;Net benefit (action)&#34;
        if self.benefit_type == &#34;noop&#34;:
            ylabel = &#34;Net benefit (no-action)&#34;
        if self.benefit_type == &#34;overall&#34;:
            ylabel = &#34;Overall net benefit&#34;

        ax.set(xlabel=&#34;Threshold probability&#34;, ylabel=ylabel)
        margin = 0.05
        ax.set_ylim([-margin, 1 + margin])
        ax.legend(loc=&#34;upper right&#34;, frameon=False)

        return self

    @classmethod
    def from_predictions(
        cls,
        y_true,
        y_pred,
        benefit_type: Literal[&#34;action&#34;, &#34;noop&#34;, &#34;overall&#34;] = &#34;action&#34;,
        thresholds: int = 100,
        name: Optional[str] = None,
        show_references: bool = True,
        ax=None,
    ):
        &#34;&#34;&#34;Make a net benefit plot from true and predicted labels.

        Args:
            y_true: Binary ground truth label (1: positive, 0: negative class).
            y_pred: Predicted class labels.
            benefit_type: Type of net benefit curve. `&#34;action&#34;`: net benefit of
                treatment/intervention/action; `&#34;noop`: net benefit of no
                treatment/intervention/action; `&#34;overall&#34;`: overall net benefit (see
                `overall_net_benefit`).
            show_references: Show oracle (requires prevalence) and no
                action/treatment/intervention reference curves.
            thresholds: When an array, evaluate net benefit at these coordinates (the
                probability thresholds). When an int, the number of x coordinates.
            ax: Optional axes object to plot on. If `None`, a new figure and axes is
                created.

        &#34;&#34;&#34;
        if benefit_type == &#34;action&#34;:
            oracle = net_benefit_oracle(y_true, action=True)
            thresholds, benefit = net_benefit(y_true, y_pred, thresholds)
            benefit_action = net_benefit_action(y_true, thresholds, action=True)
            benefit_noop = zeros_like(benefit)

        elif benefit_type == &#34;noop&#34;:
            oracle = net_benefit_oracle(y_true, action=False)
            thresholds, benefit = net_benefit(y_true, y_pred, thresholds, action=False)
            benefit_noop = net_benefit_action(y_true, thresholds, action=False)
            benefit_action = zeros_like(benefit)

        elif benefit_type == &#34;overall&#34;:
            oracle = 1.0
            thresholds, benefit = overall_net_benefit(y_true, y_pred, thresholds)
            benefit_action = net_benefit_action(y_true, thresholds, action=True)
            benefit_noop = net_benefit_action(y_true, thresholds, action=False)

        return cls(
            thresholds,
            benefit,
            benefit_action,
            benefit_noop,
            benefit_type,
            oracle,
            estimator_name=name,
        ).plot(ax=ax, show_references=show_references)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="statkit.decision.net_benefit"><code class="name flex">
<span>def <span class="ident">net_benefit</span></span>(<span>y_true:Â pandas.core.series.SeriesÂ |Â numpy.ndarray[typing.Any,Â numpy.dtype[+_ScalarType_co]], y_pred:Â pandas.core.series.SeriesÂ |Â numpy.ndarray[typing.Any,Â numpy.dtype[+_ScalarType_co]], thresholds=100, action:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Net benefit of taking an action using a model's predictions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y_true</code></strong></dt>
<dd>Binary ground truth label (1: positive, 0: negative class).</dd>
<dt><strong><code>y_pred</code></strong></dt>
<dd>Probability of positive class label.</dd>
<dt><strong><code>thresholds</code></strong></dt>
<dd>When an array, evaluate net benefit at these coordinates (the
probability thresholds). When an int, the number of x coordinates.</dd>
<dt><strong><code>action</code></strong></dt>
<dd>When <code>True</code> (<code>False</code>), estimate net benefit of taking (not taking) an
action/intervention/treatment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>thresholds</code></dt>
<dd>Probability threshold of prediction a positive class.</dd>
<dt><code>benefit</code></dt>
<dd>The net benefit corresponding to the thresholds.</dd>
</dl>
<h2 id="references">References</h2>
<p>[1]: Vickers-Elkin. "Decision curve analysis: a novel method for evaluating
prediction models." Medical Decision Making 26.6 (2006): 565-574.</p>
<p>[2]: Rousson-Zumbrunn. "Decision curve analysis revisited: overall net
benefit, relationships to ROC curve analysis, and application to case-control
studies." BMC medical informatics and decision making 11.1 (2011): 1â€“9.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def net_benefit(
    y_true: Series | NDArray,
    y_pred: Series | NDArray,
    thresholds=100,
    action: bool = True,
):
    &#34;&#34;&#34;Net benefit of taking an action using a model&#39;s predictions.

    Args:
        y_true: Binary ground truth label (1: positive, 0: negative class).
        y_pred: Probability of positive class label.
        thresholds: When an array, evaluate net benefit at these coordinates (the
            probability thresholds). When an int, the number of x coordinates.
        action: When `True` (`False`), estimate net benefit of taking (not taking) an
            action/intervention/treatment.

    Returns:
        thresholds: Probability threshold of prediction a positive class.
        benefit: The net benefit corresponding to the thresholds.

    References:
        [1]: Vickers-Elkin. &#34;Decision curve analysis: a novel method for evaluating
        prediction models.&#34; Medical Decision Making 26.6 (2006): 565-574.

        [2]: Rousson-Zumbrunn. &#34;Decision curve analysis revisited: overall net
        benefit, relationships to ROC curve analysis, and application to case-control
        studies.&#34; BMC medical informatics and decision making 11.1 (2011): 1â€“9.
    &#34;&#34;&#34;
    if set(y_true.astype(int)) != {0, 1}:
        raise ValueError(
            &#34;Decision curve analysis only supports binary classification (with labels 1 and 0).&#34;
        )

    if isinstance(thresholds, int):
        thresholds = linspace(0, 1, num=thresholds)

    N = len(y_true)
    tns, fps, fns, tps = _binary_classification_thresholds(y_true, y_pred, thresholds)
    if action:
        loss_over_profit = divide(
            thresholds, 1 - thresholds, where=thresholds &lt; 1, out=zeros_like(thresholds)
        )

        benefit = tps / N - fps / N * loss_over_profit
    else:
        # Invert 0&lt;--&gt;1 so that true positives are true negatives, and false positives
        # are false negatives.
        profit_over_loss = divide(
            1 - thresholds,
            thresholds,
            where=thresholds != 0,
            out=zeros_like(thresholds),
        )
        benefit = tns / N - fns / N * profit_over_loss
    return thresholds, benefit</code></pre>
</details>
</dd>
<dt id="statkit.decision.net_benefit_action"><code class="name flex">
<span>def <span class="ident">net_benefit_action</span></span>(<span>y_true, thresholds, action:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Net benefit of always doing an action/intervention/treatment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong></dt>
<dd>When <code>False</code>, invert positive label in <code>y_true</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def net_benefit_action(y_true, thresholds, action: bool = True):
    &#34;&#34;&#34;Net benefit of always doing an action/intervention/treatment.

    Args:
        action: When `False`, invert positive label in `y_true`.
    &#34;&#34;&#34;
    if action:
        loss_over_profit = divide(
            thresholds,
            1 - thresholds,
            where=thresholds &lt; 1,
            out=1e9 * ones_like(thresholds),
        )
        return y_true.mean() - (1 - y_true.mean()) * loss_over_profit
    profit_over_loss = divide(
        1 - thresholds,
        thresholds,
        where=thresholds != 0,
        out=1e9 * ones_like(thresholds),
    )
    return 1 - y_true.mean() - y_true.mean() * profit_over_loss</code></pre>
</details>
</dd>
<dt id="statkit.decision.net_benefit_oracle"><code class="name flex">
<span>def <span class="ident">net_benefit_oracle</span></span>(<span>y_true, action:Â boolÂ =Â True) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Net benefit of omniscient strategy, i.e., a hypothetical perfect predictor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def net_benefit_oracle(y_true, action: bool = True) -&gt; float:
    &#34;&#34;&#34;Net benefit of omniscient strategy, i.e., a hypothetical perfect predictor.&#34;&#34;&#34;
    if action:
        return y_true.mean()
    return 1 - y_true.mean()</code></pre>
</details>
</dd>
<dt id="statkit.decision.overall_net_benefit"><code class="name flex">
<span>def <span class="ident">overall_net_benefit</span></span>(<span>y_true, y_pred, n_thresholds:Â intÂ =Â 100)</span>
</code></dt>
<dd>
<div class="desc"><p>Net benefit combining both taking and not-taking action.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overall_net_benefit(y_true, y_pred, n_thresholds: int = 100):
    &#34;&#34;&#34;Net benefit combining both taking and not-taking action.&#34;&#34;&#34;
    thresholds_action, benefit_action = net_benefit(
        y_true, y_pred, n_thresholds, action=True
    )
    _, benefit_no_action = net_benefit(y_true, y_pred, thresholds_action, action=False)
    return thresholds_action, benefit_action + benefit_no_action</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="statkit.decision.NetBenefitDisplay"><code class="flex name class">
<span>class <span class="ident">NetBenefitDisplay</span></span>
<span>(</span><span>threshold_probability, net_benefit, net_benefit_action=None, net_benefit_noop=None, benefit_type:Â Literal['action',Â 'noop',Â 'overall']Â =Â 'action', oracle:Â Optional[float]Â =Â None, estimator_name:Â Optional[str]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Net benefit decision curve analysis visualisation.</p>
<h2 id="example">Example</h2>
<p>Create some toy data and fit a model:</p>
<pre><code class="language-python">from sklearn.datasets import make_blobs
from sklearn.linear_model import LogisticRegression

centers = [[0, 0], [1, 1]]
X_train, y_train = make_blobs(
    centers=centers, cluster_std=1, n_samples=20, random_state=5
)
X_test, y_test = make_blobs(
    centers=centers, cluster_std=1, n_samples=20, random_state=1005
)

clf = LogisticRegression(random_state=5).fit(X_train, y_train)
</code></pre>
<p>Use the model's predictions to make a net benefit curve:</p>
<pre><code class="language-python">from statkit.decision import NetBenefitDisplay

y_pred_base = clf.predict_proba(X_test)[:, 1]
NetBenefitDisplay.from_predictions(y_test, y_pred_base, name='Logistic Regression')
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>threshold_probability</code></strong></dt>
<dd>Probability to dichotomise the predicted probability
of the model.</dd>
<dt><strong><code>net_benefit</code></strong></dt>
<dd>Net benefit of taking an action as a function of
<code>threshold_probability</code>.</dd>
<dt><strong><code>oracle</code></strong></dt>
<dd>The (constant) net benefit of a perfect predictor.</dd>
<dt><strong><code>benefit_type</code></strong></dt>
<dd>Literal["action", "noop", "overall"] = "action",</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetBenefitDisplay:
    &#34;&#34;&#34;Net benefit decision curve analysis visualisation.

    Example:
        Create some toy data and fit a model:
        ```python
        from sklearn.datasets import make_blobs
        from sklearn.linear_model import LogisticRegression

        centers = [[0, 0], [1, 1]]
        X_train, y_train = make_blobs(
            centers=centers, cluster_std=1, n_samples=20, random_state=5
        )
        X_test, y_test = make_blobs(
            centers=centers, cluster_std=1, n_samples=20, random_state=1005
        )

        clf = LogisticRegression(random_state=5).fit(X_train, y_train)
        ```

        Use the model&#39;s predictions to make a net benefit curve:

        ```python
        from statkit.decision import NetBenefitDisplay

        y_pred_base = clf.predict_proba(X_test)[:, 1]
        NetBenefitDisplay.from_predictions(y_test, y_pred_base, name=&#39;Logistic Regression&#39;)
        ```

    Args:
        threshold_probability: Probability to dichotomise the predicted probability
            of the model.
        net_benefit: Net benefit of taking an action as a function of
            `threshold_probability`.
        oracle: The (constant) net benefit of a perfect predictor.
        benefit_type: Literal[&#34;action&#34;, &#34;noop&#34;, &#34;overall&#34;] = &#34;action&#34;,
    &#34;&#34;&#34;

    def __init__(
        self,
        threshold_probability,
        net_benefit,
        net_benefit_action=None,
        net_benefit_noop=None,
        benefit_type: Literal[&#34;action&#34;, &#34;noop&#34;, &#34;overall&#34;] = &#34;action&#34;,
        oracle: Optional[float] = None,
        estimator_name: Optional[str] = None,
    ):
        self.threshold_probability = threshold_probability
        self.net_benefit = net_benefit
        self.net_benefit_action = net_benefit_action
        self.net_benefit_noop = net_benefit_noop
        self.benefit_type = benefit_type
        self.estimator_name = estimator_name
        self.oracle = oracle

    def plot(self, show_references: bool = True, ax=None):
        &#34;&#34;&#34;
        Args:
            show_references: Show oracle (requires prevalence) and no
                action/treatment/intervention reference curves.
            ax: Optional axes object to plot on. If `None`, a new figure and axes is
                created.
        &#34;&#34;&#34;
        if ax is None:
            _, ax = plt.subplots()
        self.ax_ = ax
        self.figure_ = ax.figure

        ax.plot(
            self.threshold_probability, self.net_benefit, &#34;-&#34;, label=self.estimator_name
        )
        if show_references:
            ax.plot(
                self.threshold_probability,
                self.net_benefit_action,
                &#34;:&#34;,
                label=&#34;Always act&#34;,
            )
            ax.plot(
                self.threshold_probability,
                self.net_benefit_noop,
                &#34;-.&#34;,
                label=&#34;Never act&#34;,
            )

            if self.oracle is not None:
                ax.plot([0, 1], [self.oracle, self.oracle], &#34;--&#34;, label=&#34;Oracle&#34;)

        ylabel = &#34;Net benefit&#34;
        if self.benefit_type == &#34;action&#34;:
            ylabel = &#34;Net benefit (action)&#34;
        if self.benefit_type == &#34;noop&#34;:
            ylabel = &#34;Net benefit (no-action)&#34;
        if self.benefit_type == &#34;overall&#34;:
            ylabel = &#34;Overall net benefit&#34;

        ax.set(xlabel=&#34;Threshold probability&#34;, ylabel=ylabel)
        margin = 0.05
        ax.set_ylim([-margin, 1 + margin])
        ax.legend(loc=&#34;upper right&#34;, frameon=False)

        return self

    @classmethod
    def from_predictions(
        cls,
        y_true,
        y_pred,
        benefit_type: Literal[&#34;action&#34;, &#34;noop&#34;, &#34;overall&#34;] = &#34;action&#34;,
        thresholds: int = 100,
        name: Optional[str] = None,
        show_references: bool = True,
        ax=None,
    ):
        &#34;&#34;&#34;Make a net benefit plot from true and predicted labels.

        Args:
            y_true: Binary ground truth label (1: positive, 0: negative class).
            y_pred: Predicted class labels.
            benefit_type: Type of net benefit curve. `&#34;action&#34;`: net benefit of
                treatment/intervention/action; `&#34;noop`: net benefit of no
                treatment/intervention/action; `&#34;overall&#34;`: overall net benefit (see
                `overall_net_benefit`).
            show_references: Show oracle (requires prevalence) and no
                action/treatment/intervention reference curves.
            thresholds: When an array, evaluate net benefit at these coordinates (the
                probability thresholds). When an int, the number of x coordinates.
            ax: Optional axes object to plot on. If `None`, a new figure and axes is
                created.

        &#34;&#34;&#34;
        if benefit_type == &#34;action&#34;:
            oracle = net_benefit_oracle(y_true, action=True)
            thresholds, benefit = net_benefit(y_true, y_pred, thresholds)
            benefit_action = net_benefit_action(y_true, thresholds, action=True)
            benefit_noop = zeros_like(benefit)

        elif benefit_type == &#34;noop&#34;:
            oracle = net_benefit_oracle(y_true, action=False)
            thresholds, benefit = net_benefit(y_true, y_pred, thresholds, action=False)
            benefit_noop = net_benefit_action(y_true, thresholds, action=False)
            benefit_action = zeros_like(benefit)

        elif benefit_type == &#34;overall&#34;:
            oracle = 1.0
            thresholds, benefit = overall_net_benefit(y_true, y_pred, thresholds)
            benefit_action = net_benefit_action(y_true, thresholds, action=True)
            benefit_noop = net_benefit_action(y_true, thresholds, action=False)

        return cls(
            thresholds,
            benefit,
            benefit_action,
            benefit_noop,
            benefit_type,
            oracle,
            estimator_name=name,
        ).plot(ax=ax, show_references=show_references)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="statkit.decision.NetBenefitDisplay.from_predictions"><code class="name flex">
<span>def <span class="ident">from_predictions</span></span>(<span>y_true, y_pred, benefit_type:Â Literal['action',Â 'noop',Â 'overall']Â =Â 'action', thresholds:Â intÂ =Â 100, name:Â Optional[str]Â =Â None, show_references:Â boolÂ =Â True, ax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a net benefit plot from true and predicted labels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y_true</code></strong></dt>
<dd>Binary ground truth label (1: positive, 0: negative class).</dd>
<dt><strong><code>y_pred</code></strong></dt>
<dd>Predicted class labels.</dd>
<dt><strong><code>benefit_type</code></strong></dt>
<dd>Type of net benefit curve. <code>"action"</code>: net benefit of
treatment/intervention/action; <code>"noop</code>: net benefit of no
treatment/intervention/action; <code>"overall"</code>: overall net benefit (see
<code><a title="statkit.decision.overall_net_benefit" href="#statkit.decision.overall_net_benefit">overall_net_benefit()</a></code>).</dd>
<dt><strong><code>show_references</code></strong></dt>
<dd>Show oracle (requires prevalence) and no
action/treatment/intervention reference curves.</dd>
<dt><strong><code>thresholds</code></strong></dt>
<dd>When an array, evaluate net benefit at these coordinates (the
probability thresholds). When an int, the number of x coordinates.</dd>
<dt><strong><code>ax</code></strong></dt>
<dd>Optional axes object to plot on. If <code>None</code>, a new figure and axes is
created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_predictions(
    cls,
    y_true,
    y_pred,
    benefit_type: Literal[&#34;action&#34;, &#34;noop&#34;, &#34;overall&#34;] = &#34;action&#34;,
    thresholds: int = 100,
    name: Optional[str] = None,
    show_references: bool = True,
    ax=None,
):
    &#34;&#34;&#34;Make a net benefit plot from true and predicted labels.

    Args:
        y_true: Binary ground truth label (1: positive, 0: negative class).
        y_pred: Predicted class labels.
        benefit_type: Type of net benefit curve. `&#34;action&#34;`: net benefit of
            treatment/intervention/action; `&#34;noop`: net benefit of no
            treatment/intervention/action; `&#34;overall&#34;`: overall net benefit (see
            `overall_net_benefit`).
        show_references: Show oracle (requires prevalence) and no
            action/treatment/intervention reference curves.
        thresholds: When an array, evaluate net benefit at these coordinates (the
            probability thresholds). When an int, the number of x coordinates.
        ax: Optional axes object to plot on. If `None`, a new figure and axes is
            created.

    &#34;&#34;&#34;
    if benefit_type == &#34;action&#34;:
        oracle = net_benefit_oracle(y_true, action=True)
        thresholds, benefit = net_benefit(y_true, y_pred, thresholds)
        benefit_action = net_benefit_action(y_true, thresholds, action=True)
        benefit_noop = zeros_like(benefit)

    elif benefit_type == &#34;noop&#34;:
        oracle = net_benefit_oracle(y_true, action=False)
        thresholds, benefit = net_benefit(y_true, y_pred, thresholds, action=False)
        benefit_noop = net_benefit_action(y_true, thresholds, action=False)
        benefit_action = zeros_like(benefit)

    elif benefit_type == &#34;overall&#34;:
        oracle = 1.0
        thresholds, benefit = overall_net_benefit(y_true, y_pred, thresholds)
        benefit_action = net_benefit_action(y_true, thresholds, action=True)
        benefit_noop = net_benefit_action(y_true, thresholds, action=False)

    return cls(
        thresholds,
        benefit,
        benefit_action,
        benefit_noop,
        benefit_type,
        oracle,
        estimator_name=name,
    ).plot(ax=ax, show_references=show_references)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="statkit.decision.NetBenefitDisplay.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, show_references:Â boolÂ =Â True, ax=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>show_references</code></strong></dt>
<dd>Show oracle (requires prevalence) and no
action/treatment/intervention reference curves.</dd>
<dt><strong><code>ax</code></strong></dt>
<dd>Optional axes object to plot on. If <code>None</code>, a new figure and axes is
created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, show_references: bool = True, ax=None):
    &#34;&#34;&#34;
    Args:
        show_references: Show oracle (requires prevalence) and no
            action/treatment/intervention reference curves.
        ax: Optional axes object to plot on. If `None`, a new figure and axes is
            created.
    &#34;&#34;&#34;
    if ax is None:
        _, ax = plt.subplots()
    self.ax_ = ax
    self.figure_ = ax.figure

    ax.plot(
        self.threshold_probability, self.net_benefit, &#34;-&#34;, label=self.estimator_name
    )
    if show_references:
        ax.plot(
            self.threshold_probability,
            self.net_benefit_action,
            &#34;:&#34;,
            label=&#34;Always act&#34;,
        )
        ax.plot(
            self.threshold_probability,
            self.net_benefit_noop,
            &#34;-.&#34;,
            label=&#34;Never act&#34;,
        )

        if self.oracle is not None:
            ax.plot([0, 1], [self.oracle, self.oracle], &#34;--&#34;, label=&#34;Oracle&#34;)

    ylabel = &#34;Net benefit&#34;
    if self.benefit_type == &#34;action&#34;:
        ylabel = &#34;Net benefit (action)&#34;
    if self.benefit_type == &#34;noop&#34;:
        ylabel = &#34;Net benefit (no-action)&#34;
    if self.benefit_type == &#34;overall&#34;:
        ylabel = &#34;Overall net benefit&#34;

    ax.set(xlabel=&#34;Threshold probability&#34;, ylabel=ylabel)
    margin = 0.05
    ax.set_ylim([-margin, 1 + margin])
    ax.legend(loc=&#34;upper right&#34;, frameon=False)

    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="statkit" href="index.html">statkit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="statkit.decision.net_benefit" href="#statkit.decision.net_benefit">net_benefit</a></code></li>
<li><code><a title="statkit.decision.net_benefit_action" href="#statkit.decision.net_benefit_action">net_benefit_action</a></code></li>
<li><code><a title="statkit.decision.net_benefit_oracle" href="#statkit.decision.net_benefit_oracle">net_benefit_oracle</a></code></li>
<li><code><a title="statkit.decision.overall_net_benefit" href="#statkit.decision.overall_net_benefit">overall_net_benefit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="statkit.decision.NetBenefitDisplay" href="#statkit.decision.NetBenefitDisplay">NetBenefitDisplay</a></code></h4>
<ul class="">
<li><code><a title="statkit.decision.NetBenefitDisplay.from_predictions" href="#statkit.decision.NetBenefitDisplay.from_predictions">from_predictions</a></code></li>
<li><code><a title="statkit.decision.NetBenefitDisplay.plot" href="#statkit.decision.NetBenefitDisplay.plot">plot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>