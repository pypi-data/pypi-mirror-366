# 实施计划：修复优雅停机流程中调度器停止问题

## 任务清单

### 阶段 1：核心修复实施

- [x] 1. 修改 `_graceful_shutdown()` 方法
  - [x] 1.1 在 `src/mx_rmq/queue.py` 中定位 `_graceful_shutdown()` 方法
  - [x] 1.2 在步骤 1 "停止接收新消息" 之前添加调度器停止逻辑
  - [x] 1.3 添加 `self._logger.info("【stop】停止调度器服务...")` 日志
  - [x] 1.4 添加调度器停止调用：`await self._monitor_service.stop_delay_processing()`
  - [x] 1.5 添加异常处理确保调度器停止失败不影响后续步骤

- [x] 2. 增强 `ScheduleService.stop_delay_processing()` 方法
  - [x] 2.1 在 `src/mx_rmq/core/schedule.py` 中定位 `stop_delay_processing()` 方法
  - [x] 2.2 添加运行状态检查，如果未运行则直接返回
  - [x] 2.3 为 `scheduler_task` 等待添加 5 秒超时保护
  - [x] 2.4 添加 `finally` 块确保 `scheduler_task` 被重置为 `None`
  - [x] 2.5 改进异常处理和日志记录

- [x] 3. 改进 `delay_scheduler_loop()` 停止响应
  - [x] 3.1 在循环开始时添加 `is_running` 状态检查
  - [x] 3.2 为长时间等待（>5秒）实现分段等待机制
  - [x] 3.3 在异常处理中添加 `is_running` 状态检查
  - [x] 3.4 确保只有在运行状态下才记录错误日志

- [x] 4. 改进 `pubsub_listener()` 停止逻辑
  - [x] 4.1 在重连等待循环中添加停止状态检查
  - [x] 4.2 将长时间等待分解为小段，每 0.1 秒检查一次停止状态
  - [x] 4.3 确保在 `is_running = False` 时快速退出所有等待循环

### 阶段 2：测试实施

- [x] 5. 测试验证
  - [x] 5.1 创建 `test_graceful_shutdown_fix.py` 测试文件
  - [x] 5.2 测试 `stop_delay_processing()` 方法的正常停止场景
  - [x] 5.3 测试 `stop_delay_processing()` 方法的重复调用场景
  - [x] 5.4 测试 `stop_delay_processing()` 方法的超时场景
  - [x] 5.5 测试 `_graceful_shutdown()` 包含调度器停止的完整流程

- [ ] 6. 编写集成测试
  - [ ] 6.1 测试完整的 `queue.stop()` 流程
  - [ ] 6.2 测试信号处理（SIGINT）的停机流程
  - [ ] 6.3 测试有延时任务时的停机行为
  - [ ] 6.4 测试高负载下的停机行为

- [ ] 7. 编写压力测试
  - [ ] 7.1 实现连续启停测试（100次循环）
  - [ ] 7.2 实现并发停机测试
  - [ ] 7.3 实现异常情况下的停机测试

### 阶段 3：验证和优化

- [ ] 8. 功能验证
  - [ ] 8.1 验证 Ctrl+C 能够在 30 秒内完全停止程序
  - [ ] 8.2 验证 `await queue.stop()` 能够正确停止所有服务
  - [ ] 8.3 验证停机过程中的日志输出完整性
  - [ ] 8.4 验证没有僵尸进程或未关闭的连接

- [ ] 9. 性能验证
  - [ ] 9.1 测量正常情况下的停机时间（目标：5-10秒）
  - [ ] 9.2 测量有延时任务时的停机时间
  - [ ] 9.3 测量高负载下的停机时间
  - [ ] 9.4 验证停机过程中的资源占用

- [ ] 10. 边界情况测试
  - [ ] 10.1 测试调度器未启动时的停机行为
  - [ ] 10.2 测试调度器已停止时的重复停止调用
  - [ ] 10.3 测试网络异常时的停机行为
  - [ ] 10.4 测试 Redis 连接异常时的停机行为

### 阶段 4：文档和清理

- [ ] 11. 更新文档
  - [ ] 11.1 更新 README.md 中的优雅停机说明
  - [ ] 11.2 更新 API 文档中的 `stop()` 方法说明
  - [ ] 11.3 添加停机流程的故障排除指南
  - [ ] 11.4 更新示例代码中的停机处理

- [ ] 12. 代码清理
  - [ ] 12.1 检查并移除不必要的调试日志
  - [ ] 12.2 确保代码符合项目的编码规范
  - [ ] 12.3 运行 `black` 和 `ruff` 进行代码格式化
  - [ ] 12.4 运行 `mypy` 进行类型检查

- [ ] 13. 最终验证
  - [ ] 13.1 运行完整的测试套件确保没有回归
  - [ ] 13.2 在示例项目中验证修复效果
  - [ ] 13.3 进行代码审查
  - [ ] 13.4 准备发布说明

## 实施顺序说明

### 依赖关系
- 任务 2 依赖任务 1（需要先修改调用方再增强被调用方）
- 任务 5-7 依赖任务 1-4（测试需要在代码修改完成后进行）
- 任务 8-10 依赖任务 5-7（验证需要在测试完成后进行）
- 任务 11-13 依赖任务 8-10（文档和清理在功能验证完成后进行）

### 关键路径
1. **核心修复**：任务 1 → 任务 2 → 任务 3 → 任务 4
2. **测试验证**：任务 5 → 任务 6 → 任务 8
3. **性能优化**：任务 7 → 任务 9 → 任务 10
4. **发布准备**：任务 11 → 任务 12 → 任务 13

### 预估工作量
- **阶段 1**：2-3 小时（核心修复）
- **阶段 2**：3-4 小时（测试实施）
- **阶段 3**：2-3 小时（验证和优化）
- **阶段 4**：1-2 小时（文档和清理）
- **总计**：8-12 小时

### 风险评估
- **低风险**：任务 1-4（核心修复逻辑清晰）
- **中风险**：任务 5-7（测试可能发现边界情况）
- **低风险**：任务 8-13（验证和文档工作）

### 成功标准
- 所有任务完成率达到 100%
- 所有测试通过率达到 100%
- 停机时间控制在 30 秒以内
- 没有资源泄漏或僵尸进程

## Rules & Tips

### 实施过程中的发现和约束

1. **队列启动方法**：RedisMessageQueue 使用 `start_background()` 方法启动后台服务，而不是 `start_consuming()` 方法。

2. **调度器停止逻辑**：在 `_graceful_shutdown()` 中必须先停止调度器服务，再停止接收新消息，确保延时任务不会在停机过程中被重新调度。

3. **超时保护**：所有异步等待操作都应该有超时保护，特别是 `scheduler_task` 的等待，建议使用 5 秒超时。

4. **分段等待机制**：对于长时间等待（>5秒），应该实现分段等待机制，每小段时间检查一次停止状态，以提高停止响应速度。

5. **异常处理原则**：停机过程中的异常不应该阻止后续停机步骤的执行，应该记录错误但继续执行。

6. **状态检查频率**：在循环中应该在适当的位置检查 `is_running` 状态，包括循环开始时和长时间等待时。

7. **资源清理**：确保在 `finally` 块中重置任务引用（如 `scheduler_task = None`），避免资源泄漏。