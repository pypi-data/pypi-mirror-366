from typing import overload, Any, Callable, TypeVar, Union
from typing import Tuple, List, Sequence, MutableSequence

Callback = Union[Callable[..., None], None]
Buffer = TypeVar('Buffer')
Pointer = TypeVar('Pointer')
Template = TypeVar('Template')

import xsigmamodules.Core

matrix:'template'
tensor:'template'
vector:'template'

class matrix_IdE(object):
    def at(self, i:int, j:int) -> 'auto': ...
    def columns(self) -> 'auto': ...
    @overload
    def data(self) -> 'auto': ...
    @overload
    def data(self, idx:int) -> 'auto': ...
    def dimensions() -> int: ...
    def empty(self) -> bool: ...
    def identity(self) -> bool: ...
    def is_correlation(self) -> bool: ...
    def is_zero(self) -> bool: ...
    def length() -> int: ...
    def non_negative(self) -> bool: ...
    def positive(self) -> bool: ...
    def rows(self) -> 'auto': ...
    def size(self) -> 'auto': ...
    def static_cast(self) -> 'matrix_IdE': ...
    def symmetric(self) -> bool: ...
    def to_string(self) -> str: ...
    def trace(self) -> 'auto': ...

class matrix_IfE(object):
    def at(self, i:int, j:int) -> 'auto': ...
    def columns(self) -> 'auto': ...
    @overload
    def data(self) -> 'auto': ...
    @overload
    def data(self, idx:int) -> 'auto': ...
    def dimensions() -> int: ...
    def empty(self) -> bool: ...
    def identity(self) -> bool: ...
    def is_correlation(self) -> bool: ...
    def is_zero(self) -> bool: ...
    def length() -> int: ...
    def non_negative(self) -> bool: ...
    def positive(self) -> bool: ...
    def rows(self) -> 'auto': ...
    def size(self) -> 'auto': ...
    def static_cast(self) -> 'matrix_IfE': ...
    def symmetric(self) -> bool: ...
    def to_string(self) -> str: ...
    def trace(self) -> 'auto': ...

class tensor_IdE(object):
    def at(self, indices:Sequence[int]) -> float: ...
    def begin(self) -> 'auto': ...
    def data(self) -> 'auto': ...
    def dimension(self, n:int) -> int: ...
    def dimensions(self) -> Tuple[int, int]: ...
    def end(self) -> 'auto': ...
    @overload
    def get_matrix(self, indice:int) -> 'matrix_IdE': ...
    @overload
    def get_matrix(self, indices:Sequence[int]) -> 'matrix_IdE': ...
    def length() -> int: ...
    def rank(self) -> int: ...
    def size(self) -> 'auto': ...
    def static_cast(self) -> 'tensor_IdE': ...

class tensor_IfE(object):
    def at(self, indices:Sequence[int]) -> float: ...
    def begin(self) -> 'auto': ...
    def data(self) -> 'auto': ...
    def dimension(self, n:int) -> int: ...
    def dimensions(self) -> Tuple[int, int]: ...
    def end(self) -> 'auto': ...
    @overload
    def get_matrix(self, indice:int) -> 'matrix_IfE': ...
    @overload
    def get_matrix(self, indices:Sequence[int]) -> 'matrix_IfE': ...
    def length() -> int: ...
    def rank(self) -> int: ...
    def size(self) -> 'auto': ...
    def static_cast(self) -> 'tensor_IfE': ...

class vector_IdE(object):
    def at(self, i:int) -> 'auto': ...
    def columns(self) -> 'auto': ...
    @overload
    def data(self) -> 'auto': ...
    @overload
    def data(self, i:int) -> Pointer: ...
    def dimensions() -> int: ...
    def length() -> int: ...
    def rows(self) -> 'auto': ...
    def size(self) -> 'auto': ...
    def static_cast(self) -> 'vector_IdE': ...
    def to_string(self) -> str: ...

class vector_IfE(object):
    def at(self, i:int) -> 'auto': ...
    def columns(self) -> 'auto': ...
    @overload
    def data(self) -> 'auto': ...
    @overload
    def data(self, i:int) -> Pointer: ...
    def dimensions() -> int: ...
    def length() -> int: ...
    def rows(self) -> 'auto': ...
    def size(self) -> 'auto': ...
    def static_cast(self) -> 'vector_IfE': ...
    def to_string(self) -> str: ...

