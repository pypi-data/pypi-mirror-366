from typing import overload, Any, Callable, TypeVar, Union
from typing import Tuple, List, Sequence, MutableSequence

Callback = Union[Callable[..., None], None]
Buffer = TypeVar('Buffer')
Pointer = TypeVar('Pointer')
Template = TypeVar('Template')

import xsigmamodules.Core

class callback_return_enum(int):
    INVALID:'callback_return_enum'
    SOLVER_ABORT:'callback_return_enum'
    SOLVER_CONTINUE:'callback_return_enum'
    SOLVER_TERMINATE_SUCCESSFULLY:'callback_return_enum'

class covariance_algorithm_enum(int):
    DENSE_SVD:'covariance_algorithm_enum'
    INVALID:'covariance_algorithm_enum'
    SPARSE_QR:'covariance_algorithm_enum'

class dense_linear_algebra_library_enum(int):
    CUDA:'dense_linear_algebra_library_enum'
    EIGEN:'dense_linear_algebra_library_enum'
    INVALID:'dense_linear_algebra_library_enum'
    LAPACK:'dense_linear_algebra_library_enum'

class dimension_enum(int):
    DYNAMIC:'dimension_enum'
    INVALID:'dimension_enum'

class dogleg_enum(int):
    INVALID:'dogleg_enum'
    SUBSPACE_DOGLEG:'dogleg_enum'
    TRADITIONAL_DOGLEG:'dogleg_enum'

class dump_format_enum(int):
    CONSOLE:'dump_format_enum'
    INVALID:'dump_format_enum'
    TEXTFILE:'dump_format_enum'

class hartman_watson_distribution_enum(int):
    FULLY_ASYMPTOTIC:'hartman_watson_distribution_enum'
    MIXTURE:'hartman_watson_distribution_enum'
    NUMERICAL_INTEGRAL:'hartman_watson_distribution_enum'

class interpolation_enum(int):
    CUBIC_HERMITE:'interpolation_enum'
    CUBIC_SPLINE:'interpolation_enum'
    FIXED_STRIKE:'interpolation_enum'
    GEOMETRIC:'interpolation_enum'
    GEOMETRIC_AVERAGE:'interpolation_enum'
    LINEAR:'interpolation_enum'
    LINEAR_EXPONENTIAL:'interpolation_enum'
    MEAN_REVERTING:'interpolation_enum'
    PIECEWISE_CONSTANT_LEFT:'interpolation_enum'
    PIECEWISE_CONSTANT_RIGHT:'interpolation_enum'

class lbfgs_line_search_method_type(int):
    ARMIJO:'lbfgs_line_search_method_type'
    STRONG_WOLFE:'lbfgs_line_search_method_type'
    WOLFE:'lbfgs_line_search_method_type'

class lbfgs_line_search_type(int):
    BACKTRACKING:'lbfgs_line_search_type'
    BRACKETING:'lbfgs_line_search_type'
    NOCEDAL_WRIGHT:'lbfgs_line_search_type'

class levenberg_marquardt_solver_enum(int):
    LEVENBERG:'levenberg_marquardt_solver_enum'
    NIELSEN:'levenberg_marquardt_solver_enum'
    QUADRATIC:'levenberg_marquardt_solver_enum'

class line_search_direction_enum(int):
    BFGS:'line_search_direction_enum'
    NONLINEAR_CONJUGATE_GRADIENT:'line_search_direction_enum'
    STEEPEST_DESCENT:'line_search_direction_enum'
    lbfgs_solver:'line_search_direction_enum'

class line_search_enum(int):
    ARMIJO:'line_search_enum'
    INVALID:'line_search_enum'
    WOLFE:'line_search_enum'

class line_search_interpolation_enum(int):
    BISECTION:'line_search_interpolation_enum'
    CUBIC:'line_search_interpolation_enum'
    INVALID:'line_search_interpolation_enum'
    QUADRATIC:'line_search_interpolation_enum'

class linear_solver_enum(int):
    CGNR:'linear_solver_enum'
    DENSE_NORMAL_CHOLESKY:'linear_solver_enum'
    DENSE_QR:'linear_solver_enum'
    DENSE_SCHUR:'linear_solver_enum'
    ITERATIVE_SCHUR:'linear_solver_enum'
    SPARSE_NORMAL_CHOLESKY:'linear_solver_enum'
    SPARSE_SCHUR:'linear_solver_enum'

class linear_solver_ordering_enum(int):
    AMD:'linear_solver_ordering_enum'
    INVALID:'linear_solver_ordering_enum'
    NESDIS:'linear_solver_ordering_enum'

class logging_enum(int):
    INVALID:'logging_enum'
    PER_MINIMIZER_ITERATION:'logging_enum'
    SILENT:'logging_enum'

class minimizer_enum(int):
    INVALID:'minimizer_enum'
    LINE_SEARCH:'minimizer_enum'
    TRUST_REGION:'minimizer_enum'

class nlopt_algo_name(int):
    AUGMENTED_LAGRANGIAN:'nlopt_algo_name'
    AUGMENTED_LAGRANGIAN_WITH_BOBYQA:'nlopt_algo_name'
    AUGMENTED_LAGRANGIAN_WITH_COBYLA:'nlopt_algo_name'
    AUGMENTED_LAGRANGIAN_WITH_EQUALITY_CONSTRAINTS:'nlopt_algo_name'
    BOUND_OPTIMIZATION_BY_QUADRATIC_APPROXIMATION:'nlopt_algo_name'
    CONSTRAINED_OPTIMIZATION_BY_LINEAR_APPROXIMATIONS:'nlopt_algo_name'
    CONTROLLED_RANDOM_SEARCH_WITH_LOCAL_MUTATION:'nlopt_algo_name'
    DIVIDING_RECTANGLES:'nlopt_algo_name'
    IMPROVED_STOCHASTIC_RANKING_EVOLUTION_STRATEGY:'nlopt_algo_name'
    LBFGS:'nlopt_algo_name'
    METHOD_OF_MOVING_ASYMPTOTES:'nlopt_algo_name'
    PRECONDITIONED_TRUNCATED_NEWTON_METHOD:'nlopt_algo_name'
    SEQUENTIAL_LEAST_SQUARES_PROGRAMMING:'nlopt_algo_name'
    VARIABLE_METRIC_METHOD:'nlopt_algo_name'

class nonlinear_conjugate_gradient_enum(int):
    FLETCHER_REEVES:'nonlinear_conjugate_gradient_enum'
    HESTENES_STIEFEL:'nonlinear_conjugate_gradient_enum'
    POLAK_RIBIERE:'nonlinear_conjugate_gradient_enum'

class numeric_diff_method_enum(int):
    CENTRAL:'numeric_diff_method_enum'
    FORWARD:'numeric_diff_method_enum'
    INVALID:'numeric_diff_method_enum'
    RIDDERS:'numeric_diff_method_enum'

class preconditioner_enum(int):
    CLUSTER_JACOBI:'preconditioner_enum'
    CLUSTER_TRIDIAGONAL:'preconditioner_enum'
    IDENTITY:'preconditioner_enum'
    JACOBI:'preconditioner_enum'
    SCHUR_JACOBI:'preconditioner_enum'
    SCHUR_POWER_SERIES_EXPANSION:'preconditioner_enum'
    SUBSET:'preconditioner_enum'

class solver_enum(int):
    CERES:'solver_enum'
    LBFGS:'solver_enum'
    LM:'solver_enum'
    NLOPT:'solver_enum'

class sparse_linear_algebra_library_enum(int):
    ACCELERATE_SPARSE:'sparse_linear_algebra_library_enum'
    CUDA_SPARSE:'sparse_linear_algebra_library_enum'
    EIGEN_SPARSE:'sparse_linear_algebra_library_enum'
    INVALID:'sparse_linear_algebra_library_enum'
    NO_SPARSE:'sparse_linear_algebra_library_enum'
    SUITE_SPARSE:'sparse_linear_algebra_library_enum'

class trust_region_strategy_enum(int):
    DOGLEG:'trust_region_strategy_enum'
    INVALID:'trust_region_strategy_enum'
    LEVENBERG_MARQUARDT:'trust_region_strategy_enum'

class visibility_clustering_enum(int):
    CANONICAL_VIEWS:'visibility_clustering_enum'
    SINGLE_LINKAGE:'visibility_clustering_enum'

class ceresSolver(object):
    def is_supported() -> bool: ...
    def static_cast(self) -> 'ceresSolver': ...

class copula(object):
    def density(self, u:Sequence[float]) -> float: ...
    def dimension(self) -> int: ...
    def evaluate(self, u:Sequence[float]) -> float: ...
    def static_cast(self) -> 'copula': ...

class claytonCopula(copula):
    @overload
    def __init__(self, theta:float) -> None: ...
    @overload
    def __init__(self, __a:'claytonCopula') -> None: ...
    def density(self, u:Sequence[float]) -> float: ...
    def dimension(self) -> int: ...
    def evaluate(self, u:Sequence[float]) -> float: ...
    def static_cast(self) -> 'claytonCopula': ...
    def theta(self) -> float: ...

class frankCopula(copula):
    @overload
    def __init__(self, theta:float) -> None: ...
    @overload
    def __init__(self, __a:'frankCopula') -> None: ...
    def density(self, u:Sequence[float]) -> float: ...
    def dimension(self) -> int: ...
    def evaluate(self, u:Sequence[float]) -> float: ...
    def static_cast(self) -> 'frankCopula': ...
    def theta(self) -> float: ...

class galambosCopula(copula):
    @overload
    def __init__(self, theta:float) -> None: ...
    @overload
    def __init__(self, __a:'galambosCopula') -> None: ...
    def density(self, u:Sequence[float]) -> float: ...
    def dimension(self) -> int: ...
    def evaluate(self, u:Sequence[float]) -> float: ...
    def static_cast(self) -> 'galambosCopula': ...
    def theta(self) -> float: ...

class gammaDistribution(object):
    def gamma(x:float) -> float: ...
    def lgamma(x:float) -> float: ...
    def static_cast(self) -> 'gammaDistribution': ...

class gaussianCopula(copula):
    @overload
    def __init__(self, rho:float) -> None: ...
    @overload
    def __init__(self, correlation_matrix:Sequence[float], dimension:int) -> None: ...
    @overload
    def __init__(self, __a:'gaussianCopula') -> None: ...
    def density(self, u:Sequence[float]) -> float: ...
    def dimension(self) -> int: ...
    def evaluate(self, u:Sequence[float]) -> float: ...
    def rho(self) -> float: ...
    def static_cast(self) -> 'gaussianCopula': ...

class gaussianQuadrature(object):
    def gauss_hermite_coefficients(np:int, points:'vector_IdE', weights:'vector_IdE', use_precomputed:bool=True, tolerance:float=..., max_iter:int=20) -> None: ...
    def gauss_kronrod(n:int, x:'vector_IdE', w1:'vector_IdE', w2:'vector_IdE', tolerance:float=1.e-14, max_iter:int=20) -> None: ...
    def gauss_laguerre_coefficients(alpha:float, n:int, points:'vector_IdE', weights:'vector_IdE', tolerance:float=..., max_iter:int=20) -> None: ...
    def gauss_legendre_coefficients(n:int, points:'vector_IdE', weights:'vector_IdE', tolerance:float=1.e-14) -> None: ...
    def static_cast(self) -> 'gaussianQuadrature': ...

class gumbelCopula(copula):
    @overload
    def __init__(self, theta:float) -> None: ...
    @overload
    def __init__(self, __a:'gumbelCopula') -> None: ...
    def density(self, u:Sequence[float]) -> float: ...
    def dimension(self) -> int: ...
    def evaluate(self, u:Sequence[float]) -> float: ...
    def static_cast(self) -> 'gumbelCopula': ...
    def theta(self) -> float: ...

class hartmanWatsonDistribution(object):
    def cheyette_density(density:'vector_IdE', U:'vector_IdE', t:float, roots:'vector_IdE', weights:'vector_IdE', hartman_watson_roots:'vector_IdE', hartman_watson_weights:'vector_IdE') -> None: ...
    def distribution(results:'vector_IdE', t:float, x:'vector_IdE', roots:'vector_IdE', weights:'vector_IdE', type:'hartman_watson_distribution_enum'=..., max_bound:float=...) -> None: ...
    def distribution_numerical(x:float, t:float, roots:'vector_IdE', weights:'vector_IdE') -> float: ...
    def log_distribution_asymptotique(x:float, t:float) -> float: ...
    def static_cast(self) -> 'hartmanWatsonDistribution': ...

class inverseGaussianDistribution(object):
    def cdf(x:float, lambda_:float) -> float: ...
    def density(x:float, lambda_:float) -> float: ...
    def static_cast(self) -> 'inverseGaussianDistribution': ...

class laplaceInverterGaverStehfest(object):
    @overload
    def __init__(self, size:int, shift:float) -> None: ...
    @overload
    def __init__(self, __a:'laplaceInverterGaverStehfest') -> None: ...
    def static_cast(self) -> 'laplaceInverterGaverStehfest': ...

class levenbergMarquardtSolver(object):
    def static_cast(self) -> 'levenbergMarquardtSolver': ...

class nloptSolver(object):
    def is_supported() -> bool: ...
    def static_cast(self) -> 'nloptSolver': ...

class normalDistribution(object):
    def cdf(z:float) -> float: ...
    def cdf_over_density(z:float) -> float: ...
    def density(x:float) -> float: ...
    @overload
    def inv_cdf(p:float) -> float: ...
    @overload
    def inv_cdf(size:int, uniform:Sequence[float], gaussian:MutableSequence[float]) -> None: ...
    def inv_cdf_fast(p:float) -> float: ...
    def static_cast(self) -> 'normalDistribution': ...

class plackettCopula(copula):
    @overload
    def __init__(self, theta:float) -> None: ...
    @overload
    def __init__(self, __a:'plackettCopula') -> None: ...
    def density(self, u:Sequence[float]) -> float: ...
    def dimension(self) -> int: ...
    def evaluate(self, u:Sequence[float]) -> float: ...
    def static_cast(self) -> 'plackettCopula': ...
    def theta(self) -> float: ...

class rootFindingAlgorithms(object):
    def static_cast(self) -> 'rootFindingAlgorithms': ...

class solverOptions(object):
    def aad_jacobian(self) -> bool: ...
    def debug(self) -> bool: ...
    def function_tolerance(self) -> float: ...
    def gradient_tolerance(self) -> float: ...
    def max_num_iterations(self) -> int: ...
    def parameter_tolerance(self) -> float: ...
    def set_debug(self, debug:bool) -> None: ...
    def set_function_tolerance(self, function_tolerance:float) -> None: ...
    def set_gradient_tolerance(self, gradient_tolerance:float) -> None: ...
    def set_max_num_iterations(self, max_num_iterations:int) -> None: ...
    def set_parameter_tolerance(self, parameter_tolerance:float) -> None: ...
    def set_solver(self, solver:'solver_enum') -> None: ...
    def solver(self) -> 'solver_enum': ...
    def static_cast(self) -> 'solverOptions': ...

class solverOptionsBfgs(solverOptions):
    @overload
    def __init__(self, max_num_iterations:int, function_tolerance:float=..., gradient_tolerance:float=..., parameter_tolerance:float=..., debug:bool=False) -> None: ...
    @overload
    def __init__(self, __a:'solverOptionsBfgs') -> None: ...
    def bump(self) -> float: ...
    def linesearch_tolerance(self) -> float: ...
    def linesearch_wolfe(self) -> float: ...
    def max_iteration_linesearch(self) -> int: ...
    def method_type(self) -> 'lbfgs_line_search_method_type': ...
    def printf(rhs:'solverOptionsBfgs') -> str: ...
    def read_from_binary(file_name:str) -> 'solverOptionsBfgs': ...
    def read_from_json(file_name:str) -> 'solverOptionsBfgs': ...
    def set_bump(self, bump:float) -> None: ...
    def set_linesearch_tolerance(self, linesearch_tolerance:float) -> None: ...
    def set_linesearch_wolfe(self, linesearch_wolfe:float) -> None: ...
    def set_max_iteration_linesearch(self, max_iteration_linesearch:int) -> None: ...
    def set_method_type(self, method_type:'lbfgs_line_search_method_type') -> None: ...
    def set_step_max(self, step_max:float) -> None: ...
    def set_step_min(self, step_min:float) -> None: ...
    def set_tau(self, tau:int) -> None: ...
    def set_type(self, type:'lbfgs_line_search_type') -> None: ...
    def static_cast(self) -> 'solverOptionsBfgs': ...
    def step_max(self) -> float: ...
    def step_min(self) -> float: ...
    def tau(self) -> int: ...
    def type(self) -> 'lbfgs_line_search_type': ...
    def write_to_binary(file_name:str, rhs:'solverOptionsBfgs') -> None: ...
    def write_to_json(file_name:str, rhs:'solverOptionsBfgs') -> None: ...

class solverOptionsBfgsBuilder(object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __a:'solverOptionsBfgsBuilder') -> None: ...
    def build(self) -> 'solverOptionsBfgs': ...
    def static_cast(self) -> 'solverOptionsBfgsBuilder': ...
    def with_aad_jacobian(self, val:bool=True) -> 'solverOptionsBfgsBuilder': ...
    def with_bump(self, val:float) -> 'solverOptionsBfgsBuilder': ...
    def with_debug(self, val:bool=True) -> 'solverOptionsBfgsBuilder': ...
    def with_function_tolerance(self, val:float) -> 'solverOptionsBfgsBuilder': ...
    def with_gradient_tolerance(self, val:float) -> 'solverOptionsBfgsBuilder': ...
    def with_linesearch_tolerance(self, val:float) -> 'solverOptionsBfgsBuilder': ...
    def with_linesearch_wolfe(self, val:float) -> 'solverOptionsBfgsBuilder': ...
    def with_max_iteration_linesearch(self, val:int) -> 'solverOptionsBfgsBuilder': ...
    def with_max_iterations(self, val:int) -> 'solverOptionsBfgsBuilder': ...
    def with_method_type(self, val:'lbfgs_line_search_method_type') -> 'solverOptionsBfgsBuilder': ...
    def with_parameter_tolerance(self, val:float) -> 'solverOptionsBfgsBuilder': ...
    def with_step_max(self, val:float) -> 'solverOptionsBfgsBuilder': ...
    def with_step_min(self, val:float) -> 'solverOptionsBfgsBuilder': ...
    def with_tau(self, val:int) -> 'solverOptionsBfgsBuilder': ...
    def with_type(self, val:'lbfgs_line_search_type') -> 'solverOptionsBfgsBuilder': ...

class solverOptionsCeres(solverOptions):
    @overload
    def __init__(self, max_num_iterations:int, function_tolerance:float=..., gradient_tolerance:float=..., parameter_tolerance:float=..., debug:bool=False) -> None: ...
    @overload
    def __init__(self, __a:'solverOptionsCeres') -> None: ...
    def check_gradients(self) -> bool: ...
    def dense_linear_algebra_library_type(self) -> 'dense_linear_algebra_library_enum': ...
    def dogleg_type(self) -> 'dogleg_enum': ...
    def dynamic_sparsity(self) -> bool: ...
    def eta(self) -> float: ...
    def gradient_check_numeric_derivative_relative_step_size(self) -> float: ...
    def gradient_check_relative_precision(self) -> float: ...
    def initial_trust_region_radius(self) -> float: ...
    def inner_iteration_tolerance(self) -> float: ...
    def jacobi_scaling(self) -> bool: ...
    def line_search_direction_type(self) -> 'line_search_direction_enum': ...
    def line_search_interpolation_type(self) -> 'line_search_interpolation_enum': ...
    def line_search_sufficient_curvature_decrease(self) -> float: ...
    def line_search_sufficient_function_decrease(self) -> float: ...
    def line_search_type(self) -> 'line_search_enum': ...
    def linear_solver_ordering_type(self) -> 'linear_solver_ordering_enum': ...
    def linear_solver_type(self) -> 'linear_solver_enum': ...
    def max_lbfgs_rank(self) -> int: ...
    def max_line_search_step_contraction(self) -> float: ...
    def max_line_search_step_expansion(self) -> float: ...
    def max_linear_solver_iterations(self) -> int: ...
    def max_num_refinement_iterations(self) -> int: ...
    def max_solver_time_in_seconds(self) -> float: ...
    def max_trust_region_radius(self) -> float: ...
    def min_line_search_step_contraction(self) -> float: ...
    def min_line_search_step_size(self) -> float: ...
    def min_linear_solver_iterations(self) -> int: ...
    def min_relative_decrease(self) -> float: ...
    def min_trust_region_radius(self) -> float: ...
    def minimizer_type(self) -> 'minimizer_enum': ...
    def nonlinear_conjugate_gradient_type(self) -> 'nonlinear_conjugate_gradient_enum': ...
    def num_threads(self) -> int: ...
    def numeric_diff_method(self) -> 'numeric_diff_method_enum': ...
    def preconditioner_type(self) -> 'preconditioner_enum': ...
    def printf(rhs:'solverOptionsCeres') -> str: ...
    def read_from_binary(file_name:str) -> 'solverOptionsCeres': ...
    def read_from_json(file_name:str) -> 'solverOptionsCeres': ...
    def set_check_gradients(self, check:bool) -> None: ...
    def set_dense_linear_algebra_library_type(self, type:'dense_linear_algebra_library_enum') -> None: ...
    def set_dogleg_type(self, type:'dogleg_enum') -> None: ...
    def set_dynamic_sparsity(self, sparsity:bool) -> None: ...
    def set_eta(self, eta:float) -> None: ...
    def set_gradient_check_numeric_derivative_relative_step_size(self, step_size:float) -> None: ...
    def set_gradient_check_relative_precision(self, precision:float) -> None: ...
    def set_initial_trust_region_radius(self, radius:float) -> None: ...
    def set_inner_iteration_tolerance(self, tolerance:float) -> None: ...
    def set_jacobi_scaling(self, scaling:bool) -> None: ...
    def set_line_search_direction_type(self, type:'line_search_direction_enum') -> None: ...
    def set_line_search_interpolation_type(self, type:'line_search_interpolation_enum') -> None: ...
    def set_line_search_sufficient_curvature_decrease(self, decrease:float) -> None: ...
    def set_line_search_sufficient_function_decrease(self, decrease:float) -> None: ...
    def set_line_search_type(self, type:'line_search_enum') -> None: ...
    def set_linear_solver_ordering_type(self, type:'linear_solver_ordering_enum') -> None: ...
    def set_linear_solver_type(self, type:'linear_solver_enum') -> None: ...
    def set_max_lbfgs_rank(self, rank:int) -> None: ...
    def set_max_line_search_step_contraction(self, contraction:float) -> None: ...
    def set_max_line_search_step_expansion(self, expansion:float) -> None: ...
    def set_max_linear_solver_iterations(self, iterations:int) -> None: ...
    def set_max_num_refinement_iterations(self, iterations:int) -> None: ...
    def set_max_solver_time_in_seconds(self, time:float) -> None: ...
    def set_max_trust_region_radius(self, radius:float) -> None: ...
    def set_min_line_search_step_contraction(self, contraction:float) -> None: ...
    def set_min_line_search_step_size(self, step_size:float) -> None: ...
    def set_min_linear_solver_iterations(self, iterations:int) -> None: ...
    def set_min_relative_decrease(self, decrease:float) -> None: ...
    def set_min_trust_region_radius(self, radius:float) -> None: ...
    def set_minimizer_type(self, type:'minimizer_enum') -> None: ...
    def set_nonlinear_conjugate_gradient_type(self, type:'nonlinear_conjugate_gradient_enum') -> None: ...
    def set_num_threads(self, threads:int) -> None: ...
    def set_numeric_diff_method(self, type:'numeric_diff_method_enum') -> None: ...
    def set_preconditioner_type(self, type:'preconditioner_enum') -> None: ...
    def set_sparse_linear_algebra_library_type(self, type:'sparse_linear_algebra_library_enum') -> None: ...
    def set_trust_region_minimizer_iterations_to_dump(self, iterations:Sequence[int]) -> None: ...
    def set_trust_region_problem_dump_directory(self, directory:str) -> None: ...
    def set_trust_region_problem_dump_format_type(self, type:'dump_format_enum') -> None: ...
    def set_trust_region_strategy_type(self, type:'trust_region_strategy_enum') -> None: ...
    def set_use_inner_iterations(self, use:bool) -> None: ...
    def set_use_mixed_precision_solves(self, use:bool) -> None: ...
    def set_visibility_clustering_type(self, type:'visibility_clustering_enum') -> None: ...
    def sparse_linear_algebra_library_type(self) -> 'sparse_linear_algebra_library_enum': ...
    def static_cast(self) -> 'solverOptionsCeres': ...
    def trust_region_minimizer_iterations_to_dump(self) -> Tuple[int, int]: ...
    def trust_region_problem_dump_directory(self) -> str: ...
    def trust_region_problem_dump_format_type(self) -> 'dump_format_enum': ...
    def trust_region_strategy_type(self) -> 'trust_region_strategy_enum': ...
    def use_inner_iterations(self) -> bool: ...
    def use_mixed_precision_solves(self) -> bool: ...
    def visibility_clustering_type(self) -> 'visibility_clustering_enum': ...
    def write_to_binary(file_name:str, rhs:'solverOptionsCeres') -> None: ...
    def write_to_json(file_name:str, rhs:'solverOptionsCeres') -> None: ...

class solverOptionsCeresBuilder(object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __a:'solverOptionsCeresBuilder') -> None: ...
    def build(self) -> 'solverOptionsCeres': ...
    def static_cast(self) -> 'solverOptionsCeresBuilder': ...
    def with_aad_jacobian(self, val:bool=True) -> 'solverOptionsCeresBuilder': ...
    def with_debug(self, val:bool=True) -> 'solverOptionsCeresBuilder': ...
    def with_dense_linear_algebra_library_type(self, val:'dense_linear_algebra_library_enum') -> 'solverOptionsCeresBuilder': ...
    def with_dogleg_type(self, val:'dogleg_enum') -> 'solverOptionsCeresBuilder': ...
    def with_function_tolerance(self, val:float) -> 'solverOptionsCeresBuilder': ...
    def with_gradient_tolerance(self, val:float) -> 'solverOptionsCeresBuilder': ...
    def with_line_search_direction_type(self, val:'line_search_direction_enum') -> 'solverOptionsCeresBuilder': ...
    def with_line_search_interpolation_type(self, val:'line_search_interpolation_enum') -> 'solverOptionsCeresBuilder': ...
    def with_line_search_type(self, val:'line_search_enum') -> 'solverOptionsCeresBuilder': ...
    def with_linear_solver_ordering_type(self, val:'linear_solver_ordering_enum') -> 'solverOptionsCeresBuilder': ...
    def with_linear_solver_type(self, val:'linear_solver_enum') -> 'solverOptionsCeresBuilder': ...
    def with_max_iterations(self, val:int) -> 'solverOptionsCeresBuilder': ...
    def with_max_solver_time_in_seconds(self, val:float) -> 'solverOptionsCeresBuilder': ...
    def with_minimizer_type(self, val:'minimizer_enum') -> 'solverOptionsCeresBuilder': ...
    def with_nonlinear_conjugate_gradient_type(self, val:'nonlinear_conjugate_gradient_enum') -> 'solverOptionsCeresBuilder': ...
    def with_num_threads(self, val:int) -> 'solverOptionsCeresBuilder': ...
    def with_numeric_diff_method(self, val:'numeric_diff_method_enum') -> 'solverOptionsCeresBuilder': ...
    def with_parameter_tolerance(self, val:float) -> 'solverOptionsCeresBuilder': ...
    def with_preconditioner_type(self, val:'preconditioner_enum') -> 'solverOptionsCeresBuilder': ...
    def with_sparse_linear_algebra_library_type(self, val:'sparse_linear_algebra_library_enum') -> 'solverOptionsCeresBuilder': ...
    def with_trust_region_strategy_type(self, val:'trust_region_strategy_enum') -> 'solverOptionsCeresBuilder': ...

class solverOptionsLm(solverOptions):
    @overload
    def __init__(self, max_num_iterations:int, function_tolerance:float=..., gradient_tolerance:float=0.0, parameter_tolerance:float=..., debug:bool=False) -> None: ...
    @overload
    def __init__(self, __a:'solverOptionsLm') -> None: ...
    def accept_uphill_step(self) -> bool: ...
    def alpha(self) -> float: ...
    def bump(self) -> float: ...
    def epsilon(self) -> float: ...
    def lambda_down_fac(self) -> float: ...
    def lambda_up_fac(self) -> float: ...
    def log_file(self) -> str: ...
    def nu(self) -> float: ...
    def printf(rhs:'solverOptionsLm') -> str: ...
    def read_from_binary(file_name:str) -> 'solverOptionsLm': ...
    def read_from_json(file_name:str) -> 'solverOptionsLm': ...
    def set_accept_uphill_step(self, accept:bool) -> None: ...
    def set_alpha(self, alpha:float) -> None: ...
    def set_bump(self, bump:float) -> None: ...
    def set_epsilon(self, epsilon:float) -> None: ...
    def set_lambda(self, lambda_:float) -> None: ...
    def set_lambda_down_fac(self, fac:float) -> None: ...
    def set_lambda_up_fac(self, fac:float) -> None: ...
    def set_log_file(self, log_file:str) -> None: ...
    def set_nu(self, nu:float) -> None: ...
    def set_type(self, type:'levenberg_marquardt_solver_enum') -> None: ...
    def set_use_geodesic(self, use:bool) -> None: ...
    def static_cast(self) -> 'solverOptionsLm': ...
    def type(self) -> 'levenberg_marquardt_solver_enum': ...
    def use_geodesic(self) -> bool: ...
    def write_to_binary(file_name:str, rhs:'solverOptionsLm') -> None: ...
    def write_to_json(file_name:str, rhs:'solverOptionsLm') -> None: ...

class solverOptionsLmBuilder(object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __a:'solverOptionsLmBuilder') -> None: ...
    def build(self) -> 'solverOptionsLm': ...
    def static_cast(self) -> 'solverOptionsLmBuilder': ...
    def with_aad_jacobian(self, val:bool=True) -> 'solverOptionsLmBuilder': ...
    def with_accept_uphill_step(self, val:bool=True) -> 'solverOptionsLmBuilder': ...
    def with_alpha(self, val:float) -> 'solverOptionsLmBuilder': ...
    def with_bump(self, val:float) -> 'solverOptionsLmBuilder': ...
    def with_debug(self, val:bool=True) -> 'solverOptionsLmBuilder': ...
    def with_epsilon(self, val:float) -> 'solverOptionsLmBuilder': ...
    def with_function_tolerance(self, val:float) -> 'solverOptionsLmBuilder': ...
    def with_gradient_tolerance(self, val:float) -> 'solverOptionsLmBuilder': ...
    def with_lambda(self, val:float) -> 'solverOptionsLmBuilder': ...
    def with_lambda_down_fac(self, val:float) -> 'solverOptionsLmBuilder': ...
    def with_lambda_up_fac(self, val:float) -> 'solverOptionsLmBuilder': ...
    def with_log_file(self, val:str) -> 'solverOptionsLmBuilder': ...
    def with_max_iterations(self, val:int) -> 'solverOptionsLmBuilder': ...
    def with_nu(self, val:float) -> 'solverOptionsLmBuilder': ...
    def with_parameter_tolerance(self, val:float) -> 'solverOptionsLmBuilder': ...
    def with_type(self, val:'levenberg_marquardt_solver_enum') -> 'solverOptionsLmBuilder': ...
    def with_use_geodesic(self, val:bool=True) -> 'solverOptionsLmBuilder': ...

class solverOptionsNlopt(solverOptions):
    @overload
    def __init__(self, nloptal:'nlopt_algo_name', max_num_iterations:int, function_tolerance:float=..., gradient_tolerance:float=..., parameter_tolerance:float=..., debug:bool=False) -> None: ...
    @overload
    def __init__(self, __a:'solverOptionsNlopt') -> None: ...
    def nloptal(self) -> 'nlopt_algo_name': ...
    def printf(rhs:'solverOptionsNlopt') -> str: ...
    def read_from_binary(file_name:str) -> 'solverOptionsNlopt': ...
    def read_from_json(file_name:str) -> 'solverOptionsNlopt': ...
    def set_nloptal(self, nloptal:'nlopt_algo_name') -> None: ...
    def static_cast(self) -> 'solverOptionsNlopt': ...
    def write_to_binary(file_name:str, rhs:'solverOptionsNlopt') -> None: ...
    def write_to_json(file_name:str, rhs:'solverOptionsNlopt') -> None: ...

class solverOptionsNloptBuilder(object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __a:'solverOptionsNloptBuilder') -> None: ...
    def build(self) -> 'solverOptionsNlopt': ...
    def static_cast(self) -> 'solverOptionsNloptBuilder': ...
    def with_aad_jacobian(self, val:bool) -> 'solverOptionsNloptBuilder': ...
    def with_algorithm(self, val:'nlopt_algo_name') -> 'solverOptionsNloptBuilder': ...
    def with_debug(self, val:bool=True) -> 'solverOptionsNloptBuilder': ...
    def with_function_tolerance(self, val:float) -> 'solverOptionsNloptBuilder': ...
    def with_gradient_tolerance(self, val:float) -> 'solverOptionsNloptBuilder': ...
    def with_max_iterations(self, val:int) -> 'solverOptionsNloptBuilder': ...
    def with_parameter_tolerance(self, val:float) -> 'solverOptionsNloptBuilder': ...

class solverWrapper(object):
    def is_supported(solver_type:'solver_enum') -> bool: ...
    def solve(self, parameters:MutableSequence[float], options:'solverOptions') -> bool: ...
    def static_cast(self) -> 'solverWrapper': ...

