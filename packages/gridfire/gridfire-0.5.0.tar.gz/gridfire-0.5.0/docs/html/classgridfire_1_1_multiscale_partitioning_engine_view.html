<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GridFire: gridfire::MultiscalePartitioningEngineView Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GridFire<span id="projectnumber">&#160;0.0.1a</span>
   </div>
   <div id="projectbrief">General Purpose Nuclear Network</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classgridfire_1_1_multiscale_partitioning_engine_view.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classgridfire_1_1_multiscale_partitioning_engine_view-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">gridfire::MultiscalePartitioningEngineView Class Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>An engine view that partitions the reaction network into multiple groups based on timescales.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for gridfire::MultiscalePartitioningEngineView:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgridfire_1_1_multiscale_partitioning_engine_view.png" usemap="#gridfire::MultiscalePartitioningEngineView_map" alt=""/>
  <map id="gridfire::MultiscalePartitioningEngineView_map" name="gridfire::MultiscalePartitioningEngineView_map">
<area href="classgridfire_1_1_dynamic_engine.html" title="Abstract class for engines supporting Jacobian and stoichiometry operations." alt="gridfire::DynamicEngine" shape="rect" coords="0,56,246,80"/>
<area href="classgridfire_1_1_engine_view.html" alt="gridfire::EngineView&lt; DynamicEngine &gt;" shape="rect" coords="256,56,502,80"/>
<area href="classgridfire_1_1_engine.html" title="Abstract base class for a reaction network engine." alt="gridfire::Engine" shape="rect" coords="0,0,246,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_cache_stats.html">CacheStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for tracking cache statistics.  <a href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_cache_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_eigen_functor.html">EigenFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for solving QSE abundances using Eigen's nonlinear optimization.  <a href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_eigen_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html">QSEGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing a QSE group.  <a href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0df457c0f0f6f403a295335c84fd828f" id="r_a0df457c0f0f6f403a295335c84fd828f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0df457c0f0f6f403a295335c84fd828f">MultiscalePartitioningEngineView</a> (<a class="el" href="classgridfire_1_1_graph_engine.html">GraphEngine</a> &amp;baseEngine)</td></tr>
<tr class="memdesc:a0df457c0f0f6f403a295335c84fd828f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classgridfire_1_1_multiscale_partitioning_engine_view.html" title="An engine view that partitions the reaction network into multiple groups based on timescales.">MultiscalePartitioningEngineView</a>.  <br /></td></tr>
<tr class="separator:a0df457c0f0f6f403a295335c84fd828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696f74f5135bbd62169b6577f92fee80" id="r_a696f74f5135bbd62169b6577f92fee80"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; fourdst::atomic::Species &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a696f74f5135bbd62169b6577f92fee80">getNetworkSpecies</a> () const override</td></tr>
<tr class="memdesc:a696f74f5135bbd62169b6577f92fee80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the list of species in the network.  <br /></td></tr>
<tr class="separator:a696f74f5135bbd62169b6577f92fee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716d7357e944e8394d8b8e0b5e7625eb" id="r_a716d7357e944e8394d8b8e0b5e7625eb"><td class="memItemLeft" align="right" valign="top">std::expected&lt; <a class="el" href="structgridfire_1_1_step_derivatives.html">StepDerivatives</a>&lt; double &gt;, <a class="el" href="structgridfire_1_1expectations_1_1_stale_engine_error.html">expectations::StaleEngineError</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a716d7357e944e8394d8b8e0b5e7625eb">calculateRHSAndEnergy</a> (const std::vector&lt; double &gt; &amp;Y_full, double T9, double rho) const override</td></tr>
<tr class="memdesc:a716d7357e944e8394d8b8e0b5e7625eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the right-hand side (dY/dt) and energy generation.  <br /></td></tr>
<tr class="separator:a716d7357e944e8394d8b8e0b5e7625eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf5ad8765290ea2b78170235aea391d" id="r_acdf5ad8765290ea2b78170235aea391d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdf5ad8765290ea2b78170235aea391d">generateJacobianMatrix</a> (const std::vector&lt; double &gt; &amp;Y_full, double T9, double rho) const override</td></tr>
<tr class="memdesc:acdf5ad8765290ea2b78170235aea391d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the Jacobian matrix for the current state.  <br /></td></tr>
<tr class="separator:acdf5ad8765290ea2b78170235aea391d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac961484383e86d9712a424728e068633" id="r_ac961484383e86d9712a424728e068633"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac961484383e86d9712a424728e068633">getJacobianMatrixEntry</a> (int i_full, int j_full) const override</td></tr>
<tr class="memdesc:ac961484383e86d9712a424728e068633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an entry from the previously generated Jacobian matrix.  <br /></td></tr>
<tr class="separator:ac961484383e86d9712a424728e068633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe76a46784b1ebc8ad67a9eec40d369a" id="r_abe76a46784b1ebc8ad67a9eec40d369a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe76a46784b1ebc8ad67a9eec40d369a">generateStoichiometryMatrix</a> () override</td></tr>
<tr class="memdesc:abe76a46784b1ebc8ad67a9eec40d369a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the stoichiometry matrix for the network.  <br /></td></tr>
<tr class="separator:abe76a46784b1ebc8ad67a9eec40d369a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510b920dea726aef859ac1f6d051807e" id="r_a510b920dea726aef859ac1f6d051807e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a510b920dea726aef859ac1f6d051807e">getStoichiometryMatrixEntry</a> (int speciesIndex, int reactionIndex) const override</td></tr>
<tr class="memdesc:a510b920dea726aef859ac1f6d051807e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an entry from the stoichiometry matrix.  <br /></td></tr>
<tr class="separator:a510b920dea726aef859ac1f6d051807e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eb9c108d694a27ec913ed0143aa044" id="r_a79eb9c108d694a27ec913ed0143aa044"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79eb9c108d694a27ec913ed0143aa044">calculateMolarReactionFlow</a> (const <a class="el" href="classgridfire_1_1reaction_1_1_reaction.html">reaction::Reaction</a> &amp;reaction, const std::vector&lt; double &gt; &amp;Y_full, double T9, double rho) const override</td></tr>
<tr class="memdesc:a79eb9c108d694a27ec913ed0143aa044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the molar reaction flow for a given reaction.  <br /></td></tr>
<tr class="separator:a79eb9c108d694a27ec913ed0143aa044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad751f2c1306895ee74a61f2071ca96eb" id="r_ad751f2c1306895ee74a61f2071ca96eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegridfire_1_1reaction.html#aa86f08712565f278adacc7cd2361eb31">reaction::LogicalReactionSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad751f2c1306895ee74a61f2071ca96eb">getNetworkReactions</a> () const override</td></tr>
<tr class="memdesc:ad751f2c1306895ee74a61f2071ca96eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of logical reactions in the network.  <br /></td></tr>
<tr class="separator:ad751f2c1306895ee74a61f2071ca96eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5fa7f03cd89b8c1b6b9ffdf3abb12e" id="r_acb5fa7f03cd89b8c1b6b9ffdf3abb12e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb5fa7f03cd89b8c1b6b9ffdf3abb12e">setNetworkReactions</a> (const <a class="el" href="namespacegridfire_1_1reaction.html#aa86f08712565f278adacc7cd2361eb31">reaction::LogicalReactionSet</a> &amp;reactions) override</td></tr>
<tr class="memdesc:acb5fa7f03cd89b8c1b6b9ffdf3abb12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the set of logical reactions in the network.  <br /></td></tr>
<tr class="separator:acb5fa7f03cd89b8c1b6b9ffdf3abb12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560612347bbd5b7b380e990624d01105" id="r_a560612347bbd5b7b380e990624d01105"><td class="memItemLeft" align="right" valign="top">std::expected&lt; std::unordered_map&lt; fourdst::atomic::Species, double &gt;, <a class="el" href="structgridfire_1_1expectations_1_1_stale_engine_error.html">expectations::StaleEngineError</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a560612347bbd5b7b380e990624d01105">getSpeciesTimescales</a> (const std::vector&lt; double &gt; &amp;Y, double T9, double rho) const override</td></tr>
<tr class="memdesc:a560612347bbd5b7b380e990624d01105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes timescales for all species in the network.  <br /></td></tr>
<tr class="separator:a560612347bbd5b7b380e990624d01105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38c367ef3c74d012ccd10521cd5a727" id="r_aa38c367ef3c74d012ccd10521cd5a727"><td class="memItemLeft" align="right" valign="top">std::expected&lt; std::unordered_map&lt; fourdst::atomic::Species, double &gt;, <a class="el" href="structgridfire_1_1expectations_1_1_stale_engine_error.html">expectations::StaleEngineError</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa38c367ef3c74d012ccd10521cd5a727">getSpeciesDestructionTimescales</a> (const std::vector&lt; double &gt; &amp;Y, double T9, double rho) const override</td></tr>
<tr class="memdesc:aa38c367ef3c74d012ccd10521cd5a727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes destruction timescales for all species in the network.  <br /></td></tr>
<tr class="separator:aa38c367ef3c74d012ccd10521cd5a727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bee75b5a6e508e6eebf83f0d48c50b8" id="r_a6bee75b5a6e508e6eebf83f0d48c50b8"><td class="memItemLeft" align="right" valign="top">fourdst::composition::Composition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bee75b5a6e508e6eebf83f0d48c50b8">update</a> (const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;netIn) override</td></tr>
<tr class="memdesc:a6bee75b5a6e508e6eebf83f0d48c50b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the internal state of the engine, performing partitioning and QSE equilibration.  <br /></td></tr>
<tr class="separator:a6bee75b5a6e508e6eebf83f0d48c50b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7847959fc5af2b83f5446dd73567b46" id="r_ae7847959fc5af2b83f5446dd73567b46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7847959fc5af2b83f5446dd73567b46">isStale</a> (const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;netIn) override</td></tr>
<tr class="memdesc:ae7847959fc5af2b83f5446dd73567b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the engine's internal state is stale relative to the provided conditions.  <br /></td></tr>
<tr class="separator:ae7847959fc5af2b83f5446dd73567b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0c0a0ade632eb10f0eecab828a059f" id="r_a1a0c0a0ade632eb10f0eecab828a059f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a0c0a0ade632eb10f0eecab828a059f">setScreeningModel</a> (<a class="el" href="namespacegridfire_1_1screening.html#aa82aafbc4f8c28d0a75b60798e3a7d25">screening::ScreeningType</a> model) override</td></tr>
<tr class="memdesc:a1a0c0a0ade632eb10f0eecab828a059f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the electron screening model.  <br /></td></tr>
<tr class="separator:a1a0c0a0ade632eb10f0eecab828a059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfb4e6fec2f337a1dea69e3d4f1fc82" id="r_a7bfb4e6fec2f337a1dea69e3d4f1fc82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegridfire_1_1screening.html#aa82aafbc4f8c28d0a75b60798e3a7d25">screening::ScreeningType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bfb4e6fec2f337a1dea69e3d4f1fc82">getScreeningModel</a> () const override</td></tr>
<tr class="memdesc:a7bfb4e6fec2f337a1dea69e3d4f1fc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current electron screening model.  <br /></td></tr>
<tr class="separator:a7bfb4e6fec2f337a1dea69e3d4f1fc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bd1f0e821ed415611d75bac67063d1" id="r_a22bd1f0e821ed415611d75bac67063d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgridfire_1_1_dynamic_engine.html">DynamicEngine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22bd1f0e821ed415611d75bac67063d1">getBaseEngine</a> () const override</td></tr>
<tr class="memdesc:a22bd1f0e821ed415611d75bac67063d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the base engine.  <br /></td></tr>
<tr class="separator:a22bd1f0e821ed415611d75bac67063d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13e764c118a6cc51847384e9c70e05b" id="r_af13e764c118a6cc51847384e9c70e05b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af13e764c118a6cc51847384e9c70e05b">analyzeTimescalePoolConnectivity</a> (const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;timescale_pools, const std::vector&lt; double &gt; &amp;Y, double T9, double rho) const</td></tr>
<tr class="memdesc:af13e764c118a6cc51847384e9c70e05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes the connectivity of timescale pools.  <br /></td></tr>
<tr class="separator:af13e764c118a6cc51847384e9c70e05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d26945df5395b9317552a3989c42d1c" id="r_a7d26945df5395b9317552a3989c42d1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d26945df5395b9317552a3989c42d1c">partitionNetwork</a> (const std::vector&lt; double &gt; &amp;Y, double T9, double rho)</td></tr>
<tr class="memdesc:a7d26945df5395b9317552a3989c42d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions the network into dynamic and algebraic (QSE) groups based on timescales.  <br /></td></tr>
<tr class="separator:a7d26945df5395b9317552a3989c42d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b11ffe498846f5a3a72f08504346b7" id="r_a98b11ffe498846f5a3a72f08504346b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98b11ffe498846f5a3a72f08504346b7">partitionNetwork</a> (const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;netIn)</td></tr>
<tr class="memdesc:a98b11ffe498846f5a3a72f08504346b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions the network based on timescales from a <code><a class="el" href="structgridfire_1_1_net_in.html">NetIn</a></code> struct.  <br /></td></tr>
<tr class="separator:a98b11ffe498846f5a3a72f08504346b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff59a15abac30eee16e9fa7b355fb18" id="r_acff59a15abac30eee16e9fa7b355fb18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acff59a15abac30eee16e9fa7b355fb18">exportToDot</a> (const std::string &amp;filename, const std::vector&lt; double &gt; &amp;Y, const double T9, const double rho) const</td></tr>
<tr class="memdesc:acff59a15abac30eee16e9fa7b355fb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the network to a DOT file for visualization.  <br /></td></tr>
<tr class="separator:acff59a15abac30eee16e9fa7b355fb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d32b7197fcb27ee697d5bfde960f3f" id="r_a91d32b7197fcb27ee697d5bfde960f3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91d32b7197fcb27ee697d5bfde960f3f">getSpeciesIndex</a> (const fourdst::atomic::Species &amp;species) const override</td></tr>
<tr class="memdesc:a91d32b7197fcb27ee697d5bfde960f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of a species in the full network.  <br /></td></tr>
<tr class="separator:a91d32b7197fcb27ee697d5bfde960f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada497e8df74a295fdf5df7d7cdf64e0" id="r_aada497e8df74a295fdf5df7d7cdf64e0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aada497e8df74a295fdf5df7d7cdf64e0">mapNetInToMolarAbundanceVector</a> (const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;netIn) const override</td></tr>
<tr class="memdesc:aada497e8df74a295fdf5df7d7cdf64e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <code><a class="el" href="structgridfire_1_1_net_in.html">NetIn</a></code> struct to a molar abundance vector for the full network.  <br /></td></tr>
<tr class="separator:aada497e8df74a295fdf5df7d7cdf64e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05730ced13ac5331060ca011f0da6235" id="r_a05730ced13ac5331060ca011f0da6235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgridfire_1_1_priming_report.html">PrimingReport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05730ced13ac5331060ca011f0da6235">primeEngine</a> (const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;netIn) override</td></tr>
<tr class="memdesc:a05730ced13ac5331060ca011f0da6235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primes the engine with a specific species.  <br /></td></tr>
<tr class="separator:a05730ced13ac5331060ca011f0da6235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c82e4e082d1c82b1b090ac9847c7c5e" id="r_a3c82e4e082d1c82b1b090ac9847c7c5e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; fourdst::atomic::Species &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c82e4e082d1c82b1b090ac9847c7c5e">getFastSpecies</a> () const</td></tr>
<tr class="memdesc:a3c82e4e082d1c82b1b090ac9847c7c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fast species in the network.  <br /></td></tr>
<tr class="separator:a3c82e4e082d1c82b1b090ac9847c7c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e04e8cb8c84b1bd033ac599accf0888" id="r_a1e04e8cb8c84b1bd033ac599accf0888"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; fourdst::atomic::Species &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e04e8cb8c84b1bd033ac599accf0888">getDynamicSpecies</a> () const</td></tr>
<tr class="memdesc:a1e04e8cb8c84b1bd033ac599accf0888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dynamic species in the network.  <br /></td></tr>
<tr class="separator:a1e04e8cb8c84b1bd033ac599accf0888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc879246c6fbd8633b05052858df51d" id="r_a4bc879246c6fbd8633b05052858df51d"><td class="memItemLeft" align="right" valign="top">fourdst::composition::Composition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bc879246c6fbd8633b05052858df51d">equilibrateNetwork</a> (const std::vector&lt; double &gt; &amp;Y, double T9, double rho)</td></tr>
<tr class="memdesc:a4bc879246c6fbd8633b05052858df51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equilibrates the network by partitioning and solving for QSE abundances.  <br /></td></tr>
<tr class="separator:a4bc879246c6fbd8633b05052858df51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b17f94386882ea1524147782b7a1ddc" id="r_a1b17f94386882ea1524147782b7a1ddc"><td class="memItemLeft" align="right" valign="top">fourdst::composition::Composition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b17f94386882ea1524147782b7a1ddc">equilibrateNetwork</a> (const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;netIn)</td></tr>
<tr class="memdesc:a1b17f94386882ea1524147782b7a1ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equilibrates the network using QSE from a <code><a class="el" href="structgridfire_1_1_net_in.html">NetIn</a></code> struct.  <br /></td></tr>
<tr class="separator:a1b17f94386882ea1524147782b7a1ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgridfire_1_1_dynamic_engine"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classgridfire_1_1_dynamic_engine')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgridfire_1_1_dynamic_engine.html">gridfire::DynamicEngine</a></td></tr>
<tr class="memitem:a818d942efa843959393e4eed3263b7e7 inherit pub_methods_classgridfire_1_1_dynamic_engine" id="r_a818d942efa843959393e4eed3263b7e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridfire_1_1_dynamic_engine.html#a818d942efa843959393e4eed3263b7e7">generateJacobianMatrix</a> (const std::vector&lt; double &gt; &amp;Y_dynamic, double T9, double rho, const <a class="el" href="namespacegridfire.html#a898dfe22579e649935645cbd6f073178">SparsityPattern</a> &amp;sparsityPattern) const</td></tr>
<tr class="separator:a818d942efa843959393e4eed3263b7e7 inherit pub_methods_classgridfire_1_1_dynamic_engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04317b66ef14d519264bc30ee69f5bf9 inherit pub_methods_classgridfire_1_1_dynamic_engine" id="r_a04317b66ef14d519264bc30ee69f5bf9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegridfire.html#a3b1f70dc7ff5b501809330a97079e4f6">BuildDepthType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridfire_1_1_dynamic_engine.html#a04317b66ef14d519264bc30ee69f5bf9">getDepth</a> () const</td></tr>
<tr class="separator:a04317b66ef14d519264bc30ee69f5bf9 inherit pub_methods_classgridfire_1_1_dynamic_engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2c8b896661b7a89beffe0066cb21cf inherit pub_methods_classgridfire_1_1_dynamic_engine" id="r_a4e2c8b896661b7a89beffe0066cb21cf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridfire_1_1_dynamic_engine.html#a4e2c8b896661b7a89beffe0066cb21cf">rebuild</a> (const fourdst::composition::Composition &amp;comp, <a class="el" href="namespacegridfire.html#a3b1f70dc7ff5b501809330a97079e4f6">BuildDepthType</a> depth)</td></tr>
<tr class="separator:a4e2c8b896661b7a89beffe0066cb21cf inherit pub_methods_classgridfire_1_1_dynamic_engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgridfire_1_1_engine"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classgridfire_1_1_engine')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgridfire_1_1_engine.html">gridfire::Engine</a></td></tr>
<tr class="memitem:a2e7970bed2100699f226f4141d5db037 inherit pub_methods_classgridfire_1_1_engine" id="r_a2e7970bed2100699f226f4141d5db037"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridfire_1_1_engine.html#a2e7970bed2100699f226f4141d5db037">~Engine</a> ()=default</td></tr>
<tr class="memdesc:a2e7970bed2100699f226f4141d5db037 inherit pub_methods_classgridfire_1_1_engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a2e7970bed2100699f226f4141d5db037 inherit pub_methods_classgridfire_1_1_engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgridfire_1_1_engine_view"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classgridfire_1_1_engine_view')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgridfire_1_1_engine_view.html">gridfire::EngineView&lt; DynamicEngine &gt;</a></td></tr>
<tr class="memitem:a994660f2d553f3a123512dc5eb421e74 inherit pub_methods_classgridfire_1_1_engine_view" id="r_a994660f2d553f3a123512dc5eb421e74"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridfire_1_1_engine_view.html#a994660f2d553f3a123512dc5eb421e74">~EngineView</a> ()=default</td></tr>
<tr class="memdesc:a994660f2d553f3a123512dc5eb421e74 inherit pub_methods_classgridfire_1_1_engine_view"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a994660f2d553f3a123512dc5eb421e74 inherit pub_methods_classgridfire_1_1_engine_view"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a34b5fdb2078e748edfbe6846ecadd681" id="r_a34b5fdb2078e748edfbe6846ecadd681"><td class="memItemLeft" align="right" valign="top">typedef std::tuple&lt; std::vector&lt; fourdst::atomic::Species &gt;, std::vector&lt; size_t &gt;, std::vector&lt; fourdst::atomic::Species &gt;, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34b5fdb2078e748edfbe6846ecadd681">QSEPartition</a></td></tr>
<tr class="memdesc:a34b5fdb2078e748edfbe6846ecadd681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a QSE partition.  <br /></td></tr>
<tr class="separator:a34b5fdb2078e748edfbe6846ecadd681"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad4d29ee55f89384807616d1068797067" id="r_ad4d29ee55f89384807616d1068797067"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4d29ee55f89384807616d1068797067">partitionByTimescale</a> (const std::vector&lt; double &gt; &amp;Y_full, double T9, double rho) const</td></tr>
<tr class="memdesc:ad4d29ee55f89384807616d1068797067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions the network by timescale.  <br /></td></tr>
<tr class="separator:ad4d29ee55f89384807616d1068797067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0865e361dfeb23984d70409fdd9f39" id="r_aae0865e361dfeb23984d70409fdd9f39"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; size_t, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae0865e361dfeb23984d70409fdd9f39">buildConnectivityGraph</a> (const std::unordered_set&lt; size_t &gt; &amp;fast_reaction_indices) const</td></tr>
<tr class="memdesc:aae0865e361dfeb23984d70409fdd9f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a connectivity graph from a set of fast reaction indices.  <br /></td></tr>
<tr class="separator:aae0865e361dfeb23984d70409fdd9f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55ed182301d216264daae3e6dfd8917" id="r_aa55ed182301d216264daae3e6dfd8917"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html">QSEGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa55ed182301d216264daae3e6dfd8917">validateGroupsWithFluxAnalysis</a> (const std::vector&lt; <a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html">QSEGroup</a> &gt; &amp;candidate_groups, const std::vector&lt; double &gt; &amp;Y, double T9, double rho) const</td></tr>
<tr class="memdesc:aa55ed182301d216264daae3e6dfd8917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates candidate QSE groups using flux analysis.  <br /></td></tr>
<tr class="separator:aa55ed182301d216264daae3e6dfd8917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5fcb8e3396d74359fd601554c9ffa9" id="r_a3c5fcb8e3396d74359fd601554c9ffa9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c5fcb8e3396d74359fd601554c9ffa9">solveQSEAbundances</a> (const std::vector&lt; double &gt; &amp;Y_full, double T9, double rho)</td></tr>
<tr class="memdesc:a3c5fcb8e3396d74359fd601554c9ffa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves for the QSE abundances of the algebraic species in a given state.  <br /></td></tr>
<tr class="separator:a3c5fcb8e3396d74359fd601554c9ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ca8004fbd8d6d3ea6f67efeb5dbc8d" id="r_a54ca8004fbd8d6d3ea6f67efeb5dbc8d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54ca8004fbd8d6d3ea6f67efeb5dbc8d">identifyMeanSlowestPool</a> (const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;pools, const std::vector&lt; double &gt; &amp;Y, double T9, double rho) const</td></tr>
<tr class="memdesc:a54ca8004fbd8d6d3ea6f67efeb5dbc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the pool with the slowest mean timescale.  <br /></td></tr>
<tr class="separator:a54ca8004fbd8d6d3ea6f67efeb5dbc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3875c61dc916c0982ed122c2e272d94" id="r_ae3875c61dc916c0982ed122c2e272d94"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; size_t, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3875c61dc916c0982ed122c2e272d94">buildConnectivityGraph</a> (const std::vector&lt; size_t &gt; &amp;species_pool) const</td></tr>
<tr class="memdesc:ae3875c61dc916c0982ed122c2e272d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a connectivity graph from a species pool.  <br /></td></tr>
<tr class="separator:ae3875c61dc916c0982ed122c2e272d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac206840057bac65b7f7738e6dfd1047a" id="r_ac206840057bac65b7f7738e6dfd1047a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html">QSEGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac206840057bac65b7f7738e6dfd1047a">constructCandidateGroups</a> (const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;candidate_pools, const std::vector&lt; double &gt; &amp;Y, double T9, double rho) const</td></tr>
<tr class="memdesc:ac206840057bac65b7f7738e6dfd1047a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs candidate QSE groups from connected timescale pools.  <br /></td></tr>
<tr class="separator:ac206840057bac65b7f7738e6dfd1047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7d357c775dcbb253a4001d172805380a" id="r_a7d357c775dcbb253a4001d172805380a"><td class="memItemLeft" align="right" valign="top">quill::Logger *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d357c775dcbb253a4001d172805380a">m_logger</a> = LogManager::getInstance().getLogger(&quot;log&quot;)</td></tr>
<tr class="memdesc:a7d357c775dcbb253a4001d172805380a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logger instance for logging messages.  <br /></td></tr>
<tr class="separator:a7d357c775dcbb253a4001d172805380a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0437c51f94bf834a11adf481b2afad93" id="r_a0437c51f94bf834a11adf481b2afad93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgridfire_1_1_graph_engine.html">GraphEngine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0437c51f94bf834a11adf481b2afad93">m_baseEngine</a></td></tr>
<tr class="memdesc:a0437c51f94bf834a11adf481b2afad93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base engine to which this view delegates calculations.  <br /></td></tr>
<tr class="separator:a0437c51f94bf834a11adf481b2afad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4aa04a1e641204e4fd82361b0e39c6" id="r_a1b4aa04a1e641204e4fd82361b0e39c6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html">QSEGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b4aa04a1e641204e4fd82361b0e39c6">m_qse_groups</a></td></tr>
<tr class="memdesc:a1b4aa04a1e641204e4fd82361b0e39c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of identified equilibrium groups.  <br /></td></tr>
<tr class="separator:a1b4aa04a1e641204e4fd82361b0e39c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6126b5c4a397d090790d7b75f9f70f" id="r_aec6126b5c4a397d090790d7b75f9f70f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; fourdst::atomic::Species &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec6126b5c4a397d090790d7b75f9f70f">m_dynamic_species</a></td></tr>
<tr class="memdesc:aec6126b5c4a397d090790d7b75f9f70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplified set of species presented to the solver (the "slow" species).  <br /></td></tr>
<tr class="separator:aec6126b5c4a397d090790d7b75f9f70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b4f0373c3bd81503889650c0bb69bb" id="r_a38b4f0373c3bd81503889650c0bb69bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38b4f0373c3bd81503889650c0bb69bb">m_dynamic_species_indices</a></td></tr>
<tr class="memdesc:a38b4f0373c3bd81503889650c0bb69bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indices mapping the dynamic species back to the base engine's full species list.  <br /></td></tr>
<tr class="separator:a38b4f0373c3bd81503889650c0bb69bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4656c05b8235dbf4ec698b03a716a8c8" id="r_a4656c05b8235dbf4ec698b03a716a8c8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; fourdst::atomic::Species &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4656c05b8235dbf4ec698b03a716a8c8">m_algebraic_species</a></td></tr>
<tr class="memdesc:a4656c05b8235dbf4ec698b03a716a8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Species that are treated as algebraic (in QSE) in the QSE groups.  <br /></td></tr>
<tr class="separator:a4656c05b8235dbf4ec698b03a716a8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53862719dd73f98bc69eecde090cf655" id="r_a53862719dd73f98bc69eecde090cf655"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53862719dd73f98bc69eecde090cf655">m_algebraic_species_indices</a></td></tr>
<tr class="memdesc:a53862719dd73f98bc69eecde090cf655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indices of algebraic species in the full network.  <br /></td></tr>
<tr class="separator:a53862719dd73f98bc69eecde090cf655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d97b11e80fa78ab5f509fce1f156b8" id="r_a57d97b11e80fa78ab5f509fce1f156b8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57d97b11e80fa78ab5f509fce1f156b8">m_activeSpeciesIndices</a></td></tr>
<tr class="memdesc:a57d97b11e80fa78ab5f509fce1f156b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indices of all species considered active in the current partition (dynamic + algebraic).  <br /></td></tr>
<tr class="separator:a57d97b11e80fa78ab5f509fce1f156b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445d7447f2cf18f755fc8b8b288e68cb" id="r_a445d7447f2cf18f755fc8b8b288e68cb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a445d7447f2cf18f755fc8b8b288e68cb">m_activeReactionIndices</a></td></tr>
<tr class="memdesc:a445d7447f2cf18f755fc8b8b288e68cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indices of all reactions involving only active species.  <br /></td></tr>
<tr class="separator:a445d7447f2cf18f755fc8b8b288e68cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707e46d2f72993c206210f81b35b884e" id="r_a707e46d2f72993c206210f81b35b884e"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="structgridfire_1_1_q_s_e_cache_key.html">QSECacheKey</a>, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a707e46d2f72993c206210f81b35b884e">m_qse_abundance_cache</a></td></tr>
<tr class="memdesc:a707e46d2f72993c206210f81b35b884e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache for QSE abundances based on T9, rho, and Y.  <br /></td></tr>
<tr class="separator:a707e46d2f72993c206210f81b35b884e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81057b96cf46986151a5e8ef99a017a" id="r_aa81057b96cf46986151a5e8ef99a017a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_cache_stats.html">CacheStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa81057b96cf46986151a5e8ef99a017a">m_cacheStats</a></td></tr>
<tr class="memdesc:aa81057b96cf46986151a5e8ef99a017a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics for the QSE abundance cache.  <br /></td></tr>
<tr class="separator:aa81057b96cf46986151a5e8ef99a017a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An engine view that partitions the reaction network into multiple groups based on timescales. </p>
<p>@purpose This class is designed to accelerate the integration of stiff nuclear reaction networks. It identifies species that react on very short timescales ("fast" species) and treats them as being in Quasi-Steady-State Equilibrium (QSE). Their abundances are solved for algebraically, removing their stiff differential equations from the system. The remaining "slow" or "dynamic" species are integrated normally. This significantly improves the stability and performance of the solver.</p>
<p>@how The core logic resides in the <code><a class="el" href="#a7d26945df5395b9317552a3989c42d1c" title="Partitions the network into dynamic and algebraic (QSE) groups based on timescales.">partitionNetwork()</a></code> and <code><a class="el" href="#a4bc879246c6fbd8633b05052858df51d" title="Equilibrates the network by partitioning and solving for QSE abundances.">equilibrateNetwork()</a></code> methods. The partitioning process involves:</p><ol type="1">
<li><b>Timescale Analysis:</b> Using <code>getSpeciesDestructionTimescales</code> from the base engine, all species are sorted by their characteristic timescales.</li>
<li><b>Gap Detection:</b> The sorted list of timescales is scanned for large gaps (e.g., several orders of magnitude) to create distinct "timescale pools".</li>
<li><b>Connectivity Analysis:</b> Each pool is analyzed for internal reaction connectivity to form cohesive groups.</li>
<li><b>Flux Validation:</b> Candidate QSE groups are validated by comparing the total reaction flux <em>within</em> the group to the flux <em>leaving</em> the group. A high internal-to-external flux ratio indicates a valid QSE group.</li>
<li><b>QSE Solve:</b> For valid QSE groups, <code>solveQSEAbundances</code> uses a Levenberg-Marquardt nonlinear solver (<code>Eigen::LevenbergMarquardt</code>) to find the equilibrium abundances of the "algebraic" species, holding the "seed" species constant.</li>
</ol>
<p>All calculations are cached using <code><a class="el" href="structgridfire_1_1_q_s_e_cache_key.html" title="Key struct for the QSE abundance cache.">QSECacheKey</a></code> to avoid re-partitioning and re-solving for similar thermodynamic conditions.</p>
<dl class="section user"><dt>Usage Example:</dt><dd><div class="fragment"><div class="line"><span class="comment">// 1. Create a base engine (e.g., GraphEngine)</span></div>
<div class="line"><a class="code hl_class" href="classgridfire_1_1_graph_engine.html">gridfire::GraphEngine</a> baseEngine(composition);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Wrap it with the MultiscalePartitioningEngineView</span></div>
<div class="line"><a class="code hl_class" href="classgridfire_1_1_multiscale_partitioning_engine_view.html">gridfire::MultiscalePartitioningEngineView</a> multiscaleEngine(baseEngine);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Before integration, update the view to partition the network</span></div>
<div class="line"><span class="comment">//    and find the initial equilibrium state.</span></div>
<div class="line"><a class="code hl_struct" href="structgridfire_1_1_net_in.html">NetIn</a> initialConditions = { .composition = composition, .temperature = 1e8, .density = 1e3 };</div>
<div class="line">fourdst::composition::Composition equilibratedComp = multiscaleEngine.update(initialConditions);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 4. Use the multiscaleEngine for integration. It will use the cached QSE solution.</span></div>
<div class="line"><span class="comment">//    The integrator will call calculateRHSAndEnergy, etc. on the multiscaleEngine.</span></div>
<div class="line"><span class="keyword">auto</span> Y_initial = multiscaleEngine.mapNetInToMolarAbundanceVector({equilibratedComp, ...});</div>
<div class="line"><span class="keyword">auto</span> derivatives = multiscaleEngine.calculateRHSAndEnergy(Y_initial, T9, rho);</div>
<div class="ttc" id="aclassgridfire_1_1_graph_engine_html"><div class="ttname"><a href="classgridfire_1_1_graph_engine.html">gridfire::GraphEngine</a></div><div class="ttdoc">A reaction network engine that uses a graph-based representation.</div><div class="ttdef"><b>Definition</b> <a href="engine__graph_8h_source.html#l00101">engine_graph.h:101</a></div></div>
<div class="ttc" id="aclassgridfire_1_1_multiscale_partitioning_engine_view_html"><div class="ttname"><a href="classgridfire_1_1_multiscale_partitioning_engine_view.html">gridfire::MultiscalePartitioningEngineView</a></div><div class="ttdoc">An engine view that partitions the reaction network into multiple groups based on timescales.</div><div class="ttdef"><b>Definition</b> <a href="engine__multiscale_8h_source.html#l00174">engine_multiscale.h:174</a></div></div>
<div class="ttc" id="astructgridfire_1_1_net_in_html"><div class="ttname"><a href="structgridfire_1_1_net_in.html">gridfire::NetIn</a></div><div class="ttdef"><b>Definition</b> <a href="network_8h_source.html#l00053">network.h:53</a></div></div>
</div><!-- fragment --></dd></dl>
<p>&lt;DynamicEngine&gt; </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00174">174</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a34b5fdb2078e748edfbe6846ecadd681" name="a34b5fdb2078e748edfbe6846ecadd681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b5fdb2078e748edfbe6846ecadd681">&#9670;&#160;</a></span>QSEPartition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::tuple&lt;std::vector&lt;fourdst::atomic::Species&gt;, std::vector&lt;size_t&gt;, std::vector&lt;fourdst::atomic::Species&gt;, std::vector&lt;size_t&gt; &gt; <a class="el" href="#a34b5fdb2078e748edfbe6846ecadd681">gridfire::MultiscalePartitioningEngineView::QSEPartition</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type alias for a QSE partition. </p>
<p>A QSE partition is a tuple containing the fast species, their indices, the slow species, and their indices. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00181">181</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0df457c0f0f6f403a295335c84fd828f" name="a0df457c0f0f6f403a295335c84fd828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df457c0f0f6f403a295335c84fd828f">&#9670;&#160;</a></span>MultiscalePartitioningEngineView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gridfire::MultiscalePartitioningEngineView::MultiscalePartitioningEngineView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgridfire_1_1_graph_engine.html">GraphEngine</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>baseEngine</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classgridfire_1_1_multiscale_partitioning_engine_view.html" title="An engine view that partitions the reaction network into multiple groups based on timescales.">MultiscalePartitioningEngineView</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseEngine</td><td>The underlying <a class="el" href="classgridfire_1_1_graph_engine.html" title="A reaction network engine that uses a graph-based representation.">GraphEngine</a> to which this view delegates calculations. It must be a <code><a class="el" href="classgridfire_1_1_graph_engine.html" title="A reaction network engine that uses a graph-based representation.">GraphEngine</a></code> and not a more general <code><a class="el" href="classgridfire_1_1_dynamic_engine.html" title="Abstract class for engines supporting Jacobian and stoichiometry operations.">DynamicEngine</a></code> because this view relies on its specific implementation details. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00153">153</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af13e764c118a6cc51847384e9c70e05b" name="af13e764c118a6cc51847384e9c70e05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13e764c118a6cc51847384e9c70e05b">&#9670;&#160;</a></span>analyzeTimescalePoolConnectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; size_t &gt; &gt; gridfire::MultiscalePartitioningEngineView::analyzeTimescalePoolConnectivity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timescale_pools</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyzes the connectivity of timescale pools. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timescale_pools</td><td>A vector of vectors of species indices, where each inner vector represents a timescale pool. </td></tr>
    <tr><td class="paramname">Y</td><td>Vector of current molar abundances for the full network. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of species indices, where each inner vector represents a single connected component.</dd></dl>
<p>@purpose To merge timescale pools that are strongly connected by reactions, forming cohesive groups for QSE analysis.</p>
<p>@how For each pool, it builds a reaction connectivity graph using <code>buildConnectivityGraph</code>. It then finds the connected components within that graph using a Breadth-First Search (BFS). The resulting components from all pools are collected and returned. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00416">416</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="aae0865e361dfeb23984d70409fdd9f39" name="aae0865e361dfeb23984d70409fdd9f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0865e361dfeb23984d70409fdd9f39">&#9670;&#160;</a></span>buildConnectivityGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; size_t, std::vector&lt; size_t &gt; &gt; gridfire::MultiscalePartitioningEngineView::buildConnectivityGraph </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fast_reaction_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a connectivity graph from a set of fast reaction indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fast_reaction_indices</td><td>A set of indices for reactions considered "fast". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered map representing the adjacency list of the connectivity graph, where keys are species indices and values are vectors of connected species indices.</dd></dl>
<p>@purpose To represent the reaction pathways among a subset of reactions.</p>
<p>@how It iterates through the specified fast reactions. For each reaction, it creates a two-way edge in the graph between every reactant and every product, signifying that mass can flow between them. </p>

</div>
</div>
<a id="ae3875c61dc916c0982ed122c2e272d94" name="ae3875c61dc916c0982ed122c2e272d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3875c61dc916c0982ed122c2e272d94">&#9670;&#160;</a></span>buildConnectivityGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; size_t, std::vector&lt; size_t &gt; &gt; gridfire::MultiscalePartitioningEngineView::buildConnectivityGraph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>species_pool</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a connectivity graph from a species pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">species_pool</td><td>A vector of species indices representing a species pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered map representing the adjacency list of the connectivity graph.</dd></dl>
<p>@purpose To find reaction connections within a specific group of species.</p>
<p>@how It iterates through all reactions in the base engine. If a reaction involves at least two distinct species from the input <code>species_pool</code> (one as a reactant and one as a product), it adds edges between all reactants and products from that reaction that are also in the pool. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l01344">1344</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a79eb9c108d694a27ec913ed0143aa044" name="a79eb9c108d694a27ec913ed0143aa044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb9c108d694a27ec913ed0143aa044">&#9670;&#160;</a></span>calculateMolarReactionFlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double gridfire::MultiscalePartitioningEngineView::calculateMolarReactionFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgridfire_1_1reaction_1_1_reaction.html">reaction::Reaction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reaction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y_full</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the molar reaction flow for a given reaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction</td><td>The reaction for which to calculate the flow. </td></tr>
    <tr><td class="paramname">Y_full</td><td>Vector of current molar abundances for the full network. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Molar flow rate for the reaction (e.g., mol/g/s).</dd></dl>
<p>@purpose To compute the net rate of a single reaction.</p>
<p>@how It first checks the QSE cache. On a hit, it retrieves the cached equilibrium abundances for the algebraic species. It creates a mutable copy of <code>Y_full</code>, overwrites the algebraic species abundances with the cached equilibrium values, and then calls the base engine's <code>calculateMolarReactionFlow</code> with this modified abundance vector.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The engine must have a valid QSE cache entry for the given state. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">StaleEngineError</td><td>If the QSE cache misses. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#a6633b1757c41dd9e1c397333f4f9e785">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00253">253</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a716d7357e944e8394d8b8e0b5e7625eb" name="a716d7357e944e8394d8b8e0b5e7625eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716d7357e944e8394d8b8e0b5e7625eb">&#9670;&#160;</a></span>calculateRHSAndEnergy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::expected&lt; <a class="el" href="structgridfire_1_1_step_derivatives.html">StepDerivatives</a>&lt; double &gt;, <a class="el" href="structgridfire_1_1expectations_1_1_stale_engine_error.html">expectations::StaleEngineError</a> &gt; gridfire::MultiscalePartitioningEngineView::calculateRHSAndEnergy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y_full</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the right-hand side (dY/dt) and energy generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y_full</td><td>Vector of current molar abundances for all species in the base engine. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::expected</code> containing <code><a class="el" href="structgridfire_1_1_step_derivatives.html" title="Structure holding derivatives and energy generation for a network step.">StepDerivatives</a>&lt;double&gt;</code> on success, or a <code>StaleEngineError</code> if the engine's QSE cache does not contain a solution for the given state.</dd></dl>
<p>@purpose To compute the time derivatives for the ODE solver. This implementation modifies the derivatives from the base engine to enforce the QSE condition.</p>
<p>@how It first performs a lookup in the QSE abundance cache (<code>m_qse_abundance_cache</code>). If a cache hit occurs, it calls the base engine's <code>calculateRHSAndEnergy</code>. It then manually sets the time derivatives (<code>dydt</code>) of all identified algebraic species to zero, effectively removing their differential equations from the system being solved.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The engine must have been updated via <code><a class="el" href="#a6bee75b5a6e508e6eebf83f0d48c50b8" title="Updates the internal state of the engine, performing partitioning and QSE equilibration.">update()</a></code> or <code><a class="el" href="#a4bc879246c6fbd8633b05052858df51d" title="Equilibrates the network by partitioning and solving for QSE abundances.">equilibrateNetwork()</a></code> for the current thermodynamic conditions, so that a valid entry exists in the QSE cache. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The returned derivatives will have <code>dydt=0</code> for all algebraic species.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">StaleEngineError</td><td>If the QSE cache does not contain an entry for the given (T9, rho, Y_full). This indicates <code><a class="el" href="#a6bee75b5a6e508e6eebf83f0d48c50b8" title="Updates the internal state of the engine, performing partitioning and QSE equilibration.">update()</a></code> was not called recently enough. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgridfire_1_1_engine.html#a89f714d19b84a93a004a7afbb487a6cb">gridfire::Engine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00161">161</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="ac206840057bac65b7f7738e6dfd1047a" name="ac206840057bac65b7f7738e6dfd1047a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac206840057bac65b7f7738e6dfd1047a">&#9670;&#160;</a></span>constructCandidateGroups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html">MultiscalePartitioningEngineView::QSEGroup</a> &gt; gridfire::MultiscalePartitioningEngineView::constructCandidateGroups </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidate_pools</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs candidate QSE groups from connected timescale pools. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidate_pools</td><td>A vector of vectors of species indices, where each inner vector represents a connected pool of species with similar fast timescales. </td></tr>
    <tr><td class="paramname">Y</td><td>Vector of current molar abundances. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <code><a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html" title="Struct representing a QSE group.">QSEGroup</a></code> structs, ready for flux validation.</dd></dl>
<p>@how For each input pool, it identifies "bridge" reactions that connect the pool to species outside the pool. The reactants of these bridge reactions that are <em>not</em> in the pool are identified as "seed" species. The original pool members are the "algebraic" species. It then bundles the seed and algebraic species into a <code><a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html" title="Struct representing a QSE group.">QSEGroup</a></code> struct.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>candidate_pools</code> should be connected components from <code>analyzeTimescalePoolConnectivity</code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A list of candidate <code><a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html" title="Struct representing a QSE group.">QSEGroup</a></code> objects is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l01405">1405</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a1b17f94386882ea1524147782b7a1ddc" name="a1b17f94386882ea1524147782b7a1ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b17f94386882ea1524147782b7a1ddc">&#9670;&#160;</a></span>equilibrateNetwork() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fourdst::composition::Composition gridfire::MultiscalePartitioningEngineView::equilibrateNetwork </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>netIn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equilibrates the network using QSE from a <code><a class="el" href="structgridfire_1_1_net_in.html">NetIn</a></code> struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netIn</td><td>A struct containing the current network input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equilibrated composition.</dd></dl>
<p>@purpose A convenience overload for <code>equilibrateNetwork</code>.</p>
<p>@how It unpacks the <code>netIn</code> struct into <code>Y</code>, <code>T9</code>, and <code>rho</code> and then calls the primary <code>equilibrateNetwork</code> method. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00834">834</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a4bc879246c6fbd8633b05052858df51d" name="a4bc879246c6fbd8633b05052858df51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc879246c6fbd8633b05052858df51d">&#9670;&#160;</a></span>equilibrateNetwork() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fourdst::composition::Composition gridfire::MultiscalePartitioningEngineView::equilibrateNetwork </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equilibrates the network by partitioning and solving for QSE abundances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y</td><td>Vector of current molar abundances for the full network. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new composition object with the equilibrated abundances.</dd></dl>
<p>@purpose A convenience method to run the full QSE analysis and get an equilibrated composition object as a result.</p>
<p>@how It first calls <code><a class="el" href="#a7d26945df5395b9317552a3989c42d1c" title="Partitions the network into dynamic and algebraic (QSE) groups based on timescales.">partitionNetwork()</a></code> with the given state to define the QSE groups. Then, it calls <code><a class="el" href="#a3c5fcb8e3396d74359fd601554c9ffa9" title="Solves for the QSE abundances of the algebraic species in a given state.">solveQSEAbundances()</a></code> to compute the new equilibrium abundances for the algebraic species. Finally, it packs the resulting full abundance vector into a new <code>fourdst::composition::Composition</code> object and returns it.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The input state (Y, T9, rho) must be a valid physical state. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The engine's internal partition is updated. A new composition object is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00797">797</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="acff59a15abac30eee16e9fa7b355fb18" name="acff59a15abac30eee16e9fa7b355fb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff59a15abac30eee16e9fa7b355fb18">&#9670;&#160;</a></span>exportToDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gridfire::MultiscalePartitioningEngineView::exportToDot </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports the network to a DOT file for visualization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the DOT file to create. </td></tr>
    <tr><td class="paramname">Y</td><td>Vector of current molar abundances for the full network. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3.</td></tr>
  </table>
  </dd>
</dl>
<p>@purpose To visualize the partitioned network graph.</p>
<p>@how This method delegates the DOT file export to the base engine. It does not currently add any partitioning information to the output graph. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00558">558</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="acdf5ad8765290ea2b78170235aea391d" name="acdf5ad8765290ea2b78170235aea391d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf5ad8765290ea2b78170235aea391d">&#9670;&#160;</a></span>generateJacobianMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gridfire::MultiscalePartitioningEngineView::generateJacobianMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y_full</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the Jacobian matrix for the current state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y_full</td><td>Vector of current molar abundances. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3.</td></tr>
  </table>
  </dd>
</dl>
<p>@purpose To compute the Jacobian matrix required by implicit ODE solvers.</p>
<p>@how It first performs a QSE cache lookup. On a hit, it delegates the full Jacobian calculation to the base engine. While this view could theoretically return a modified, sparser Jacobian reflecting the QSE constraints, the current implementation returns the full Jacobian from the base engine. The solver is expected to handle the algebraic constraints (e.g., via <code>dydt=0</code> from <code>calculateRHSAndEnergy</code>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The engine must have a valid QSE cache entry for the given state. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The base engine's internal Jacobian is updated.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classgridfire_1_1exceptions_1_1_stale_engine_error.html">exceptions::StaleEngineError</a></td><td>If the QSE cache misses, as it cannot proceed without a valid partition. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#a29bdd4231c29c3a4e524ad6ca66a127d">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00204">204</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="abe76a46784b1ebc8ad67a9eec40d369a" name="abe76a46784b1ebc8ad67a9eec40d369a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe76a46784b1ebc8ad67a9eec40d369a">&#9670;&#160;</a></span>generateStoichiometryMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gridfire::MultiscalePartitioningEngineView::generateStoichiometryMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the stoichiometry matrix for the network. </p>
<p>@purpose To prepare the stoichiometry matrix for later queries.</p>
<p>@how This method delegates directly to the base engine's <code><a class="el" href="#abe76a46784b1ebc8ad67a9eec40d369a" title="Generates the stoichiometry matrix for the network.">generateStoichiometryMatrix()</a></code>. The stoichiometry is based on the full, unpartitioned network. </p>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#aeae6d84ef74d88fd2cdf07b82e98a16f">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00242">242</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a22bd1f0e821ed415611d75bac67063d1" name="a22bd1f0e821ed415611d75bac67063d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bd1f0e821ed415611d75bac67063d1">&#9670;&#160;</a></span>getBaseEngine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgridfire_1_1_dynamic_engine.html">DynamicEngine</a> &amp; gridfire::MultiscalePartitioningEngineView::getBaseEngine </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the base engine. </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the base engine. </dd></dl>

<p>Implements <a class="el" href="classgridfire_1_1_engine_view.html#ad294227f8b5cf6d970c349eabf5447a6">gridfire::EngineView&lt; DynamicEngine &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00412">412</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a1e04e8cb8c84b1bd033ac599accf0888" name="a1e04e8cb8c84b1bd033ac599accf0888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e04e8cb8c84b1bd033ac599accf0888">&#9670;&#160;</a></span>getDynamicSpecies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; Species &gt; &amp; gridfire::MultiscalePartitioningEngineView::getDynamicSpecies </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dynamic species in the network. </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the vector of species identified as "dynamic" or "slow".</dd></dl>
<p>@purpose To allow external queries of the partitioning results.</p>
<p>@how It returns a const reference to the <code>m_dynamic_species</code> member vector.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code><a class="el" href="#a7d26945df5395b9317552a3989c42d1c" title="Partitions the network into dynamic and algebraic (QSE) groups based on timescales.">partitionNetwork()</a></code> must have been called. </dd></dl>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00789">789</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a3c82e4e082d1c82b1b090ac9847c7c5e" name="a3c82e4e082d1c82b1b090ac9847c7c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c82e4e082d1c82b1b090ac9847c7c5e">&#9670;&#160;</a></span>getFastSpecies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Species &gt; gridfire::MultiscalePartitioningEngineView::getFastSpecies </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fast species in the network. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector of species identified as "fast" or "algebraic" by the partitioning.</dd></dl>
<p>@purpose To allow external queries of the partitioning results.</p>
<p>@how It returns a copy of the <code>m_algebraic_species</code> member vector.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code><a class="el" href="#a7d26945df5395b9317552a3989c42d1c" title="Partitions the network into dynamic and algebraic (QSE) groups based on timescales.">partitionNetwork()</a></code> must have been called. </dd></dl>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00776">776</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="ac961484383e86d9712a424728e068633" name="ac961484383e86d9712a424728e068633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac961484383e86d9712a424728e068633">&#9670;&#160;</a></span>getJacobianMatrixEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double gridfire::MultiscalePartitioningEngineView::getJacobianMatrixEntry </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i_full</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j_full</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an entry from the previously generated Jacobian matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_full</td><td>Row index (species index) in the full network. </td></tr>
    <tr><td class="paramname">j_full</td><td>Column index (species index) in the full network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the Jacobian matrix at (i_full, j_full).</dd></dl>
<p>@purpose To provide Jacobian entries to an implicit solver.</p>
<p>@how This method directly delegates to the base engine's <code>getJacobianMatrixEntry</code>. It does not currently modify the Jacobian to reflect the QSE algebraic constraints, as these are handled by setting <code>dY/dt = 0</code> in <code>calculateRHSAndEnergy</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code><a class="el" href="#acdf5ad8765290ea2b78170235aea391d" title="Generates the Jacobian matrix for the current state.">generateJacobianMatrix()</a></code> must have been called for the current state. </dd></dl>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#a05d15ff35a6bc06a2fa7eda19838bd07">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00228">228</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="ad751f2c1306895ee74a61f2071ca96eb" name="ad751f2c1306895ee74a61f2071ca96eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad751f2c1306895ee74a61f2071ca96eb">&#9670;&#160;</a></span>getNetworkReactions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegridfire_1_1reaction.html#aa86f08712565f278adacc7cd2361eb31">reaction::LogicalReactionSet</a> &amp; gridfire::MultiscalePartitioningEngineView::getNetworkReactions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the set of logical reactions in the network. </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the <code><a class="el" href="namespacegridfire_1_1reaction.html#aa86f08712565f278adacc7cd2361eb31" title="A set of logical reactions.">LogicalReactionSet</a></code> from the base engine, containing all reactions in the full network. </dd></dl>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#ad2a82099edbb374bbb2c9509ccdb1037">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00286">286</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a696f74f5135bbd62169b6577f92fee80" name="a696f74f5135bbd62169b6577f92fee80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696f74f5135bbd62169b6577f92fee80">&#9670;&#160;</a></span>getNetworkSpecies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; Species &gt; &amp; gridfire::MultiscalePartitioningEngineView::getNetworkSpecies </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the list of species in the network. </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the vector of <code>Species</code> objects representing all species in the underlying base engine. This view does not alter the species list itself, only how their abundances are evolved. </dd></dl>

<p>Implements <a class="el" href="classgridfire_1_1_engine.html#a020e1b493d6964cafdad08fde697ceb3">gridfire::Engine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00157">157</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a7bfb4e6fec2f337a1dea69e3d4f1fc82" name="a7bfb4e6fec2f337a1dea69e3d4f1fc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfb4e6fec2f337a1dea69e3d4f1fc82">&#9670;&#160;</a></span>getScreeningModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridfire_1_1screening.html#aa82aafbc4f8c28d0a75b60798e3a7d25">screening::ScreeningType</a> gridfire::MultiscalePartitioningEngineView::getScreeningModel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current electron screening model. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently active screening model type.</dd></dl>
<p>@how This method delegates directly to the base engine's <code><a class="el" href="#a7bfb4e6fec2f337a1dea69e3d4f1fc82" title="Gets the current electron screening model.">getScreeningModel()</a></code>. </p>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#a7a203f8e0f3a6744ddc912dfbcfdbcc0">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00408">408</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="aa38c367ef3c74d012ccd10521cd5a727" name="aa38c367ef3c74d012ccd10521cd5a727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38c367ef3c74d012ccd10521cd5a727">&#9670;&#160;</a></span>getSpeciesDestructionTimescales()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::expected&lt; std::unordered_map&lt; fourdst::atomic::Species, double &gt;, <a class="el" href="structgridfire_1_1expectations_1_1_stale_engine_error.html">expectations::StaleEngineError</a> &gt; gridfire::MultiscalePartitioningEngineView::getSpeciesDestructionTimescales </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes destruction timescales for all species in the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y</td><td>Vector of current molar abundances for the full network. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::expected</code> containing a map from <code>Species</code> to their characteristic destruction timescales (s) on success, or a <code>StaleEngineError</code> on failure.</dd></dl>
<p>@purpose To get the timescale for species destruction, which is used as the primary metric for network partitioning.</p>
<p>@how It delegates the calculation to the base engine. For any species identified as algebraic (in QSE), it manually sets their timescale to 0.0.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The engine must have a valid QSE cache entry for the given state. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">StaleEngineError</td><td>If the QSE cache misses. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#a6ca0f315f75252ca505507a61556dda6">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00326">326</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a91d32b7197fcb27ee697d5bfde960f3f" name="a91d32b7197fcb27ee697d5bfde960f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d32b7197fcb27ee697d5bfde960f3f">&#9670;&#160;</a></span>getSpeciesIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gridfire::MultiscalePartitioningEngineView::getSpeciesIndex </td>
          <td>(</td>
          <td class="paramtype">const fourdst::atomic::Species &amp;</td>          <td class="paramname"><span class="paramname"><em>species</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the index of a species in the full network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">species</td><td>The species to get the index of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the species in the base engine's network.</dd></dl>
<p>@how This method delegates directly to the base engine's <code><a class="el" href="#a91d32b7197fcb27ee697d5bfde960f3f" title="Gets the index of a species in the full network.">getSpeciesIndex()</a></code>. </p>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#ad3d56a8b9161b9cc7f4da51f6bf7e8c9">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00846">846</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a560612347bbd5b7b380e990624d01105" name="a560612347bbd5b7b380e990624d01105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560612347bbd5b7b380e990624d01105">&#9670;&#160;</a></span>getSpeciesTimescales()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::expected&lt; std::unordered_map&lt; Species, double &gt;, <a class="el" href="structgridfire_1_1expectations_1_1_stale_engine_error.html">expectations::StaleEngineError</a> &gt; gridfire::MultiscalePartitioningEngineView::getSpeciesTimescales </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes timescales for all species in the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y</td><td>Vector of current molar abundances for the full network. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::expected</code> containing a map from <code>Species</code> to their characteristic timescales (s) on success, or a <code>StaleEngineError</code> on failure.</dd></dl>
<p>@purpose To get the characteristic timescale <code>Y / (dY/dt)</code> for each species.</p>
<p>@how It delegates the calculation to the base engine. For any species identified as algebraic (in QSE), it manually sets their timescale to 0.0 to signify that they equilibrate instantaneously on the timescale of the solver.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The engine must have a valid QSE cache entry for the given state. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">StaleEngineError</td><td>If the QSE cache misses. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#a6772ac384b4c3d3e91712041e4aaa813">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00295">295</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a510b920dea726aef859ac1f6d051807e" name="a510b920dea726aef859ac1f6d051807e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510b920dea726aef859ac1f6d051807e">&#9670;&#160;</a></span>getStoichiometryMatrixEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gridfire::MultiscalePartitioningEngineView::getStoichiometryMatrixEntry </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>speciesIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>reactionIndex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an entry from the stoichiometry matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speciesIndex</td><td>Index of the species in the full network. </td></tr>
    <tr><td class="paramname">reactionIndex</td><td>Index of the reaction in the full network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stoichiometric coefficient for the species in the reaction.</dd></dl>
<p>@purpose To query the stoichiometric relationship between a species and a reaction.</p>
<p>@how This method delegates directly to the base engine's <code><a class="el" href="#a510b920dea726aef859ac1f6d051807e" title="Gets an entry from the stoichiometry matrix.">getStoichiometryMatrixEntry()</a></code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code><a class="el" href="#abe76a46784b1ebc8ad67a9eec40d369a" title="Generates the stoichiometry matrix for the network.">generateStoichiometryMatrix()</a></code> must have been called. </dd></dl>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#afa108dd5227dbb1045e90d7b3bd8b84f">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00246">246</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a54ca8004fbd8d6d3ea6f67efeb5dbc8d" name="a54ca8004fbd8d6d3ea6f67efeb5dbc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ca8004fbd8d6d3ea6f67efeb5dbc8d">&#9670;&#160;</a></span>identifyMeanSlowestPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t gridfire::MultiscalePartitioningEngineView::identifyMeanSlowestPool </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pools</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies the pool with the slowest mean timescale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pools</td><td>A vector of vectors of species indices, where each inner vector represents a timescale pool. </td></tr>
    <tr><td class="paramname">Y</td><td>Vector of current molar abundances for the full network. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the pool with the largest (slowest) mean destruction timescale.</dd></dl>
<p>@purpose To identify the core set of dynamic species that will not be part of any QSE group.</p>
<p>@how It calculates the geometric mean of the destruction timescales for all species in each pool and returns the index of the pool with the maximum mean timescale. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l01291">1291</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="ae7847959fc5af2b83f5446dd73567b46" name="ae7847959fc5af2b83f5446dd73567b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7847959fc5af2b83f5446dd73567b46">&#9670;&#160;</a></span>isStale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gridfire::MultiscalePartitioningEngineView::isStale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>netIn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the engine's internal state is stale relative to the provided conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netIn</td><td>A struct containing the current network input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the engine is stale, <code>false</code> otherwise.</dd></dl>
<p>@purpose To determine if <code><a class="el" href="#a6bee75b5a6e508e6eebf83f0d48c50b8" title="Updates the internal state of the engine, performing partitioning and QSE equilibration.">update()</a></code> needs to be called.</p>
<p>@how It creates a <code><a class="el" href="structgridfire_1_1_q_s_e_cache_key.html" title="Key struct for the QSE abundance cache.">QSECacheKey</a></code> from the <code>netIn</code> data and checks for its existence in the <code>m_qse_abundance_cache</code>. A cache miss indicates the engine is stale because it does not have a valid QSE partition for the current conditions. It also queries the base engine's <code><a class="el" href="#ae7847959fc5af2b83f5446dd73567b46" title="Checks if the engine&#39;s internal state is stale relative to the provided conditions.">isStale()</a></code> method. </p>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#a942e65ced17ca602482cc42e469d6398">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00390">390</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="aada497e8df74a295fdf5df7d7cdf64e0" name="aada497e8df74a295fdf5df7d7cdf64e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada497e8df74a295fdf5df7d7cdf64e0">&#9670;&#160;</a></span>mapNetInToMolarAbundanceVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; gridfire::MultiscalePartitioningEngineView::mapNetInToMolarAbundanceVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>netIn</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a <code><a class="el" href="structgridfire_1_1_net_in.html">NetIn</a></code> struct to a molar abundance vector for the full network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netIn</td><td>A struct containing the current network input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of molar abundances corresponding to the species order in the base engine.</dd></dl>
<p>@how This method delegates directly to the base engine's <code><a class="el" href="#aada497e8df74a295fdf5df7d7cdf64e0" title="Maps a NetIn struct to a molar abundance vector for the full network.">mapNetInToMolarAbundanceVector()</a></code>. </p>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#a55f1b7e5ebe2840e1d7c54665ca5411a">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00768">768</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="ad4d29ee55f89384807616d1068797067" name="ad4d29ee55f89384807616d1068797067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d29ee55f89384807616d1068797067">&#9670;&#160;</a></span>partitionByTimescale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; size_t &gt; &gt; gridfire::MultiscalePartitioningEngineView::partitionByTimescale </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y_full</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partitions the network by timescale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y_full</td><td>Vector of current molar abundances for all species. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of species indices, where each inner vector represents a timescale pool.</dd></dl>
<p>@purpose To group species into "pools" based on their destruction timescales.</p>
<p>@how It retrieves all species destruction timescales from the base engine, sorts them, and then iterates through the sorted list, creating a new pool whenever it detects a gap between consecutive timescales that is larger than a predefined threshold (e.g., a factor of 100). </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00850">850</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a98b11ffe498846f5a3a72f08504346b7" name="a98b11ffe498846f5a3a72f08504346b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b11ffe498846f5a3a72f08504346b7">&#9670;&#160;</a></span>partitionNetwork() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gridfire::MultiscalePartitioningEngineView::partitionNetwork </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>netIn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions the network based on timescales from a <code><a class="el" href="structgridfire_1_1_net_in.html">NetIn</a></code> struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netIn</td><td>A struct containing the current network input.</td></tr>
  </table>
  </dd>
</dl>
<p>@purpose A convenience overload for <code>partitionNetwork</code>.</p>
<p>@how It unpacks the <code>netIn</code> struct into <code>Y</code>, <code>T9</code>, and <code>rho</code> and then calls the primary <code>partitionNetwork</code> method. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00548">548</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a7d26945df5395b9317552a3989c42d1c" name="a7d26945df5395b9317552a3989c42d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d26945df5395b9317552a3989c42d1c">&#9670;&#160;</a></span>partitionNetwork() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gridfire::MultiscalePartitioningEngineView::partitionNetwork </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions the network into dynamic and algebraic (QSE) groups based on timescales. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y</td><td>Vector of current molar abundances for the full network. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3.</td></tr>
  </table>
  </dd>
</dl>
<p>@purpose To perform the core partitioning logic that identifies which species are "fast" (and can be treated algebraically) and which are "slow" (and must be integrated dynamically).</p>
<p>@how</p><ol type="1">
<li><b><code>partitionByTimescale</code></b>: Gets species destruction timescales from the base engine, sorts them, and looks for large gaps to create timescale "pools".</li>
<li><b><code>identifyMeanSlowestPool</code></b>: The pool with the slowest average timescale is designated as the core set of dynamic species.</li>
<li><b><code>analyzeTimescalePoolConnectivity</code></b>: The other (faster) pools are analyzed for reaction connectivity to form cohesive groups.</li>
<li><b><code>constructCandidateGroups</code></b>: These connected groups are processed to identify "seed" species (dynamic species that feed the group) and "algebraic" species (the rest).</li>
<li><b><code>validateGroupsWithFluxAnalysis</code></b>: The groups are validated by ensuring their internal reaction flux is much larger than the flux connecting them to the outside network.</li>
</ol>
<dl class="section pre"><dt>Precondition</dt><dd>The input state (Y, T9, rho) must be a valid physical state. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The internal member variables <code>m_qse_groups</code>, <code>m_dynamic_species</code>, and <code>m_algebraic_species</code> (and their index maps) are populated with the results of the partitioning. </dd></dl>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00438">438</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a05730ced13ac5331060ca011f0da6235" name="a05730ced13ac5331060ca011f0da6235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05730ced13ac5331060ca011f0da6235">&#9670;&#160;</a></span>primeEngine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgridfire_1_1_priming_report.html">PrimingReport</a> gridfire::MultiscalePartitioningEngineView::primeEngine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>netIn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Primes the engine with a specific species. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netIn</td><td>A struct containing the current network input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structgridfire_1_1_priming_report.html" title="Captures the result of a network priming operation.">PrimingReport</a></code> struct containing information about the priming process.</dd></dl>
<p>@purpose To prepare the network for ignition or specific pathway studies.</p>
<p>@how This method delegates directly to the base engine's <code><a class="el" href="#a05730ced13ac5331060ca011f0da6235" title="Primes the engine with a specific species.">primeEngine()</a></code>. The multiscale view does not currently interact with the priming process. </p>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#a21c34f59c080a853fafa38a25175124e">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00793">793</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="acb5fa7f03cd89b8c1b6b9ffdf3abb12e" name="acb5fa7f03cd89b8c1b6b9ffdf3abb12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5fa7f03cd89b8c1b6b9ffdf3abb12e">&#9670;&#160;</a></span>setNetworkReactions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gridfire::MultiscalePartitioningEngineView::setNetworkReactions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegridfire_1_1reaction.html#aa86f08712565f278adacc7cd2361eb31">reaction::LogicalReactionSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reactions</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the set of logical reactions in the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reactions</td><td>The set of logical reactions to use.</td></tr>
  </table>
  </dd>
</dl>
<p>@purpose To modify the reaction network.</p>
<p>@how This operation is not supported by the <code><a class="el" href="classgridfire_1_1_multiscale_partitioning_engine_view.html" title="An engine view that partitions the reaction network into multiple groups based on timescales.">MultiscalePartitioningEngineView</a></code> as it would invalidate the partitioning logic. It logs a critical error and throws an exception. <a class="el" href="classgridfire_1_1_network.html">Network</a> modifications should be done on the base engine before it is wrapped by this view.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classgridfire_1_1exceptions_1_1_unable_to_set_network_reactions_error.html">exceptions::UnableToSetNetworkReactionsError</a></td><td>Always. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#afb2ec904d88fc8aab516db4059d0e00f">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00290">290</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a1a0c0a0ade632eb10f0eecab828a059f" name="a1a0c0a0ade632eb10f0eecab828a059f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0c0a0ade632eb10f0eecab828a059f">&#9670;&#160;</a></span>setScreeningModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gridfire::MultiscalePartitioningEngineView::setScreeningModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegridfire_1_1screening.html#aa82aafbc4f8c28d0a75b60798e3a7d25">screening::ScreeningType</a></td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the electron screening model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The type of screening model to use for reaction rate calculations.</td></tr>
  </table>
  </dd>
</dl>
<p>@how This method delegates directly to the base engine's <code><a class="el" href="#a1a0c0a0ade632eb10f0eecab828a059f" title="Sets the electron screening model.">setScreeningModel()</a></code>. </p>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#a3fb44b6f55563a2f590f31916528f2bd">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00402">402</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a3c5fcb8e3396d74359fd601554c9ffa9" name="a3c5fcb8e3396d74359fd601554c9ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5fcb8e3396d74359fd601554c9ffa9">&#9670;&#160;</a></span>solveQSEAbundances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; gridfire::MultiscalePartitioningEngineView::solveQSEAbundances </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y_full</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves for the QSE abundances of the algebraic species in a given state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y_full</td><td>Vector of current molar abundances for all species in the base engine. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of molar abundances for the algebraic species.</dd></dl>
<p>@purpose To find the equilibrium abundances of the algebraic species that satisfy the QSE conditions.</p>
<p>@how It uses the Levenberg-Marquardt algorithm via Eigen's <code>LevenbergMarquardt</code> class. The problem is defined by the <code><a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_eigen_functor.html" title="Functor for solving QSE abundances using Eigen&#39;s nonlinear optimization.">EigenFunctor</a></code> which computes the residuals and Jacobian for the QSE equations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The input state (Y_full, T9, rho) must be a valid physical state. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The algebraic species in the QSE cache are updated with the new equilibrium abundances. </dd></dl>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l01136">1136</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="a6bee75b5a6e508e6eebf83f0d48c50b8" name="a6bee75b5a6e508e6eebf83f0d48c50b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bee75b5a6e508e6eebf83f0d48c50b8">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fourdst::composition::Composition gridfire::MultiscalePartitioningEngineView::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgridfire_1_1_net_in.html">NetIn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>netIn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the internal state of the engine, performing partitioning and QSE equilibration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netIn</td><td>A struct containing the current network input: temperature, density, and composition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new composition after QSE species have been brought to equilibrium.</dd></dl>
<p>@purpose This is the main entry point for preparing the multiscale engine for use. It triggers the network partitioning and solves for the initial QSE abundances, caching the result.</p>
<p>@how</p><ol type="1">
<li>It first checks the QSE cache. If a valid entry already exists for the input state, it returns the input composition, as no work is needed.</li>
<li>If the cache misses, it calls <code><a class="el" href="#a4bc879246c6fbd8633b05052858df51d" title="Equilibrates the network by partitioning and solving for QSE abundances.">equilibrateNetwork()</a></code>.</li>
<li><code><a class="el" href="#a4bc879246c6fbd8633b05052858df51d" title="Equilibrates the network by partitioning and solving for QSE abundances.">equilibrateNetwork()</a></code> in turn calls <code><a class="el" href="#a7d26945df5395b9317552a3989c42d1c" title="Partitions the network into dynamic and algebraic (QSE) groups based on timescales.">partitionNetwork()</a></code> to define the dynamic and algebraic species sets.</li>
<li>It then calls <code><a class="el" href="#a3c5fcb8e3396d74359fd601554c9ffa9" title="Solves for the QSE abundances of the algebraic species in a given state.">solveQSEAbundances()</a></code> to compute the equilibrium abundances.</li>
<li>The resulting equilibrium abundances for the algebraic species are stored in the <code>m_qse_abundance_cache</code>.</li>
<li>A new <code>fourdst::composition::Composition</code> object reflecting the equilibrated state is created and returned.</li>
</ol>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>netIn</code> struct should contain a valid physical state. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The engine is partitioned (<code>m_dynamic_species</code>, <code>m_algebraic_species</code>, etc. are populated). The <code>m_qse_abundance_cache</code> is populated with the QSE solution for the given state. The returned composition reflects the new equilibrium. </dd></dl>

<p>Implements <a class="el" href="classgridfire_1_1_dynamic_engine.html#aa799ff785e7e79bf35b11efd55f6282a">gridfire::DynamicEngine</a>.</p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l00356">356</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<a id="aa55ed182301d216264daae3e6dfd8917" name="aa55ed182301d216264daae3e6dfd8917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55ed182301d216264daae3e6dfd8917">&#9670;&#160;</a></span>validateGroupsWithFluxAnalysis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html">MultiscalePartitioningEngineView::QSEGroup</a> &gt; gridfire::MultiscalePartitioningEngineView::validateGroupsWithFluxAnalysis </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html">QSEGroup</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidate_groups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>T9</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rho</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates candidate QSE groups using flux analysis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidate_groups</td><td>A vector of candidate QSE groups. </td></tr>
    <tr><td class="paramname">Y</td><td>Vector of current molar abundances for the full network. </td></tr>
    <tr><td class="paramname">T9</td><td>Temperature in units of 10^9 K. </td></tr>
    <tr><td class="paramname">rho</td><td>Density in g/cm^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of validated QSE groups that meet the flux criteria.</dd></dl>
<p>@purpose To ensure that a candidate QSE group is truly in equilibrium by checking that the reaction fluxes <em>within</em> the group are much larger than the fluxes <em>leaving</em> the group.</p>
<p>@how For each candidate group, it calculates the sum of all internal reaction fluxes and the sum of all external (bridge) reaction fluxes. If the ratio of internal to external flux exceeds a configurable threshold, the group is considered valid and is added to the returned vector. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8cpp_source.html#l01002">1002</a> of file <a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a445d7447f2cf18f755fc8b8b288e68cb" name="a445d7447f2cf18f755fc8b8b288e68cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445d7447f2cf18f755fc8b8b288e68cb">&#9670;&#160;</a></span>m_activeReactionIndices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; gridfire::MultiscalePartitioningEngineView::m_activeReactionIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indices of all reactions involving only active species. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00943">943</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<a id="a57d97b11e80fa78ab5f509fce1f156b8" name="a57d97b11e80fa78ab5f509fce1f156b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d97b11e80fa78ab5f509fce1f156b8">&#9670;&#160;</a></span>m_activeSpeciesIndices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; gridfire::MultiscalePartitioningEngineView::m_activeSpeciesIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indices of all species considered active in the current partition (dynamic + algebraic). </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00939">939</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<a id="a4656c05b8235dbf4ec698b03a716a8c8" name="a4656c05b8235dbf4ec698b03a716a8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4656c05b8235dbf4ec698b03a716a8c8">&#9670;&#160;</a></span>m_algebraic_species</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;fourdst::atomic::Species&gt; gridfire::MultiscalePartitioningEngineView::m_algebraic_species</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Species that are treated as algebraic (in QSE) in the QSE groups. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00930">930</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<a id="a53862719dd73f98bc69eecde090cf655" name="a53862719dd73f98bc69eecde090cf655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53862719dd73f98bc69eecde090cf655">&#9670;&#160;</a></span>m_algebraic_species_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; gridfire::MultiscalePartitioningEngineView::m_algebraic_species_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indices of algebraic species in the full network. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00934">934</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<a id="a0437c51f94bf834a11adf481b2afad93" name="a0437c51f94bf834a11adf481b2afad93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0437c51f94bf834a11adf481b2afad93">&#9670;&#160;</a></span>m_baseEngine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgridfire_1_1_graph_engine.html">GraphEngine</a>&amp; gridfire::MultiscalePartitioningEngineView::m_baseEngine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The base engine to which this view delegates calculations. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00914">914</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<a id="aa81057b96cf46986151a5e8ef99a017a" name="aa81057b96cf46986151a5e8ef99a017a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81057b96cf46986151a5e8ef99a017a">&#9670;&#160;</a></span>m_cacheStats</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_cache_stats.html">CacheStats</a> gridfire::MultiscalePartitioningEngineView::m_cacheStats</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel mutable">mutable</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Statistics for the QSE abundance cache. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00957">957</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<a id="aec6126b5c4a397d090790d7b75f9f70f" name="aec6126b5c4a397d090790d7b75f9f70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6126b5c4a397d090790d7b75f9f70f">&#9670;&#160;</a></span>m_dynamic_species</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;fourdst::atomic::Species&gt; gridfire::MultiscalePartitioningEngineView::m_dynamic_species</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The simplified set of species presented to the solver (the "slow" species). </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00922">922</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<a id="a38b4f0373c3bd81503889650c0bb69bb" name="a38b4f0373c3bd81503889650c0bb69bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b4f0373c3bd81503889650c0bb69bb">&#9670;&#160;</a></span>m_dynamic_species_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; gridfire::MultiscalePartitioningEngineView::m_dynamic_species_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indices mapping the dynamic species back to the base engine's full species list. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00926">926</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<a id="a7d357c775dcbb253a4001d172805380a" name="a7d357c775dcbb253a4001d172805380a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d357c775dcbb253a4001d172805380a">&#9670;&#160;</a></span>m_logger</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">quill::Logger* gridfire::MultiscalePartitioningEngineView::m_logger = LogManager::getInstance().getLogger(&quot;log&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logger instance for logging messages. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00910">910</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<a id="a707e46d2f72993c206210f81b35b884e" name="a707e46d2f72993c206210f81b35b884e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707e46d2f72993c206210f81b35b884e">&#9670;&#160;</a></span>m_qse_abundance_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="structgridfire_1_1_q_s_e_cache_key.html">QSECacheKey</a>, std::vector&lt;double&gt; &gt; gridfire::MultiscalePartitioningEngineView::m_qse_abundance_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel mutable">mutable</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache for QSE abundances based on T9, rho, and Y. </p>
<p>@purpose This is the core of the caching mechanism. It stores the results of QSE solves to avoid re-computation. The key is a <code><a class="el" href="structgridfire_1_1_q_s_e_cache_key.html" title="Key struct for the QSE abundance cache.">QSECacheKey</a></code> which hashes the thermodynamic state, and the value is the vector of solved molar abundances for the algebraic species. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00953">953</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<a id="a1b4aa04a1e641204e4fd82361b0e39c6" name="a1b4aa04a1e641204e4fd82361b0e39c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4aa04a1e641204e4fd82361b0e39c6">&#9670;&#160;</a></span>m_qse_groups</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structgridfire_1_1_multiscale_partitioning_engine_view_1_1_q_s_e_group.html">QSEGroup</a>&gt; gridfire::MultiscalePartitioningEngineView::m_qse_groups</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of identified equilibrium groups. </p>

<p class="definition">Definition at line <a class="el" href="engine__multiscale_8h_source.html#l00918">918</a> of file <a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/include/gridfire/engine/views/<a class="el" href="engine__multiscale_8h_source.html">engine_multiscale.h</a></li>
<li>src/lib/engine/views/<a class="el" href="engine__multiscale_8cpp_source.html">engine_multiscale.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegridfire.html">gridfire</a></li><li class="navelem"><a class="el" href="classgridfire_1_1_multiscale_partitioning_engine_view.html">MultiscalePartitioningEngineView</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
