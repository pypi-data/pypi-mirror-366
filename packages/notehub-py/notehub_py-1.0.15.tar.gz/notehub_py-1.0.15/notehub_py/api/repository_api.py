# coding: utf-8

"""
Notehub API

The OpenAPI definition for the Notehub.io API.

The version of the OpenAPI document: 1.2.0
Contact: engineering@blues.io
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import Optional, Union
from typing_extensions import Annotated
from notehub_py.models.create_update_repository import CreateUpdateRepository
from notehub_py.models.data_set import DataSet
from notehub_py.models.repository import Repository

from notehub_py.api_client import ApiClient, RequestSerialized
from notehub_py.api_response import ApiResponse
from notehub_py.rest import RESTResponseType


class RepositoryApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def create_repository(
        self,
        create_update_repository: CreateUpdateRepository,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Repository:
        """create_repository

        Create a new repository

        :param create_update_repository: (required)
        :type create_update_repository: CreateUpdateRepository
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_repository_serialize(
            create_update_repository=create_update_repository,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "Repository",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_repository_with_http_info(
        self,
        create_update_repository: CreateUpdateRepository,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Repository]:
        """create_repository

        Create a new repository

        :param create_update_repository: (required)
        :type create_update_repository: CreateUpdateRepository
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_repository_serialize(
            create_update_repository=create_update_repository,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "Repository",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_repository_without_preload_content(
        self,
        create_update_repository: CreateUpdateRepository,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """create_repository

        Create a new repository

        :param create_update_repository: (required)
        :type create_update_repository: CreateUpdateRepository
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_repository_serialize(
            create_update_repository=create_update_repository,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "Repository",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_repository_serialize(
        self,
        create_update_repository,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_update_repository is not None:
            _body_params = create_update_repository

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["api_key"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/repositories",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def create_repository_dataset(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        data_set: DataSet,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataSet:
        """create_repository_dataset

        Create a new dataset within a repository

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param data_set: (required)
        :type data_set: DataSet
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_repository_dataset_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            data_set=data_set,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "DataSet",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_repository_dataset_with_http_info(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        data_set: DataSet,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataSet]:
        """create_repository_dataset

        Create a new dataset within a repository

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param data_set: (required)
        :type data_set: DataSet
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_repository_dataset_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            data_set=data_set,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "DataSet",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_repository_dataset_without_preload_content(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        data_set: DataSet,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """create_repository_dataset

        Create a new dataset within a repository

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param data_set: (required)
        :type data_set: DataSet
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_repository_dataset_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            data_set=data_set,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "DataSet",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_repository_dataset_serialize(
        self,
        repository_uid,
        x_repository_key,
        data_set,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if repository_uid is not None:
            _path_params["repositoryUID"] = repository_uid
        # process the query parameters
        # process the header parameters
        if x_repository_key is not None:
            _header_params["X-Repository-Key"] = x_repository_key
        # process the form parameters
        # process the body parameter
        if data_set is not None:
            _body_params = data_set

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["api_key"]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/v1/repositories/{repositoryUID}/datasets",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def delete_repository(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """delete_repository

        Delete a repository

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_repository_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_repository_with_http_info(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """delete_repository

        Delete a repository

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_repository_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_repository_without_preload_content(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_repository

        Delete a repository

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_repository_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_repository_serialize(
        self,
        repository_uid,
        x_repository_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if repository_uid is not None:
            _path_params["repositoryUID"] = repository_uid
        # process the query parameters
        # process the header parameters
        if x_repository_key is not None:
            _header_params["X-Repository-Key"] = x_repository_key
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["api_key"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v1/repositories/{repositoryUID}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def delete_repository_dataset(
        self,
        repository_uid: StrictStr,
        name: Annotated[StrictStr, Field(description="The name of the data set")],
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """delete_repository_dataset

        Delete a dataset

        :param repository_uid: (required)
        :type repository_uid: str
        :param name: The name of the data set (required)
        :type name: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_repository_dataset_serialize(
            repository_uid=repository_uid,
            name=name,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_repository_dataset_with_http_info(
        self,
        repository_uid: StrictStr,
        name: Annotated[StrictStr, Field(description="The name of the data set")],
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """delete_repository_dataset

        Delete a dataset

        :param repository_uid: (required)
        :type repository_uid: str
        :param name: The name of the data set (required)
        :type name: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_repository_dataset_serialize(
            repository_uid=repository_uid,
            name=name,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_repository_dataset_without_preload_content(
        self,
        repository_uid: StrictStr,
        name: Annotated[StrictStr, Field(description="The name of the data set")],
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_repository_dataset

        Delete a dataset

        :param repository_uid: (required)
        :type repository_uid: str
        :param name: The name of the data set (required)
        :type name: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_repository_dataset_serialize(
            repository_uid=repository_uid,
            name=name,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_repository_dataset_serialize(
        self,
        repository_uid,
        name,
        x_repository_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if repository_uid is not None:
            _path_params["repositoryUID"] = repository_uid
        if name is not None:
            _path_params["name"] = name
        # process the query parameters
        # process the header parameters
        if x_repository_key is not None:
            _header_params["X-Repository-Key"] = x_repository_key
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["api_key"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v1/repositories/{repositoryUID}/datasets/{name}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_repository(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Repository:
        """get_repository

        Get repository information

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repository_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Repository",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_repository_with_http_info(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Repository]:
        """get_repository

        Get repository information

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repository_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Repository",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_repository_without_preload_content(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_repository

        Get repository information

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repository_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Repository",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_repository_serialize(
        self,
        repository_uid,
        x_repository_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if repository_uid is not None:
            _path_params["repositoryUID"] = repository_uid
        # process the query parameters
        # process the header parameters
        if x_repository_key is not None:
            _header_params["X-Repository-Key"] = x_repository_key
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["api_key"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v1/repositories/{repositoryUID}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_repository_data(
        self,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        repository_uid: StrictStr,
        start: Annotated[
            StrictStr,
            Field(
                description="Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format."
            ),
        ],
        end: Annotated[
            Optional[StrictStr],
            Field(
                description="End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """get_repository_data

        Get event and session data from a repository in NDJSON format.

        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param repository_uid: (required)
        :type repository_uid: str
        :param start: Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format. (required)
        :type start: str
        :param end: End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used.
        :type end: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repository_data_serialize(
            x_repository_key=x_repository_key,
            repository_uid=repository_uid,
            start=start,
            end=end,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_repository_data_with_http_info(
        self,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        repository_uid: StrictStr,
        start: Annotated[
            StrictStr,
            Field(
                description="Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format."
            ),
        ],
        end: Annotated[
            Optional[StrictStr],
            Field(
                description="End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """get_repository_data

        Get event and session data from a repository in NDJSON format.

        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param repository_uid: (required)
        :type repository_uid: str
        :param start: Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format. (required)
        :type start: str
        :param end: End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used.
        :type end: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repository_data_serialize(
            x_repository_key=x_repository_key,
            repository_uid=repository_uid,
            start=start,
            end=end,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_repository_data_without_preload_content(
        self,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        repository_uid: StrictStr,
        start: Annotated[
            StrictStr,
            Field(
                description="Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format."
            ),
        ],
        end: Annotated[
            Optional[StrictStr],
            Field(
                description="End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_repository_data

        Get event and session data from a repository in NDJSON format.

        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param repository_uid: (required)
        :type repository_uid: str
        :param start: Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format. (required)
        :type start: str
        :param end: End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used.
        :type end: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repository_data_serialize(
            x_repository_key=x_repository_key,
            repository_uid=repository_uid,
            start=start,
            end=end,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_repository_data_serialize(
        self,
        x_repository_key,
        repository_uid,
        start,
        end,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if repository_uid is not None:
            _path_params["repositoryUID"] = repository_uid
        # process the query parameters
        if start is not None:

            _query_params.append(("start", start))

        if end is not None:

            _query_params.append(("end", end))

        # process the header parameters
        if x_repository_key is not None:
            _header_params["X-Repository-Key"] = x_repository_key
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["text/csv", "application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["api_key"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v1/repositories/{repositoryUID}/data",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_repository_dataset(
        self,
        repository_uid: StrictStr,
        name: Annotated[StrictStr, Field(description="The name of the data set")],
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataSet:
        """get_repository_dataset

        Get the details of a dataset

        :param repository_uid: (required)
        :type repository_uid: str
        :param name: The name of the data set (required)
        :type name: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repository_dataset_serialize(
            repository_uid=repository_uid,
            name=name,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "DataSet",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_repository_dataset_with_http_info(
        self,
        repository_uid: StrictStr,
        name: Annotated[StrictStr, Field(description="The name of the data set")],
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataSet]:
        """get_repository_dataset

        Get the details of a dataset

        :param repository_uid: (required)
        :type repository_uid: str
        :param name: The name of the data set (required)
        :type name: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repository_dataset_serialize(
            repository_uid=repository_uid,
            name=name,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "DataSet",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_repository_dataset_without_preload_content(
        self,
        repository_uid: StrictStr,
        name: Annotated[StrictStr, Field(description="The name of the data set")],
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_repository_dataset

        Get the details of a dataset

        :param repository_uid: (required)
        :type repository_uid: str
        :param name: The name of the data set (required)
        :type name: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repository_dataset_serialize(
            repository_uid=repository_uid,
            name=name,
            x_repository_key=x_repository_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "DataSet",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_repository_dataset_serialize(
        self,
        repository_uid,
        name,
        x_repository_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if repository_uid is not None:
            _path_params["repositoryUID"] = repository_uid
        if name is not None:
            _path_params["name"] = name
        # process the query parameters
        # process the header parameters
        if x_repository_key is not None:
            _header_params["X-Repository-Key"] = x_repository_key
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["api_key"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v1/repositories/{repositoryUID}/datasets/{name}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def put_repository(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        create_update_repository: CreateUpdateRepository,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Repository:
        """put_repository

        Update a repository

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param create_update_repository: (required)
        :type create_update_repository: CreateUpdateRepository
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repository_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            create_update_repository=create_update_repository,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Repository",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def put_repository_with_http_info(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        create_update_repository: CreateUpdateRepository,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Repository]:
        """put_repository

        Update a repository

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param create_update_repository: (required)
        :type create_update_repository: CreateUpdateRepository
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repository_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            create_update_repository=create_update_repository,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Repository",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def put_repository_without_preload_content(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        create_update_repository: CreateUpdateRepository,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_repository

        Update a repository

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param create_update_repository: (required)
        :type create_update_repository: CreateUpdateRepository
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repository_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            create_update_repository=create_update_repository,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Repository",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _put_repository_serialize(
        self,
        repository_uid,
        x_repository_key,
        create_update_repository,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if repository_uid is not None:
            _path_params["repositoryUID"] = repository_uid
        # process the query parameters
        # process the header parameters
        if x_repository_key is not None:
            _header_params["X-Repository-Key"] = x_repository_key
        # process the form parameters
        # process the body parameter
        if create_update_repository is not None:
            _body_params = create_update_repository

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["api_key"]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/v1/repositories/{repositoryUID}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def query_repository_dataset(
        self,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        repository_uid: StrictStr,
        name: Annotated[StrictStr, Field(description="The name of the data set")],
        start: Annotated[
            StrictStr,
            Field(
                description="Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format."
            ),
        ],
        end: Annotated[
            Optional[StrictStr],
            Field(
                description="End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used."
            ),
        ] = None,
        select: Annotated[
            Optional[StrictStr],
            Field(
                description="Comma separated list of fields to include. Supports aggregate functions (avg, sum, min, max, count, most_recent)."
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr],
            Field(
                description="Additional filters using boolean logic mini-language (e.g. and.(device.eq.dev:123,temp.gt.100))"
            ),
        ] = None,
        aggregate_window: Annotated[
            Optional[StrictStr],
            Field(
                description="Aggregate results into buckets for a time duration, expressed in Postgres INTERVAL format"
            ),
        ] = None,
        location_near: Annotated[
            Optional[StrictStr],
            Field(
                description="Latitude and Longitude for location-based filtering, location_near_radius must also be provided"
            ),
        ] = None,
        location_near_radius: Annotated[
            Optional[StrictInt],
            Field(
                description="Distance from location_near in meters, location_near must also be provided"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Limit the number of results returned"),
        ] = None,
        order_by: Annotated[
            Optional[StrictStr], Field(description="Order the results by a field")
        ] = None,
        distinct: Annotated[
            Optional[StrictBool], Field(description="Return only distinct results")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """query_repository_dataset

        Query a dataset with support for time ranges, field selection, filtering, and location-based queries

        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param repository_uid: (required)
        :type repository_uid: str
        :param name: The name of the data set (required)
        :type name: str
        :param start: Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format. (required)
        :type start: str
        :param end: End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used.
        :type end: str
        :param select: Comma separated list of fields to include. Supports aggregate functions (avg, sum, min, max, count, most_recent).
        :type select: str
        :param where: Additional filters using boolean logic mini-language (e.g. and.(device.eq.dev:123,temp.gt.100))
        :type where: str
        :param aggregate_window: Aggregate results into buckets for a time duration, expressed in Postgres INTERVAL format
        :type aggregate_window: str
        :param location_near: Latitude and Longitude for location-based filtering, location_near_radius must also be provided
        :type location_near: str
        :param location_near_radius: Distance from location_near in meters, location_near must also be provided
        :type location_near_radius: int
        :param limit: Limit the number of results returned
        :type limit: int
        :param order_by: Order the results by a field
        :type order_by: str
        :param distinct: Return only distinct results
        :type distinct: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_repository_dataset_serialize(
            x_repository_key=x_repository_key,
            repository_uid=repository_uid,
            name=name,
            start=start,
            end=end,
            select=select,
            where=where,
            aggregate_window=aggregate_window,
            location_near=location_near,
            location_near_radius=location_near_radius,
            limit=limit,
            order_by=order_by,
            distinct=distinct,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_repository_dataset_with_http_info(
        self,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        repository_uid: StrictStr,
        name: Annotated[StrictStr, Field(description="The name of the data set")],
        start: Annotated[
            StrictStr,
            Field(
                description="Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format."
            ),
        ],
        end: Annotated[
            Optional[StrictStr],
            Field(
                description="End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used."
            ),
        ] = None,
        select: Annotated[
            Optional[StrictStr],
            Field(
                description="Comma separated list of fields to include. Supports aggregate functions (avg, sum, min, max, count, most_recent)."
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr],
            Field(
                description="Additional filters using boolean logic mini-language (e.g. and.(device.eq.dev:123,temp.gt.100))"
            ),
        ] = None,
        aggregate_window: Annotated[
            Optional[StrictStr],
            Field(
                description="Aggregate results into buckets for a time duration, expressed in Postgres INTERVAL format"
            ),
        ] = None,
        location_near: Annotated[
            Optional[StrictStr],
            Field(
                description="Latitude and Longitude for location-based filtering, location_near_radius must also be provided"
            ),
        ] = None,
        location_near_radius: Annotated[
            Optional[StrictInt],
            Field(
                description="Distance from location_near in meters, location_near must also be provided"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Limit the number of results returned"),
        ] = None,
        order_by: Annotated[
            Optional[StrictStr], Field(description="Order the results by a field")
        ] = None,
        distinct: Annotated[
            Optional[StrictBool], Field(description="Return only distinct results")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """query_repository_dataset

        Query a dataset with support for time ranges, field selection, filtering, and location-based queries

        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param repository_uid: (required)
        :type repository_uid: str
        :param name: The name of the data set (required)
        :type name: str
        :param start: Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format. (required)
        :type start: str
        :param end: End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used.
        :type end: str
        :param select: Comma separated list of fields to include. Supports aggregate functions (avg, sum, min, max, count, most_recent).
        :type select: str
        :param where: Additional filters using boolean logic mini-language (e.g. and.(device.eq.dev:123,temp.gt.100))
        :type where: str
        :param aggregate_window: Aggregate results into buckets for a time duration, expressed in Postgres INTERVAL format
        :type aggregate_window: str
        :param location_near: Latitude and Longitude for location-based filtering, location_near_radius must also be provided
        :type location_near: str
        :param location_near_radius: Distance from location_near in meters, location_near must also be provided
        :type location_near_radius: int
        :param limit: Limit the number of results returned
        :type limit: int
        :param order_by: Order the results by a field
        :type order_by: str
        :param distinct: Return only distinct results
        :type distinct: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_repository_dataset_serialize(
            x_repository_key=x_repository_key,
            repository_uid=repository_uid,
            name=name,
            start=start,
            end=end,
            select=select,
            where=where,
            aggregate_window=aggregate_window,
            location_near=location_near,
            location_near_radius=location_near_radius,
            limit=limit,
            order_by=order_by,
            distinct=distinct,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_repository_dataset_without_preload_content(
        self,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        repository_uid: StrictStr,
        name: Annotated[StrictStr, Field(description="The name of the data set")],
        start: Annotated[
            StrictStr,
            Field(
                description="Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format."
            ),
        ],
        end: Annotated[
            Optional[StrictStr],
            Field(
                description="End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used."
            ),
        ] = None,
        select: Annotated[
            Optional[StrictStr],
            Field(
                description="Comma separated list of fields to include. Supports aggregate functions (avg, sum, min, max, count, most_recent)."
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr],
            Field(
                description="Additional filters using boolean logic mini-language (e.g. and.(device.eq.dev:123,temp.gt.100))"
            ),
        ] = None,
        aggregate_window: Annotated[
            Optional[StrictStr],
            Field(
                description="Aggregate results into buckets for a time duration, expressed in Postgres INTERVAL format"
            ),
        ] = None,
        location_near: Annotated[
            Optional[StrictStr],
            Field(
                description="Latitude and Longitude for location-based filtering, location_near_radius must also be provided"
            ),
        ] = None,
        location_near_radius: Annotated[
            Optional[StrictInt],
            Field(
                description="Distance from location_near in meters, location_near must also be provided"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Limit the number of results returned"),
        ] = None,
        order_by: Annotated[
            Optional[StrictStr], Field(description="Order the results by a field")
        ] = None,
        distinct: Annotated[
            Optional[StrictBool], Field(description="Return only distinct results")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """query_repository_dataset

        Query a dataset with support for time ranges, field selection, filtering, and location-based queries

        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param repository_uid: (required)
        :type repository_uid: str
        :param name: The name of the data set (required)
        :type name: str
        :param start: Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format. (required)
        :type start: str
        :param end: End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used.
        :type end: str
        :param select: Comma separated list of fields to include. Supports aggregate functions (avg, sum, min, max, count, most_recent).
        :type select: str
        :param where: Additional filters using boolean logic mini-language (e.g. and.(device.eq.dev:123,temp.gt.100))
        :type where: str
        :param aggregate_window: Aggregate results into buckets for a time duration, expressed in Postgres INTERVAL format
        :type aggregate_window: str
        :param location_near: Latitude and Longitude for location-based filtering, location_near_radius must also be provided
        :type location_near: str
        :param location_near_radius: Distance from location_near in meters, location_near must also be provided
        :type location_near_radius: int
        :param limit: Limit the number of results returned
        :type limit: int
        :param order_by: Order the results by a field
        :type order_by: str
        :param distinct: Return only distinct results
        :type distinct: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_repository_dataset_serialize(
            x_repository_key=x_repository_key,
            repository_uid=repository_uid,
            name=name,
            start=start,
            end=end,
            select=select,
            where=where,
            aggregate_window=aggregate_window,
            location_near=location_near,
            location_near_radius=location_near_radius,
            limit=limit,
            order_by=order_by,
            distinct=distinct,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _query_repository_dataset_serialize(
        self,
        x_repository_key,
        repository_uid,
        name,
        start,
        end,
        select,
        where,
        aggregate_window,
        location_near,
        location_near_radius,
        limit,
        order_by,
        distinct,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if repository_uid is not None:
            _path_params["repositoryUID"] = repository_uid
        if name is not None:
            _path_params["name"] = name
        # process the query parameters
        if start is not None:

            _query_params.append(("start", start))

        if end is not None:

            _query_params.append(("end", end))

        if select is not None:

            _query_params.append(("select", select))

        if where is not None:

            _query_params.append(("where", where))

        if aggregate_window is not None:

            _query_params.append(("aggregate_window", aggregate_window))

        if location_near is not None:

            _query_params.append(("location_near", location_near))

        if location_near_radius is not None:

            _query_params.append(("location_near_radius", location_near_radius))

        if limit is not None:

            _query_params.append(("limit", limit))

        if order_by is not None:

            _query_params.append(("order_by", order_by))

        if distinct is not None:

            _query_params.append(("distinct", distinct))

        # process the header parameters
        if x_repository_key is not None:
            _header_params["X-Repository-Key"] = x_repository_key
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["text/csv", "application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["api_key"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v1/repositories/{repositoryUID}/datasets/{name}/query",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def query_repository_sql(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        body: Annotated[
            StrictStr, Field(description="Clickhouse-compatible SQL statement")
        ],
        x_click_house_format: Annotated[
            Optional[StrictStr],
            Field(
                description="Specify the format of the response data. This functions the same as the ClickHouse `FORMAT` clause. Supported values include `CSV`, `JSON`, `JSONEachRow`, `TabSeparated`, and `NDJSON`. If not specified, defaults to `TabSeparated`."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """query_repository_sql

        Run a raw Clickhouse-compatible SQL statement against the repository's database. Results are returned in CSV format

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param body: Clickhouse-compatible SQL statement (required)
        :type body: str
        :param x_click_house_format: Specify the format of the response data. This functions the same as the ClickHouse `FORMAT` clause. Supported values include `CSV`, `JSON`, `JSONEachRow`, `TabSeparated`, and `NDJSON`. If not specified, defaults to `TabSeparated`.
        :type x_click_house_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_repository_sql_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            body=body,
            x_click_house_format=x_click_house_format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_repository_sql_with_http_info(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        body: Annotated[
            StrictStr, Field(description="Clickhouse-compatible SQL statement")
        ],
        x_click_house_format: Annotated[
            Optional[StrictStr],
            Field(
                description="Specify the format of the response data. This functions the same as the ClickHouse `FORMAT` clause. Supported values include `CSV`, `JSON`, `JSONEachRow`, `TabSeparated`, and `NDJSON`. If not specified, defaults to `TabSeparated`."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """query_repository_sql

        Run a raw Clickhouse-compatible SQL statement against the repository's database. Results are returned in CSV format

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param body: Clickhouse-compatible SQL statement (required)
        :type body: str
        :param x_click_house_format: Specify the format of the response data. This functions the same as the ClickHouse `FORMAT` clause. Supported values include `CSV`, `JSON`, `JSONEachRow`, `TabSeparated`, and `NDJSON`. If not specified, defaults to `TabSeparated`.
        :type x_click_house_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_repository_sql_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            body=body,
            x_click_house_format=x_click_house_format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_repository_sql_without_preload_content(
        self,
        repository_uid: StrictStr,
        x_repository_key: Annotated[
            StrictStr,
            Field(description="The secret key used to access this repository"),
        ],
        body: Annotated[
            StrictStr, Field(description="Clickhouse-compatible SQL statement")
        ],
        x_click_house_format: Annotated[
            Optional[StrictStr],
            Field(
                description="Specify the format of the response data. This functions the same as the ClickHouse `FORMAT` clause. Supported values include `CSV`, `JSON`, `JSONEachRow`, `TabSeparated`, and `NDJSON`. If not specified, defaults to `TabSeparated`."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """query_repository_sql

        Run a raw Clickhouse-compatible SQL statement against the repository's database. Results are returned in CSV format

        :param repository_uid: (required)
        :type repository_uid: str
        :param x_repository_key: The secret key used to access this repository (required)
        :type x_repository_key: str
        :param body: Clickhouse-compatible SQL statement (required)
        :type body: str
        :param x_click_house_format: Specify the format of the response data. This functions the same as the ClickHouse `FORMAT` clause. Supported values include `CSV`, `JSON`, `JSONEachRow`, `TabSeparated`, and `NDJSON`. If not specified, defaults to `TabSeparated`.
        :type x_click_house_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_repository_sql_serialize(
            repository_uid=repository_uid,
            x_repository_key=x_repository_key,
            body=body,
            x_click_house_format=x_click_house_format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _query_repository_sql_serialize(
        self,
        repository_uid,
        x_repository_key,
        body,
        x_click_house_format,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if repository_uid is not None:
            _path_params["repositoryUID"] = repository_uid
        # process the query parameters
        # process the header parameters
        if x_repository_key is not None:
            _header_params["X-Repository-Key"] = x_repository_key
        if x_click_house_format is not None:
            _header_params["X-ClickHouse-Format"] = x_click_house_format
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["text/plain", "application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["text/plain"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["api_key"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/repositories/{repositoryUID}/sql",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
