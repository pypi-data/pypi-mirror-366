"""
Implementation of the `pakto generate` command with Jinja2 templating support.

This module implements the CLI command for generating lock files from manifest files,
focusing on simple local file-to-file copy operations with templating capability.
"""

import asyncio
from pathlib import Path
from typing import Optional, Tuple

import click

from ..cli.progress import ProgressDisplay, create_progress_callback
from ..services.lock import LockService


class LockError(Exception):
    """Exception raised during the generate process."""

    pass


@click.command(hidden=True)
@click.argument(
    "manifest_file", type=click.Path(exists=True, dir_okay=False, readable=True)
)
@click.option(
    "--output",
    "-o",
    type=click.Path(),
    help="Output lockfile path (default: auto-generated)",
)
@click.option(
    "--var",
    "-v",
    multiple=True,
    help="Template variable in key=value format (can be used multiple times)",
)
@click.option(
    "--no-progress",
    is_flag=True,
    default=False,
    help="Disable progress display for HTTP downloads",
)
@click.pass_context
def lock(
    ctx,
    manifest_file: str,
    output: Optional[str] = None,
    var: Tuple[str, ...] = (),
    no_progress: bool = False,
):
    """
    Generate a lock file from a manifest file with optional Jinja2 templating.

    MANIFEST_FILE is the path to the Pakto manifest YAML file.

    Variables can be defined in the manifest under a 'variables' section and/or
    provided via CLI options. CLI variables override manifest variables.

    Examples:

        pakto bundle lock manifest.yaml
        pakto bundle lock manifest.yaml --var env=prod --var version=1.2.3
        pakto bundle lock manifest.yaml --no-progress  # Disable download progress
    """
    # Get config service from context
    # Output path is determined by CLI argument or auto-generated by LockService
    if not output:
        output_path_object = Path.cwd() / "output"
        output_path_object.mkdir(parents=True, exist_ok=True)
        output = str(output_path_object)

    async def async_lock():
        service = LockService()

        # Setup progress display unless disabled
        progress_callback = None
        display = None  # Initialize display to None
        if not no_progress:
            display = ProgressDisplay()
            progress_callback = create_progress_callback(display)
            display.start()

        try:
            # Use async generation for concurrent downloads and progress
            lockfile_path, lockfile = await service.generate_lockfile_async(
                manifest_file,
                cli_variables=var,
                output_path=output,
                progress_callback=progress_callback,
            )

            # Stop progress display before printing results
            if (
                display and display.progress
            ):  # Check if display was initialized and started
                display.stop()

            if service.parsed_cli_variables:
                click.echo(
                    f"Using template variables: {', '.join(f'{k}={v}' for k, v in service.parsed_cli_variables.items())}"
                )

            click.echo(f"✓ Loaded manifest from: {manifest_file}")
            click.echo(f"✓ Lock file generated: {lockfile_path}")
            click.echo(f"  - {len(lockfile.artifacts)} artifact(s) processed")

        finally:
            # Ensure display is stopped even on error
            if (
                display and display.progress
            ):  # Check if display was initialized and started
                display.stop()

    try:
        asyncio.run(async_lock())

    except LockError as e:
        click.echo(f"Error: {e}", err=True)
        raise click.Abort() from e
    except Exception as e:
        click.echo(f"Unexpected error: {e}", err=True)
        raise click.Abort() from e
