Metadata-Version: 2.3
Name: modapi
Version: 0.2.1
Summary: Unified API for Modbus communication with support for RTU, TCP, and REST APIs
License: Apache-2.0
Author: Tom Sapletta
Author-email: info@softreck.dev
Requires-Python: >=3.10,<4.0
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: System :: Hardware :: Hardware Drivers
Requires-Dist: flask (>=2.3.3,<3.0.0)
Requires-Dist: paho-mqtt (>=2.0.0,<3.0.0)
Requires-Dist: pyserial (>=3.5,<4.0)
Requires-Dist: python-dotenv (>=1.0.0,<2.0.0)
Requires-Dist: requests (>=2.31.0,<3.0.0)
Description-Content-Type: text/markdown

# modapi

üöÄ **Direct Modbus RTU Communication API** - Bezpo≈õrednia komunikacja z urzƒÖdzeniami Modbus przez port szeregowy.

## ‚ú® Kluczowe cechy

- **üîß Direct RTU Module** - Bezpo≈õrednia komunikacja Modbus RTU bez PyModbus
- **üì° Verified Hardware Support** - Przetestowane z rzeczywistym sprzƒôtem `/dev/ttyACM0`
- **üîç Smart Auto-detection** - Automatyczne wykrywanie dzia≈ÇajƒÖcych urzƒÖdze≈Ñ i konfiguracji
- **üåê Web Interface** - Nowoczesny interfejs web do sterowania cewkami
- **üí™ Enhanced CRC Handling** - Zaawansowana obs≈Çuga CRC dla urzƒÖdze≈Ñ Waveshare
- **üîÑ Robust Error Recovery** - Inteligentne odzyskiwanie po b≈Çƒôdach komunikacji
- **‚ö° Multiple APIs**:
  - **REST API** - HTTP API dla aplikacji web
  - **Direct RTU** - Bezpo≈õrednia komunikacja szeregowa
  - **Shell CLI** - Interfejs linii polece≈Ñ
- **üß™ Fully Tested** - Kompletne testy jednostkowe i integracyjne
- **üìã Production Ready** - Gotowe do u≈ºycia produkcyjnego

## üÜö Dlaczego nowa wersja?

| Aspekt | Stara wersja (PyModbus) | **Nowa wersja (RTU)** |
|--------|-------------------------|----------------------|
| **Komunikacja z sprzƒôtem** | ‚ùå Nie dzia≈Ça≈Ça | ‚úÖ **Dzia≈Ça niezawodnie** |
| **Auto-detekcja** | ‚ùå Zwraca≈Ça b≈Çƒôdy | ‚úÖ **Znajduje urzƒÖdzenia** |
| **Odczyt/zapis cewek** | ‚ùå B≈Çƒôdy komunikacji | ‚úÖ **100% sprawne** |
| **Obs≈Çuga CRC** | ‚ùå Tylko standardowa | ‚úÖ **Zaawansowana dla Waveshare** |
| **Odporno≈õƒá na b≈Çƒôdy** | ‚ùå Niska | ‚úÖ **Wysoka z auto-korektƒÖ** |
| **Logowanie** | ‚ùå Niejasne b≈Çƒôdy | ‚úÖ **Szczeg√≥≈Çowe logi** |
| **Testy** | ‚ùå Zawodne | ‚úÖ **Wszystkie przechodzƒÖ** |
| **Dokumentacja** | ‚ùå Nieaktualna | ‚úÖ **Kompletna + przyk≈Çady** |

## üîß Szybki start

### Wymagania
- Python 3.8+
- UrzƒÖdzenie Modbus RTU pod≈ÇƒÖczone do `/dev/ttyACM0` lub `/dev/ttyUSB0`
- Uprawnienia do port√≥w szeregowych (dodaj u≈ºytkownika do grupy `dialout`)

### Instalacja

```bash
# Sklonuj repozytorium
git clone https://github.com/yourusername/modapi.git
cd modapi

# Utw√≥rz ≈õrodowisko wirtualne
python -m venv venv
source venv/bin/activate  # Linux/Mac
# lub: venv\Scripts\activate  # Windows

# Zainstaluj zale≈ºno≈õci
pip install -r requirements.txt
# lub u≈ºyj Poetry:
poetry install && poetry shell
```

### ‚ö° Natychmiastowe uruchomienie

**1. Test komunikacji RTU:**
```bash
python -c "from api.rtu import ModbusRTU; client = ModbusRTU(); print('Config:', client.auto_detect())"
```

**2. Uruchom serwer web:**
```bash
python run_rtu_output.py
# Otw√≥rz http://localhost:5005 w przeglƒÖdarce
```

**3. Przyk≈Çady u≈ºycia:**
```bash
python examples/rtu_usage.py
```

## üß™ Development i testowanie

### Uruchom testy
```bash
# Wszystkie testy RTU
python -m pytest tests/test_rtu.py -v

# Z pokryciem kodu
python -m pytest tests/test_rtu.py --cov=api.rtu

# Test z rzeczywistym sprzƒôtem (opcjonalny)
python -c "from tests.test_rtu import TestIntegration; TestIntegration().test_real_hardware_connection()"
```

### Debugowanie komunikacji
```bash
# Szczeg√≥≈Çowe logi komunikacji
python -c "
import logging
logging.basicConfig(level=logging.DEBUG)
from api.rtu import ModbusRTU
client = ModbusRTU()
config = client.auto_detect()
print('Debug config:', config)
"
```

### Budowanie i publikacja
```bash
# Budowa pakietu
poetry build

# Publikacja do PyPI
poetry publish --build
```

## üîç Troubleshooting

### Problem: Nie mo≈ºna znale≈∫ƒá urzƒÖdzenia
```bash
# Sprawd≈∫ dostƒôpne porty szeregowe
ls -la /dev/tty{ACM,USB}*

# Sprawd≈∫ uprawnienia (dodaj u≈ºytkownika do grupy dialout)
sudo usermod -a -G dialout $USER
# Wyloguj siƒô i zaloguj ponownie

# Test rƒôczny z r√≥≈ºnymi prƒôdko≈õciami
python -c "
from api.rtu import ModbusRTU
for baud in [9600, 19200, 38400]:
    client = ModbusRTU('/dev/ttyACM0', baud)
    if client.connect():
        success, result = client.test_connection(1)
        print(f'{baud} baud: {success} - {result}')
        client.disconnect()
"
```

### Problem: B≈Çƒôdy komunikacji i CRC
```bash
# Sprawd≈∫ parametry szeregowe urzƒÖdzenia w dokumentacji
# Typowe ustawienia: 8N1 (8 bit√≥w danych, bez parzysto≈õci, 1 bit stopu)
# Mo≈ºe wymagaƒá innych ustawie≈Ñ: 8E1, 8O1, itp.

# W≈ÇƒÖcz szczeg√≥≈Çowe logowanie dla debugowania CRC
python -c "
import logging
logging.basicConfig(level=logging.DEBUG)
from api.rtu import ModbusRTU
client = ModbusRTU('/dev/ttyACM0')
client.connect()
# Dla urzƒÖdze≈Ñ Waveshare - modu≈Ç automatycznie obs≈Çuguje alternatywne CRC
result = client.read_coils(1, 0, 8)
print(f'Odczyt cewek z obs≈ÇugƒÖ alternatywnego CRC: {result}')
client.disconnect()
"
```

### Problem: UrzƒÖdzenia Waveshare zwracajƒÖ b≈Çƒôdy funkcji
```bash
# Modu≈Ç RTU zawiera specjalnƒÖ obs≈Çugƒô dla urzƒÖdze≈Ñ Waveshare
# Automatycznie obs≈Çuguje:
# - Alternatywne obliczenia CRC
# - Niezgodno≈õci ID jednostki (broadcast, exception responses)
# - Mapowanie kod√≥w funkcji
# - Szczeg√≥≈Çowe komunikaty b≈Çƒôd√≥w dla wyjƒÖtk√≥w Modbus

# Test z w≈ÇƒÖczonym debugowaniem
python -c "
import logging
logging.basicConfig(level=logging.DEBUG)
from api.rtu import ModbusRTU
client = ModbusRTU('/dev/ttyACM0')
client.connect()
# Pr√≥ba odczytu rejestr√≥w wej≈õciowych (mo≈ºe zwr√≥ciƒá wyjƒÖtek na niekt√≥rych urzƒÖdzeniach)
result = client.read_input_registers(1, 0, 4)
print(f'Wynik z obs≈ÇugƒÖ wyjƒÖtk√≥w Waveshare: {result}')
client.disconnect()
"
```

   The simulator will start with these test values:
   - Coils 0-3: `[1, 0, 1, 0]`
   - Holding Registers 0-2: `[1234, 5678, 9012]`

4. Configure your `.env` file to use the virtual port:
   ```ini
   MODBUS_PORT=/tmp/ttyp0
   MODBUS_BAUDRATE=9600
   MODBUS_TIMEOUT=0.1
   ```

5. You can now run the API server or CLI commands to interact with the simulator.

## Usage

### Command Line Interface

The modapi CLI supports multiple subcommands:

```bash
# Direct command execution
modapi cmd wc 0 1       # Write value 1 to coil at address 0
modapi cmd rc 0 8       # Read 8 coils starting at address 0
modapi cmd rh 0 5       # Read 5 holding registers starting at address 0
modapi cmd wh 0 42      # Write value 42 to holding register at address 0

# Interactive shell
modapi shell

# REST API server
modapi rest --host 0.0.0.0 --port 5005

# MQTT client
modapi mqtt --broker localhost --port 1883

# Scan for Modbus devices
modapi scan

# With options
modapi cmd --verbose rc 0 8    # Verbose mode
modapi cmd --modbus-port /dev/ttyACM0 wc 0 1  # Specify port
```

For backward compatibility, you can also use the direct command format:
```bash
# These are automatically converted to the new format
./run_cli.py wc 0 1       # Equivalent to: modapi cmd wc 0 1
./run_cli.py rc 0 8       # Equivalent to: modapi cmd rc 0 8
```

### REST API

```python
from modapi.api.rest import create_rest_app

# Create and run Flask app
app = create_rest_app(port='/dev/ttyACM0', api_port=5005)
```

### üåê REST API Server

```bash
# Uruchom serwer RTU
python run_rtu_output.py

# API endpoints:
# GET  /status              - status po≈ÇƒÖczenia RTU
# GET  /coil/<address>      - odczyt cewki
# POST /coil/<address>      - zapis cewki (JSON: {"state": true})
# GET  /coils               - odczyt wszystkich cewek 0-15
# GET  /registers/<address> - odczyt rejestru
```

### üìÅ Przyk≈Çady curl

```bash
# Sprawd≈∫ status
curl http://localhost:5005/status

# Odczytaj cewkƒô 0
curl http://localhost:5005/coil/0

# Ustaw cewkƒô 0 na TRUE
curl -X POST http://localhost:5005/coil/0 \
     -H "Content-Type: application/json" \
     -d '{"state": true}'

# Odczytaj wszystkie cewki
curl http://localhost:5005/coils
```

### üîß Zaawansowane u≈ºycie

```python
from api.rtu import ModbusRTU
import time

# Niestandardowa konfiguracja
client = ModbusRTU(
    port='/dev/ttyACM0',
    baudrate=19200,
    timeout=2.0,
    parity='E',  # Even parity
    stopbits=1
)

if client.connect():
    # Monitorowanie zmian cewek
    previous_states = None
    
    for _ in range(10):  # Monitoruj przez 10 iteracji
        current_states = client.read_coils(1, 0, 4)
        
        if current_states and current_states != previous_states:
            print(f"{time.strftime('%H:%M:%S')} - Zmiana: {current_states}")
            previous_states = current_states
            
        time.sleep(1)
    
    client.disconnect()
```

### MQTT API

```python
from modapi.api.mqtt import start_mqtt_broker

# Start MQTT client
start_mqtt_broker(
    port='/dev/ttyACM0',
    broker='localhost',
    mqtt_port=1883,
    topic_prefix='modbus'
)
```

#### MQTT Topics

- Subscribe to `modbus/command/#` to send commands
- Subscribe to `modbus/request/#` to send requests
- Publish to `modbus/command/write_coil` with payload `{"address": 0, "value": true}` to write to a coil
- Publish to `modbus/request/read_coils` with payload `{"address": 0, "count": 8}` to read coils
- Results are published to `modbus/result/<command>` and `modbus/response/<request>`

### Direct API Usage

```python
from modapi.api.cmd import execute_command
from modapi.api.shell import interactive_mode

# Execute a command directly
success, response = execute_command('wc', ['0', '1'], port='/dev/ttyACM0')
print(response)

# Start interactive mode
interactive_mode(port='/dev/ttyACM0', verbose=True)
```

## Project Structure

```
modapi/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py    # Exports main API functions
‚îÇ   ‚îú‚îÄ‚îÄ cmd.py         # Direct command execution
‚îÇ   ‚îú‚îÄ‚îÄ mqtt.py        # MQTT broker client
‚îÇ   ‚îú‚îÄ‚îÄ rest.py        # REST API Flask app
‚îÇ   ‚îî‚îÄ‚îÄ shell.py       # Interactive shell
‚îú‚îÄ‚îÄ client.py          # Modbus client implementation
‚îú‚îÄ‚îÄ __main__.py        # CLI entry point
‚îî‚îÄ‚îÄ ...
```



## Output Modu≈Ç [output.py]

Modu≈Ç [output](modapi/output.py:296:4-332:54) odpowiada za wizualizacjƒô i przetwarzanie stan√≥w wyj≈õƒá cyfrowych (cewek) w systemie Modbus. Zapewnia funkcje do parsowania i wy≈õwietlania stan√≥w wyj≈õƒá w formie interaktywnego wid≈ºetu SVG.


### [parse_coil_status(text: str) -> Tuple[Optional[int], Optional[bool]]](modapi/output.py:18:0-33:21)
**Opis**:  
Parsuje wiadomo≈õƒá o stanie cewki i zwraca jej adres oraz status.

**Parametry**:
- `text` - Tekst wiadomo≈õci (np. 'Coil 0 set to ON' lub 'Coil 5 set to OFF')

**Zwraca**:
- Krotkƒô zawierajƒÖcƒÖ:
  - `address` (int) - Adres cewki
  - [status](modapi/output.py:18:0-33:21) (bool) - Stan cewki (True = W≈ÅƒÑCZONA, False = WY≈ÅƒÑCZONA)

- [(None, None)](modapi/output.py:403:4-405:54) w przypadku b≈Çƒôdu parsowania

**Przyk≈Çad u≈ºycia**:
```python
address, status = parse_coil_status("Coil 3 set to ON")
# address = 3, status = True



## License

This project is licensed under the Apache 2.0 License - see the LICENSE file for details.

