# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: control/control.proto, debug/debug.proto, infrastructure/finish-line.proto, outputs/battery.proto, outputs/camera.proto, outputs/controller.proto, outputs/distance.proto, outputs/energy.proto, outputs/generic.proto, outputs/imu.proto, outputs/laptime.proto, outputs/lidar.proto, outputs/lux.proto, outputs/rpm.proto, outputs/speed.proto, outputs/wrapper.proto, segmentation/segmentation.proto, simulator/simulator.proto, tuning/tuning.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


class DetectedObjects(betterproto.Enum):
    """Possible Objects the Imaging Service may detect"""

    FINISH_LINE = 0
    OFF_TRACK = 1
    OBSTACLE = 2
    INTERSECTION = 3
    MISSING_LEFT_LANE = 4
    MISSING_RIGHT_LANE = 5
    SHARP_RIGHT = 6
    SHARP_LEFT = 7
    U_TURN = 8
    S_TURN = 9


class SimStatus(betterproto.Enum):
    """Possible Sim Requests. Useful for interfaces with Gym"""

    SIM_PAUSED = 0
    SIM_REQ_STEP = 1
    SIM_REQ_RESET = 2


@dataclass
class ConnectionState(betterproto.Message):
    """Tell a client if a given client/rover is connected or not"""

    client: str = betterproto.string_field(1)
    connected: bool = betterproto.bool_field(2)
    timestamp_offset: int = betterproto.int64_field(3)


@dataclass
class ControlError(betterproto.Message):
    message: str = betterproto.string_field(1)
    timestamp: int = betterproto.int64_field(2)


@dataclass
class ServiceIdentifier(betterproto.Message):
    """Used to identify a service within the pipeline"""

    name: str = betterproto.string_field(1)
    pid: int = betterproto.int32_field(2)


@dataclass
class ServiceEndpoint(betterproto.Message):
    """An endpoint that is made available by a service"""

    name: str = betterproto.string_field(1)
    address: str = betterproto.string_field(2)


@dataclass
class DebugOutput(betterproto.Message):
    """
    When the transceivers picks up a SensorOutput from a service, it will wrap
    it in a ServiceMessage message, so that the receiver can determine from
    which process the message originated
    """

    service: "ServiceIdentifier" = betterproto.message_field(1)
    endpoint: "ServiceEndpoint" = betterproto.message_field(2)
    sent_at: int = betterproto.int64_field(4)
    message: bytes = betterproto.bytes_field(3)


@dataclass
class FinishLineEvent(betterproto.Message):
    timestamp: int = betterproto.uint64_field(1)


@dataclass
class BatterySensorOutput(betterproto.Message):
    """
    This is the message format that a battery service can send out. It contains
    information about the battery's current state.
    """

    current_output_voltage: float = betterproto.float_field(1)
    warn_voltage: float = betterproto.float_field(2)
    kill_voltage: float = betterproto.float_field(3)


@dataclass
class CameraSensorOutput(betterproto.Message):
    """
    This is the message format that a camera-like service can send out. For
    example, the official ASE imaging service uses this output format. This can
    then be used by (for example) a controller, to determine how to steer, to
    stay on the track, or to detect obstacles, intersections, etc.
    """

    # Basic information, contains everything you need to know to steer and
    # compute the middle of the track
    resolution: "Resolution" = betterproto.message_field(1)
    horizontal_scans: List["HorizontalScan"] = betterproto.message_field(2)
    detected_objects: List["DetectedObjects"] = betterproto.enum_field(3)
    # Additional information that can be used to debug the image processing if
    # present, it is rendered in roverctl-web
    debug_frame: "DebugFrame" = betterproto.message_field(4)


@dataclass
class Resolution(betterproto.Message):
    width: int = betterproto.uint32_field(1)
    height: int = betterproto.uint32_field(2)


@dataclass
class HorizontalScan(betterproto.Message):
    x_left: int = betterproto.uint32_field(1)
    x_right: int = betterproto.uint32_field(2)
    y: int = betterproto.uint32_field(3)


@dataclass
class DebugFrame(betterproto.Message):
    # (Compressed) JPEG image of the camera output, useful for debugging just
    # JPEG bytes, that will be rendered in roverctl-web
    jpeg: bytes = betterproto.bytes_field(1)
    # A "canvas" that you can "draw" on, for example by placing points, these are
    # also rendered in roverctl-web
    canvas: "Canvas" = betterproto.message_field(5)


@dataclass
class CanvasObject(betterproto.Message):
    circle: "CanvasObjectCircle" = betterproto.message_field(1, group="object")


@dataclass
class CanvasObjectPoint(betterproto.Message):
    x: int = betterproto.uint32_field(1)
    y: int = betterproto.uint32_field(2)


@dataclass
class CanvasObjectCircle(betterproto.Message):
    center: "CanvasObjectPoint" = betterproto.message_field(1)
    radius: int = betterproto.uint32_field(2)
    width: int = betterproto.uint32_field(3)


@dataclass
class Canvas(betterproto.Message):
    # The width and height are a legacy feature, they should be the same as the
    # resolution of the camera
    width: int = betterproto.uint32_field(1)
    height: int = betterproto.uint32_field(2)
    objects: List["CanvasObject"] = betterproto.message_field(3)


@dataclass
class ControllerOutput(betterproto.Message):
    # Steering angle (-1.0 to 1.0 <-> left - right)
    steering_angle: float = betterproto.float_field(2)
    # Throttle (-1.0 to 1.0 <-> full reverse - full forward)
    left_throttle: float = betterproto.float_field(3)
    right_throttle: float = betterproto.float_field(4)
    # Onboard lights (0.0 to 1.0 <-> off - on)
    front_lights: bool = betterproto.bool_field(5)
    # Fan speed (0.0 to 1.0 <-> off - full speed)
    fan_speed: float = betterproto.float_field(6)
    # Useful for debugging
    raw_error: float = betterproto.float_field(7)
    scaled_error: float = betterproto.float_field(8)


@dataclass
class DistanceSensorOutput(betterproto.Message):
    # distance in meters
    distance: float = betterproto.float_field(1)


@dataclass
class EnergySensorOutput(betterproto.Message):
    # The measure supply voltage measured in volts (V).
    supply_voltage: float = betterproto.float_field(1)
    # The current amp draw in amperes (A) of the power supply source.
    current_amps: float = betterproto.float_field(2)
    # The current power output of the Rover measured in watts (W).
    power_watts: float = betterproto.float_field(3)


@dataclass
class GenericIntScalar(betterproto.Message):
    """
    This message holds a single integer value, it will be plotted in the debug
    view of roverctl
    """

    key: str = betterproto.string_field(1)
    value: int = betterproto.int32_field(2)


@dataclass
class GenericFloatScalar(betterproto.Message):
    """
    This message holds a single float value, it will be plotted in the debug
    view of roverctl
    """

    key: str = betterproto.string_field(1)
    value: float = betterproto.float_field(2)


@dataclass
class GenericBoolScalar(betterproto.Message):
    """
    This message holds a single boolean value, it will *NOT* be plotted in the
    debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    value: bool = betterproto.bool_field(2)


@dataclass
class GenericStringScalar(betterproto.Message):
    """
    This message holds a single string value, it will *NOT* be plotted in the
    debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)


@dataclass
class GenericIntArray(betterproto.Message):
    """
    This message holds an array of integer values, it will *NOT* be plotted in
    the debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    values: List[int] = betterproto.int32_field(2)


@dataclass
class GenericFloatArray(betterproto.Message):
    """
    This message holds an array of float values, it will *NOT* be plotted in
    the debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    values: List[float] = betterproto.float_field(2)


@dataclass
class GenericBoolArray(betterproto.Message):
    """
    This message holds an array of boolean values, it will *NOT* be plotted in
    the debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    values: List[bool] = betterproto.bool_field(2)


@dataclass
class GenericStringArray(betterproto.Message):
    """
    This message holds an array of string values, it will *NOT* be plotted in
    the debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    values: List[str] = betterproto.string_field(2)


@dataclass
class ImuSensorOutput(betterproto.Message):
    temperature: int = betterproto.int32_field(1)
    magnetometer: "ImuSensorOutputVector" = betterproto.message_field(2)
    gyroscope: "ImuSensorOutputVector" = betterproto.message_field(3)
    euler: "ImuSensorOutputVector" = betterproto.message_field(4)
    accelerometer: "ImuSensorOutputVector" = betterproto.message_field(5)
    linear_accelerometer: "ImuSensorOutputVector" = betterproto.message_field(6)
    velocity: "ImuSensorOutputVector" = betterproto.message_field(7)
    speed: float = betterproto.float_field(8)


@dataclass
class ImuSensorOutputVector(betterproto.Message):
    x: float = betterproto.float_field(1)
    y: float = betterproto.float_field(2)
    z: float = betterproto.float_field(3)


@dataclass
class LapTimeOutput(betterproto.Message):
    lap_time: int = betterproto.uint64_field(1)
    lap_start_time: int = betterproto.uint64_field(2)


@dataclass
class LidarSensorOutput(betterproto.Message):
    # Many (but not necessarily all) scans in a single rotation
    scans: List["LidarSensorOutputScan"] = betterproto.message_field(1)


@dataclass
class LidarSensorOutputScan(betterproto.Message):
    """
    A scan corresponds to a single shot of the laser. One rotation contains
    many scans.
    """

    # angle in degrees
    angle: float = betterproto.float_field(1)
    # distance in meters
    distance: float = betterproto.float_field(2)
    # quality of the scan (0 is worst, 255 is best)
    quality: int = betterproto.uint32_field(3)
    # true if this is the start of a new scan rotation
    is_start: bool = betterproto.bool_field(4)


@dataclass
class LuxSensorOutput(betterproto.Message):
    lux: int = betterproto.int32_field(1)


@dataclass
class RpmSensorOutput(betterproto.Message):
    """
    This is the message format that a RPM sensor service can send out. It is
    deliberately left with many details, to allow  for different use cases.
    """

    left_motor: "MotorInformation" = betterproto.message_field(1)
    right_motor: "MotorInformation" = betterproto.message_field(2)


@dataclass
class MotorInformation(betterproto.Message):
    # This is probably all the information you need to understand how the motor
    # behaves
    rpm: float = betterproto.float_field(1)
    speed: float = betterproto.float_field(2)
    # More fine-grained details to (re)compute the RPM and speed or other
    # parameters you are interested in
    ticks: int = betterproto.uint32_field(3)
    timeout_count: int = betterproto.uint32_field(4)
    sequence_number: int = betterproto.uint32_field(5)


@dataclass
class SpeedSensorOutput(betterproto.Message):
    rpm: int = betterproto.int32_field(1)


@dataclass
class SensorOutput(betterproto.Message):
    # Every sensor has a unique ID to support multiple sensors of the same type
    sensor_id: int = betterproto.uint32_field(1)
    # Add a timestamp to the output to make debugging, logging and
    # synchronisation easier
    timestamp: int = betterproto.uint64_field(2)
    # Report an error if the sensor is not working correctly (controller can
    # decide to ignore or stop the car) 0 = no error, any other value = error
    status: int = betterproto.uint32_field(3)
    camera_output: "CameraSensorOutput" = betterproto.message_field(
        4, group="sensorOutput"
    )
    distance_output: "DistanceSensorOutput" = betterproto.message_field(
        5, group="sensorOutput"
    )
    speed_output: "SpeedSensorOutput" = betterproto.message_field(
        6, group="sensorOutput"
    )
    controller_output: "ControllerOutput" = betterproto.message_field(
        7, group="sensorOutput"
    )
    imu_output: "ImuSensorOutput" = betterproto.message_field(8, group="sensorOutput")
    battery_output: "BatterySensorOutput" = betterproto.message_field(
        9, group="sensorOutput"
    )
    rpm_output: "RpmSensorOutput" = betterproto.message_field(10, group="sensorOutput")
    lux_output: "LuxSensorOutput" = betterproto.message_field(11, group="sensorOutput")
    generic_int_scalar: "GenericIntScalar" = betterproto.message_field(
        13, group="sensorOutput"
    )
    generic_float_scalar: "GenericFloatScalar" = betterproto.message_field(
        14, group="sensorOutput"
    )
    generic_bool_scalar: "GenericBoolScalar" = betterproto.message_field(
        15, group="sensorOutput"
    )
    generic_string_scalar: "GenericStringScalar" = betterproto.message_field(
        16, group="sensorOutput"
    )
    generic_int_array: "GenericIntArray" = betterproto.message_field(
        17, group="sensorOutput"
    )
    generic_float_array: "GenericFloatArray" = betterproto.message_field(
        18, group="sensorOutput"
    )
    generic_bool_array: "GenericBoolArray" = betterproto.message_field(
        19, group="sensorOutput"
    )
    generic_string_array: "GenericStringArray" = betterproto.message_field(
        20, group="sensorOutput"
    )
    lidar_output: "LidarSensorOutput" = betterproto.message_field(
        21, group="sensorOutput"
    )
    energy_output: "EnergySensorOutput" = betterproto.message_field(
        22, group="sensorOutput"
    )


@dataclass
class Segment(betterproto.Message):
    """
    Control messages exchanged by client(s), the server and the car to send
    data in multiple segments
    """

    packet_id: int = betterproto.int64_field(1)
    segment_id: int = betterproto.int64_field(2)
    total_segments: int = betterproto.int64_field(3)
    data: bytes = betterproto.bytes_field(4)


@dataclass
class SimulatorImageOutput(betterproto.Message):
    """Simulator sensor outputs."""

    width: int = betterproto.uint32_field(2)
    height: int = betterproto.uint32_field(3)
    pixels: bytes = betterproto.bytes_field(4)


@dataclass
class SimulatorState(betterproto.Message):
    """Generic state of Simulator"""

    speed: float = betterproto.float_field(1)
    wheel_off_track: List[bool] = betterproto.bool_field(2)
    image: "SimulatorImageOutput" = betterproto.message_field(3)
    pos: List[float] = betterproto.float_field(4)
    is_drifting: bool = betterproto.bool_field(5)


@dataclass
class TuningState(betterproto.Message):
    timestamp: int = betterproto.uint64_field(1)
    dynamic_parameters: List["TuningStateParameter"] = betterproto.message_field(2)


@dataclass
class TuningStateParameter(betterproto.Message):
    number: "TuningStateParameterNumberParameter" = betterproto.message_field(
        1, group="parameter"
    )
    string: "TuningStateParameterStringParameter" = betterproto.message_field(
        3, group="parameter"
    )


@dataclass
class TuningStateParameterNumberParameter(betterproto.Message):
    """
    note: it may seem weird to not extract the key from the oneof, but this is
    so that the parser can easily determine the type of the parameter
    extracting it to a separate field on the same level as oneof would make it
    ambiguous
    """

    key: str = betterproto.string_field(1)
    value: float = betterproto.float_field(2)


@dataclass
class TuningStateParameterStringParameter(betterproto.Message):
    key: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)