"""Module for artifact and trial management in the pipeline.

This module defines data models for managing artifacts and trials in the pipeline,
including their configurations, outputs, and optimization details.
"""

from typing import Any

import numpy as np
from numpy.typing import NDArray
from pydantic import BaseModel, ConfigDict, Field

from autointent.configs import EmbedderConfig
from autointent.custom_types import ListOfLabelsWithOOS, NodeType


class Artifact(BaseModel):
    """Base class for artifacts generated by pipeline nodes."""


class RegexArtifact(Artifact):
    """Artifact containing results from the regex node."""


class EmbeddingArtifact(Artifact):
    """Artifact containing details from the embedding node.

    Attributes:
        config: Configuration settings for the embedder.
    """

    config: EmbedderConfig


class ScorerArtifact(Artifact):
    """Artifact containing outputs from the scoring node.

    Outputs from the best scorer, numpy arrays of shape (n_samples, n_classes).

    Attributes:
        train_scores: Scorer outputs for train utterances.
        validation_scores: Scorer outputs for validation utterances.
        test_scores: Scorer outputs for test utterances.
        folded_scores: Scores for each fold from cross-validation.
    """

    model_config = ConfigDict(arbitrary_types_allowed=True)
    train_scores: NDArray[np.float64] | None = Field(None, description="Scorer outputs for train utterances")
    validation_scores: NDArray[np.float64] | None = Field(None, description="Scorer outputs for validation utterances")
    test_scores: NDArray[np.float64] | None = Field(None, description="Scorer outputs for test utterances")
    folded_scores: list[NDArray[np.float64]] | None = Field(
        None, description="Scores for each fold from cross-validation"
    )

    def model_dump(self, **kwargs: Any) -> dict[str, Any]:  # noqa: ANN401
        """Convert the model to a dictionary, converting numpy arrays to lists."""
        data = super().model_dump(**kwargs)
        if data["train_scores"] is not None:
            data["train_scores"] = data["train_scores"].tolist()
        if data["validation_scores"] is not None:
            data["validation_scores"] = data["validation_scores"].tolist()
        if data["test_scores"] is not None:
            data["test_scores"] = data["test_scores"].tolist()
        if data["folded_scores"] is not None:
            data["folded_scores"] = [arr.tolist() for arr in data["folded_scores"]]
        return data

    @classmethod
    def model_validate(cls, obj: dict[str, Any]) -> "ScorerArtifact":
        """Convert lists back to numpy arrays during validation."""
        if obj.get("train_scores") is not None:
            obj["train_scores"] = np.array(obj["train_scores"])
        if obj.get("validation_scores") is not None:
            obj["validation_scores"] = np.array(obj["validation_scores"])
        if obj.get("test_scores") is not None:
            obj["test_scores"] = np.array(obj["test_scores"])
        if obj.get("folded_scores") is not None:
            obj["folded_scores"] = [np.array(arr) for arr in obj["folded_scores"]]
        return super().model_validate(obj)


class DecisionArtifact(Artifact):
    """Artifact containing outputs from the predictor node.

    Outputs from the best predictor, numpy array of shape (n_samples,) or
    (n_samples, n_classes) depending on classification mode (multi-class or multi-label).

    Attributes:
        labels: Predicted labels for the samples.
    """

    model_config = ConfigDict(arbitrary_types_allowed=True)
    labels: ListOfLabelsWithOOS


def validate_node_name(value: str) -> str:
    """Validate and return the node type.

    Args:
        value: Node type as a string.

    Returns:
        Validated node type string.

    Raises:
        ValueError: If the node type is invalid.
    """
    if value in [NodeType.embedding, NodeType.scoring, NodeType.decision, NodeType.regex]:
        return value
    msg = f"Unknown node_type: {value}. Expected one of ['regex', 'embedding', 'scoring', 'decision']"
    raise ValueError(msg)


class Artifacts(BaseModel):
    """Container for storing and managing artifacts generated by pipeline nodes.

    Only stores the best artifact for each node type to optimize memory usage.
    The best ones are transmitted between nodes of the pipeline.

    Attributes:
        regex: Best artifact from the regex node.
        embedding: Best artifact from the embedding node.
        scoring: Best artifact from the scoring node.
        decision: Best artifact from the decision node.
    """

    model_config = ConfigDict(arbitrary_types_allowed=True)

    regex: RegexArtifact | None = None
    embedding: EmbeddingArtifact | None = None
    scoring: ScorerArtifact | None = None
    decision: DecisionArtifact | None = None

    def model_dump(self, **kwargs: Any) -> dict[str, Any]:  # noqa: ANN401
        """Convert the model to a dictionary, ensuring nested artifacts are properly serialized."""
        data = super().model_dump(**kwargs)
        for node_type in [NodeType.regex, NodeType.embedding, NodeType.scoring, NodeType.decision]:
            artifact = getattr(self, node_type.value)
            if artifact is not None:
                data[node_type.value] = artifact.model_dump(**kwargs)
            else:
                data[node_type.value] = None
        return data

    @classmethod
    def model_validate(cls, obj: dict[str, Any]) -> "Artifacts":
        """Convert the dictionary back to an Artifacts instance, ensuring nested artifacts are properly deserialized."""
        # First convert the lists back to numpy arrays in the scoring artifacts
        if "scoring" in obj and obj["scoring"] is not None:
            if obj["scoring"].get("train_scores") is not None:
                obj["scoring"]["train_scores"] = np.array(obj["scoring"]["train_scores"])
            if obj["scoring"].get("validation_scores") is not None:
                obj["scoring"]["validation_scores"] = np.array(obj["scoring"]["validation_scores"])
            if obj["scoring"].get("test_scores") is not None:
                obj["scoring"]["test_scores"] = np.array(obj["scoring"]["test_scores"])
            if obj["scoring"].get("folded_scores") is not None:
                obj["scoring"]["folded_scores"] = [np.array(arr) for arr in obj["scoring"]["folded_scores"]]

        return super().model_validate(obj)

    def add_artifact(self, node_type: str, artifact: Artifact) -> None:
        """Add an artifact to the specified node type, replacing any existing artifact.

        Args:
            node_type: Node type as a string.
            artifact: The artifact to add.
        """
        setattr(self, validate_node_name(node_type), artifact)

    def get_artifact(self, node_type: str) -> Artifact | None:
        """Retrieve the artifact for a specified node type.

        Args:
            node_type: Node type as a string.

        Returns:
            The artifact for the node type, or None if no artifact exists.
        """
        return getattr(self, validate_node_name(node_type))  # type: ignore[no-any-return]

    def get_best_artifact(self, node_type: str) -> Artifact:
        """Retrieve the artifact for a specified node type.

        Args:
            node_type: Node type as a string.

        Returns:
            The artifact for the node type.

        Raises:
            ValueError: If no artifact exists for the node type.
        """
        artifact = self.get_artifact(node_type)
        if artifact is None:
            msg = f"No artifact for {node_type}"
            raise ValueError(msg)
        return artifact

    def has_artifacts(self) -> bool:
        """Check if any artifacts have been saved in RAM.

        Returns:
            True if any artifacts exist, False otherwise.
        """
        node_types = [NodeType.regex, NodeType.embedding, NodeType.scoring, NodeType.decision]
        return any(self.get_artifact(nt) is not None for nt in node_types)


class Trial(BaseModel):
    """Representation of an individual optimization trial.

    Attributes:
        module_name: Type of the module being optimized.
        module_params: Parameters of the module for the trial.
        metric_name: Name of the evaluation metric.
        metric_value: Value of the evaluation metric for this trial.
        module_dump_dir: Directory where the module is dumped.
        metrics: Dictionary of metric names and their values.
    """

    module_name: str
    module_params: dict[str, Any]
    metric_name: str
    metric_value: float
    module_dump_dir: str | None
    metrics: dict[str, float]


class Trials(BaseModel):
    """Container for managing optimization trials for pipeline nodes.

    Attributes:
        regex: List of trials for the regex node.
        embedding: List of trials for the embedding node.
        scoring: List of trials for the scoring node.
        decision: List of trials for the decision node.
    """

    regex: list[Trial] = []
    embedding: list[Trial] = []
    scoring: list[Trial] = []
    decision: list[Trial] = []

    def get_trial(self, node_type: str, idx: int) -> Trial:
        """Retrieve a specific trial for a node type and index.

        Args:
            node_type: Node type as a string.
            idx: Index of the trial.

        Returns:
            The requested trial.
        """
        return self.get_trials(node_type)[idx]

    def get_trials(self, node_type: str) -> list[Trial]:
        """Retrieve all trials for a specified node type.

        Args:
            node_type: Node type as a string.

        Returns:
            A list of trials for the node type.
        """
        return getattr(self, validate_node_name(node_type))  # type: ignore[no-any-return]

    def add_trial(self, node_type: str, trial: Trial) -> None:
        """Add a trial to a specified node type.

        Args:
            node_type: Node type as a string.
            trial: The trial to add.
        """
        self.get_trials(node_type).append(trial)
