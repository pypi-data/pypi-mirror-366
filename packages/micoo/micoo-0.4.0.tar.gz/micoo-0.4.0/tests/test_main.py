"""Test cases for the main application commands using Typer's CLI runner."""

from pathlib import Path

import pytest
from typer.testing import CliRunner

from micoo.main import app

runner = CliRunner()


@pytest.mark.dependency
def test_update() -> None:
    """Test the `update` command of the application.

    This test checks if the `update` command runs without any errors.

    Scenario:
        - Run the `update` command of the application.

    Expected Result:
        - The command should execute successfully.
    Given:
        - The application is set up with a `update` command.
    When:
        - The `update` command is invoked using the CLI runner.
    Then:
        - The command should exit with code 0, indicating success.
        - The output should contain the message indicating success.
    And:
        - If the command fails, the test should fail with the output message.

    Note:
        - This test does not check the actual update logic,
        only that the command runs successfully.

    """
    result = runner.invoke(app, ["update"])
    assert result.exit_code == 0, result.output


@pytest.mark.dependency(depends=["test_update"])
def test_list() -> None:
    """Test the `list` command of the application.

    This test checks if the `list` command runs without any errors.

    Scenario:
        - Run the `list` command of the application.

    Expected Result:
        - The command should execute successfully and return the list of
        available cookbooks.
    Given:
        - The application is set up with a `list` command.
    When:
        - The `list` command is invoked using the CLI runner.
    Then:
        - The command should exit with code 0, indicating success.
        - The output should contain the list of available cookbooks.
    And:
        - If the command fails, the test should fail with the output message.

    Note:
        - This test does not check the actual list of cookbooks,
        only that the command runs successfully.

    """
    result = runner.invoke(app, ["list"])
    assert result.exit_code == 0, result.output
    assert "Available cookbooks:" in result.output, result.output


@pytest.mark.dependency(depends=["test_update"])
def test_search() -> None:
    """Test the `search` command of the application.

    This test checks if the `search` command runs without any errors.

    Scenario:
        - Run the `search` command of the application.

    Expected Result:
        - The command should execute successfully and return the list of search results.
    Given:
        - The application is set up with a `search` command.
    When:
        - The `search` command is invoked using the CLI runner.
    Then:
        - The command should exit with code 0, indicating success.
        - The output should contain the list of search results.
    And:
        - If the command fails, the test should fail with the output message.

    Note:
        - This test does not check the actual search logic,
        only that the command runs successfully.

    """
    result = runner.invoke(app, ["search", "on"])
    assert result.exit_code == 0, result.output
    assert "python" in result.output, result.output
    assert "ruby-on-rails" in result.output, result.output


@pytest.mark.dependency(depends=["test_update"])
def test_dump() -> None:
    """Test the `dump` command of the application.

    This test checks if the `dump` command runs without any errors.

    Scenario:
        - Run the `dump` command of the application.

    Expected Result:
        - The command should execute successfully and return the cookbook content.
    Given:
        - The application is set up with a `dump` command.
    When:
        - The `dump` command is invoked using the CLI runner.
    Then:
        - The command should exit with code 0, indicating success.
        - The output should contain the cookbook content.
    And:
        - If the command fails, the test should fail with the output message.

    Note:
        - This test does not check the actual cookbook content,
        only that the command runs successfully.

    """
    cookbook_name = "python"
    result = runner.invoke(app, ["dump", cookbook_name])
    assert result.exit_code == 0, result.output
    assert "### Generated by micoo " in result.output


def test_root() -> None:
    """Test the `root` command of the application.

    This test checks if the `root` command runs without any errors.

    Scenario:
        - Run the `root` command of the application.

    Expected Result:
        - The command should execute successfully and return the repository path.
    Given:
        - The application is set up with a `root` command.
    When:
        - The `root` command is invoked using the CLI runner.
    Then:
        - The command should exit with code 0, indicating success.
        - The output should contain the repository path information.
    And:
        - If the command fails, the test should fail with the output message.

    Note:
        - This test does not check the actual repository path,
        only that the command runs successfully.

    """
    result = runner.invoke(app, ["root"])
    assert result.exit_code == 0, result.output


def test_log() -> None:
    """Test the `log` command of the application.

    This test checks if the `log` command runs without any errors.

    Scenario:
        - Run the `log` command of the application.

    Expected Result:
        - The command should execute successfully and return the log file path.
    Given:
        - The application is set up with a `log` command.
    When:
        - The `log` command is invoked using the CLI runner.
    Then:
        - The command should exit with code 0, indicating success.
        - The output should contain the log file path information.
    And:
        - If the command fails, the test should fail with the output message.

    Note:
        - This test does not check the actual log file path,
        only that the command runs successfully.

    """
    result = runner.invoke(app, ["log"])
    assert result.exit_code == 0, result.output


def test_remote() -> None:
    """Test the `remote` command of the application.

    This test checks if the `remote` command runs without any errors.

    Scenario:
        - Run the `remote` command of the application.

    Expected Result:
        - The command should execute successfully and return the remote repository url.
    Given:
        - The application is set up with a `remote` command.
    When:
        - The `remote` command is invoked using the CLI runner.
    Then:
        - The command should exit with code 0, indicating success.
        - The output should contain the remote repository url information.
    And:
        - If the command fails, the test should fail with the output message.

    Note:
        - This test does not check the actual remote repository url,
        only that the command runs successfully.

    """
    result = runner.invoke(app, ["remote"])
    assert result.exit_code == 0, result.output


def test_version() -> None:
    """Test the `version` command of the application.

    This test checks if the `version` command runs without any errors.

    Scenario:
        - Run the `version` command of the application.

    Expected Result:
        - The command should execute successfully and return the application version.
    Given:
        - The application is set up with a `version` command.
    When:
        - The `version` command is invoked using the CLI runner.
    Then:
        - The command should exit with code 0, indicating success.
        - The output should contain the application version information.
    And:
        - If the command fails, the test should fail with the output message.

    Note:
        - This test does not check the actual version number,
        only that the command runs successfully.

    """
    result = runner.invoke(app, ["version"])
    assert result.exit_code == 0, result.output


def test_info() -> None:
    """Test the `info` command of the application.

    This test checks if the `info` command runs without any errors.

    Scenario:
        - Run the `info` command of the application.

    Expected Result:
        - The command should execute successfully and return the application
        information.
    Given:
        - The application is set up with an `info` command.
    When:
        - The `info` command is invoked using the CLI runner.
    Then:
        - The command should exit with code 0, indicating success.
        - The output should contain the application information.
    And:
        - If the command fails, the test should fail with the output message.

    Note:
        - This test does not check the actual information content,
        only that the command runs successfully.

    """
    result = runner.invoke(app, ["info"])
    assert result.exit_code == 0, result.output


def test_interactive() -> None:
    """Test the `interactive` command of the application.

    This test checks if the `interactive` command runs without any errors.

    Scenario:
        - Run the `interactive` command of the application.
    """
    # Delete `mise.local.toml` if it exists
    if Path("mise.local.toml").exists():
        Path("mise.local.toml").unlink()
    result = runner.invoke(app, ["interactive"], input="python\nmise.local.toml\ny\n")
    assert result.exit_code == 0, result.output
