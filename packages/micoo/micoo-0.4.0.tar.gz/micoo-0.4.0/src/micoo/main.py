"""micoo is a command-line tool for easily accessing mise cookbooks."""

from __future__ import annotations

import platform
from importlib.metadata import version
from pathlib import Path
from typing import List, Sequence, Union

import click
import typer
from git import GitCommandError, Repo
from rich.console import Console
from rich.table import Table

from micoo.config import (
    cookbooks_repository_url,
    file_extension,
    log_file_path,
    micoo_repository_url,
    repository_path,
)
from micoo.logging_setup import logger

console = Console()

app = typer.Typer(
    name="micoo is a command-line tool for easily accessing mise cookbooks.",
    no_args_is_help=True,
    rich_markup_mode="rich",
)


cookbook_template = """### Generated by micoo ({micoo_repository_url})
### {remote_web_root}
{content}
"""


def ensure_repository_exists() -> bool:
    """Ensure the repository exists and is accessible.

    Returns:
        True if repository exists, False otherwise (error message already displayed)
    """
    if not repository_path.exists():
        msg = "Repository does not exist. Please run `micoo update` first."
        typer.echo(msg)
        logger.error(msg)
        return False
    return True


def get_available_cookbooks() -> List[str]:
    """Get list of available cookbooks.

    Returns:
        List of cookbook names
    """
    cookbooks = [
        cookbook
        for cookbook in repository_path.rglob(pattern=f"*{file_extension}")
        if cookbook.is_file()
    ]
    return sorted([cookbook.name[: -len(file_extension)] for cookbook in cookbooks])


def prepare_cookbook(name: str) -> str:
    """Prepare a cookbook for generation.

    Returns:
        The prepared cookbook content
    """
    cookbook_path = repository_path / (name + file_extension)
    if not cookbook_path.exists():
        msg = f"Cookbook '{name}' not found in the repository."
        typer.echo(msg)
        logger.error(msg)
        typer.Exit(1)

    repo = Repo(repository_path)
    revision_hash = repo.head.commit.hexsha

    with cookbook_path.open() as f:
        content = f.read()
    repository_url_raw = cookbooks_repository_url.replace(
        "https://github.com",
        "https://raw.github.com",
    )
    remote_web_root = f"{repository_url_raw}/{revision_hash}/{name}{file_extension}"
    return cookbook_template.format(
        micoo_repository_url=micoo_repository_url,
        remote_web_root=remote_web_root,
        content=content,
    )


@app.command()
def update() -> None:
    """Clone or fetch the `mise-cookbooks` repository.

    Update the repository to the latest version:
        micoo update

    Example output:
        Repository pulled successfully.
    """
    logger.info("Command `update` called.")
    repo: Union[Repo, None] = None
    try:
        if not repository_path.exists():
            logger.info("Repository does not exist. Cloning...")
            repo = Repo.clone_from(
                url=cookbooks_repository_url,
                to_path=repository_path,
                branch="main",
            )
            msg = "Repository cloned successfully."
            typer.echo(msg)
            logger.info(msg)
            return
        logger.info("Repository exists. Pulling...")
        repo = Repo(repository_path)
        repo.remotes[0].pull()
        msg = "Repository pulled successfully."
        typer.echo(msg)
        logger.info(msg)
    except GitCommandError as e:
        logger.error(f"Git command error: {e}")
        typer.echo("An error occurred while cloning/pulling the repository.")
    except Exception as e:  # noqa: BLE001
        logger.error(f"An unexpected error occurred: {e}")
        typer.echo("An error occurred while cloning/pulling the repository.")


@app.command(name="list")
def list_cookbooks() -> None:
    """List the available mise cookbooks.

    List all available cookbooks:
        micoo list

    Example output:
        Available cookbooks:
        - terraform
        - python
        - cpp
        - pnpm
        - node
        - ruby-on-rails
        - opentofu
    """
    logger.info("Command `list` called.")
    if not ensure_repository_exists():
        return
    cookbooks = list(repository_path.rglob(pattern=f"*{file_extension}"))
    if not cookbooks:
        msg = "No cookbooks found."
        typer.echo(msg)
        logger.error(msg)
        return
    typer.echo("Available cookbooks:")
    for cookbook_path in cookbooks:
        typer.echo(f"- {cookbook_path.name[: -len(file_extension)]}")
    logger.info("Cookbooks listed successfully.")


@app.command()
def search(
    name: str = typer.Argument(
        ...,
        help="Name of the cookbook to search for.",
        metavar="on",
    ),
) -> None:
    """Search for a mise cookbook.

    Search for a "generic" cookbook:
        micoo search generic

    Example output:
        No cookbooks found matching 'generic'.

    Search for a cookbook that contains "on" in its name:
        micoo search on

    Example output:
        python
        ruby-on-rails
    """
    logger.info("Command `search` called with name: %s", name)
    if not ensure_repository_exists():
        return

    found = False
    search_term = name.lower()
    cookbooks = list(repository_path.rglob(pattern=f"*{file_extension}"))
    for cookbook_path in cookbooks:
        filename = cookbook_path.name[: -len(file_extension)]
        if search_term in filename.lower():
            typer.echo(f"- {filename}")
            found = True
    if found:
        logger.info("Cookbooks found successfully.")
        return
    msg = f"No cookbooks found matching the search term: '{name}'."
    typer.echo(msg)
    logger.error(msg)


@app.command()
def dump(
    name: str = typer.Argument(
        ...,
        help="Name of the cookbook to dump.",
        metavar="python",
    ),
) -> None:
    """Dump a mise cookbook.

    Dump a specific cookbook to the console:
        micoo dump python

    Example output:
        ### Generated by micoo (https://github.com/hasansezertasan/micoo)
        ### https://raw.github.com/hasansezertasan/mise-cookbooks/81747c2e983fa1278005c8cb8b0e311a7726923a/python.mise.toml
        min_version = "2024.9.5"

        [env]
        # Use the project name derived from the current directory
        PROJECT_NAME = "{{ config_root | basename }}"

        # Automatic virtualenv activation
        _.python.venv = { path = ".venv", create = true }

        [tools]
        python = "{{ get_env(name='PYTHON_VERSION', default='3.11') }}"
        ruff = "latest"

        [tasks.install]
        description = "Install dependencies"
        alias = "i"
        run = "uv pip install -r requirements.txt"

        [tasks.run]
        description = "Run the application"
        run = "python app.py"

        [tasks.test]
        description = "Run tests"
        run = "pytest tests/"

        [tasks.lint]
        description = "Lint the code"
        run = "ruff src/"

        [tasks.info]
        description = "Print project information"
        run = '''
        echo "Project: $PROJECT_NAME"
        echo "Virtual Environment: $VIRTUAL_ENV"
        '''


    Dump a specific cookbook to a file:
        micoo dump python > .mise.toml
    """
    logger.info("Command `dump` called with name: %s", name)
    if not ensure_repository_exists():
        return
    msg = prepare_cookbook(name)
    typer.echo(msg)
    logger.info("Cookbook dumped successfully.")


@app.command()
def root() -> None:
    """Show the path to the micoo boilerplates directory.

    Show the root directory:
        micoo root

    Example output:
        /Users/hasansezertasan/Library/Caches/micoo/mise-cookbooks

    Open the root directory in a file manager:
        open $(micoo root)

    """
    logger.info("Command `root` called.")
    typer.echo(repository_path)
    logger.info("Root directory displayed successfully.")


@app.command()
def log() -> None:
    """Show the path to the micoo log file.

    Show the log file location:
        micoo log

    Example output:
        /Users/hasansezertasan/Library/Logs/micoo/micoo.log

    Open the log file in a file manager:
        open $(micoo log)

    """
    logger.info("Command `log` called.")
    typer.echo(log_file_path)
    logger.info("Log file displayed successfully.")


@app.command()
def remote() -> None:
    """Show the URL to the remote repository.

    Show the remote URL
        micoo remote

    Example output:
        https://github.com/hasansezertasan/mise-cookbooks

    Open the remote URL in a web browser
        open $(micoo remote)
    """
    logger.info("Command `remote` called.")
    typer.echo(cookbooks_repository_url)
    logger.info("Remote URL displayed successfully.")


@app.command(name="version")
def show_version() -> None:
    """Show the current version number of micoo.

    Show the version number:
        micoo version

    Example output:
        0.4.0
    """
    logger.info("Command `version` called.")
    typer.echo(version("micoo"))
    logger.info("Version displayed successfully.")


@app.command()
def info() -> None:
    """Display information about the micoo application.

    Show application information:
        micoo info

    Example output:
        Application Version: 0.4.0
        Python Version: 3.9.23 (CPython)
        Platform: Darwin
        Repository Path: /Users/hasansezertasan/Library/Caches/micoo/mise-cookbooks
        Repository URL: https://github.com/hasansezertasan/mise-cookbooks/tree/81747c2e983fa1278005c8cb8b0e311a7726923a
        Log File: /Users/hasansezertasan/Library/Logs/micoo/micoo.log
    """
    logger.info("Command `info` called.")
    python_version = platform.python_version()
    python_implementation = platform.python_implementation()
    typer.echo(f"Application Version: {version('micoo')}")
    typer.echo(f"Python Version: {python_version} ({python_implementation})")
    typer.echo(f"Platform: {platform.system()}")
    typer.echo(f"Repository Path: {repository_path}")
    url = "N/A"
    if repository_path.exists():
        repo = Repo(repository_path)
        url = f"{cookbooks_repository_url}/tree/{repo.head.commit.hexsha}"
    typer.echo(f"Repository URL: {url}")
    typer.echo(f"Log File: {log_file_path}")
    logger.info("Application information displayed successfully.")


@app.command()
def interactive() -> None:
    """Start interactive mode for cookbook selection and generation.

    Launch interactive mode:
        micoo interactive

    """
    msg = "Command `interactive` called."
    logger.info(msg)
    if not ensure_repository_exists():
        return
    name: str = typer.prompt(
        "Select a cookbook",
        type=click.Choice(get_available_cookbooks(), case_sensitive=False),
    )
    output_options_table = [
        ("mise.toml", "Standard configuration file"),
        ("mise.local.toml", "Local config (not committed to source control)"),
        ("mise/config.toml", "Configuration in mise subdirectory"),
        (".config/mise.toml", "Configuration in .config directory"),
        (".config/mise/config.toml", "Configuration in .config/mise subdirectory"),
        (
            ".config/mise/conf.d/custom.toml",
            "Configuration in conf.d directory (alphabetical loading)",
        ),
    ]
    table = Table("Name", "Description")
    for option in output_options_table:
        table.add_row(option[0], option[1])
    console.print(table)

    output_options: Sequence[str] = [option[0] for option in output_options_table]
    output_file: str = typer.prompt(
        "Select output file location",
        default="mise.local.toml",
        type=click.Choice(output_options, case_sensitive=False),
        show_choices=False,
    )
    if not typer.confirm(f"Generate {name} cookbook to {output_file}?"):
        msg = "Interactive mode cancelled by user."
        logger.info(msg)
        typer.Exit(1)

    msg = prepare_cookbook(name)
    output_path = Path(output_file)
    if output_path.exists():
        msg = f"Output file '{output_file}' already exists."
        typer.echo(msg)
        logger.error(msg)
        typer.Exit(1)
    with output_path.open("w", encoding="utf-8") as f:
        f.write(msg)

    msg = "Command `interactive` completed successfully."
    logger.info(msg)
