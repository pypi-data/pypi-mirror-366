"""Gemini transcript detection and validation."""

import re
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime

from ...utils.logger import get_logger

logger = get_logger(__name__)


class GeminiTranscriptDetector:
    """Detects and validates Gemini meeting transcripts."""
    
    # Patterns that indicate a Gemini transcript
    GEMINI_PATTERNS = [
        r"Notes by Gemini",
        r"Meeting notes by Gemini",
        r"Transcript by Gemini",
        r"Generated by Gemini"
    ]
    
    # Tab structure patterns
    TAB_PATTERNS = [
        r"^Tab \d+:?\s*(.+)$",  # Tab 1: Overview
        r"^\t+Tab \d+:?\s*(.+)$",  # With leading tabs
        r"^#{1,3}\s*Tab \d+:?\s*(.+)$"  # With markdown headers
    ]
    
    # Common tab names in Gemini transcripts
    COMMON_TAB_NAMES = [
        "overview", "summary", "transcript", "full transcript",
        "action items", "actions", "decisions", "notes",
        "participants", "attendees", "details", "meeting details"
    ]
    
    def __init__(self):
        """Initialize the detector."""
        self.compiled_patterns = {
            'gemini': [re.compile(p, re.IGNORECASE) for p in self.GEMINI_PATTERNS],
            'tabs': [re.compile(p, re.MULTILINE | re.IGNORECASE) for p in self.TAB_PATTERNS]
        }
    
    def is_gemini_transcript(self, content: str, filename: str = "") -> Tuple[bool, float]:
        """Determine if content is a Gemini transcript.
        
        Args:
            content: Document content
            filename: Optional filename for additional context
            
        Returns:
            Tuple of (is_transcript, confidence_score)
        """
        if not content:
            return False, 0.0
        
        confidence = 0.0
        
        # Check filename
        if filename:
            filename_lower = filename.lower()
            if any(pattern.lower() in filename_lower for pattern in ["gemini", "meeting notes", "transcript"]):
                confidence += 0.2
        
        # Check for Gemini patterns
        gemini_found = False
        for pattern in self.compiled_patterns['gemini']:
            if pattern.search(content):
                gemini_found = True
                confidence += 0.3
                break
        
        # Check for tab structure
        tabs = self.extract_tabs(content)
        if tabs:
            confidence += 0.3
            
            # Check if tabs match common names
            tab_names = [tab['name'].lower() for tab in tabs]
            common_matches = sum(1 for name in self.COMMON_TAB_NAMES if any(name in tab_name for tab_name in tab_names))
            if common_matches >= 2:
                confidence += 0.2
        
        # Check for meeting-like content
        if self._has_meeting_characteristics(content):
            confidence += 0.1
        
        # Final decision
        is_transcript = gemini_found or (tabs and confidence >= 0.5)
        
        # Ensure confidence doesn't exceed 1.0
        confidence = min(confidence, 1.0)
        
        return is_transcript, confidence
    
    def extract_tabs(self, content: str) -> List[Dict[str, Any]]:
        """Extract tab structure from Gemini transcript.
        
        Args:
            content: Document content
            
        Returns:
            List of tab dictionaries with name, start_pos, content
        """
        tabs = []
        lines = content.split('\n')
        
        current_tab = None
        tab_content_lines = []
        
        for i, line in enumerate(lines):
            # Check if line is a tab header
            is_tab_header = False
            tab_name = None
            
            for pattern in self.compiled_patterns['tabs']:
                match = pattern.match(line)
                if match:
                    is_tab_header = True
                    tab_name = match.group(1).strip()
                    break
            
            if is_tab_header:
                # Save previous tab if exists
                if current_tab:
                    current_tab['content'] = '\n'.join(tab_content_lines).strip()
                    tabs.append(current_tab)
                
                # Start new tab
                current_tab = {
                    'name': tab_name,
                    'line_number': i + 1,
                    'tab_number': len(tabs) + 1
                }
                tab_content_lines = []
            
            elif current_tab:
                # Add line to current tab content
                tab_content_lines.append(line)
        
        # Save last tab
        if current_tab:
            current_tab['content'] = '\n'.join(tab_content_lines).strip()
            tabs.append(current_tab)
        
        return tabs
    
    def validate_transcript(self, content: str) -> Dict[str, Any]:
        """Validate and analyze a Gemini transcript.
        
        Args:
            content: Document content
            
        Returns:
            Validation results with extracted information
        """
        is_transcript, confidence = self.is_gemini_transcript(content)
        
        validation = {
            'is_valid': is_transcript,
            'confidence': confidence,
            'tabs': [],
            'metadata': {},
            'warnings': []
        }
        
        if not is_transcript:
            validation['warnings'].append("Content does not appear to be a Gemini transcript")
            return validation
        
        # Extract tabs
        tabs = self.extract_tabs(content)
        validation['tabs'] = tabs
        
        if not tabs:
            validation['warnings'].append("No tab structure found")
        
        # Extract metadata from content
        metadata = self._extract_metadata(content, tabs)
        validation['metadata'] = metadata
        
        # Validate tab content
        for tab in tabs:
            if len(tab['content']) < 10:
                validation['warnings'].append(f"Tab '{tab['name']}' has very little content")
        
        # Check for transcript tab
        has_transcript = any('transcript' in tab['name'].lower() for tab in tabs)
        if not has_transcript:
            validation['warnings'].append("No transcript tab found")
        
        return validation
    
    def _extract_metadata(self, content: str, tabs: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Extract metadata from transcript content.
        
        Args:
            content: Full document content
            tabs: Extracted tabs
            
        Returns:
            Metadata dictionary
        """
        metadata = {}
        
        # Look for date patterns
        date_patterns = [
            r"Date:\s*(.+)",
            r"Meeting Date:\s*(.+)",
            r"(\d{1,2}/\d{1,2}/\d{2,4})",
            r"(\d{4}-\d{2}-\d{2})"
        ]
        
        for pattern in date_patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                metadata['meeting_date'] = match.group(1).strip()
                break
        
        # Look for participants
        participant_patterns = [
            r"Participants?:\s*(.+)",
            r"Attendees?:\s*(.+)",
            r"Present:\s*(.+)"
        ]
        
        for pattern in participant_patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                participants_str = match.group(1).strip()
                # Split by common delimiters
                participants = re.split(r'[,;]', participants_str)
                metadata['participants'] = [p.strip() for p in participants if p.strip()]
                break
        
        # Look for duration
        duration_match = re.search(r"Duration:\s*(\d+)\s*(hours?|minutes?|mins?)", content, re.IGNORECASE)
        if duration_match:
            metadata['duration'] = f"{duration_match.group(1)} {duration_match.group(2)}"
        
        # Extract from specific tabs
        for tab in tabs:
            tab_name_lower = tab['name'].lower()
            
            # Overview/Summary tab often has metadata
            if any(keyword in tab_name_lower for keyword in ['overview', 'summary', 'details']):
                # Try to extract structured data from this tab
                tab_content = tab['content']
                
                # Meeting title
                if 'meeting_title' not in metadata:
                    title_match = re.search(r"^(.+)$", tab_content.split('\n')[0])
                    if title_match and len(title_match.group(1)) < 200:
                        metadata['meeting_title'] = title_match.group(1).strip()
        
        # Count action items if found
        action_items = self._extract_action_items(content, tabs)
        if action_items:
            metadata['action_item_count'] = len(action_items)
        
        return metadata
    
    def _extract_action_items(self, content: str, tabs: List[Dict[str, Any]]) -> List[str]:
        """Extract action items from transcript.
        
        Args:
            content: Full document content
            tabs: Extracted tabs
            
        Returns:
            List of action items
        """
        action_items = []
        
        # Look for action items tab
        for tab in tabs:
            if 'action' in tab['name'].lower():
                # Extract bullet points or numbered items
                lines = tab['content'].split('\n')
                for line in lines:
                    line = line.strip()
                    if re.match(r'^[-*•]\s+', line) or re.match(r'^\d+\.\s+', line):
                        # Remove bullet/number
                        item = re.sub(r'^[-*•]\s+|^\d+\.\s+', '', line)
                        if item:
                            action_items.append(item)
        
        return action_items
    
    def _has_meeting_characteristics(self, content: str) -> bool:
        """Check if content has characteristics of a meeting transcript.
        
        Args:
            content: Document content
            
        Returns:
            True if meeting-like content found
        """
        meeting_keywords = [
            'meeting', 'discussion', 'agenda', 'action items',
            'participants', 'attendees', 'decisions', 'next steps',
            'follow up', 'questions', 'summary'
        ]
        
        content_lower = content.lower()
        keyword_count = sum(1 for keyword in meeting_keywords if keyword in content_lower)
        
        # Also check for dialogue patterns
        has_dialogue = bool(re.search(r'^\s*\w+:\s+', content, re.MULTILINE))
        
        return keyword_count >= 3 or has_dialogue
    
    def extract_transcript_content(self, content: str, tabs: List[Dict[str, Any]]) -> str:
        """Extract the main transcript content from tabs.
        
        Args:
            content: Full document content
            tabs: Extracted tabs
            
        Returns:
            Main transcript text
        """
        # Look for transcript tab
        for tab in tabs:
            tab_name_lower = tab['name'].lower()
            if 'transcript' in tab_name_lower or 'conversation' in tab_name_lower:
                return tab['content']
        
        # If no transcript tab, try to find the longest tab
        if tabs:
            longest_tab = max(tabs, key=lambda t: len(t['content']))
            if len(longest_tab['content']) > 500:  # Reasonable minimum for transcript
                return longest_tab['content']
        
        # Fallback to full content
        return content